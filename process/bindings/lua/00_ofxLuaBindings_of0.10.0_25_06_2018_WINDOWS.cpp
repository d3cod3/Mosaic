/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 3.0.12
 *
 * This file is not intended to be easily readable and contains a number of
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG
 * interface file instead.
 * ----------------------------------------------------------------------------- */

#if defined( __WIN32__ ) || defined( _WIN32 )
	#include <cmath>
#endif



#ifndef SWIGLUA
#define SWIGLUA
#endif

#define SWIG_LUA_TARGET SWIG_LUA_FLAVOR_LUA
#define SWIG_LUA_MODULE_GLOBAL


#ifdef __cplusplus
/* SwigValueWrapper is described in swig.swg */
template<typename T> class SwigValueWrapper {
  struct SwigMovePointer {
    T *ptr;
    SwigMovePointer(T *p) : ptr(p) { }
    ~SwigMovePointer() { delete ptr; }
    SwigMovePointer& operator=(SwigMovePointer& rhs) { T* oldptr = ptr; ptr = 0; delete oldptr; ptr = rhs.ptr; rhs.ptr = 0; return *this; }
  } pointer;
  SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
  SwigValueWrapper(const SwigValueWrapper<T>& rhs);
public:
  SwigValueWrapper() : pointer(0) { }
  SwigValueWrapper& operator=(const T& t) { SwigMovePointer tmp(new T(t)); pointer = tmp; return *this; }
  operator T&() const { return *pointer.ptr; }
  T *operator&() { return pointer.ptr; }
};

template <typename T> T SwigValueInit() {
  return T();
}
#endif

/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#  define SWIGTEMPLATEDISAMBIGUATOR template
# elif defined(__HP_aCC)
/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
#  define SWIGTEMPLATEDISAMBIGUATOR template
# else
#  define SWIGTEMPLATEDISAMBIGUATOR
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__))
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__))
# else
#   define SWIGUNUSED
# endif
#endif

#ifndef SWIG_MSC_UNSUPPRESS_4505
# if defined(_MSC_VER)
#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
# endif
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if defined(__GNUC__)
#  if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#    ifndef GCC_HASCLASSVISIBILITY
#      define GCC_HASCLASSVISIBILITY
#    endif
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
# define _SCL_SECURE_NO_DEPRECATE
#endif

/* Deal with Apple's deprecated 'AssertMacros.h' from Carbon-framework */
#if defined(__APPLE__) && !defined(__ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES)
# define __ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES 0
#endif

/* Intel's compiler complains if a variable which was never initialised is
 * cast to void, which is a common idiom which we use to indicate that we
 * are aware a variable isn't used.  So we just silence that warning.
 * See: https://github.com/swig/swig/issues/192 for more discussion.
 */
#ifdef __INTEL_COMPILER
# pragma warning disable 592
#endif

/* -----------------------------------------------------------------------------
 * swigrun.swg
 *
 * This file contains generic C API SWIG runtime support for pointer
 * type checking.
 * ----------------------------------------------------------------------------- */

/* This should only be incremented when either the layout of swig_type_info changes,
   or for whatever reason, the runtime changes incompatibly */
#define SWIG_RUNTIME_VERSION "4"

/* define SWIG_TYPE_TABLE_NAME as "SWIG_TYPE_TABLE" */
#ifdef SWIG_TYPE_TABLE
# define SWIG_QUOTE_STRING(x) #x
# define SWIG_EXPAND_AND_QUOTE_STRING(x) SWIG_QUOTE_STRING(x)
# define SWIG_TYPE_TABLE_NAME SWIG_EXPAND_AND_QUOTE_STRING(SWIG_TYPE_TABLE)
#else
# define SWIG_TYPE_TABLE_NAME
#endif

/*
  You can use the SWIGRUNTIME and SWIGRUNTIMEINLINE macros for
  creating a static or dynamic library from the SWIG runtime code.
  In 99.9% of the cases, SWIG just needs to declare them as 'static'.

  But only do this if strictly necessary, ie, if you have problems
  with your compiler or suchlike.
*/

#ifndef SWIGRUNTIME
# define SWIGRUNTIME SWIGINTERN
#endif

#ifndef SWIGRUNTIMEINLINE
# define SWIGRUNTIMEINLINE SWIGRUNTIME SWIGINLINE
#endif

/*  Generic buffer size */
#ifndef SWIG_BUFFER_SIZE
# define SWIG_BUFFER_SIZE 1024
#endif

/* Flags for pointer conversions */
#define SWIG_POINTER_DISOWN        0x1
#define SWIG_CAST_NEW_MEMORY       0x2

/* Flags for new pointer objects */
#define SWIG_POINTER_OWN           0x1


/*
   Flags/methods for returning states.

   The SWIG conversion methods, as ConvertPtr, return an integer
   that tells if the conversion was successful or not. And if not,
   an error code can be returned (see swigerrors.swg for the codes).

   Use the following macros/flags to set or process the returning
   states.

   In old versions of SWIG, code such as the following was usually written:

     if (SWIG_ConvertPtr(obj,vptr,ty.flags) != -1) {
       // success code
     } else {
       //fail code
     }

   Now you can be more explicit:

    int res = SWIG_ConvertPtr(obj,vptr,ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
    } else {
      // fail code
    }

   which is the same really, but now you can also do

    Type *ptr;
    int res = SWIG_ConvertPtr(obj,(void **)(&ptr),ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
      if (SWIG_IsNewObj(res) {
        ...
	delete *ptr;
      } else {
        ...
      }
    } else {
      // fail code
    }

   I.e., now SWIG_ConvertPtr can return new objects and you can
   identify the case and take care of the deallocation. Of course that
   also requires SWIG_ConvertPtr to return new result values, such as

      int SWIG_ConvertPtr(obj, ptr,...) {
        if (<obj is ok>) {
          if (<need new object>) {
            *ptr = <ptr to new allocated object>;
            return SWIG_NEWOBJ;
          } else {
            *ptr = <ptr to old object>;
            return SWIG_OLDOBJ;
          }
        } else {
          return SWIG_BADOBJ;
        }
      }

   Of course, returning the plain '0(success)/-1(fail)' still works, but you can be
   more explicit by returning SWIG_BADOBJ, SWIG_ERROR or any of the
   SWIG errors code.

   Finally, if the SWIG_CASTRANK_MODE is enabled, the result code
   allows to return the 'cast rank', for example, if you have this

       int food(double)
       int fooi(int);

   and you call

      food(1)   // cast rank '1'  (1 -> 1.0)
      fooi(1)   // cast rank '0'

   just use the SWIG_AddCast()/SWIG_CheckState()
*/

#define SWIG_OK                    (0)
#define SWIG_ERROR                 (-1)
#define SWIG_IsOK(r)               (r >= 0)
#define SWIG_ArgError(r)           ((r != SWIG_ERROR) ? r : SWIG_TypeError)

/* The CastRankLimit says how many bits are used for the cast rank */
#define SWIG_CASTRANKLIMIT         (1 << 8)
/* The NewMask denotes the object was created (using new/malloc) */
#define SWIG_NEWOBJMASK            (SWIG_CASTRANKLIMIT  << 1)
/* The TmpMask is for in/out typemaps that use temporal objects */
#define SWIG_TMPOBJMASK            (SWIG_NEWOBJMASK << 1)
/* Simple returning values */
#define SWIG_BADOBJ                (SWIG_ERROR)
#define SWIG_OLDOBJ                (SWIG_OK)
#define SWIG_NEWOBJ                (SWIG_OK | SWIG_NEWOBJMASK)
#define SWIG_TMPOBJ                (SWIG_OK | SWIG_TMPOBJMASK)
/* Check, add and del mask methods */
#define SWIG_AddNewMask(r)         (SWIG_IsOK(r) ? (r | SWIG_NEWOBJMASK) : r)
#define SWIG_DelNewMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_NEWOBJMASK) : r)
#define SWIG_IsNewObj(r)           (SWIG_IsOK(r) && (r & SWIG_NEWOBJMASK))
#define SWIG_AddTmpMask(r)         (SWIG_IsOK(r) ? (r | SWIG_TMPOBJMASK) : r)
#define SWIG_DelTmpMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_TMPOBJMASK) : r)
#define SWIG_IsTmpObj(r)           (SWIG_IsOK(r) && (r & SWIG_TMPOBJMASK))

/* Cast-Rank Mode */
#if defined(SWIG_CASTRANK_MODE)
#  ifndef SWIG_TypeRank
#    define SWIG_TypeRank             unsigned long
#  endif
#  ifndef SWIG_MAXCASTRANK            /* Default cast allowed */
#    define SWIG_MAXCASTRANK          (2)
#  endif
#  define SWIG_CASTRANKMASK          ((SWIG_CASTRANKLIMIT) -1)
#  define SWIG_CastRank(r)           (r & SWIG_CASTRANKMASK)
SWIGINTERNINLINE int SWIG_AddCast(int r) {
  return SWIG_IsOK(r) ? ((SWIG_CastRank(r) < SWIG_MAXCASTRANK) ? (r + 1) : SWIG_ERROR) : r;
}
SWIGINTERNINLINE int SWIG_CheckState(int r) {
  return SWIG_IsOK(r) ? SWIG_CastRank(r) + 1 : 0;
}
#else /* no cast-rank mode */
#  define SWIG_AddCast(r) (r)
#  define SWIG_CheckState(r) (SWIG_IsOK(r) ? 1 : 0)
#endif


#include <string.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef void *(*swig_converter_func)(void *, int *);
typedef struct swig_type_info *(*swig_dycast_func)(void **);

/* Structure to store information on one type */
typedef struct swig_type_info {
  const char             *name;			/* mangled name of this type */
  const char             *str;			/* human readable name of this type */
  swig_dycast_func        dcast;		/* dynamic cast function down a hierarchy */
  struct swig_cast_info  *cast;			/* linked list of types that can cast into this type */
  void                   *clientdata;		/* language specific type data */
  int                    owndata;		/* flag if the structure owns the clientdata */
} swig_type_info;

/* Structure to store a type and conversion function used for casting */
typedef struct swig_cast_info {
  swig_type_info         *type;			/* pointer to type that is equivalent to this type */
  swig_converter_func     converter;		/* function to cast the void pointers */
  struct swig_cast_info  *next;			/* pointer to next cast in linked list */
  struct swig_cast_info  *prev;			/* pointer to the previous cast */
} swig_cast_info;

/* Structure used to store module information
 * Each module generates one structure like this, and the runtime collects
 * all of these structures and stores them in a circularly linked list.*/
typedef struct swig_module_info {
  swig_type_info         **types;		/* Array of pointers to swig_type_info structures that are in this module */
  size_t                 size;		        /* Number of types in this module */
  struct swig_module_info *next;		/* Pointer to next element in circularly linked list */
  swig_type_info         **type_initial;	/* Array of initially generated type structures */
  swig_cast_info         **cast_initial;	/* Array of initially generated casting structures */
  void                    *clientdata;		/* Language specific module data */
} swig_module_info;

/*
  Compare two type names skipping the space characters, therefore
  "char*" == "char *" and "Class<int>" == "Class<int >", etc.

  Return 0 when the two name types are equivalent, as in
  strncmp, but skipping ' '.
*/
SWIGRUNTIME int
SWIG_TypeNameComp(const char *f1, const char *l1,
		  const char *f2, const char *l2) {
  for (;(f1 != l1) && (f2 != l2); ++f1, ++f2) {
    while ((*f1 == ' ') && (f1 != l1)) ++f1;
    while ((*f2 == ' ') && (f2 != l2)) ++f2;
    if (*f1 != *f2) return (*f1 > *f2) ? 1 : -1;
  }
  return (int)((l1 - f1) - (l2 - f2));
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if equal, -1 if nb < tb, 1 if nb > tb
*/
SWIGRUNTIME int
SWIG_TypeCmp(const char *nb, const char *tb) {
  int equiv = 1;
  const char* te = tb + strlen(tb);
  const char* ne = nb;
  while (equiv != 0 && *ne) {
    for (nb = ne; *ne; ++ne) {
      if (*ne == '|') break;
    }
    equiv = SWIG_TypeNameComp(nb, ne, tb, te);
    if (*ne) ++ne;
  }
  return equiv;
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if not equal, 1 if equal
*/
SWIGRUNTIME int
SWIG_TypeEquiv(const char *nb, const char *tb) {
  return SWIG_TypeCmp(nb, tb) == 0 ? 1 : 0;
}

/*
  Check the typename
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheck(const char *c, swig_type_info *ty) {
  if (ty) {
    swig_cast_info *iter = ty->cast;
    while (iter) {
      if (strcmp(iter->type->name, c) == 0) {
        if (iter == ty->cast)
          return iter;
        /* Move iter to the top of the linked list */
        iter->prev->next = iter->next;
        if (iter->next)
          iter->next->prev = iter->prev;
        iter->next = ty->cast;
        iter->prev = 0;
        if (ty->cast) ty->cast->prev = iter;
        ty->cast = iter;
        return iter;
      }
      iter = iter->next;
    }
  }
  return 0;
}

/*
  Identical to SWIG_TypeCheck, except strcmp is replaced with a pointer comparison
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheckStruct(swig_type_info *from, swig_type_info *ty) {
  if (ty) {
    swig_cast_info *iter = ty->cast;
    while (iter) {
      if (iter->type == from) {
        if (iter == ty->cast)
          return iter;
        /* Move iter to the top of the linked list */
        iter->prev->next = iter->next;
        if (iter->next)
          iter->next->prev = iter->prev;
        iter->next = ty->cast;
        iter->prev = 0;
        if (ty->cast) ty->cast->prev = iter;
        ty->cast = iter;
        return iter;
      }
      iter = iter->next;
    }
  }
  return 0;
}

/*
  Cast a pointer up an inheritance hierarchy
*/
SWIGRUNTIMEINLINE void *
SWIG_TypeCast(swig_cast_info *ty, void *ptr, int *newmemory) {
  return ((!ty) || (!ty->converter)) ? ptr : (*ty->converter)(ptr, newmemory);
}

/*
   Dynamic pointer casting. Down an inheritance hierarchy
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
  swig_type_info *lastty = ty;
  if (!ty || !ty->dcast) return ty;
  while (ty && (ty->dcast)) {
    ty = (*ty->dcast)(ptr);
    if (ty) lastty = ty;
  }
  return lastty;
}

/*
  Return the name associated with this type
*/
SWIGRUNTIMEINLINE const char *
SWIG_TypeName(const swig_type_info *ty) {
  return ty->name;
}

/*
  Return the pretty name associated with this type,
  that is an unmangled type name in a form presentable to the user.
*/
SWIGRUNTIME const char *
SWIG_TypePrettyName(const swig_type_info *type) {
  /* The "str" field contains the equivalent pretty names of the
     type, separated by vertical-bar characters.  We choose
     to print the last name, as it is often (?) the most
     specific. */
  if (!type) return NULL;
  if (type->str != NULL) {
    const char *last_name = type->str;
    const char *s;
    for (s = type->str; *s; s++)
      if (*s == '|') last_name = s+1;
    return last_name;
  }
  else
    return type->name;
}

/*
   Set the clientdata field for a type
*/
SWIGRUNTIME void
SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
  swig_cast_info *cast = ti->cast;
  /* if (ti->clientdata == clientdata) return; */
  ti->clientdata = clientdata;

  while (cast) {
    if (!cast->converter) {
      swig_type_info *tc = cast->type;
      if (!tc->clientdata) {
	SWIG_TypeClientData(tc, clientdata);
      }
    }
    cast = cast->next;
  }
}
SWIGRUNTIME void
SWIG_TypeNewClientData(swig_type_info *ti, void *clientdata) {
  SWIG_TypeClientData(ti, clientdata);
  ti->owndata = 1;
}

/*
  Search for a swig_type_info structure only by mangled name
  Search is a O(log #types)

  We start searching at module start, and finish searching when start == end.
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_MangledTypeQueryModule(swig_module_info *start,
                            swig_module_info *end,
		            const char *name) {
  swig_module_info *iter = start;
  do {
    if (iter->size) {
      size_t l = 0;
      size_t r = iter->size - 1;
      do {
	/* since l+r >= 0, we can (>> 1) instead (/ 2) */
	size_t i = (l + r) >> 1;
	const char *iname = iter->types[i]->name;
	if (iname) {
	  int compare = strcmp(name, iname);
	  if (compare == 0) {
	    return iter->types[i];
	  } else if (compare < 0) {
	    if (i) {
	      r = i - 1;
	    } else {
	      break;
	    }
	  } else if (compare > 0) {
	    l = i + 1;
	  }
	} else {
	  break; /* should never happen */
	}
      } while (l <= r);
    }
    iter = iter->next;
  } while (iter != end);
  return 0;
}

/*
  Search for a swig_type_info structure for either a mangled name or a human readable name.
  It first searches the mangled names of the types, which is a O(log #types)
  If a type is not found it then searches the human readable names, which is O(#types).

  We start searching at module start, and finish searching when start == end.
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeQueryModule(swig_module_info *start,
                     swig_module_info *end,
		     const char *name) {
  /* STEP 1: Search the name field using binary search */
  swig_type_info *ret = SWIG_MangledTypeQueryModule(start, end, name);
  if (ret) {
    return ret;
  } else {
    /* STEP 2: If the type hasn't been found, do a complete search
       of the str field (the human readable name) */
    swig_module_info *iter = start;
    do {
      size_t i = 0;
      for (; i < iter->size; ++i) {
	if (iter->types[i]->str && (SWIG_TypeEquiv(iter->types[i]->str, name)))
	  return iter->types[i];
      }
      iter = iter->next;
    } while (iter != end);
  }

  /* neither found a match */
  return 0;
}

/*
   Pack binary data into a string
*/
SWIGRUNTIME char *
SWIG_PackData(char *c, void *ptr, size_t sz) {
  static const char hex[17] = "0123456789abcdef";
  const unsigned char *u = (unsigned char *) ptr;
  const unsigned char *eu =  u + sz;
  for (; u != eu; ++u) {
    unsigned char uu = *u;
    *(c++) = hex[(uu & 0xf0) >> 4];
    *(c++) = hex[uu & 0xf];
  }
  return c;
}

/*
   Unpack binary data from a string
*/
SWIGRUNTIME const char *
SWIG_UnpackData(const char *c, void *ptr, size_t sz) {
  unsigned char *u = (unsigned char *) ptr;
  const unsigned char *eu = u + sz;
  for (; u != eu; ++u) {
    char d = *(c++);
    unsigned char uu;
    if ((d >= '0') && (d <= '9'))
      uu = (unsigned char)((d - '0') << 4);
    else if ((d >= 'a') && (d <= 'f'))
      uu = (unsigned char)((d - ('a'-10)) << 4);
    else
      return (char *) 0;
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu |= (unsigned char)(d - '0');
    else if ((d >= 'a') && (d <= 'f'))
      uu |= (unsigned char)(d - ('a'-10));
    else
      return (char *) 0;
    *u = uu;
  }
  return c;
}

/*
   Pack 'void *' into a string buffer.
*/
SWIGRUNTIME char *
SWIG_PackVoidPtr(char *buff, void *ptr, const char *name, size_t bsz) {
  char *r = buff;
  if ((2*sizeof(void *) + 2) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,&ptr,sizeof(void *));
  if (strlen(name) + 1 > (bsz - (r - buff))) return 0;
  strcpy(r,name);
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackVoidPtr(const char *c, void **ptr, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      *ptr = (void *) 0;
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sizeof(void *));
}

SWIGRUNTIME char *
SWIG_PackDataName(char *buff, void *ptr, size_t sz, const char *name, size_t bsz) {
  char *r = buff;
  size_t lname = (name ? strlen(name) : 0);
  if ((2*sz + 2 + lname) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,ptr,sz);
  if (lname) {
    strncpy(r,name,lname+1);
  } else {
    *r = 0;
  }
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackDataName(const char *c, void *ptr, size_t sz, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      memset(ptr,0,sz);
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sz);
}

#ifdef __cplusplus
}
#endif

/* -----------------------------------------------------------------------------
 * luarun.swg
 *
 * This file contains the runtime support for Lua modules
 * and includes code for managing global variables and pointer
 * type checking.
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#endif

#include "lua.h"
#include "lauxlib.h"
#include <stdlib.h>  /* for malloc */
#include <assert.h>  /* for a few sanity tests */

/* -----------------------------------------------------------------------------
 * Lua flavors
 * ----------------------------------------------------------------------------- */

#define SWIG_LUA_FLAVOR_LUA 1
#define SWIG_LUA_FLAVOR_ELUA 2
#define SWIG_LUA_FLAVOR_ELUAC 3

#if !defined(SWIG_LUA_TARGET)
# error SWIG_LUA_TARGET not defined
#endif

#if defined(SWIG_LUA_ELUA_EMULATE)

struct swig_elua_entry;

typedef struct swig_elua_key {
  int type;
  union {
    const char* strkey;
    lua_Number numkey;
  } key;
} swig_elua_key;

typedef struct swig_elua_val {
  int type;
  union {
    lua_Number number;
    const struct swig_elua_entry *table;
    const char *string;
    lua_CFunction function;
    struct {
      char member;
      long lvalue;
      void *pvalue;
      swig_type_info **ptype;
    } userdata;
  } value;
} swig_elua_val;

typedef struct swig_elua_entry {
  swig_elua_key key;
  swig_elua_val value;
} swig_elua_entry;

#define LSTRKEY(x) {LUA_TSTRING, {.strkey = x} }
#define LNUMKEY(x) {LUA_TNUMBER, {.numkey = x} }
#define LNILKEY {LUA_TNIL, {.strkey = 0} }

#define LNUMVAL(x) {LUA_TNUMBER, {.number = x} }
#define LFUNCVAL(x) {LUA_TFUNCTION, {.function = x} }
#define LROVAL(x) {LUA_TTABLE, {.table = x} }
#define LNILVAL {LUA_TNIL, {.string = 0} }
#define LSTRVAL(x) {LUA_TSTRING, {.string = x} }

#define LUA_REG_TYPE swig_elua_entry

#define SWIG_LUA_ELUA_EMUL_METATABLE_KEY "__metatable"

#define lua_pushrotable(L,p)\
  lua_newtable(L);\
  assert(p);\
  SWIG_Lua_elua_emulate_register(L,(swig_elua_entry*)(p));

#define SWIG_LUA_CONSTTAB_POINTER(B,C,D)\
  LSTRKEY(B), {LUA_TUSERDATA, { .userdata={0,0,(void*)(C),&D} } }

#define SWIG_LUA_CONSTTAB_BINARY(B,S,C,D)\
  LSTRKEY(B), {LUA_TUSERDATA, { .userdata={1,S,(void*)(C),&D} } }
#endif

#if (SWIG_LUA_TARGET == SWIG_LUA_FLAVOR_ELUA) || (SWIG_LUA_TARGET == SWIG_LUA_FLAVOR_ELUAC)
#  define SWIG_LUA_CONSTTAB_INT(B, C) LSTRKEY(B), LNUMVAL(C)
#  define SWIG_LUA_CONSTTAB_FLOAT(B, C) LSTRKEY(B), LNUMVAL(C)
#  define SWIG_LUA_CONSTTAB_STRING(B, C) LSTRKEY(B), LSTRVAL(C)
#  define SWIG_LUA_CONSTTAB_CHAR(B, C) LSTRKEY(B), LNUMVAL(C)
    /* Those two types of constants are not supported in elua */

#ifndef SWIG_LUA_CONSTTAB_POINTER
#warning eLua does not support pointers as constants. By default, nil will be used as value
#define SWIG_LUA_CONSTTAB_POINTER(B,C,D) LSTRKEY(B), LNILVAL
#endif

#ifndef SWIG_LUA_CONSTTAB_BINARY
#warning eLua does not support pointers to member as constants. By default, nil will be used as value
#define SWIG_LUA_CONSTTAB_BINARY(B, S, C, D) LSTRKEY(B), LNILVAL
#endif
#else /* SWIG_LUA_FLAVOR_LUA */
#  define SWIG_LUA_CONSTTAB_INT(B, C) SWIG_LUA_INT, (char *)B, (long)C, 0, 0, 0
#  define SWIG_LUA_CONSTTAB_FLOAT(B, C) SWIG_LUA_FLOAT, (char *)B, 0, (double)C, 0, 0
#  define SWIG_LUA_CONSTTAB_STRING(B, C) SWIG_LUA_STRING, (char *)B, 0, 0, (void *)C, 0
#  define SWIG_LUA_CONSTTAB_CHAR(B, C) SWIG_LUA_CHAR, (char *)B, (long)C, 0, 0, 0
#  define SWIG_LUA_CONSTTAB_POINTER(B,C,D)\
       SWIG_LUA_POINTER, (char *)B, 0, 0, (void *)C, &D
#  define SWIG_LUA_CONSTTAB_BINARY(B, S, C, D)\
       SWIG_LUA_BINARY,  (char *)B, S, 0, (void *)C, &D
#endif

#ifndef SWIG_LUA_ELUA_EMULATE
#if (SWIG_LUA_TARGET == SWIG_LUA_FLAVOR_ELUA) || (SWIG_LUA_TARGET == SWIG_LUA_FLAVOR_ELUAC)
#  define LRO_STRVAL(v) {{.p = (char *) v}, LUA_TSTRING}
#  define LSTRVAL LRO_STRVAL
#endif
#endif /* SWIG_LUA_ELUA_EMULATE*/

#ifndef SWIG_LUA_ELUA_EMULATE
#if (SWIG_LUA_TARGET == SWIG_LUA_FLAVOR_ELUA) || (SWIG_LUA_TARGET == SWIG_LUA_FLAVOR_ELUAC)

#ifndef MIN_OPT_LEVEL
#define MIN_OPT_LEVEL 2
#endif

#include "lrodefs.h"
#include "lrotable.h"
#endif
#endif /* SWIG_LUA_ELUA_EMULATE*/
/* -----------------------------------------------------------------------------
 * compatibility defines
 * ----------------------------------------------------------------------------- */

/* History of Lua C API length functions:  In Lua 5.0 (and before?)
   there was "lua_strlen".  In Lua 5.1, this was renamed "lua_objlen",
   but a compatibility define of "lua_strlen" was added.  In Lua 5.2,
   this function was again renamed, to "lua_rawlen" (to emphasize that
   it doesn't call the "__len" metamethod), and the compatibility
   define of lua_strlen was removed.  All SWIG uses have been updated
   to "lua_rawlen", and we add our own defines of that here for older
   versions of Lua.  */
#if !defined(LUA_VERSION_NUM) || LUA_VERSION_NUM < 501
# define lua_rawlen lua_strlen
#elif LUA_VERSION_NUM == 501
# define lua_rawlen lua_objlen
#endif


/* lua_pushglobaltable is the recommended "future-proof" way to get
   the global table for Lua 5.2 and later.  Here we define
   lua_pushglobaltable ourselves for Lua versions before 5.2.  */
#if !defined(LUA_VERSION_NUM) || LUA_VERSION_NUM < 502
# define lua_pushglobaltable(L) lua_pushvalue(L, LUA_GLOBALSINDEX)
#endif

/* lua_absindex was introduced in Lua 5.2 */
#if !defined(LUA_VERSION_NUM) || LUA_VERSION_NUM < 502
# define lua_absindex(L,i) ((i)>0 || (i) <= LUA_REGISTRYINDEX ? (i) : lua_gettop(L) + (i) + 1)
#endif

/* lua_rawsetp was introduced in Lua 5.2 */
#if !defined(LUA_VERSION_NUM) || LUA_VERSION_NUM < 502
#define lua_rawsetp(L,index,ptr)\
  lua_pushlightuserdata(L,(void*)(ptr));\
  lua_insert(L,-2);\
  lua_rawset(L,index);

#define lua_rawgetp(L,index,ptr)\
  lua_pushlightuserdata(L,(void*)(ptr));\
  lua_rawget(L,index);

#endif

/* --------------------------------------------------------------------------
 * Helper functions for error handling
 * -------------------------------------------------------------------------- */

/* Push the string STR on the Lua stack, like lua_pushstring, but
   prefixed with the the location of the innermost Lua call-point
   (as formated by luaL_where).  */
SWIGRUNTIME void
SWIG_Lua_pusherrstring (lua_State *L, const char *str)
{
  luaL_where (L, 1);
  lua_pushstring (L, str);
  lua_concat (L, 2);
}

/* Push a formatted string generated from FMT and following args on
   the Lua stack, like lua_pushfstring, but prefixed with the the
   location of the innermost Lua call-point (as formated by luaL_where).  */
SWIGRUNTIME void
SWIG_Lua_pushferrstring (lua_State *L, const char *fmt, ...)
{
  va_list argp;
  va_start(argp, fmt);
  luaL_where(L, 1);
  lua_pushvfstring(L, fmt, argp);
  va_end(argp);
  lua_concat(L, 2);
}


/* -----------------------------------------------------------------------------
 * global swig types
 * ----------------------------------------------------------------------------- */
/* Constant table */
#define SWIG_LUA_INT     1
#define SWIG_LUA_FLOAT   2
#define SWIG_LUA_STRING  3
#define SWIG_LUA_POINTER 4
#define SWIG_LUA_BINARY  5
#define SWIG_LUA_CHAR    6

/* Structure for variable linking table */
typedef struct {
  const char *name;
  lua_CFunction get;
  lua_CFunction set;
} swig_lua_var_info;

#if (SWIG_LUA_TARGET == SWIG_LUA_FLAVOR_ELUA) || (SWIG_LUA_TARGET == SWIG_LUA_FLAVOR_ELUAC)
typedef const LUA_REG_TYPE swig_lua_method;
typedef const LUA_REG_TYPE swig_lua_const_info;
#else /* Normal lua */
typedef luaL_Reg swig_lua_method;

/* Constant information structure */
typedef struct {
    int type;
    char *name;
    long lvalue;
    double dvalue;
    void   *pvalue;
    swig_type_info **ptype;
} swig_lua_const_info;

#endif

typedef struct {
  const char     *name;
  lua_CFunction   getmethod;
  lua_CFunction   setmethod;
} swig_lua_attribute;


struct swig_lua_class;
/* Can be used to create namespaces. Currently used to wrap class static methods/variables/constants */
typedef struct swig_lua_namespace {
  const char            *name;
  swig_lua_method       *ns_methods;
  swig_lua_attribute    *ns_attributes;
  swig_lua_const_info   *ns_constants;
  struct swig_lua_class        **ns_classes;
  struct swig_lua_namespace    **ns_namespaces;
} swig_lua_namespace;

typedef struct swig_lua_class {
  const char    *name; /* Name that this class has in Lua */
  const char    *fqname; /* Fully qualified name - Scope + class name */
  swig_type_info   **type;
  lua_CFunction  constructor;
  void    (*destructor)(void *);
  swig_lua_method   *methods;
  swig_lua_attribute     *attributes;
  swig_lua_namespace    *cls_static;
  swig_lua_method   *metatable; /* 0 for -eluac */
  struct swig_lua_class **bases;
  const char **base_names;
} swig_lua_class;

/* this is the struct for wrapping all pointers in SwigLua
*/
typedef struct {
  swig_type_info   *type;
  int     own;  /* 1 if owned & must be destroyed */
  void        *ptr;
} swig_lua_userdata;

/* this is the struct for wrapping arbitrary packed binary data
(currently it is only used for member function pointers)
the data ordering is similar to swig_lua_userdata, but it is currently not possible
to tell the two structures apart within SWIG, other than by looking at the type
*/
typedef struct {
  swig_type_info   *type;
  int     own;  /* 1 if owned & must be destroyed */
  char data[1];       /* arbitary amount of data */    
} swig_lua_rawdata;

/* Common SWIG API */
#define SWIG_NewPointerObj(L, ptr, type, owner)       SWIG_Lua_NewPointerObj(L, (void *)ptr, type, owner)
#define SWIG_ConvertPtr(L,idx, ptr, type, flags)    SWIG_Lua_ConvertPtr(L,idx,ptr,type,flags)
#define SWIG_MustGetPtr(L,idx, type,flags, argnum,fnname)  SWIG_Lua_MustGetPtr(L,idx, type,flags, argnum,fnname)
/* for C++ member pointers, ie, member methods */
#define SWIG_ConvertMember(L, idx, ptr, sz, ty)       SWIG_Lua_ConvertPacked(L, idx, ptr, sz, ty)
#define SWIG_NewMemberObj(L, ptr, sz, type)      SWIG_Lua_NewPackedObj(L, ptr, sz, type)

/* Runtime API */
#define SWIG_GetModule(clientdata) SWIG_Lua_GetModule((lua_State*)(clientdata))
#define SWIG_SetModule(clientdata, pointer) SWIG_Lua_SetModule((lua_State*) (clientdata), pointer)
#define SWIG_MODULE_CLIENTDATA_TYPE lua_State*

/* Contract support */
#define SWIG_contract_assert(expr, msg)  \
  if (!(expr)) { SWIG_Lua_pusherrstring(L, (char *) msg); goto fail; } else


/* helper #defines */
#define SWIG_fail {goto fail;}
#define SWIG_fail_arg(func_name,argnum,type) \
  {SWIG_Lua_pushferrstring(L,"Error in %s (arg %d), expected '%s' got '%s'",\
  func_name,argnum,type,SWIG_Lua_typename(L,argnum));\
  goto fail;}
#define SWIG_fail_ptr(func_name,argnum,type) \
  SWIG_fail_arg(func_name,argnum,(type && type->str)?type->str:"void*")
#define SWIG_check_num_args(func_name,a,b) \
  if (lua_gettop(L)<a || lua_gettop(L)>b) \
  {SWIG_Lua_pushferrstring(L,"Error in %s expected %d..%d args, got %d",func_name,a,b,lua_gettop(L));\
  goto fail;}


#define SWIG_Lua_get_table(L,n) \
  (lua_pushstring(L, n), lua_rawget(L,-2))

#define SWIG_Lua_add_function(L,n,f) \
  (lua_pushstring(L, n), \
      lua_pushcfunction(L, f), \
      lua_rawset(L,-3))

#define SWIG_Lua_add_boolean(L,n,b) \
  (lua_pushstring(L, n), \
      lua_pushboolean(L, b), \
      lua_rawset(L,-3))

/* special helper for allowing 'nil' for usertypes */
#define SWIG_isptrtype(L,I) (lua_isuserdata(L,I) || lua_isnil(L,I))

#ifdef __cplusplus
/* Special helper for member function pointers 
it gets the address, casts it, then dereferences it */
/*#define SWIG_mem_fn_as_voidptr(a)  (*((char**)&(a))) */
#endif

/* storing/access of swig_module_info */
SWIGRUNTIME swig_module_info *
SWIG_Lua_GetModule(lua_State *L) {
  swig_module_info *ret = 0;
  lua_pushstring(L,"swig_runtime_data_type_pointer" SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME);
  lua_rawget(L,LUA_REGISTRYINDEX);
  if (lua_islightuserdata(L,-1))
    ret=(swig_module_info*)lua_touserdata(L,-1);
  lua_pop(L,1);  /* tidy */
  return ret;
}

SWIGRUNTIME void
SWIG_Lua_SetModule(lua_State *L, swig_module_info *module) {
  /* add this all into the Lua registry: */
  lua_pushstring(L,"swig_runtime_data_type_pointer" SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME);
  lua_pushlightuserdata(L,(void*)module);
  lua_rawset(L,LUA_REGISTRYINDEX);
}

/* -----------------------------------------------------------------------------
 * global variable support code: modules
 * ----------------------------------------------------------------------------- */

/* this function is called when trying to set an immutable.
default action is to print an error.
This can removed with a compile flag SWIGLUA_IGNORE_SET_IMMUTABLE */
SWIGINTERN int SWIG_Lua_set_immutable(lua_State *L)
{
/*  there should be 1 param passed in: the new value */
#ifndef SWIGLUA_IGNORE_SET_IMMUTABLE
  lua_pop(L,1);  /* remove it */
  luaL_error(L,"This variable is immutable");
#endif
    return 0;   /* should not return anything */
}

#ifdef SWIG_LUA_ELUA_EMULATE

SWIGRUNTIME void SWIG_Lua_NewPointerObj(lua_State *L,void *ptr,swig_type_info *type, int own);
SWIGRUNTIME void SWIG_Lua_NewPackedObj(lua_State *L,void *ptr,size_t size,swig_type_info *type);
static int swig_lua_elua_emulate_unique_key;

/* This function emulates eLua rotables behaviour. It loads a rotable definition into the usual lua table. */
SWIGINTERN void SWIG_Lua_elua_emulate_register(lua_State *L, const swig_elua_entry *table)
{
  int i, table_parsed, parsed_tables_array, target_table;
  assert(lua_istable(L,-1));
  target_table = lua_gettop(L);
  /* Get the registry where we put all parsed tables to avoid loops */
  lua_rawgetp(L, LUA_REGISTRYINDEX, &swig_lua_elua_emulate_unique_key);
  if(lua_isnil(L,-1)) {
    lua_pop(L,1);
    lua_newtable(L);
    lua_pushvalue(L,-1);
    lua_rawsetp(L,LUA_REGISTRYINDEX,(void*)(&swig_lua_elua_emulate_unique_key));
  }
  parsed_tables_array = lua_gettop(L);
  lua_pushvalue(L,target_table);
  lua_rawsetp(L, parsed_tables_array, table);
  table_parsed = 0;
  const int SWIGUNUSED pairs_start = lua_gettop(L);
  for(i = 0;table[i].key.type != LUA_TNIL || table[i].value.type != LUA_TNIL;i++)
  {
    const swig_elua_entry *entry = table + i;
    int is_metatable = 0;
    switch(entry->key.type) {
      case LUA_TSTRING:
        lua_pushstring(L,entry->key.key.strkey);
        if(strcmp(entry->key.key.strkey, SWIG_LUA_ELUA_EMUL_METATABLE_KEY) == 0)
          is_metatable = 1;
        break;
      case  LUA_TNUMBER:
        lua_pushnumber(L,entry->key.key.numkey);
        break;
      case LUA_TNIL:
        lua_pushnil(L);
        break;
      default:
        assert(0);
    }
    switch(entry->value.type) {
      case LUA_TSTRING:
        lua_pushstring(L,entry->value.value.string);
        break;
      case  LUA_TNUMBER:
        lua_pushnumber(L,entry->value.value.number);
        break;
      case LUA_TFUNCTION:
        lua_pushcfunction(L,entry->value.value.function);
        break;
      case LUA_TTABLE:
        lua_rawgetp(L,parsed_tables_array, entry->value.value.table);
        table_parsed = !lua_isnil(L,-1);
        if(!table_parsed) {
          lua_pop(L,1); /*remove nil */
          lua_newtable(L);
          SWIG_Lua_elua_emulate_register(L,entry->value.value.table);
        } 
        if(is_metatable) {
          assert(lua_istable(L,-1));
          lua_pushvalue(L,-1);
          lua_setmetatable(L,target_table);
        }

        break;
      case LUA_TUSERDATA:
        if(entry->value.value.userdata.member) 
          SWIG_NewMemberObj(L,entry->value.value.userdata.pvalue,
              entry->value.value.userdata.lvalue,
              *(entry->value.value.userdata.ptype));
        else 
          SWIG_NewPointerObj(L,entry->value.value.userdata.pvalue,
              *(entry->value.value.userdata.ptype),0);
        break;
      case LUA_TNIL:
        lua_pushnil(L);
        break;
      default:
        assert(0);
    }
    assert(lua_gettop(L) == pairs_start + 2);
    lua_rawset(L,target_table);
  }
  lua_pop(L,1); /* Removing parsed tables storage */
  assert(lua_gettop(L) == target_table);
}

SWIGINTERN void SWIG_Lua_elua_emulate_register_clear(lua_State *L)
{
  lua_pushnil(L);
  lua_rawsetp(L, LUA_REGISTRYINDEX, &swig_lua_elua_emulate_unique_key);
}

SWIGINTERN void SWIG_Lua_get_class_registry(lua_State *L);

SWIGINTERN int SWIG_Lua_emulate_elua_getmetatable(lua_State *L)
{
  SWIG_check_num_args("getmetatable(SWIG eLua emulation)", 1, 1);
  SWIG_Lua_get_class_registry(L);
  lua_getfield(L,-1,"lua_getmetatable");
  lua_remove(L,-2); /* remove the registry*/
  assert(!lua_isnil(L,-1));
  lua_pushvalue(L,1);
  assert(lua_gettop(L) == 3); /* object | function | object again */
  lua_call(L,1,1);
  if(!lua_isnil(L,-1)) /*There is an ordinary metatable */
    return 1;
  /*if it is a table, then emulate elua behaviour - check for __metatable attribute of a table*/
  assert(lua_gettop(L) == 2);
  if(lua_istable(L,-2)) {
    lua_pop(L,1); /*remove the nil*/
    lua_getfield(L,-1, SWIG_LUA_ELUA_EMUL_METATABLE_KEY);
  }
  assert(lua_gettop(L) == 2);
  return 1;
  
fail:
  lua_error(L);
  return 0;
}

SWIGINTERN void SWIG_Lua_emulate_elua_swap_getmetatable(lua_State *L)
{
  SWIG_Lua_get_class_registry(L);
  lua_pushglobaltable(L);
  lua_pushstring(L,"lua_getmetatable");
  lua_getfield(L,-2,"getmetatable");
  assert(!lua_isnil(L,-1));
  lua_rawset(L,-4);
  lua_pushstring(L, "getmetatable");
  lua_pushcfunction(L, SWIG_Lua_emulate_elua_getmetatable);
  lua_rawset(L,-3);
  lua_pop(L,2);
      
}
/* END OF REMOVE */

#endif
/* -----------------------------------------------------------------------------
 * global variable support code: namespaces and modules (which are the same thing)
 * ----------------------------------------------------------------------------- */

SWIGINTERN int SWIG_Lua_namespace_get(lua_State *L)
{
/*  there should be 2 params passed in
  (1) table (not the meta table)
  (2) string name of the attribute
*/
  assert(lua_istable(L,-2));  /* just in case */
  lua_getmetatable(L,-2);
  assert(lua_istable(L,-1));
  SWIG_Lua_get_table(L,".get"); /* find the .get table */
  assert(lua_istable(L,-1));
  /* look for the key in the .get table */
  lua_pushvalue(L,2);  /* key */
  lua_rawget(L,-2);
  lua_remove(L,-2); /* stack tidy, remove .get table */
  if (lua_iscfunction(L,-1))
  {  /* found it so call the fn & return its value */
    lua_call(L,0,1);  /* 1 value in (userdata),1 out (result) */
    lua_remove(L,-2); /* stack tidy, remove metatable */
    return 1;
  }
  lua_pop(L,1);  /* remove whatever was there */
  /* ok, so try the .fn table */
  SWIG_Lua_get_table(L,".fn"); /* find the .get table */
  assert(lua_istable(L,-1));  /* just in case */
  lua_pushvalue(L,2);  /* key */
  lua_rawget(L,-2);  /* look for the fn */
  lua_remove(L,-2); /* stack tidy, remove .fn table */
  if (lua_isfunction(L,-1)) /* note: whether it's a C function or lua function */
  {  /* found it so return the fn & let lua call it */
    lua_remove(L,-2); /* stack tidy, remove metatable */
    return 1;
  }
  lua_pop(L,1);  /* remove whatever was there */
  return 0;
}

SWIGINTERN int SWIG_Lua_namespace_set(lua_State *L)
{
/*  there should be 3 params passed in
  (1) table (not the meta table)
  (2) string name of the attribute
  (3) any for the new value
*/

  assert(lua_istable(L,1));
  lua_getmetatable(L,1);    /* get the meta table */
  assert(lua_istable(L,-1));

  SWIG_Lua_get_table(L,".set"); /* find the .set table */
  if (lua_istable(L,-1))
  {
    /* look for the key in the .set table */
    lua_pushvalue(L,2);  /* key */
    lua_rawget(L,-2);
    if (lua_iscfunction(L,-1))
    {  /* found it so call the fn & return its value */
      lua_pushvalue(L,3);  /* value */
      lua_call(L,1,0);
      return 0;
    }
    lua_pop(L,1);  /* remove the value */
  }
  lua_pop(L,1);  /* remove the value .set table */
  lua_pop(L,1); /* remote metatable */
  lua_rawset(L,-3);
  return 0;
}

#if (SWIG_LUA_TARGET == SWIG_LUA_FLAVOR_LUA) /* In elua this is useless */
SWIGINTERN void SWIG_Lua_InstallConstants(lua_State *L, swig_lua_const_info constants[]); /* forward declaration */
SWIGINTERN void  SWIG_Lua_add_variable(lua_State *L,const char *name,lua_CFunction getFn,lua_CFunction setFn); /* forward declaration */
SWIGINTERN void  SWIG_Lua_class_register(lua_State *L,swig_lua_class *clss);

/* helper function - register namespace methods and attributes into namespace */
SWIGINTERN int SWIG_Lua_add_namespace_details(lua_State *L, swig_lua_namespace *ns)
{
  int i;
  /* There must be namespace table (not metatable) at the top of the stack */
  assert(lua_istable(L,-1));
  SWIG_Lua_InstallConstants(L, ns->ns_constants);

  /* add methods to the namespace/module table */
  for(i=0;ns->ns_methods[i].name;i++){
    SWIG_Lua_add_function(L,ns->ns_methods[i].name,ns->ns_methods[i].func);
  }
  lua_getmetatable(L,-1);

  /* add fns */
  for(i=0;ns->ns_attributes[i].name;i++){
    SWIG_Lua_add_variable(L,ns->ns_attributes[i].name,ns->ns_attributes[i].getmethod,ns->ns_attributes[i].setmethod);
  }

  /* clear stack - remove metatble */
  lua_pop(L,1);
  return 0;
}

/* Register all classes in the namespace */
SWIGINTERN void SWIG_Lua_add_namespace_classes(lua_State *L, swig_lua_namespace *ns)
{
  swig_lua_class **classes;

  /* There must be a module/namespace table at the top of the stack */
  assert(lua_istable(L,-1));

  classes = ns->ns_classes;

  if( classes != 0 ) {
    while(*classes != 0) {
      SWIG_Lua_class_register(L, *classes);
      classes++;
    }
  }
}

/* Helper function. Creates namespace table and adds it to module table
   if 'reg' is true, then will register namespace table to parent one (must be on top of the stack
   when function is called).
   Function always returns newly registered table on top of the stack.
*/
SWIGINTERN void SWIG_Lua_namespace_register(lua_State *L, swig_lua_namespace *ns, int reg)
{
  swig_lua_namespace **sub_namespace;
  /* 1 argument - table on the top of the stack */
  const int SWIGUNUSED begin = lua_gettop(L);
  assert(lua_istable(L,-1)); /* just in case. This is supposed to be module table or parent namespace table */
  lua_checkstack(L,5);
  lua_newtable(L); /* namespace itself */
  lua_newtable(L); /* metatable for namespace */

  /* add a table called ".get" */
  lua_pushstring(L,".get");
  lua_newtable(L);
  lua_rawset(L,-3);
  /* add a table called ".set" */
  lua_pushstring(L,".set");
  lua_newtable(L);
  lua_rawset(L,-3);
  /* add a table called ".fn" */
  lua_pushstring(L,".fn");
  lua_newtable(L);
  lua_rawset(L,-3);

  /* add accessor fns for using the .get,.set&.fn */
  SWIG_Lua_add_function(L,"__index",SWIG_Lua_namespace_get);
  SWIG_Lua_add_function(L,"__newindex",SWIG_Lua_namespace_set);

  lua_setmetatable(L,-2); /* set metatable */

  /* Register all functions, variables etc */
  SWIG_Lua_add_namespace_details(L,ns);
  /* Register classes */
  SWIG_Lua_add_namespace_classes(L,ns);

  sub_namespace = ns->ns_namespaces;
  if( sub_namespace != 0) {
    while(*sub_namespace != 0) {
      SWIG_Lua_namespace_register(L, *sub_namespace, 1);
      lua_pop(L,1); /* removing sub-namespace table */
      sub_namespace++;
    }
  }

  if (reg) {
    lua_pushstring(L,ns->name);
    lua_pushvalue(L,-2);
    lua_rawset(L,-4); /* add namespace to module table */
  }
  assert(lua_gettop(L) == begin+1);
}
#endif /* SWIG_LUA_TARGET == SWIG_LUA_FLAVOR_LUA */

/* -----------------------------------------------------------------------------
 * global variable support code: classes
 * ----------------------------------------------------------------------------- */

SWIGINTERN void  SWIG_Lua_get_class_metatable(lua_State *L,const char *cname);

typedef int (*swig_lua_base_iterator_func)(lua_State*,swig_type_info*, int, int *ret);

SWIGINTERN int SWIG_Lua_iterate_bases(lua_State *L, swig_type_info * SWIGUNUSED swig_type,
  int first_arg, swig_lua_base_iterator_func func, int  *const ret)
{
    /* first_arg - position of the object in stack. Everything that is above are arguments
     * and is passed to every evocation of the func */
    int last_arg = lua_gettop(L);/* position of last argument */
    int original_metatable = last_arg + 1;
    size_t bases_count;
    int result = SWIG_ERROR;
    int bases_table;
    (void)swig_type;
    lua_getmetatable(L,first_arg);

    /* initialise base search */
#if (SWIG_LUA_TARGET == SWIG_LUA_FLAVOR_LUA)
    SWIG_Lua_get_table(L,".bases");
    assert(lua_istable(L,-1));
    bases_count = lua_rawlen(L,-1);
    bases_table = lua_gettop(L);
#else
    /* In elua .bases table doesn't exist. Use table from swig_lua_class */
    (void)bases_table;
    assert(swig_type!=0);
    swig_module_info *module=SWIG_GetModule(L);
    swig_lua_class **bases= ((swig_lua_class*)(swig_type->clientdata))->bases;
    const char **base_names= ((swig_lua_class*)(swig_type->clientdata))->base_names;
    bases_count = 0;
    for(;base_names[bases_count];
      bases_count++);/* get length of bases */
#endif

    if(ret)
      *ret = 0;
    if(bases_count>0)
    {
      int to_remove;
      size_t i;
      int j;
      int subcall_last_arg;
      int subcall_first_arg = lua_gettop(L) + 1;/* Here a copy of first_arg and arguments begin */
      int valid = 1;
      swig_type_info *base_swig_type = 0;
      for(j=first_arg;j<=last_arg;j++)
        lua_pushvalue(L,j);
      subcall_last_arg = lua_gettop(L);

      /* Trick: temporarily replacing original metatable with metatable for base class and call getter */
      for(i=0;i<bases_count;i++) {
        /* Iteration through class bases */
#if (SWIG_LUA_TARGET == SWIG_LUA_FLAVOR_LUA)
        lua_rawgeti(L,bases_table,i+1);
        base_swig_type = 0;
        if(lua_isnil(L,-1)) {
          valid = 0;
          lua_pop(L,1);
        } else {
          valid = 1;
        }
#else /* In elua .bases table doesn't exist. Use table from swig_lua_class */
        swig_lua_class *base_class = bases[i];
        if(!base_class) {
          valid = 0;
        } else {
          valid = 1;
          SWIG_Lua_get_class_metatable(L,base_class->fqname);
          base_swig_type = SWIG_TypeQueryModule(module,module,base_names[i]);
          assert(base_swig_type != 0);
        }
#endif

        if(!valid)
          continue;
        assert(lua_isuserdata(L, subcall_first_arg));
        assert(lua_istable(L,-1));
        lua_setmetatable(L,subcall_first_arg); /* Set new metatable */
        assert(lua_gettop(L) == subcall_last_arg);
        result = func(L, base_swig_type,subcall_first_arg, ret); /* Forward call */
        if(result != SWIG_ERROR) {
          break;
        }
      }
      /* Restore original metatable */
      lua_pushvalue(L,original_metatable);
      lua_setmetatable(L,first_arg);
      /* Clear - remove everything between last_arg and subcall_last_arg including */
      to_remove = subcall_last_arg - last_arg;
      for(j=0;j<to_remove;j++)
        lua_remove(L,last_arg+1);
    } else {
      /* Remove everything after last_arg */
      lua_pop(L, lua_gettop(L) - last_arg);
    }
    if(ret) assert(lua_gettop(L) == last_arg + *ret);
    return result;
}

/* The class.get method helper, performs the lookup of class attributes.
 * It returns an error code. Number of function return values is passed inside 'ret'.
 * first_arg is not used in this function because function always has 2 arguments.
 */
SWIGINTERN int  SWIG_Lua_class_do_get_item(lua_State *L, swig_type_info *type, int SWIGUNUSED first_arg, int *ret)
{
/*  there should be 2 params passed in
  (1) userdata (not the meta table)
  (2) string name of the attribute
*/
  int bases_search_result;
  int substack_start = lua_gettop(L)-2;
  assert(first_arg == substack_start+1);
  lua_checkstack(L,5);
  assert(lua_isuserdata(L,-2));  /* just in case */
  lua_getmetatable(L,-2);    /* get the meta table */
  assert(lua_istable(L,-1));  /* just in case */
  /* NEW: looks for the __getitem() fn
  this is a user provided get fn */
  SWIG_Lua_get_table(L,"__getitem"); /* find the __getitem fn */
  if (lua_iscfunction(L,-1))  /* if its there */
  {  /* found it so call the fn & return its value */
    lua_pushvalue(L,substack_start+1);  /* the userdata */
    lua_pushvalue(L,substack_start+2);  /* the parameter */
    lua_call(L,2,1);  /* 2 value in (userdata),1 out (result) */
    lua_remove(L,-2); /* stack tidy, remove metatable */
    if(ret) *ret = 1;
    return SWIG_OK;
  }
  lua_pop(L,1);
  /* Remove the metatable */
  lua_pop(L,1);
  /* Search in base classes */
  bases_search_result = SWIG_Lua_iterate_bases(L,type,substack_start+1,SWIG_Lua_class_do_get_item,ret);
  return bases_search_result;  /* sorry not known */
}


/* The class.get method helper, performs the lookup of class attributes.
 * It returns an error code. Number of function return values is passed inside 'ret'.
 * first_arg is not used in this function because function always has 2 arguments.
 */
SWIGINTERN int  SWIG_Lua_class_do_get(lua_State *L, swig_type_info *type, int SWIGUNUSED first_arg, int *ret)
{
/*  there should be 2 params passed in
  (1) userdata (not the meta table)
  (2) string name of the attribute
*/
  int bases_search_result;
  int substack_start = lua_gettop(L)-2;
  assert(first_arg == substack_start+1);
  lua_checkstack(L,5);
  assert(lua_isuserdata(L,-2));  /* just in case */
  lua_getmetatable(L,-2);    /* get the meta table */
  assert(lua_istable(L,-1));  /* just in case */
  SWIG_Lua_get_table(L,".get"); /* find the .get table */
  assert(lua_istable(L,-1));  /* just in case */
  /* look for the key in the .get table */
  lua_pushvalue(L,substack_start+2);  /* key */
  lua_rawget(L,-2);
  lua_remove(L,-2); /* stack tidy, remove .get table */
  if (lua_iscfunction(L,-1))
  {  /* found it so call the fn & return its value */
    lua_pushvalue(L,substack_start+1);  /* the userdata */
    lua_call(L,1,1);  /* 1 value in (userdata),1 out (result) */
    lua_remove(L,-2); /* stack tidy, remove metatable */
    if(ret)
      *ret = 1;
    return SWIG_OK;
  }
  lua_pop(L,1);  /* remove whatever was there */
  /* ok, so try the .fn table */
  SWIG_Lua_get_table(L,".fn"); /* find the .fn table */
  assert(lua_istable(L,-1));  /* just in case */
  lua_pushvalue(L,substack_start+2);  /* key */
  lua_rawget(L,-2);  /* look for the fn */
  lua_remove(L,-2); /* stack tidy, remove .fn table */
  if (lua_isfunction(L,-1)) /* note: if its a C function or lua function */
  {  /* found it so return the fn & let lua call it */
    lua_remove(L,-2); /* stack tidy, remove metatable */
    if(ret)
      *ret = 1;
    return SWIG_OK;
  }
  lua_pop(L,1);  /* remove whatever was there */
  /* Remove the metatable */
  lua_pop(L,1);
  /* Search in base classes */
  bases_search_result = SWIG_Lua_iterate_bases(L,type,substack_start+1,SWIG_Lua_class_do_get,ret);
  return bases_search_result;  /* sorry not known */
}

/* the class.get method, performs the lookup of class attributes
 */
SWIGINTERN int  SWIG_Lua_class_get(lua_State *L)
{
/*  there should be 2 params passed in
  (1) userdata (not the meta table)
  (2) string name of the attribute
*/
  int result;
  swig_lua_userdata *usr;
  swig_type_info *type;
  int ret = 0;
  assert(lua_isuserdata(L,1));
  usr=(swig_lua_userdata*)lua_touserdata(L,1);  /* get data */
  type = usr->type;
  result = SWIG_Lua_class_do_get(L,type,1,&ret);
  if(result == SWIG_OK)
    return ret;

  result = SWIG_Lua_class_do_get_item(L,type,1,&ret);
  if(result == SWIG_OK)
    return ret;

  return 0;
}

/* helper for the class.set method, performs the lookup of class attributes
 * It returns error code. Number of function return values is passed inside 'ret'
 */
SWIGINTERN int  SWIG_Lua_class_do_set(lua_State *L, swig_type_info *type, int first_arg, int *ret)
{
/*  there should be 3 params passed in
  (1) table (not the meta table)
  (2) string name of the attribute
  (3) any for the new value
  */

  int bases_search_result;
  int substack_start = lua_gettop(L) - 3;
  lua_checkstack(L,5);
  assert(lua_isuserdata(L,substack_start+1));  /* just in case */
  lua_getmetatable(L,substack_start+1);    /* get the meta table */
  assert(lua_istable(L,-1));  /* just in case */
  if(ret)
    *ret = 0; /* it is setter - number of return values is always 0 */

  SWIG_Lua_get_table(L,".set"); /* find the .set table */
  if (lua_istable(L,-1))
  {
    /* look for the key in the .set table */
    lua_pushvalue(L,substack_start+2);  /* key */
    lua_rawget(L,-2);
    lua_remove(L,-2); /* tidy stack, remove .set table */
    if (lua_iscfunction(L,-1))
    {  /* found it so call the fn & return its value */
      lua_pushvalue(L,substack_start+1);  /* userdata */
      lua_pushvalue(L,substack_start+3);  /* value */
      lua_call(L,2,0);
      lua_remove(L,substack_start+4); /*remove metatable*/
      return SWIG_OK;
    }
    lua_pop(L,1);  /* remove the value */
  } else {
    lua_pop(L,1);  /* remove the answer for .set table request*/
  }
  /* NEW: looks for the __setitem() fn
  this is a user provided set fn */
  SWIG_Lua_get_table(L,"__setitem"); /* find the fn */
  if (lua_iscfunction(L,-1))  /* if its there */
  {  /* found it so call the fn & return its value */
    lua_pushvalue(L,substack_start+1);  /* the userdata */
    lua_pushvalue(L,substack_start+2);  /* the parameter */
    lua_pushvalue(L,substack_start+3);  /* the value */
    lua_call(L,3,0);  /* 3 values in ,0 out */
    lua_remove(L,-2); /* stack tidy, remove metatable */
    return SWIG_OK;
  }
  lua_pop(L,1); /* remove value */

  lua_pop(L,1); /* remove metatable */
  /* Search among bases */
  bases_search_result = SWIG_Lua_iterate_bases(L,type,first_arg,SWIG_Lua_class_do_set,ret);
  if(ret)
    assert(*ret == 0);
  assert(lua_gettop(L) == substack_start + 3);
  return bases_search_result;
}

/* This is the actual method exported to Lua. It calls SWIG_Lua_class_do_set and correctly
 * handles return values.
 */
SWIGINTERN int  SWIG_Lua_class_set(lua_State *L)
{
/*  There should be 3 params passed in
  (1) table (not the meta table)
  (2) string name of the attribute
  (3) any for the new value
  */
  int ret = 0;
  int result;
  swig_lua_userdata *usr;
  swig_type_info *type;
  assert(lua_isuserdata(L,1));
  usr=(swig_lua_userdata*)lua_touserdata(L,1);  /* get data */
  type = usr->type;
  result = SWIG_Lua_class_do_set(L,type,1,&ret);
  if(result != SWIG_OK) {
   SWIG_Lua_pushferrstring(L,"Assignment not possible. No setter/member with this name. For custom assignments implement __setitem method.");
   lua_error(L);
  } else {
    assert(ret==0);
  }
  return 0;
}

/* the class.destruct method called by the interpreter */
SWIGINTERN int  SWIG_Lua_class_destruct(lua_State *L)
{
/*  there should be 1 params passed in
  (1) userdata (not the meta table) */
  swig_lua_userdata *usr;
  swig_lua_class *clss;
  assert(lua_isuserdata(L,-1));  /* just in case */
  usr=(swig_lua_userdata*)lua_touserdata(L,-1);  /* get it */
  /* if must be destroyed & has a destructor */
  if (usr->own) /* if must be destroyed */
  {
    clss=(swig_lua_class*)usr->type->clientdata;  /* get the class */
    if (clss && clss->destructor)  /* there is a destroy fn */
    {
      clss->destructor(usr->ptr);  /* bye bye */
    }
  }
  return 0;
}

/* the class.__tostring method called by the interpreter and print */
SWIGINTERN int  SWIG_Lua_class_tostring(lua_State *L)
{
/*  there should be 1 param passed in
  (1) userdata (not the metatable) */
  const char *className;
  void* userData;
  assert(lua_isuserdata(L,1));  /* just in case */
  userData = lua_touserdata(L,1); /* get the userdata address for later */
  lua_getmetatable(L,1);    /* get the meta table */
  assert(lua_istable(L,-1));  /* just in case */

  lua_getfield(L, -1, ".type");
  className = lua_tostring(L, -1);

  lua_pushfstring(L, "<%s userdata: %p>", className, userData);
  return 1;
}

/* to manually disown some userdata */
SWIGINTERN int  SWIG_Lua_class_disown(lua_State *L)
{
/*  there should be 1 params passed in
  (1) userdata (not the meta table) */
  swig_lua_userdata *usr;
  assert(lua_isuserdata(L,-1));  /* just in case */
  usr=(swig_lua_userdata*)lua_touserdata(L,-1);  /* get it */
  
  usr->own = 0; /* clear our ownership */
  return 0;
}

/* lua callable function to compare userdata's value
the issue is that two userdata may point to the same thing
but to lua, they are different objects */
SWIGRUNTIME int SWIG_Lua_class_equal(lua_State *L)
{
  int result;
  swig_lua_userdata *usr1,*usr2;
  if (!lua_isuserdata(L,1) || !lua_isuserdata(L,2))  /* just in case */
    return 0;  /* nil reply */
  usr1=(swig_lua_userdata*)lua_touserdata(L,1);  /* get data */
  usr2=(swig_lua_userdata*)lua_touserdata(L,2);  /* get data */
  /*result=(usr1->ptr==usr2->ptr && usr1->type==usr2->type); only works if type is the same*/
  result=(usr1->ptr==usr2->ptr);
   lua_pushboolean(L,result);
  return 1;
}

/* populate table at the top of the stack with metamethods that ought to be inherited */
SWIGINTERN void SWIG_Lua_populate_inheritable_metamethods(lua_State *L)
{
  SWIG_Lua_add_boolean(L, "__add", 1);
  SWIG_Lua_add_boolean(L, "__sub", 1);
  SWIG_Lua_add_boolean(L, "__mul", 1);
  SWIG_Lua_add_boolean(L, "__div", 1);
  SWIG_Lua_add_boolean(L, "__mod", 1);
  SWIG_Lua_add_boolean(L, "__pow", 1);
  SWIG_Lua_add_boolean(L, "__unm", 1);
  SWIG_Lua_add_boolean(L, "__len", 1 );
  SWIG_Lua_add_boolean(L, "__concat", 1 );
  SWIG_Lua_add_boolean(L, "__eq", 1);
  SWIG_Lua_add_boolean(L, "__lt", 1);
  SWIG_Lua_add_boolean(L, "__le", 1);
  SWIG_Lua_add_boolean(L, "__call", 1);
  SWIG_Lua_add_boolean(L, "__tostring", 1);
  SWIG_Lua_add_boolean(L, "__gc", 0);
}

/* creates the swig registry */
SWIGINTERN void SWIG_Lua_create_class_registry(lua_State *L)
{
  /* create main SWIG registry table */
  lua_pushstring(L,"SWIG");
  lua_newtable(L);
  /* populate it with some predefined data */

  /* .library table. Placeholder */
  lua_pushstring(L,".library");
  lua_newtable(L);
  {
    /* list of metamethods that class inherits from its bases */
    lua_pushstring(L,"inheritable_metamethods");
    lua_newtable(L);
    /* populate with list of metamethods */
    SWIG_Lua_populate_inheritable_metamethods(L);
    lua_rawset(L,-3);
  }
  lua_rawset(L,-3);

  lua_rawset(L,LUA_REGISTRYINDEX);
}

/* gets the swig registry (or creates it) */
SWIGINTERN void  SWIG_Lua_get_class_registry(lua_State *L)
{
  /* add this all into the swig registry: */
  lua_pushstring(L,"SWIG");
  lua_rawget(L,LUA_REGISTRYINDEX);  /* get the registry */
  if (!lua_istable(L,-1))  /* not there */
  {  /* must be first time, so add it */
    lua_pop(L,1);  /* remove the result */
    SWIG_Lua_create_class_registry(L);
    /* then get it */
    lua_pushstring(L,"SWIG");
    lua_rawget(L,LUA_REGISTRYINDEX);
  }
}

SWIGINTERN void SWIG_Lua_get_inheritable_metamethods(lua_State *L)
{
  SWIG_Lua_get_class_registry(L);
  lua_pushstring(L, ".library");
  lua_rawget(L,-2);
  assert( !lua_isnil(L,-1) );
  lua_pushstring(L, "inheritable_metamethods");
  lua_rawget(L,-2);

  /* Remove class registry and library table */
  lua_remove(L,-2);
  lua_remove(L,-2);
}

/* Helper function to get the classes metatable from the register */
SWIGINTERN void  SWIG_Lua_get_class_metatable(lua_State *L,const char *cname)
{
  SWIG_Lua_get_class_registry(L);  /* get the registry */
  lua_pushstring(L,cname);  /* get the name */
  lua_rawget(L,-2);    /* get it */
  lua_remove(L,-2);    /* tidy up (remove registry) */
}

/* Set up the base classes pointers.
Each class structure has a list of pointers to the base class structures.
This function fills them.
It cannot be done at compile time, as this will not work with hireachies
spread over more than one swig file. 
Therefore it must be done at runtime, querying the SWIG type system.
*/
SWIGINTERN void SWIG_Lua_init_base_class(lua_State *L,swig_lua_class *clss)
{
  int i=0;
  swig_module_info *module=SWIG_GetModule(L);
  for(i=0;clss->base_names[i];i++)
  {
    if (clss->bases[i]==0) /* not found yet */
    {
      /* lookup and cache the base class */
      swig_type_info *info = SWIG_TypeQueryModule(module,module,clss->base_names[i]);
      if (info) clss->bases[i] = (swig_lua_class *) info->clientdata;
    }
  }
}

#if defined(SWIG_LUA_SQUASH_BASES) && (SWIG_LUA_TARGET == SWIG_LUA_FLAVOR_LUA)
/* Merges two tables  */
SWIGINTERN void SWIG_Lua_merge_tables_by_index(lua_State *L, int target, int source)
{
  /* iterating */
  lua_pushnil(L);
  while (lua_next(L,source) != 0) {
    /* -1 - value, -2 - index */
    /* have to copy to assign */
    lua_pushvalue(L,-2); /* copy of index */
    lua_pushvalue(L,-2); /* copy of value */
    lua_rawset(L, target);
    lua_pop(L,1);
    /* only key is left */
  }
}

/* Merges two tables with given name. original - index of target metatable, base - index of source metatable */
SWIGINTERN void SWIG_Lua_merge_tables(lua_State *L, const char* name, int original, int base)
{
  /* push original[name], then base[name] */
  lua_pushstring(L,name);
  lua_rawget(L,original);
  int original_table = lua_gettop(L);
  lua_pushstring(L,name);
  lua_rawget(L,base);
  int base_table = lua_gettop(L);
  SWIG_Lua_merge_tables_by_index(L, original_table, base_table);
  /* clearing stack */
  lua_pop(L,2);
}

/* Function takes all symbols from base and adds it to derived class. It's just a helper. */
SWIGINTERN void SWIG_Lua_class_squash_base(lua_State *L, swig_lua_class *base_cls)
{
  /* There is one parameter - original, i.e. 'derived' class metatable */
  assert(lua_istable(L,-1));
  int original = lua_gettop(L);
  SWIG_Lua_get_class_metatable(L,base_cls->fqname);
  int base = lua_gettop(L);
  SWIG_Lua_merge_tables(L, ".fn", original, base );
  SWIG_Lua_merge_tables(L, ".set", original, base );
  SWIG_Lua_merge_tables(L, ".get", original, base );
  lua_pop(L,1);
}

/* Function squashes all symbols from 'clss' bases into itself */
SWIGINTERN void  SWIG_Lua_class_squash_bases(lua_State *L, swig_lua_class *clss)
{
  int i;
  SWIG_Lua_get_class_metatable(L,clss->fqname);
  for(i=0;clss->base_names[i];i++)
  {
    if (clss->bases[i]==0) /* Somehow it's not found. Skip it */
      continue;
    /* Thing is: all bases are already registered. Thus they have already executed
     * this function. So we just need to squash them into us, because their bases
     * are already squashed into them. No need for recursion here!
     */
    SWIG_Lua_class_squash_base(L, clss->bases[i]);
  }
  lua_pop(L,1); /*tidy stack*/
}
#endif

#if (SWIG_LUA_TARGET == SWIG_LUA_FLAVOR_LUA) /* In elua this is useless */
/* helper add a variable to a registered class */
SWIGINTERN void  SWIG_Lua_add_variable(lua_State *L,const char *name,lua_CFunction getFn,lua_CFunction setFn)
{
  assert(lua_istable(L,-1));  /* just in case */
  SWIG_Lua_get_table(L,".get"); /* find the .get table */
  assert(lua_istable(L,-1));  /* just in case */
  SWIG_Lua_add_function(L,name,getFn);
  lua_pop(L,1);       /* tidy stack (remove table) */
  if (setFn)
  {
    SWIG_Lua_get_table(L,".set"); /* find the .set table */
    assert(lua_istable(L,-1));  /* just in case */
    SWIG_Lua_add_function(L,name,setFn);
    lua_pop(L,1);       /* tidy stack (remove table) */
  }
}

/* helper to recursively add class static details (static attributes, operations and constants) */
SWIGINTERN void SWIG_Lua_add_class_static_details(lua_State *L, swig_lua_class *clss)
{
  int i = 0;
  /* The class namespace table must be on the top of the stack */
  assert(lua_istable(L,-1));
  /* call all the base classes first: we can then override these later: */
  for(i=0;clss->bases[i];i++)
  {
    SWIG_Lua_add_class_static_details(L,clss->bases[i]);
  }

  SWIG_Lua_add_namespace_details(L, clss->cls_static);
}

SWIGINTERN void SWIG_Lua_add_class_user_metamethods(lua_State *L, swig_lua_class *clss); /* forward declaration */

/* helper to recursively add class details (attributes & operations) */
SWIGINTERN void  SWIG_Lua_add_class_instance_details(lua_State *L, swig_lua_class *clss)
{
  int i;
  size_t bases_count = 0;
  /* Add bases to .bases table */
  SWIG_Lua_get_table(L,".bases");
  assert(lua_istable(L,-1));  /* just in case */
  for(i=0;clss->bases[i];i++)
  {
    SWIG_Lua_get_class_metatable(L,clss->bases[i]->fqname);
    /* Base class must be already registered */
    assert(lua_istable(L,-1));
    lua_rawseti(L,-2,i+1); /* In lua indexing starts from 1 */
    bases_count++;
  }
  assert(lua_rawlen(L,-1) == bases_count);
  lua_pop(L,1); /* remove .bases table */
  /* add attributes */
  for(i=0;clss->attributes[i].name;i++){
    SWIG_Lua_add_variable(L,clss->attributes[i].name,clss->attributes[i].getmethod,clss->attributes[i].setmethod);
  }
  /* add methods to the metatable */
  SWIG_Lua_get_table(L,".fn"); /* find the .fn table */
  assert(lua_istable(L,-1));  /* just in case */
  for(i=0;clss->methods[i].name;i++){
    SWIG_Lua_add_function(L,clss->methods[i].name,clss->methods[i].func);
  }
  lua_pop(L,1);       /* tidy stack (remove table) */
  /* add operator overloads
    This adds methods from metatable array to metatable. Can mess up garbage
    collectind if someone defines __gc method
    */
  if(clss->metatable) {
    for(i=0;clss->metatable[i].name;i++) {
      SWIG_Lua_add_function(L,clss->metatable[i].name,clss->metatable[i].func);
    }
  }

#if !defined(SWIG_LUA_SQUASH_BASES)
  /* Adding metamethods that are defined in base classes. If bases were squashed
   * then it is obviously unnecessary
   */
  SWIG_Lua_add_class_user_metamethods(L, clss);
#endif
}

/* Helpers to add user defined class metamedhods - __add, __sub etc. The helpers are needed
   for the following issue: Lua runtime checks for metamethod existence with rawget function
   ignoring our SWIG-provided __index and __newindex functions. Thus our inheritance-aware method
   search algorithm doesn't work in such case. (Not to say that Lua runtime queries metamethod directly
   in metatable and not in object).
   Current solution is this: if somewhere in hierarchy metamethod __x is defined, then all descendants
   are automatically given a special proxy __x that calls the real __x method.
   Obvious idea - to copy __x instead of creating __x-proxy is wrong because if someone changes __x in runtime,
   those changes must be reflected in all descendants.
*/

SWIGRUNTIME int SWIG_Lua_resolve_metamethod(lua_State *L); /*forward declaration*/

/* The real function that resolves a metamethod.
 * Function searches given class and all it's bases(recursively) for first instance of something that is
 * not equal to SWIG_Lua_resolve_metatmethod. (Almost always this 'something' is actual metamethod implementation
 * and it is a SWIG-generated C function.). It returns value on the top of the L and there is no garbage below the
 * answer.
 * Returns 1 if found, 0 otherwise.
 * clss is class which metatable we will search for method
 * metamethod_name_idx is index in L where metamethod name (as string) lies
 * skip_check allows to skip searching metamethod in givel clss and immideatelly go to searching in bases. skip_check
 * is not caried to subsequent recursive calls - false is always passed. It is set to true only at first call from
 * SWIG_Lua_resolve_metamethod
 * */
SWIGINTERN int SWIG_Lua_do_resolve_metamethod(lua_State *L, const swig_lua_class *clss, int metamethod_name_idx,
    int skip_check)
{
  /* This function is called recursively */
  int result = 0;
  int i = 0;

  if (!skip_check) {
    SWIG_Lua_get_class_metatable(L, clss->fqname);
    lua_pushvalue(L, metamethod_name_idx);
    lua_rawget(L,-2);
    /* If this is cfunction and it is equal to SWIG_Lua_resolve_metamethod then
     * this isn't the function we are looking for :)
     * lua_tocfunction will return NULL if not cfunction
     */
    if (!lua_isnil(L,-1) && lua_tocfunction(L,-1) != SWIG_Lua_resolve_metamethod ) {
      lua_remove(L,-2); /* removing class metatable */
      return 1;
    }
    lua_pop(L,2); /* remove class metatable and query result */
  }

  /* Forwarding calls to bases */
  for(i=0;clss->bases[i];i++)
  {
    result = SWIG_Lua_do_resolve_metamethod(L, clss->bases[i], metamethod_name_idx, 0);
    if (result)
      break;
  }

  return result;
}

/* The proxy function for metamethod. All parameters are passed as cclosure. Searches for actual method
 * and calls it */
SWIGRUNTIME int SWIG_Lua_resolve_metamethod(lua_State *L)
{
  int numargs;
  int metamethod_name_idx;
  const swig_lua_class* clss;
  int result;

  lua_checkstack(L,5);
  numargs = lua_gettop(L); /* number of arguments to pass to actual metamethod */
  
  /* Get upvalues from closure */
  lua_pushvalue(L, lua_upvalueindex(1)); /*Get function name*/
  metamethod_name_idx = lua_gettop(L);
  
  lua_pushvalue(L, lua_upvalueindex(2));
  clss = (const swig_lua_class*)(lua_touserdata(L,-1));
  lua_pop(L,1); /* remove lightuserdata with clss from stack */

  /* Actual work */
  result = SWIG_Lua_do_resolve_metamethod(L, clss, metamethod_name_idx, 1);
  if (!result) {
   SWIG_Lua_pushferrstring(L,"The metamethod proxy is set, but it failed to find actual metamethod. Memory corruption is most likely explanation.");
   lua_error(L);
   return 0;
  }

  lua_remove(L,-2); /* remove metamethod key */
  lua_insert(L,1); /* move function to correct position */
  lua_call(L, numargs, LUA_MULTRET);
  return lua_gettop(L); /* return all results */
}


/* If given metamethod must be present in given class, then creates appropriate proxy
 * Returns 1 if successfully added, 0 if not added because no base class has it, -1
 * if method is defined in the class metatable itself
 */
SWIGINTERN int SWIG_Lua_add_class_user_metamethod(lua_State *L, swig_lua_class *clss, const int metatable_index)
{
  int key_index;
  int success = 0;
  int i = 0;

  /* metamethod name - on the top of the stack */
  assert(lua_isstring(L,-1));
  
  key_index = lua_gettop(L);

  /* Check whether method is already defined in metatable */
  lua_pushvalue(L,key_index); /* copy of the key */
  lua_gettable(L,metatable_index);
  if( !lua_isnil(L,-1) ) {
    lua_pop(L,1);
    return -1;
  }
  lua_pop(L,1); 

  /* Iterating over immediate bases */
  for(i=0;clss->bases[i];i++)
  {
    const swig_lua_class *base = clss->bases[i];
    SWIG_Lua_get_class_metatable(L, base->fqname);
    lua_pushvalue(L, key_index);
    lua_rawget(L, -2);
    if( !lua_isnil(L,-1) ) {
      lua_pushvalue(L, key_index); 

      /* Add proxy function */
      lua_pushvalue(L, key_index); /* first closure value is function name */
      lua_pushlightuserdata(L, clss); /* second closure value is swig_lua_class structure */
      lua_pushcclosure(L, SWIG_Lua_resolve_metamethod, 2);
      
      lua_rawset(L, metatable_index);
      success = 1;
    }
    lua_pop(L,1); /* remove function or nil */
    lua_pop(L,1); /* remove base class metatable */

    if( success )
      break;
  }

  return success; 
}

SWIGINTERN void SWIG_Lua_add_class_user_metamethods(lua_State *L, swig_lua_class *clss)
{
  int metatable_index;
  int metamethods_info_index;
  int tostring_undefined;
  int eq_undefined = 0;

  SWIG_Lua_get_class_metatable(L, clss->fqname);
  metatable_index = lua_gettop(L);
  SWIG_Lua_get_inheritable_metamethods(L);
  assert(lua_istable(L,-1));
  metamethods_info_index = lua_gettop(L);
  lua_pushnil(L); /* first key */
  while(lua_next(L, metamethods_info_index) != 0 ) {
    /* key at index -2, value at index -1 */
    const int is_inheritable = lua_toboolean(L,-2);
    lua_pop(L,1); /* remove value - we don't need it anymore */

    if(is_inheritable) { /* if metamethod is inheritable */
      SWIG_Lua_add_class_user_metamethod(L,clss,metatable_index);
    }
  }

  lua_pop(L,1); /* remove inheritable metatmethods table */

  /* Special handling for __tostring method */
  lua_pushstring(L, "__tostring");
  lua_pushvalue(L,-1);
  lua_rawget(L,metatable_index);
  tostring_undefined = lua_isnil(L,-1);
  lua_pop(L,1);
  if( tostring_undefined ) {
    lua_pushcfunction(L, SWIG_Lua_class_tostring);
    lua_rawset(L, metatable_index);
  } else {
    lua_pop(L,1); /* remove copy of the key */
  }

  /* Special handling for __eq method */
  lua_pushstring(L, "__eq");
  lua_pushvalue(L,-1);
  lua_rawget(L,metatable_index);
  eq_undefined = lua_isnil(L,-1);
  lua_pop(L,1);
  if( eq_undefined ) {
    lua_pushcfunction(L, SWIG_Lua_class_equal);
    lua_rawset(L, metatable_index);
  } else {
    lua_pop(L,1); /* remove copy of the key */
  }
  /* Warning: __index and __newindex are SWIG-defined. For user-defined operator[]
   * a __getitem/__setitem method should be defined
   */
  lua_pop(L,1); /* pop class metatable */
}

/* Register class static methods,attributes etc as well as constructor proxy */
SWIGINTERN void SWIG_Lua_class_register_static(lua_State *L, swig_lua_class *clss)
{
  const int SWIGUNUSED begin = lua_gettop(L);
  lua_checkstack(L,5); /* just in case */
  assert(lua_istable(L,-1));  /* just in case */
  assert(strcmp(clss->name, clss->cls_static->name) == 0); /* in class those 2 must be equal */

  SWIG_Lua_namespace_register(L,clss->cls_static, 1);

  assert(lua_istable(L,-1)); /* just in case */

  /*  add its constructor to module with the name of the class
  so you can do MyClass(...) as well as new_MyClass(...)
  BUT only if a constructor is defined
  (this overcomes the problem of pure virtual classes without constructors)*/
  if (clss->constructor)
  {
    lua_getmetatable(L,-1);
    assert(lua_istable(L,-1)); /* just in case */
    SWIG_Lua_add_function(L,"__call", clss->constructor);
    lua_pop(L,1);
  }

  assert(lua_istable(L,-1)); /* just in case */
  SWIG_Lua_add_class_static_details(L, clss);

  /* clear stack */
  lua_pop(L,1);
  assert( lua_gettop(L) == begin );
}

/* Performs the instance (non-static) class registration process. Metatable for class is created
 * and added to the class registry.
 */
SWIGINTERN void  SWIG_Lua_class_register_instance(lua_State *L,swig_lua_class *clss)
{
  const int SWIGUNUSED begin = lua_gettop(L);
  int i;
  /* if name already there (class is already registered) then do nothing */
  SWIG_Lua_get_class_registry(L);  /* get the registry */
  lua_pushstring(L,clss->fqname);  /* get the name */
  lua_rawget(L,-2);
  if(!lua_isnil(L,-1)) {
    lua_pop(L,2);
    assert(lua_gettop(L)==begin);
    return;
  }
  lua_pop(L,2); /* tidy stack */
  /* Recursively initialize all bases */
  for(i=0;clss->bases[i];i++)
  {
    SWIG_Lua_class_register_instance(L,clss->bases[i]);
  }
  /* Again, get registry and push name */
  SWIG_Lua_get_class_registry(L);  /* get the registry */
  lua_pushstring(L,clss->fqname);  /* get the name */
  lua_newtable(L);    /* create the metatable */
#if defined(SWIG_LUA_SQUASH_BASES) && (SWIG_LUA_TARGET == SWIG_LUA_FLAVOR_LUA)
  /* If squashing is requested, then merges all bases metatable into this one.
   * It would get us all special methods: __getitem, __add etc.
   * This would set .fn, .type, and other .xxx incorrectly, but we will overwrite it right away
   */
  {
    int new_metatable_index = lua_absindex(L,-1);
    for(i=0;clss->bases[i];i++)
    {
      int base_metatable;
      SWIG_Lua_get_class_metatable(L,clss->bases[i]->fqname);
      base_metatable = lua_absindex(L,-1);
      SWIG_Lua_merge_tables_by_index(L,new_metatable_index, base_metatable);
      lua_pop(L,1);
    }
  }
  /* And now we will overwrite all incorrectly set data */
#endif
  /* add string of class name called ".type" */
  lua_pushstring(L,".type");
  lua_pushstring(L,clss->fqname);
  lua_rawset(L,-3);
  /* add a table called bases */
  lua_pushstring(L,".bases");
  lua_newtable(L);
  lua_rawset(L,-3);
  /* add a table called ".get" */
  lua_pushstring(L,".get");
  lua_newtable(L);
  lua_rawset(L,-3);
  /* add a table called ".set" */
  lua_pushstring(L,".set");
  lua_newtable(L);
  lua_rawset(L,-3);
  /* add a table called ".fn" */
  lua_pushstring(L,".fn");
  lua_newtable(L);
  /* add manual disown method */
  SWIG_Lua_add_function(L,"__disown",SWIG_Lua_class_disown);
  lua_rawset(L,-3);
  /* add accessor fns for using the .get,.set&.fn */
  SWIG_Lua_add_function(L,"__index",SWIG_Lua_class_get);
  SWIG_Lua_add_function(L,"__newindex",SWIG_Lua_class_set);
  SWIG_Lua_add_function(L,"__gc",SWIG_Lua_class_destruct);
  /* add it */
  lua_rawset(L,-3);  /* metatable into registry */
  lua_pop(L,1);      /* tidy stack (remove registry) */
  assert(lua_gettop(L) == begin);

#if defined(SWIG_LUA_SQUASH_BASES) && (SWIG_LUA_TARGET == SWIG_LUA_FLAVOR_LUA)
  /* Now merge all symbols from .fn, .set, .get etc from bases to our tables */
  SWIG_Lua_class_squash_bases(L,clss);
#endif
  SWIG_Lua_get_class_metatable(L,clss->fqname);
  SWIG_Lua_add_class_instance_details(L,clss);  /* recursive adding of details (atts & ops) */
  lua_pop(L,1);      /* tidy stack (remove class metatable) */
  assert( lua_gettop(L) == begin );
}

SWIGINTERN void  SWIG_Lua_class_register(lua_State *L,swig_lua_class *clss)
{
  int SWIGUNUSED begin;
  assert(lua_istable(L,-1)); /* This is a table (module or namespace) where classes will be added */
  SWIG_Lua_class_register_instance(L,clss);
  SWIG_Lua_class_register_static(L,clss);

  /* Add links from static part to instance part and vice versa */
  /* [SWIG registry]                                   [Module]
   *    "MyClass" ----> [MyClass metatable] <=====     "MyClass" -+> [static part]
   *                     ".get" ----> ...        |                |     getmetatable()----|
   *                     ".set" ----> ...        |                |                       |
   *                     ".static" --------------)----------------/           [static part metatable]
   *                                             |                                ".get" --> ...
   *                                             |                                ".set" --> ....
   *                                             |=============================== ".instance"
   */
  begin = lua_gettop(L);
  lua_pushstring(L,clss->cls_static->name);
  lua_rawget(L,-2); /* get class static table */
  assert(lua_istable(L,-1));
  lua_getmetatable(L,-1);
  assert(lua_istable(L,-1)); /* get class static metatable */
  lua_pushstring(L,".instance"); /* prepare key */

  SWIG_Lua_get_class_metatable(L,clss->fqname); /* get class metatable */
  assert(lua_istable(L,-1));
  lua_pushstring(L,".static"); /* prepare key */
  lua_pushvalue(L, -4); /* push static class TABLE */
  assert(lua_istable(L,-1));
  lua_rawset(L,-3); /* assign static class table(!NOT metatable) as ".static" member of class metatable */
  lua_rawset(L,-3); /* assign class metatable as ".instance" member of class static METATABLE */
  lua_pop(L,2);
  assert(lua_gettop(L) == begin);
}
#endif /* SWIG_LUA_TARGET == SWIG_LUA_FLAVOR_LUA */

#if (SWIG_LUA_TARGET == SWIG_LUA_FLAVOR_ELUA) || (SWIG_LUA_TARGET == SWIG_LUA_FLAVOR_ELUAC)
SWIGINTERN void SWIG_Lua_elua_class_register_instance(lua_State *L, swig_lua_class *clss)
{
  const int SWIGUNUSED begin = lua_gettop(L);
  int i;
  /* if name already there (class is already registered) then do nothing */
  SWIG_Lua_get_class_registry(L);  /* get the registry */
  lua_pushstring(L,clss->fqname);  /* get the name */
  lua_rawget(L,-2);
  if(!lua_isnil(L,-1)) {
    lua_pop(L,2);
    assert(lua_gettop(L)==begin);
    return;
  }
  lua_pop(L,2); /* tidy stack */
  /* Recursively initialize all bases */
  for(i=0;clss->bases[i];i++)
  {
    SWIG_Lua_elua_class_register_instance(L,clss->bases[i]);
  }
  /* Again, get registry and push name */
  SWIG_Lua_get_class_registry(L);  /* get the registry */
  lua_pushstring(L,clss->fqname);  /* get the name */
  assert(clss->metatable);
  lua_pushrotable(L, (void*)(clss->metatable));    /* create the metatable */
  lua_rawset(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) == begin);
}
#endif /* elua && eluac */

/* -----------------------------------------------------------------------------
 * Class/structure conversion fns
 * ----------------------------------------------------------------------------- */

/* helper to add metatable to new lua object */
SWIGINTERN void SWIG_Lua_AddMetatable(lua_State *L,swig_type_info *type)
{
  if (type->clientdata)  /* there is clientdata: so add the metatable */
  {
    SWIG_Lua_get_class_metatable(L,((swig_lua_class*)(type->clientdata))->fqname);
    if (lua_istable(L,-1))
    {
      lua_setmetatable(L,-2);
    }
    else
    {
      lua_pop(L,1);
    }
  }
}

/* pushes a new object into the lua stack */
SWIGRUNTIME void SWIG_Lua_NewPointerObj(lua_State *L,void *ptr,swig_type_info *type, int own)
{
  swig_lua_userdata *usr;
  if (!ptr){
    lua_pushnil(L);
    return;
  }
  usr=(swig_lua_userdata*)lua_newuserdata(L,sizeof(swig_lua_userdata));  /* get data */
  usr->ptr=ptr;  /* set the ptr */
  usr->type=type;
  usr->own=own;
#if (SWIG_LUA_TARGET != SWIG_LUA_FLAVOR_ELUAC)
  SWIG_Lua_AddMetatable(L,type); /* add metatable */
#endif
}

/* takes a object from the lua stack & converts it into an object of the correct type
 (if possible) */
SWIGRUNTIME int  SWIG_Lua_ConvertPtr(lua_State *L,int index,void **ptr,swig_type_info *type,int flags)
{
  swig_lua_userdata *usr;
  swig_cast_info *cast;
  if (lua_isnil(L,index)){*ptr=0; return SWIG_OK;}    /* special case: lua nil => NULL pointer */
  usr=(swig_lua_userdata*)lua_touserdata(L,index);  /* get data */
  if (usr)
  {
    if (flags & SWIG_POINTER_DISOWN) /* must disown the object */
    {
        usr->own=0;
    }
    if (!type)            /* special cast void*, no casting fn */
    {
      *ptr=usr->ptr;
      return SWIG_OK; /* ok */
    }
    cast=SWIG_TypeCheckStruct(usr->type,type); /* performs normal type checking */
    if (cast)
    {
      int newmemory = 0;
      *ptr=SWIG_TypeCast(cast,usr->ptr,&newmemory);
      assert(!newmemory); /* newmemory handling not yet implemented */
      return SWIG_OK;  /* ok */
    }
  }
  return SWIG_ERROR;  /* error */
}

SWIGRUNTIME void* SWIG_Lua_MustGetPtr(lua_State *L,int index,swig_type_info *type,int flags,
       int argnum,const char *func_name){
  void *result;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,index,&result,type,flags))){
    luaL_error (L,"Error in %s, expected a %s at argument number %d\n",
		func_name,(type && type->str)?type->str:"void*",argnum);
  }
  return result;
}

/* pushes a packed userdata. user for member fn pointers only */
SWIGRUNTIME void SWIG_Lua_NewPackedObj(lua_State *L,void *ptr,size_t size,swig_type_info *type)
{
  swig_lua_rawdata *raw;
  assert(ptr); /* not acceptable to pass in a NULL value */
  raw=(swig_lua_rawdata*)lua_newuserdata(L,sizeof(swig_lua_rawdata)-1+size);  /* alloc data */
  raw->type=type;
  raw->own=0;
  memcpy(raw->data,ptr,size); /* copy the data */
  SWIG_Lua_AddMetatable(L,type); /* add metatable */
}
    
/* converts a packed userdata. user for member fn pointers only */
SWIGRUNTIME int  SWIG_Lua_ConvertPacked(lua_State *L,int index,void *ptr,size_t size,swig_type_info *type)
{
  swig_lua_rawdata *raw;
  raw=(swig_lua_rawdata*)lua_touserdata(L,index);  /* get data */
  if (!raw) return SWIG_ERROR;  /* error */
  if (type==0 || type==raw->type) /* void* or identical type */
  {
    memcpy(ptr,raw->data,size); /* copy it */
    return SWIG_OK; /* ok */
  }
  return SWIG_ERROR;  /* error */
}

/* a function to get the typestring of a piece of data */
SWIGRUNTIME const char *SWIG_Lua_typename(lua_State *L, int tp)
{
  swig_lua_userdata *usr;
  if (lua_isuserdata(L,tp))
  {
    usr=(swig_lua_userdata*)lua_touserdata(L,tp);  /* get data */
    if (usr && usr->type && usr->type->str)
      return usr->type->str;
    return "userdata (unknown type)";
  }
  return lua_typename(L,lua_type(L,tp));
}

/* lua callable function to get the userdata's type */
SWIGRUNTIME int SWIG_Lua_type(lua_State *L)
{
  lua_pushstring(L,SWIG_Lua_typename(L,1));
  return 1;
}

/* -----------------------------------------------------------------------------
 * global variable support code: class/struct typemap functions
 * ----------------------------------------------------------------------------- */

#if ((SWIG_LUA_TARGET != SWIG_LUA_FLAVOR_ELUA) && (SWIG_LUA_TARGET != SWIG_LUA_FLAVOR_ELUAC))
/* Install Constants */
SWIGINTERN void
SWIG_Lua_InstallConstants(lua_State *L, swig_lua_const_info constants[]) {
  int i;
  for (i = 0; constants[i].type; i++) {
    switch(constants[i].type) {
    case SWIG_LUA_INT:
      lua_pushstring(L,constants[i].name);
      lua_pushinteger(L,(lua_Number)constants[i].lvalue);
      lua_rawset(L,-3);
      break;
    case SWIG_LUA_FLOAT:
      lua_pushstring(L,constants[i].name);
      lua_pushnumber(L,(lua_Number)constants[i].dvalue);
      lua_rawset(L,-3);
      break;
    case SWIG_LUA_CHAR:
      lua_pushstring(L,constants[i].name);
      {
        char c = constants[i].lvalue;
        lua_pushlstring(L,&c,1);
      }
      lua_rawset(L,-3);
      break;
    case SWIG_LUA_STRING:
      lua_pushstring(L,constants[i].name);
      lua_pushstring(L,(char *) constants[i].pvalue);
      lua_rawset(L,-3);
      break;
    case SWIG_LUA_POINTER:
      lua_pushstring(L,constants[i].name);
      SWIG_NewPointerObj(L,constants[i].pvalue, *(constants[i]).ptype,0);
      lua_rawset(L,-3);
      break;
    case SWIG_LUA_BINARY:
      lua_pushstring(L,constants[i].name);
      SWIG_NewMemberObj(L,constants[i].pvalue,constants[i].lvalue,*(constants[i]).ptype);
      lua_rawset(L,-3);
      break;
    default:
      break;
    }
  }
}
#endif

/* -----------------------------------------------------------------------------
 * executing lua code from within the wrapper
 * ----------------------------------------------------------------------------- */

#ifndef SWIG_DOSTRING_FAIL /* Allows redefining of error function */
#define SWIG_DOSTRING_FAIL(S) fprintf(stderr,"%s\n",S)
#endif
/* Executes a C string in Lua which is a really simple way of calling lua from C
Unfortunately lua keeps changing its APIs, so we need a conditional compile
In lua 5.0.X it's lua_dostring()
In lua 5.1.X it's luaL_dostring()
*/
SWIGINTERN int 
SWIG_Lua_dostring(lua_State *L, const char *str) {
  int ok,top;
  if (str==0 || str[0]==0) return 0; /* nothing to do */
  top=lua_gettop(L); /* save stack */
#if (defined(LUA_VERSION_NUM) && (LUA_VERSION_NUM>=501))
  ok=luaL_dostring(L,str);	/* looks like this is lua 5.1.X or later, good */
#else
  ok=lua_dostring(L,str);	/* might be lua 5.0.x, using lua_dostring */
#endif
  if (ok!=0) {
    SWIG_DOSTRING_FAIL(lua_tostring(L,-1));
  }
  lua_settop(L,top); /* restore the stack */
  return ok;
}    

#ifdef __cplusplus
}
#endif

/* ------------------------------ end luarun.swg  ------------------------------ */

/*  Errors in SWIG */
#define  SWIG_UnknownError    	   -1
#define  SWIG_IOError        	   -2
#define  SWIG_RuntimeError   	   -3
#define  SWIG_IndexError     	   -4
#define  SWIG_TypeError      	   -5
#define  SWIG_DivisionByZero 	   -6
#define  SWIG_OverflowError  	   -7
#define  SWIG_SyntaxError    	   -8
#define  SWIG_ValueError     	   -9
#define  SWIG_SystemError    	   -10
#define  SWIG_AttributeError 	   -11
#define  SWIG_MemoryError    	   -12
#define  SWIG_NullReferenceError   -13




/* -------- TYPES TABLE (BEGIN) -------- */

#define SWIGTYPE_p_Firmata_Encoder_Data swig_types[0]
#define SWIGTYPE_p_Firmata_I2C_Data swig_types[1]
#define SWIGTYPE_p_Firmata_Serial_Data swig_types[2]
#define SWIGTYPE_p_Firmata_Stepper_Data swig_types[3]
#define SWIGTYPE_p_GLintptr swig_types[4]
#define SWIGTYPE_p_GLsizei swig_types[5]
#define SWIGTYPE_p_GLsizeiptr swig_types[6]
#define SWIGTYPE_p_TESSindex swig_types[7]
#define SWIGTYPE_p__XDisplay swig_types[8]
#define SWIGTYPE_p_boost__filesystem__path swig_types[9]
#define SWIGTYPE_p_double swig_types[10]
#define SWIGTYPE_p_float swig_types[11]
#define SWIGTYPE_p_glm__mat3 swig_types[12]
#define SWIGTYPE_p_glm__mat4 swig_types[13]
#define SWIGTYPE_p_glm__quat swig_types[14]
#define SWIGTYPE_p_glm__tvec2T_int_glm__precision__defaultp_t swig_types[15]
#define SWIGTYPE_p_glm__tvec3T_int_glm__precision__defaultp_t swig_types[16]
#define SWIGTYPE_p_glm__tvec4T_int_glm__precision__defaultp_t swig_types[17]
#define SWIGTYPE_p_glm__vec2 swig_types[18]
#define SWIGTYPE_p_glm__vec3 swig_types[19]
#define SWIGTYPE_p_glm__vec4 swig_types[20]
#define SWIGTYPE_p_int swig_types[21]
#define SWIGTYPE_p_int16_t swig_types[22]
#define SWIGTYPE_p_int32_t swig_types[23]
#define SWIGTYPE_p_int8_t swig_types[24]
#define SWIGTYPE_p_long_long swig_types[25]
#define SWIGTYPE_p_of3dPrimitive swig_types[26]
#define SWIGTYPE_p_ofAbstractParameter swig_types[27]
#define SWIGTYPE_p_ofAppBaseWindow swig_types[28]
#define SWIGTYPE_p_ofArduino swig_types[29]
#define SWIGTYPE_p_ofBaseDraws swig_types[30]
#define SWIGTYPE_p_ofBaseHasPixels swig_types[31]
#define SWIGTYPE_p_ofBaseHasTexture swig_types[32]
#define SWIGTYPE_p_ofBaseImage_T_float_t swig_types[33]
#define SWIGTYPE_p_ofBaseImage_T_unsigned_char_t swig_types[34]
#define SWIGTYPE_p_ofBaseImage_T_unsigned_short_t swig_types[35]
#define SWIGTYPE_p_ofBaseLoggerChannel swig_types[36]
#define SWIGTYPE_p_ofBaseMaterial swig_types[37]
#define SWIGTYPE_p_ofBaseRenderer swig_types[38]
#define SWIGTYPE_p_ofBaseSoundInput swig_types[39]
#define SWIGTYPE_p_ofBaseSoundOutput swig_types[40]
#define SWIGTYPE_p_ofBaseSoundPlayer swig_types[41]
#define SWIGTYPE_p_ofBaseSoundStream swig_types[42]
#define SWIGTYPE_p_ofBaseUpdates swig_types[43]
#define SWIGTYPE_p_ofBaseVideo swig_types[44]
#define SWIGTYPE_p_ofBaseVideoDraws swig_types[45]
#define SWIGTYPE_p_ofBaseVideoGrabber swig_types[46]
#define SWIGTYPE_p_ofBaseVideoPlayer swig_types[47]
#define SWIGTYPE_p_ofBoxPrimitive swig_types[48]
#define SWIGTYPE_p_ofBuffer swig_types[49]
#define SWIGTYPE_p_ofBufferObject swig_types[50]
#define SWIGTYPE_p_ofCamera swig_types[51]
#define SWIGTYPE_p_ofColor_T_float_t swig_types[52]
#define SWIGTYPE_p_ofColor_T_unsigned_char_t swig_types[53]
#define SWIGTYPE_p_ofColor_T_unsigned_short_t swig_types[54]
#define SWIGTYPE_p_ofConePrimitive swig_types[55]
#define SWIGTYPE_p_ofConsoleLoggerChannel swig_types[56]
#define SWIGTYPE_p_ofCoreEvents swig_types[57]
#define SWIGTYPE_p_ofCylinderPrimitive swig_types[58]
#define SWIGTYPE_p_ofDirectory swig_types[59]
#define SWIGTYPE_p_ofDragInfo swig_types[60]
#define SWIGTYPE_p_ofEasyCam swig_types[61]
#define SWIGTYPE_p_ofEventArgs swig_types[62]
#define SWIGTYPE_p_ofEventT_Firmata_I2C_Data_const_t swig_types[63]
#define SWIGTYPE_p_ofEventT_Firmata_Serial_Data_const_t swig_types[64]
#define SWIGTYPE_p_ofEventT_Firmata_Stepper_Data_const_t swig_types[65]
#define SWIGTYPE_p_ofEventT_int_const_t swig_types[66]
#define SWIGTYPE_p_ofEventT_std__pairT_int_Firmata_Pin_Modes_t_const_t swig_types[67]
#define SWIGTYPE_p_ofEventT_std__string_const_t swig_types[68]
#define SWIGTYPE_p_ofEventT_std__vectorT_Firmata_Encoder_Data_t_const_t swig_types[69]
#define SWIGTYPE_p_ofEventT_std__vectorT_unsigned_char_t_const_t swig_types[70]
#define SWIGTYPE_p_ofFbo swig_types[71]
#define SWIGTYPE_p_ofFile swig_types[72]
#define SWIGTYPE_p_ofFileDialogResult swig_types[73]
#define SWIGTYPE_p_ofFileLoggerChannel swig_types[74]
#define SWIGTYPE_p_ofFilePath swig_types[75]
#define SWIGTYPE_p_ofFpsCounter swig_types[76]
#define SWIGTYPE_p_ofHttpRequest swig_types[77]
#define SWIGTYPE_p_ofHttpResponse swig_types[78]
#define SWIGTYPE_p_ofIcoSpherePrimitive swig_types[79]
#define SWIGTYPE_p_ofImageLoadSettings swig_types[80]
#define SWIGTYPE_p_ofImage_T_float_t swig_types[81]
#define SWIGTYPE_p_ofImage_T_unsigned_char_t swig_types[82]
#define SWIGTYPE_p_ofImage_T_unsigned_short_t swig_types[83]
#define SWIGTYPE_p_ofKeyEventArgs swig_types[84]
#define SWIGTYPE_p_ofLight swig_types[85]
#define SWIGTYPE_p_ofLog swig_types[86]
#define SWIGTYPE_p_ofLogError swig_types[87]
#define SWIGTYPE_p_ofLogFatalError swig_types[88]
#define SWIGTYPE_p_ofLogNotice swig_types[89]
#define SWIGTYPE_p_ofLogVerbose swig_types[90]
#define SWIGTYPE_p_ofLogWarning swig_types[91]
#define SWIGTYPE_p_ofMaterial swig_types[92]
#define SWIGTYPE_p_ofMaterialSettings swig_types[93]
#define SWIGTYPE_p_ofMatrix3x3 swig_types[94]
#define SWIGTYPE_p_ofMatrix4x4 swig_types[95]
#define SWIGTYPE_p_ofMatrixStack swig_types[96]
#define SWIGTYPE_p_ofMeshFace_T_glm__vec3_glm__vec3_ofColor_T_float_t_glm__vec2_t swig_types[97]
#define SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t swig_types[98]
#define SWIGTYPE_p_ofMessage swig_types[99]
#define SWIGTYPE_p_ofMouseEventArgs swig_types[100]
#define SWIGTYPE_p_ofNode swig_types[101]
#define SWIGTYPE_p_ofParameterGroup swig_types[102]
#define SWIGTYPE_p_ofPath swig_types[103]
#define SWIGTYPE_p_ofPixels_T_float_t swig_types[104]
#define SWIGTYPE_p_ofPixels_T_unsigned_char_t swig_types[105]
#define SWIGTYPE_p_ofPixels_T_unsigned_short_t swig_types[106]
#define SWIGTYPE_p_ofPlanePrimitive swig_types[107]
#define SWIGTYPE_p_ofPolyline_T_glm__vec3_t swig_types[108]
#define SWIGTYPE_p_ofQuaternion swig_types[109]
#define SWIGTYPE_p_ofRectangle swig_types[110]
#define SWIGTYPE_p_ofResizeEventArgs swig_types[111]
#define SWIGTYPE_p_ofSerial swig_types[112]
#define SWIGTYPE_p_ofSerialDeviceInfo swig_types[113]
#define SWIGTYPE_p_ofShader swig_types[114]
#define SWIGTYPE_p_ofShaderSettings swig_types[115]
#define SWIGTYPE_p_ofShader__TransformFeedbackSettings swig_types[116]
#define SWIGTYPE_p_ofSoundDevice swig_types[117]
#define SWIGTYPE_p_ofSoundPlayer swig_types[118]
#define SWIGTYPE_p_ofSoundStream swig_types[119]
#define SWIGTYPE_p_ofSoundStreamSettings swig_types[120]
#define SWIGTYPE_p_ofSpherePrimitive swig_types[121]
#define SWIGTYPE_p_ofStyle swig_types[122]
#define SWIGTYPE_p_ofTexture swig_types[123]
#define SWIGTYPE_p_ofTextureData swig_types[124]
#define SWIGTYPE_p_ofTime swig_types[125]
#define SWIGTYPE_p_ofTouchEventArgs swig_types[126]
#define SWIGTYPE_p_ofTrueTypeFont swig_types[127]
#define SWIGTYPE_p_ofURLFileLoader swig_types[128]
#define SWIGTYPE_p_ofVbo swig_types[129]
#define SWIGTYPE_p_ofVboMesh swig_types[130]
#define SWIGTYPE_p_ofVec2f swig_types[131]
#define SWIGTYPE_p_ofVec3f swig_types[132]
#define SWIGTYPE_p_ofVec4f swig_types[133]
#define SWIGTYPE_p_ofVideoDevice swig_types[134]
#define SWIGTYPE_p_ofVideoFormat swig_types[135]
#define SWIGTYPE_p_ofVideoGrabber swig_types[136]
#define SWIGTYPE_p_ofVideoPlayer swig_types[137]
#define SWIGTYPE_p_ofWindowPosEventArgs swig_types[138]
#define SWIGTYPE_p_ofXml swig_types[139]
#define SWIGTYPE_p_ofXml__Attribute swig_types[140]
#define SWIGTYPE_p_ofXml__RangeT_ofXmlIteratorT_pugi__xml_attribute_iterator_t_t swig_types[141]
#define SWIGTYPE_p_ofXml__RangeT_ofXmlIteratorT_pugi__xml_named_node_iterator_t_t swig_types[142]
#define SWIGTYPE_p_ofXml__RangeT_ofXmlIteratorT_pugi__xml_node_iterator_t_t swig_types[143]
#define SWIGTYPE_p_std__fstream swig_types[144]
#define SWIGTYPE_p_std__functionT_void_fofHttpResponse_const_RF_t swig_types[145]
#define SWIGTYPE_p_std__functionT_void_fofSoundBuffer_RF_t swig_types[146]
#define SWIGTYPE_p_std__istream swig_types[147]
#define SWIGTYPE_p_std__mapT_int_supportedPinTypes_t swig_types[148]
#define SWIGTYPE_p_std__mapT_std__string_std__string_t swig_types[149]
#define SWIGTYPE_p_std__shared_ptrT_ofBaseLoggerChannel_t swig_types[150]
#define SWIGTYPE_p_std__shared_ptrT_ofBaseRenderer_t swig_types[151]
#define SWIGTYPE_p_std__shared_ptrT_ofBaseSoundPlayer_t swig_types[152]
#define SWIGTYPE_p_std__shared_ptrT_ofBaseSoundStream_t swig_types[153]
#define SWIGTYPE_p_std__shared_ptrT_ofBaseVideoGrabber_t swig_types[154]
#define SWIGTYPE_p_std__shared_ptrT_ofBaseVideoPlayer_t swig_types[155]
#define SWIGTYPE_p_std__string swig_types[156]
#define SWIGTYPE_p_std__vectorT_TESSindex_t swig_types[157]
#define SWIGTYPE_p_std__vectorT_float_t swig_types[158]
#define SWIGTYPE_p_std__vectorT_glm__vec2_t swig_types[159]
#define SWIGTYPE_p_std__vectorT_glm__vec3_t swig_types[160]
#define SWIGTYPE_p_std__vectorT_int_t swig_types[161]
#define SWIGTYPE_p_std__vectorT_ofColor_T_float_t_t swig_types[162]
#define SWIGTYPE_p_std__vectorT_ofFile_t swig_types[163]
#define SWIGTYPE_p_std__vectorT_ofMeshFace_T_glm__vec3_glm__vec3_ofColor_T_float_t_glm__vec2_t_t swig_types[164]
#define SWIGTYPE_p_std__vectorT_ofPath_t swig_types[165]
#define SWIGTYPE_p_std__vectorT_ofPolyline_T_ofDefaultVertexType_t_t swig_types[166]
#define SWIGTYPE_p_std__vectorT_ofSerialDeviceInfo_t swig_types[167]
#define SWIGTYPE_p_std__vectorT_ofSoundDevice_t swig_types[168]
#define SWIGTYPE_p_std__vectorT_ofTexture_t swig_types[169]
#define SWIGTYPE_p_std__vectorT_ofVec2f_t swig_types[170]
#define SWIGTYPE_p_std__vectorT_ofVec3f_t swig_types[171]
#define SWIGTYPE_p_std__vectorT_ofVideoDevice_t swig_types[172]
#define SWIGTYPE_p_std__vectorT_ofVideoFormat_t swig_types[173]
#define SWIGTYPE_p_std__vectorT_std__string_t swig_types[174]
#define SWIGTYPE_p_std__vectorT_unsigned_char_t swig_types[175]
#define SWIGTYPE_p_std__vectorT_unsigned_int_t swig_types[176]
#define SWIGTYPE_p_supportedPinTypes swig_types[177]
#define SWIGTYPE_p_uint16_t swig_types[178]
#define SWIGTYPE_p_uint32_t swig_types[179]
#define SWIGTYPE_p_uint8_t swig_types[180]
#define SWIGTYPE_p_unsigned_char swig_types[181]
#define SWIGTYPE_p_unsigned_int swig_types[182]
#define SWIGTYPE_p_unsigned_long swig_types[183]
#define SWIGTYPE_p_unsigned_long_long swig_types[184]
#define SWIGTYPE_p_unsigned_short swig_types[185]
#define SWIGTYPE_p_void swig_types[186]
static swig_type_info *swig_types[188];
static swig_module_info swig_module = {swig_types, 187, 0, 0, 0, 0};
#define SWIG_TypeQuery(name) SWIG_TypeQueryModule(&swig_module, &swig_module, name)
#define SWIG_MangledTypeQuery(name) SWIG_MangledTypeQueryModule(&swig_module, &swig_module, name)

/* -------- TYPES TABLE (END) -------- */

#define SWIG_name      "of"
#define SWIG_init      luaopen_of
#define SWIG_init_user luaopen_of_user

#define SWIG_LUACODE   luaopen_of_luacode

namespace swig {
typedef struct{} LANGUAGE_OBJ;
}


	#include "ofMain.h"
	#undef check


#include <stdio.h>


#ifdef __cplusplus	/* generic alloc/dealloc fns*/
#define SWIG_ALLOC_ARRAY(TYPE,LEN) 	new TYPE[LEN]
#define SWIG_FREE_ARRAY(PTR)		delete[] PTR
#else
#define SWIG_ALLOC_ARRAY(TYPE,LEN) 	(TYPE *)malloc(LEN*sizeof(TYPE))
#define SWIG_FREE_ARRAY(PTR)		free(PTR)
#endif
/* counting the size of arrays:*/
SWIGINTERN int SWIG_itable_size(lua_State* L, int index)
{
	int n=0;
	while(1){
		lua_rawgeti(L,index,n+1);
		if (lua_isnil(L,-1))break;
		++n;
		lua_pop(L,1);
	}
	lua_pop(L,1);
	return n;
}

SWIGINTERN int SWIG_table_size(lua_State* L, int index)
{
	int n=0;
	lua_pushnil(L);  /* first key*/
	while (lua_next(L, index) != 0) {
		++n;
		lua_pop(L, 1);  /* removes `value'; keeps `key' for next iteration*/
	}
	return n;
}

/* super macro to declare array typemap helper fns */
#define SWIG_DECLARE_TYPEMAP_ARR_FN(NAME,TYPE)\
	SWIGINTERN int SWIG_read_##NAME##_num_array(lua_State* L,int index,TYPE *array,int size){\
		int i;\
		for (i = 0; i < size; i++) {\
			lua_rawgeti(L,index,i+1);\
			if (lua_isnumber(L,-1)){\
				array[i] = (TYPE)lua_tonumber(L,-1);\
			} else {\
				lua_pop(L,1);\
				return 0;\
			}\
			lua_pop(L,1);\
		}\
		return 1;\
	}\
	SWIGINTERN TYPE* SWIG_get_##NAME##_num_array_fixed(lua_State* L, int index, int size){\
		TYPE *array;\
		if (!lua_istable(L,index) || SWIG_itable_size(L,index) != size) {\
			SWIG_Lua_pushferrstring(L,"expected a table of size %d",size);\
			return 0;\
		}\
		array=SWIG_ALLOC_ARRAY(TYPE,size);\
		if (!SWIG_read_##NAME##_num_array(L,index,array,size)){\
			SWIG_Lua_pusherrstring(L,"table must contain numbers");\
			SWIG_FREE_ARRAY(array);\
			return 0;\
		}\
		return array;\
	}\
	SWIGINTERN TYPE* SWIG_get_##NAME##_num_array_var(lua_State* L, int index, int* size)\
	{\
		TYPE *array;\
		if (!lua_istable(L,index)) {\
			SWIG_Lua_pusherrstring(L,"expected a table");\
			return 0;\
		}\
		*size=SWIG_itable_size(L,index);\
		if (*size<1){\
			SWIG_Lua_pusherrstring(L,"table appears to be empty");\
			return 0;\
		}\
		array=SWIG_ALLOC_ARRAY(TYPE,*size);\
		if (!SWIG_read_##NAME##_num_array(L,index,array,*size)){\
			SWIG_Lua_pusherrstring(L,"table must contain numbers");\
			SWIG_FREE_ARRAY(array);\
			return 0;\
		}\
		return array;\
	}\
	SWIGINTERN void SWIG_write_##NAME##_num_array(lua_State* L,TYPE *array,int size){\
		int i;\
		lua_newtable(L);\
		for (i = 0; i < size; i++){\
			lua_pushnumber(L,(lua_Number)array[i]);\
			lua_rawseti(L,-2,i+1);/* -1 is the number, -2 is the table*/ \
		}\
	}

SWIG_DECLARE_TYPEMAP_ARR_FN(schar,signed char)
SWIG_DECLARE_TYPEMAP_ARR_FN(uchar,unsigned char)
SWIG_DECLARE_TYPEMAP_ARR_FN(int,int)
SWIG_DECLARE_TYPEMAP_ARR_FN(uint,unsigned int)
SWIG_DECLARE_TYPEMAP_ARR_FN(short,short)
SWIG_DECLARE_TYPEMAP_ARR_FN(ushort,unsigned short)
SWIG_DECLARE_TYPEMAP_ARR_FN(long,long)
SWIG_DECLARE_TYPEMAP_ARR_FN(ulong,unsigned long)
SWIG_DECLARE_TYPEMAP_ARR_FN(float,float)
SWIG_DECLARE_TYPEMAP_ARR_FN(double,double)

SWIGINTERN int SWIG_read_ptr_array(lua_State* L,int index,void **array,int size,swig_type_info *type){
	int i;
	for (i = 0; i < size; i++) {
		lua_rawgeti(L,index,i+1);
		if (!lua_isuserdata(L,-1) || SWIG_ConvertPtr(L,-1,&array[i],type,0)==-1){
			lua_pop(L,1);
			return 0;
		}
		lua_pop(L,1);
	}
	return 1;
}
SWIGINTERN void** SWIG_get_ptr_array_fixed(lua_State* L, int index, int size,swig_type_info *type){
	void **array;
	if (!lua_istable(L,index) || SWIG_itable_size(L,index) != size) {
		SWIG_Lua_pushferrstring(L,"expected a table of size %d",size);
		return 0;
	}
	array=SWIG_ALLOC_ARRAY(void*,size);
	if (!SWIG_read_ptr_array(L,index,array,size,type)){
		SWIG_Lua_pushferrstring(L,"table must contain pointers of type %s",type->name);
		SWIG_FREE_ARRAY(array);
		return 0;
	}
	return array;
}
SWIGINTERN void** SWIG_get_ptr_array_var(lua_State* L, int index, int* size,swig_type_info *type){
	void **array;
	if (!lua_istable(L,index)) {
		SWIG_Lua_pusherrstring(L,"expected a table");
		return 0;
	}
	*size=SWIG_itable_size(L,index);
	if (*size<1){
		SWIG_Lua_pusherrstring(L,"table appears to be empty");
		return 0;
	}
	array=SWIG_ALLOC_ARRAY(void*,*size);
	if (!SWIG_read_ptr_array(L,index,array,*size,type)){
		SWIG_Lua_pushferrstring(L,"table must contain pointers of type %s",type->name);
		SWIG_FREE_ARRAY(array);
		return 0;
	}
	return array;
}
SWIGINTERN void SWIG_write_ptr_array(lua_State* L,void **array,int size,swig_type_info *type,int own){
	int i;
	lua_newtable(L);
	for (i = 0; i < size; i++){
		SWIG_NewPointerObj(L,array[i],type,own);
		lua_rawseti(L,-2,i+1);/* -1 is the number, -2 is the table*/
	}
}


#include <typeinfo>
#include <stdexcept>


#define SWIG_exception(a,b)\
{ lua_pushfstring(L,"%s:%s",#a,b);SWIG_fail; }


#include <typeinfo>
#include <stdexcept>


#include <string>


SWIGINTERN int SWIG_lua_isnilstring(lua_State *L, int idx) {
  int ret = lua_isstring(L, idx);
  if (!ret)
   ret = lua_isnil(L, idx);
  return ret;
}


#include <vector>


#include <map>
#include <algorithm>
#include <stdexcept>


#include <utility>


#include <boost/filesystem.hpp>

SWIGINTERN int std_vector_Sl_int_Sg____getitem__(std::vector< int > *self,unsigned int idx){
				if (idx>=self->size())
					throw std::out_of_range("in vector::__getitem__()");
				return (*self)[idx];
			}
SWIGINTERN void std_vector_Sl_int_Sg____setitem__(std::vector< int > *self,unsigned int idx,int val){
				if (idx>=self->size())
					throw std::out_of_range("in vector::__setitem__()");
				(*self)[idx]=val;
			}
SWIGINTERN float std_vector_Sl_float_Sg____getitem__(std::vector< float > *self,unsigned int idx){
				if (idx>=self->size())
					throw std::out_of_range("in vector::__getitem__()");
				return (*self)[idx];
			}
SWIGINTERN void std_vector_Sl_float_Sg____setitem__(std::vector< float > *self,unsigned int idx,float val){
				if (idx>=self->size())
					throw std::out_of_range("in vector::__setitem__()");
				(*self)[idx]=val;
			}
SWIGINTERN std::string std_vector_Sl_std_string_Sg____getitem__(std::vector< std::string > *self,unsigned int idx){
				if (idx>=self->size())
					throw std::out_of_range("in vector::__getitem__()");
				return (*self)[idx];
			}
SWIGINTERN void std_vector_Sl_std_string_Sg____setitem__(std::vector< std::string > *self,unsigned int idx,std::string val){
				if (idx>=self->size())
					throw std::out_of_range("in vector::__setitem__()");
				(*self)[idx]=val;
			}
SWIGINTERN unsigned char std_vector_Sl_unsigned_SS_char_Sg____getitem__(std::vector< unsigned char > *self,unsigned int idx){
				if (idx>=self->size())
					throw std::out_of_range("in vector::__getitem__()");
				return (*self)[idx];
			}
SWIGINTERN void std_vector_Sl_unsigned_SS_char_Sg____setitem__(std::vector< unsigned char > *self,unsigned int idx,unsigned char val){
				if (idx>=self->size())
					throw std::out_of_range("in vector::__setitem__()");
				(*self)[idx]=val;
			}
SWIGINTERN ofVideoDevice std_vector_Sl_ofVideoDevice_Sg____getitem__(std::vector< ofVideoDevice > *self,unsigned int idx){
				if (idx>=self->size())
					throw std::out_of_range("in vector::__getitem__()");
				return (*self)[idx];
			}
SWIGINTERN void std_vector_Sl_ofVideoDevice_Sg____setitem__(std::vector< ofVideoDevice > *self,unsigned int idx,ofVideoDevice val){
				if (idx>=self->size())
					throw std::out_of_range("in vector::__setitem__()");
				(*self)[idx]=val;
			}
SWIGINTERN ofTexture std_vector_Sl_ofTexture_Sg____getitem__(std::vector< ofTexture > *self,unsigned int idx){
				if (idx>=self->size())
					throw std::out_of_range("in vector::__getitem__()");
				return (*self)[idx];
			}
SWIGINTERN void std_vector_Sl_ofTexture_Sg____setitem__(std::vector< ofTexture > *self,unsigned int idx,ofTexture val){
				if (idx>=self->size())
					throw std::out_of_range("in vector::__setitem__()");
				(*self)[idx]=val;
			}
SWIGINTERN char const *ofMatrix3x3___str__(ofMatrix3x3 *self){
		stringstream str;
		str << (*self);
		return str.str().c_str();
	}
SWIGINTERN char const *ofMatrix4x4___str__(ofMatrix4x4 *self){
		stringstream str;
		str << (*self);
		return str.str().c_str();
	}
SWIGINTERN char const *ofQuaternion___str__(ofQuaternion *self){
		stringstream str;
		str << (*self);
		return str.str().c_str();
	}
SWIGINTERN char const *ofVec2f___str__(ofVec2f *self){
		stringstream str;
		str << (*self);
		return str.str().c_str();
	}
SWIGINTERN char const *ofVec3f___str__(ofVec3f *self){
		stringstream str;
		str << (*self);
		return str.str().c_str();
	}
SWIGINTERN char const *ofVec4f___str__(ofVec4f *self){
		stringstream str;
		str << (*self);
		return str.str().c_str();
	}
SWIGINTERN ofPolyline_< glm::vec3 > std_vector_Sl_ofPolyline_Sg____getitem__(std::vector< ofPolyline > *self,unsigned int idx){
				if (idx>=self->size())
					throw std::out_of_range("in vector::__getitem__()");
				return (*self)[idx];
			}
SWIGINTERN void std_vector_Sl_ofPolyline_Sg____setitem__(std::vector< ofPolyline > *self,unsigned int idx,ofPolyline_< glm::vec3 > val){
				if (idx>=self->size())
					throw std::out_of_range("in vector::__setitem__()");
				(*self)[idx]=val;
			}

#define ofColor__Sl_unsigned_SS_char_Sg__r_get(self_) self_->r
#define ofColor__Sl_unsigned_SS_char_Sg__r_set(self_, val_) self_->r = val_
  

#define ofColor__Sl_unsigned_SS_char_Sg__g_get(self_) self_->g
#define ofColor__Sl_unsigned_SS_char_Sg__g_set(self_, val_) self_->g = val_
  

#define ofColor__Sl_unsigned_SS_char_Sg__b_get(self_) self_->b
#define ofColor__Sl_unsigned_SS_char_Sg__b_set(self_, val_) self_->b = val_
  

#define ofColor__Sl_unsigned_SS_char_Sg__a_get(self_) self_->a
#define ofColor__Sl_unsigned_SS_char_Sg__a_set(self_, val_) self_->a = val_
  

#define ofColor__Sl_float_Sg__r_get(self_) self_->r
#define ofColor__Sl_float_Sg__r_set(self_, val_) self_->r = val_
  

#define ofColor__Sl_float_Sg__g_get(self_) self_->g
#define ofColor__Sl_float_Sg__g_set(self_, val_) self_->g = val_
  

#define ofColor__Sl_float_Sg__b_get(self_) self_->b
#define ofColor__Sl_float_Sg__b_set(self_, val_) self_->b = val_
  

#define ofColor__Sl_float_Sg__a_get(self_) self_->a
#define ofColor__Sl_float_Sg__a_set(self_, val_) self_->a = val_
  

#define ofColor__Sl_unsigned_SS_short_Sg__r_get(self_) self_->r
#define ofColor__Sl_unsigned_SS_short_Sg__r_set(self_, val_) self_->r = val_
  

#define ofColor__Sl_unsigned_SS_short_Sg__g_get(self_) self_->g
#define ofColor__Sl_unsigned_SS_short_Sg__g_set(self_, val_) self_->g = val_
  

#define ofColor__Sl_unsigned_SS_short_Sg__b_get(self_) self_->b
#define ofColor__Sl_unsigned_SS_short_Sg__b_set(self_, val_) self_->b = val_
  

#define ofColor__Sl_unsigned_SS_short_Sg__a_get(self_) self_->a
#define ofColor__Sl_unsigned_SS_short_Sg__a_set(self_, val_) self_->a = val_
  
SWIGINTERN unsigned char ofColor__Sl_unsigned_SS_char_Sg__getR(ofColor_< unsigned char > *self){return self->r;}
SWIGINTERN unsigned char ofColor__Sl_unsigned_SS_char_Sg__getG(ofColor_< unsigned char > *self){return self->g;}
SWIGINTERN unsigned char ofColor__Sl_unsigned_SS_char_Sg__getB(ofColor_< unsigned char > *self){return self->b;}
SWIGINTERN unsigned char ofColor__Sl_unsigned_SS_char_Sg__getA(ofColor_< unsigned char > *self){return self->a;}
SWIGINTERN void ofColor__Sl_unsigned_SS_char_Sg__setR(ofColor_< unsigned char > *self,unsigned char r){self->r = r;}
SWIGINTERN void ofColor__Sl_unsigned_SS_char_Sg__setG(ofColor_< unsigned char > *self,unsigned char g){self->g = g;}
SWIGINTERN void ofColor__Sl_unsigned_SS_char_Sg__setB(ofColor_< unsigned char > *self,unsigned char b){self->b = b;}
SWIGINTERN void ofColor__Sl_unsigned_SS_char_Sg__setA(ofColor_< unsigned char > *self,unsigned char a){self->a = a;}
SWIGINTERN char const *ofColor__Sl_unsigned_SS_char_Sg____str__(ofColor_< unsigned char > *self){
		stringstream str;
		str << (*self);
		return str.str().c_str();
	}
SWIGINTERN float ofColor__Sl_float_Sg__getR(ofColor_< float > *self){return self->r;}
SWIGINTERN float ofColor__Sl_float_Sg__getG(ofColor_< float > *self){return self->g;}
SWIGINTERN float ofColor__Sl_float_Sg__getB(ofColor_< float > *self){return self->b;}
SWIGINTERN float ofColor__Sl_float_Sg__getA(ofColor_< float > *self){return self->a;}
SWIGINTERN void ofColor__Sl_float_Sg__setR(ofColor_< float > *self,float r){self->r = r;}
SWIGINTERN void ofColor__Sl_float_Sg__setG(ofColor_< float > *self,float g){self->g = g;}
SWIGINTERN void ofColor__Sl_float_Sg__setB(ofColor_< float > *self,float b){self->b = b;}
SWIGINTERN void ofColor__Sl_float_Sg__setA(ofColor_< float > *self,float a){self->a = a;}
SWIGINTERN char const *ofColor__Sl_float_Sg____str__(ofColor_< float > *self){
		stringstream str;
		str << (*self);
		return str.str().c_str();
	}
SWIGINTERN unsigned short ofColor__Sl_unsigned_SS_short_Sg__getR(ofColor_< unsigned short > *self){return self->r;}
SWIGINTERN unsigned short ofColor__Sl_unsigned_SS_short_Sg__getG(ofColor_< unsigned short > *self){return self->g;}
SWIGINTERN unsigned short ofColor__Sl_unsigned_SS_short_Sg__getB(ofColor_< unsigned short > *self){return self->b;}
SWIGINTERN unsigned short ofColor__Sl_unsigned_SS_short_Sg__getA(ofColor_< unsigned short > *self){return self->a;}
SWIGINTERN void ofColor__Sl_unsigned_SS_short_Sg__setR(ofColor_< unsigned short > *self,unsigned short r){self->r = r;}
SWIGINTERN void ofColor__Sl_unsigned_SS_short_Sg__setG(ofColor_< unsigned short > *self,unsigned short g){self->g = g;}
SWIGINTERN void ofColor__Sl_unsigned_SS_short_Sg__setB(ofColor_< unsigned short > *self,unsigned short b){self->b = b;}
SWIGINTERN void ofColor__Sl_unsigned_SS_short_Sg__setA(ofColor_< unsigned short > *self,unsigned short a){self->a = a;}
SWIGINTERN char const *ofColor__Sl_unsigned_SS_short_Sg____str__(ofColor_< unsigned short > *self){
		stringstream str;
		str << (*self);
		return str.str().c_str();
	}
SWIGINTERN char const *ofRectangle___str__(ofRectangle *self){
		stringstream str;
		str << (*self);
		return str.str().c_str();
	}

#define ofRectangle_x_get(self_) self_->getX()
#define ofRectangle_x_set(self_, val_) self_->setX(val_)
  

#define ofRectangle_y_get(self_) self_->getY()
#define ofRectangle_y_set(self_, val_) self_->setY(val_)
  

	void log(ofLogLevel level, const std::string & message) {
		ofLog(level, message);
	}

#ifdef __cplusplus
extern "C" {
#endif
static int _wrap_new_string__SWIG_0(lua_State* L) { int SWIG_arg = 0; std::string *result = 0 ;
  SWIG_check_num_args("std::string::string",0,0) result = (std::string *)new std::string();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__string,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_string__SWIG_1(lua_State* L) { int SWIG_arg = 0; char *arg1 = (char *) 0 ; std::string *result = 0 ;
  SWIG_check_num_args("std::string::string",1,1)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("std::string::string",1,"char const *"); arg1 = (char *)lua_tostring(L, 1);
  result = (std::string *)new std::string((char const *)arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__string,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_string(lua_State* L) { int argc; int argv[2]={ 1,2} ; argc = lua_gettop(L); if (argc == 0) {
    return _wrap_new_string__SWIG_0(L);}  if (argc == 1) { int _v; { _v = SWIG_lua_isnilstring(L,argv[0]); }  if (_v) {
      return _wrap_new_string__SWIG_1(L);}  }  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_string'\n"
  "  Possible C/C++ prototypes are:\n" "    std::string::string()\n" "    std::string::string(char const *)\n");
  lua_error(L);return 0; }
static int _wrap_string_size(lua_State* L) { int SWIG_arg = 0; std::string *arg1 = (std::string *) 0 ; unsigned int result;
  SWIG_check_num_args("std::string::size",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::string::size",1,"std::string const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__string,0))){
    SWIG_fail_ptr("string_size",1,SWIGTYPE_p_std__string); }  result = (unsigned int)((std::string const *)arg1)->size();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_string_length(lua_State* L) { int SWIG_arg = 0; std::string *arg1 = (std::string *) 0 ; unsigned int result;
  SWIG_check_num_args("std::string::length",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::string::length",1,"std::string const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__string,0))){
    SWIG_fail_ptr("string_length",1,SWIGTYPE_p_std__string); }  result = (unsigned int)((std::string const *)arg1)->length();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_string_empty(lua_State* L) { int SWIG_arg = 0; std::string *arg1 = (std::string *) 0 ; bool result;
  SWIG_check_num_args("std::string::empty",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::string::empty",1,"std::string const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__string,0))){
    SWIG_fail_ptr("string_empty",1,SWIGTYPE_p_std__string); }  result = (bool)((std::string const *)arg1)->empty();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_string_c_str(lua_State* L) { int SWIG_arg = 0; std::string *arg1 = (std::string *) 0 ; char *result = 0 ;
  SWIG_check_num_args("std::string::c_str",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::string::c_str",1,"std::string const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__string,0))){
    SWIG_fail_ptr("string_c_str",1,SWIGTYPE_p_std__string); }  result = (char *)((std::string const *)arg1)->c_str();
  lua_pushstring(L,(const char *)result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_string_data(lua_State* L) { int SWIG_arg = 0; std::string *arg1 = (std::string *) 0 ; char *result = 0 ;
  SWIG_check_num_args("std::string::data",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::string::data",1,"std::string const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__string,0))){
    SWIG_fail_ptr("string_data",1,SWIGTYPE_p_std__string); }  result = (char *)((std::string const *)arg1)->data();
  lua_pushstring(L,(const char *)result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_string_assign(lua_State* L) { int SWIG_arg = 0; std::string *arg1 = (std::string *) 0 ;
  char *arg2 = (char *) 0 ; SWIG_check_num_args("std::string::assign",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::string::assign",1,"std::string *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("std::string::assign",2,"char const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__string,0))){
    SWIG_fail_ptr("string_assign",1,SWIGTYPE_p_std__string); }  arg2 = (char *)lua_tostring(L, 2);
  (arg1)->assign((char const *)arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static void swig_delete_string(void *obj) {
std::string *arg1 = (std::string *) obj;
delete arg1;
}
static int _proxy__wrap_new_string(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_string);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_string_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_string_methods[]= {
    { "size", _wrap_string_size},
    { "length", _wrap_string_length},
    { "empty", _wrap_string_empty},
    { "c_str", _wrap_string_c_str},
    { "data", _wrap_string_data},
    { "assign", _wrap_string_assign},
    {0,0}
};
static swig_lua_method swig_string_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_string_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_string_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_string_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_string_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_string_Sf_SwigStatic = {
    "string",
    swig_string_Sf_SwigStatic_methods,
    swig_string_Sf_SwigStatic_attributes,
    swig_string_Sf_SwigStatic_constants,
    swig_string_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_string_bases[] = {0};
static const char *swig_string_base_names[] = {0};
static swig_lua_class _wrap_class_string = { "string", "string", &SWIGTYPE_p_std__string,_proxy__wrap_new_string, swig_delete_string, swig_string_methods, swig_string_attributes, &swig_string_Sf_SwigStatic, swig_string_meta, swig_string_bases, swig_string_base_names };

static int _wrap_new_path__SWIG_0(lua_State* L) { int SWIG_arg = 0; std::filesystem::path *result = 0 ;
  SWIG_check_num_args("std::filesystem::path::path",0,0) result = (std::filesystem::path *)new std::filesystem::path();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_boost__filesystem__path,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_path__SWIG_1(lua_State* L) { int SWIG_arg = 0; char *arg1 = (char *) 0 ;
  std::filesystem::path *result = 0 ; SWIG_check_num_args("std::filesystem::path::path",1,1)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("std::filesystem::path::path",1,"char const *");
  arg1 = (char *)lua_tostring(L, 1); result = (std::filesystem::path *)new std::filesystem::path((char const *)arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_boost__filesystem__path,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_path(lua_State* L) { int argc; int argv[2]={ 1,2} ; argc = lua_gettop(L); if (argc == 0) {
    return _wrap_new_path__SWIG_0(L);}  if (argc == 1) { int _v; { _v = SWIG_lua_isnilstring(L,argv[0]); }  if (_v) {
      return _wrap_new_path__SWIG_1(L);}  }  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_path'\n"
  "  Possible C/C++ prototypes are:\n" "    std::filesystem::path::path()\n" "    std::filesystem::path::path(char const *)\n");
  lua_error(L);return 0; }
static int _wrap_path_string(lua_State* L) { int SWIG_arg = 0; std::filesystem::path *arg1 = (std::filesystem::path *) 0 ;
  std::string result; SWIG_check_num_args("std::filesystem::path::string",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::filesystem::path::string",1,"std::filesystem::path const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_boost__filesystem__path,0))){
    SWIG_fail_ptr("path_string",1,SWIGTYPE_p_boost__filesystem__path); } 
  result = ((std::filesystem::path const *)arg1)->string(); lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static void swig_delete_path(void *obj) {
std::filesystem::path *arg1 = (std::filesystem::path *) obj;
delete arg1;
}
static int _proxy__wrap_new_path(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_path);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_path_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_path_methods[]= {
    { "string", _wrap_path_string},
    {0,0}
};
static swig_lua_method swig_path_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_path_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_path_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_path_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_path_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_path_Sf_SwigStatic = {
    "path",
    swig_path_Sf_SwigStatic_methods,
    swig_path_Sf_SwigStatic_attributes,
    swig_path_Sf_SwigStatic_constants,
    swig_path_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_path_bases[] = {0};
static const char *swig_path_base_names[] = {0};
static swig_lua_class _wrap_class_path = { "path", "path", &SWIGTYPE_p_boost__filesystem__path,_proxy__wrap_new_path, swig_delete_path, swig_path_methods, swig_path_attributes, &swig_path_Sf_SwigStatic, swig_path_meta, swig_path_bases, swig_path_base_names };

static int _wrap_new_IntVector__SWIG_0(lua_State* L) { int SWIG_arg = 0; std::vector< int > *result = 0 ;
  SWIG_check_num_args("std::vector< int >::vector",0,0) result = (std::vector< int > *)new std::vector< int >();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorT_int_t,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_IntVector__SWIG_1(lua_State* L) { int SWIG_arg = 0; unsigned int arg1 ; std::vector< int > *result = 0 ;
  SWIG_check_num_args("std::vector< int >::vector",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("std::vector< int >::vector",1,"unsigned int");
  SWIG_contract_assert((lua_tonumber(L,1)>=0),"number must not be negative") arg1 = (unsigned int)lua_tonumber(L, 1);
  result = (std::vector< int > *)new std::vector< int >(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorT_int_t,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_IntVector__SWIG_2(lua_State* L) { int SWIG_arg = 0; std::vector< int > *arg1 = 0 ;
  std::vector< int > *result = 0 ; SWIG_check_num_args("std::vector< int >::vector",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("std::vector< int >::vector",1,"std::vector< int > const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_int_t,0))){
    SWIG_fail_ptr("new_IntVector",1,SWIGTYPE_p_std__vectorT_int_t); } 
  result = (std::vector< int > *)new std::vector< int >((std::vector< int > const &)*arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorT_int_t,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_IntVector__SWIG_3(lua_State* L) { int SWIG_arg = 0; unsigned int arg1 ; int arg2 ;
  std::vector< int > *result = 0 ; SWIG_check_num_args("std::vector< int >::vector",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("std::vector< int >::vector",1,"unsigned int");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("std::vector< int >::vector",2,"int");
  SWIG_contract_assert((lua_tonumber(L,1)>=0),"number must not be negative") arg1 = (unsigned int)lua_tonumber(L, 1);
  arg2 = (int)lua_tonumber(L, 2); result = (std::vector< int > *)new std::vector< int >(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorT_int_t,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_IntVector(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 0) {
    return _wrap_new_IntVector__SWIG_0(L);}  if (argc == 1) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_std__vectorT_int_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_new_IntVector__SWIG_2(L);}  }  if (argc == 1) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { return _wrap_new_IntVector__SWIG_1(L);}  }  if (argc == 2) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_new_IntVector__SWIG_3(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_IntVector'\n" "  Possible C/C++ prototypes are:\n"
  "    std::vector< int >::vector()\n" "    std::vector< int >::vector(unsigned int)\n"
  "    std::vector< int >::vector(std::vector< int > const &)\n" "    std::vector< int >::vector(unsigned int,int)\n");
  lua_error(L);return 0; }
static int _wrap_IntVector_size(lua_State* L) { int SWIG_arg = 0; std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  unsigned int result; SWIG_check_num_args("std::vector< int >::size",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< int >::size",1,"std::vector< int > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_int_t,0))){
    SWIG_fail_ptr("IntVector_size",1,SWIGTYPE_p_std__vectorT_int_t); } 
  result = (unsigned int)((std::vector< int > const *)arg1)->size(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_IntVector_max_size(lua_State* L) { int SWIG_arg = 0; std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  unsigned int result; SWIG_check_num_args("std::vector< int >::max_size",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< int >::max_size",1,"std::vector< int > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_int_t,0))){
    SWIG_fail_ptr("IntVector_max_size",1,SWIGTYPE_p_std__vectorT_int_t); } 
  result = (unsigned int)((std::vector< int > const *)arg1)->max_size(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_IntVector_empty(lua_State* L) { int SWIG_arg = 0; std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  bool result; SWIG_check_num_args("std::vector< int >::empty",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< int >::empty",1,"std::vector< int > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_int_t,0))){
    SWIG_fail_ptr("IntVector_empty",1,SWIGTYPE_p_std__vectorT_int_t); } 
  result = (bool)((std::vector< int > const *)arg1)->empty(); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_IntVector_clear(lua_State* L) { int SWIG_arg = 0; std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  SWIG_check_num_args("std::vector< int >::clear",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< int >::clear",1,"std::vector< int > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_int_t,0))){
    SWIG_fail_ptr("IntVector_clear",1,SWIGTYPE_p_std__vectorT_int_t); }  (arg1)->clear(); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_IntVector_push_back(lua_State* L) { int SWIG_arg = 0; std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  int arg2 ; SWIG_check_num_args("std::vector< int >::push_back",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< int >::push_back",1,"std::vector< int > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("std::vector< int >::push_back",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_int_t,0))){
    SWIG_fail_ptr("IntVector_push_back",1,SWIGTYPE_p_std__vectorT_int_t); }  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->push_back(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_IntVector_pop_back(lua_State* L) { int SWIG_arg = 0; std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  SWIG_check_num_args("std::vector< int >::pop_back",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< int >::pop_back",1,"std::vector< int > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_int_t,0))){
    SWIG_fail_ptr("IntVector_pop_back",1,SWIGTYPE_p_std__vectorT_int_t); }  (arg1)->pop_back(); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_IntVector_front(lua_State* L) { int SWIG_arg = 0; std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  int result; SWIG_check_num_args("std::vector< int >::front",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< int >::front",1,"std::vector< int > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_int_t,0))){
    SWIG_fail_ptr("IntVector_front",1,SWIGTYPE_p_std__vectorT_int_t); } 
  result = (int)((std::vector< int > const *)arg1)->front(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_IntVector_back(lua_State* L) { int SWIG_arg = 0; std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  int result; SWIG_check_num_args("std::vector< int >::back",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< int >::back",1,"std::vector< int > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_int_t,0))){
    SWIG_fail_ptr("IntVector_back",1,SWIGTYPE_p_std__vectorT_int_t); } 
  result = (int)((std::vector< int > const *)arg1)->back(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_IntVector___getitem(lua_State* L) { int SWIG_arg = 0; std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  unsigned int arg2 ; int result; SWIG_check_num_args("std::vector< int >::__getitem__",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< int >::__getitem__",1,"std::vector< int > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("std::vector< int >::__getitem__",2,"unsigned int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_int_t,0))){
    SWIG_fail_ptr("IntVector___getitem",1,SWIGTYPE_p_std__vectorT_int_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (unsigned int)lua_tonumber(L, 2); try {
    result = (int)std_vector_Sl_int_Sg____getitem__(arg1,arg2);}  catch(std::out_of_range &_e) {
    SWIG_exception(SWIG_IndexError, (&_e)->what()); }  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_IntVector___setitem(lua_State* L) { int SWIG_arg = 0; std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  unsigned int arg2 ; int arg3 ; SWIG_check_num_args("std::vector< int >::__setitem__",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< int >::__setitem__",1,"std::vector< int > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("std::vector< int >::__setitem__",2,"unsigned int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("std::vector< int >::__setitem__",3,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_int_t,0))){
    SWIG_fail_ptr("IntVector___setitem",1,SWIGTYPE_p_std__vectorT_int_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (unsigned int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3); try { std_vector_Sl_int_Sg____setitem__(arg1,arg2,arg3);}  catch(std::out_of_range &_e) {
    SWIG_exception(SWIG_IndexError, (&_e)->what()); }  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static void swig_delete_IntVector(void *obj) {
std::vector< int > *arg1 = (std::vector< int > *) obj;
delete arg1;
}
static int _proxy__wrap_new_IntVector(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_IntVector);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_IntVector_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_IntVector_methods[]= {
    { "size", _wrap_IntVector_size},
    { "max_size", _wrap_IntVector_max_size},
    { "empty", _wrap_IntVector_empty},
    { "clear", _wrap_IntVector_clear},
    { "push_back", _wrap_IntVector_push_back},
    { "pop_back", _wrap_IntVector_pop_back},
    { "front", _wrap_IntVector_front},
    { "back", _wrap_IntVector_back},
    { "__getitem", _wrap_IntVector___getitem},
    { "__setitem", _wrap_IntVector___setitem},
    {0,0}
};
static swig_lua_method swig_IntVector_meta[] = {
    { "__getitem", _wrap_IntVector___getitem},
    { "__setitem", _wrap_IntVector___setitem},
    {0,0}
};

static swig_lua_attribute swig_IntVector_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_IntVector_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_IntVector_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_IntVector_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_IntVector_Sf_SwigStatic = {
    "IntVector",
    swig_IntVector_Sf_SwigStatic_methods,
    swig_IntVector_Sf_SwigStatic_attributes,
    swig_IntVector_Sf_SwigStatic_constants,
    swig_IntVector_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_IntVector_bases[] = {0};
static const char *swig_IntVector_base_names[] = {0};
static swig_lua_class _wrap_class_IntVector = { "IntVector", "IntVector", &SWIGTYPE_p_std__vectorT_int_t,_proxy__wrap_new_IntVector, swig_delete_IntVector, swig_IntVector_methods, swig_IntVector_attributes, &swig_IntVector_Sf_SwigStatic, swig_IntVector_meta, swig_IntVector_bases, swig_IntVector_base_names };

static int _wrap_new_FloatVector__SWIG_0(lua_State* L) { int SWIG_arg = 0; std::vector< float > *result = 0 ;
  SWIG_check_num_args("std::vector< float >::vector",0,0) result = (std::vector< float > *)new std::vector< float >();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorT_float_t,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_FloatVector__SWIG_1(lua_State* L) { int SWIG_arg = 0; unsigned int arg1 ;
  std::vector< float > *result = 0 ; SWIG_check_num_args("std::vector< float >::vector",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("std::vector< float >::vector",1,"unsigned int");
  SWIG_contract_assert((lua_tonumber(L,1)>=0),"number must not be negative") arg1 = (unsigned int)lua_tonumber(L, 1);
  result = (std::vector< float > *)new std::vector< float >(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorT_float_t,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_FloatVector__SWIG_2(lua_State* L) { int SWIG_arg = 0; std::vector< float > *arg1 = 0 ;
  std::vector< float > *result = 0 ; SWIG_check_num_args("std::vector< float >::vector",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("std::vector< float >::vector",1,"std::vector< float > const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_float_t,0))){
    SWIG_fail_ptr("new_FloatVector",1,SWIGTYPE_p_std__vectorT_float_t); } 
  result = (std::vector< float > *)new std::vector< float >((std::vector< float > const &)*arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorT_float_t,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_FloatVector__SWIG_3(lua_State* L) { int SWIG_arg = 0; unsigned int arg1 ; float arg2 ;
  std::vector< float > *result = 0 ; SWIG_check_num_args("std::vector< float >::vector",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("std::vector< float >::vector",1,"unsigned int");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("std::vector< float >::vector",2,"float");
  SWIG_contract_assert((lua_tonumber(L,1)>=0),"number must not be negative") arg1 = (unsigned int)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); result = (std::vector< float > *)new std::vector< float >(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorT_float_t,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_FloatVector(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 0) {
    return _wrap_new_FloatVector__SWIG_0(L);}  if (argc == 1) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_std__vectorT_float_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_new_FloatVector__SWIG_2(L);}  }  if (argc == 1) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { return _wrap_new_FloatVector__SWIG_1(L);}  }  if (argc == 2) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_new_FloatVector__SWIG_3(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_FloatVector'\n" "  Possible C/C++ prototypes are:\n"
  "    std::vector< float >::vector()\n" "    std::vector< float >::vector(unsigned int)\n"
  "    std::vector< float >::vector(std::vector< float > const &)\n" "    std::vector< float >::vector(unsigned int,float)\n");
  lua_error(L);return 0; }
static int _wrap_FloatVector_size(lua_State* L) { int SWIG_arg = 0; std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  unsigned int result; SWIG_check_num_args("std::vector< float >::size",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< float >::size",1,"std::vector< float > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_float_t,0))){
    SWIG_fail_ptr("FloatVector_size",1,SWIGTYPE_p_std__vectorT_float_t); } 
  result = (unsigned int)((std::vector< float > const *)arg1)->size(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatVector_max_size(lua_State* L) { int SWIG_arg = 0;
  std::vector< float > *arg1 = (std::vector< float > *) 0 ; unsigned int result;
  SWIG_check_num_args("std::vector< float >::max_size",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< float >::max_size",1,"std::vector< float > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_float_t,0))){
    SWIG_fail_ptr("FloatVector_max_size",1,SWIGTYPE_p_std__vectorT_float_t); } 
  result = (unsigned int)((std::vector< float > const *)arg1)->max_size(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatVector_empty(lua_State* L) { int SWIG_arg = 0; std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  bool result; SWIG_check_num_args("std::vector< float >::empty",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< float >::empty",1,"std::vector< float > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_float_t,0))){
    SWIG_fail_ptr("FloatVector_empty",1,SWIGTYPE_p_std__vectorT_float_t); } 
  result = (bool)((std::vector< float > const *)arg1)->empty(); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatVector_clear(lua_State* L) { int SWIG_arg = 0; std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  SWIG_check_num_args("std::vector< float >::clear",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< float >::clear",1,"std::vector< float > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_float_t,0))){
    SWIG_fail_ptr("FloatVector_clear",1,SWIGTYPE_p_std__vectorT_float_t); }  (arg1)->clear(); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatVector_push_back(lua_State* L) { int SWIG_arg = 0;
  std::vector< float > *arg1 = (std::vector< float > *) 0 ; float arg2 ;
  SWIG_check_num_args("std::vector< float >::push_back",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< float >::push_back",1,"std::vector< float > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("std::vector< float >::push_back",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_float_t,0))){
    SWIG_fail_ptr("FloatVector_push_back",1,SWIGTYPE_p_std__vectorT_float_t); }  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->push_back(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatVector_pop_back(lua_State* L) { int SWIG_arg = 0;
  std::vector< float > *arg1 = (std::vector< float > *) 0 ; SWIG_check_num_args("std::vector< float >::pop_back",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< float >::pop_back",1,"std::vector< float > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_float_t,0))){
    SWIG_fail_ptr("FloatVector_pop_back",1,SWIGTYPE_p_std__vectorT_float_t); }  (arg1)->pop_back(); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatVector_front(lua_State* L) { int SWIG_arg = 0; std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  float result; SWIG_check_num_args("std::vector< float >::front",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< float >::front",1,"std::vector< float > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_float_t,0))){
    SWIG_fail_ptr("FloatVector_front",1,SWIGTYPE_p_std__vectorT_float_t); } 
  result = (float)((std::vector< float > const *)arg1)->front(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatVector_back(lua_State* L) { int SWIG_arg = 0; std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  float result; SWIG_check_num_args("std::vector< float >::back",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< float >::back",1,"std::vector< float > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_float_t,0))){
    SWIG_fail_ptr("FloatVector_back",1,SWIGTYPE_p_std__vectorT_float_t); } 
  result = (float)((std::vector< float > const *)arg1)->back(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatVector___getitem(lua_State* L) { int SWIG_arg = 0;
  std::vector< float > *arg1 = (std::vector< float > *) 0 ; unsigned int arg2 ; float result;
  SWIG_check_num_args("std::vector< float >::__getitem__",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< float >::__getitem__",1,"std::vector< float > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("std::vector< float >::__getitem__",2,"unsigned int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_float_t,0))){
    SWIG_fail_ptr("FloatVector___getitem",1,SWIGTYPE_p_std__vectorT_float_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (unsigned int)lua_tonumber(L, 2); try {
    result = (float)std_vector_Sl_float_Sg____getitem__(arg1,arg2);}  catch(std::out_of_range &_e) {
    SWIG_exception(SWIG_IndexError, (&_e)->what()); }  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatVector___setitem(lua_State* L) { int SWIG_arg = 0;
  std::vector< float > *arg1 = (std::vector< float > *) 0 ; unsigned int arg2 ; float arg3 ;
  SWIG_check_num_args("std::vector< float >::__setitem__",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< float >::__setitem__",1,"std::vector< float > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("std::vector< float >::__setitem__",2,"unsigned int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("std::vector< float >::__setitem__",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_float_t,0))){
    SWIG_fail_ptr("FloatVector___setitem",1,SWIGTYPE_p_std__vectorT_float_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (unsigned int)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); try { std_vector_Sl_float_Sg____setitem__(arg1,arg2,arg3);}  catch(std::out_of_range &_e) {
    SWIG_exception(SWIG_IndexError, (&_e)->what()); }  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static void swig_delete_FloatVector(void *obj) {
std::vector< float > *arg1 = (std::vector< float > *) obj;
delete arg1;
}
static int _proxy__wrap_new_FloatVector(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_FloatVector);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_FloatVector_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_FloatVector_methods[]= {
    { "size", _wrap_FloatVector_size},
    { "max_size", _wrap_FloatVector_max_size},
    { "empty", _wrap_FloatVector_empty},
    { "clear", _wrap_FloatVector_clear},
    { "push_back", _wrap_FloatVector_push_back},
    { "pop_back", _wrap_FloatVector_pop_back},
    { "front", _wrap_FloatVector_front},
    { "back", _wrap_FloatVector_back},
    { "__getitem", _wrap_FloatVector___getitem},
    { "__setitem", _wrap_FloatVector___setitem},
    {0,0}
};
static swig_lua_method swig_FloatVector_meta[] = {
    { "__getitem", _wrap_FloatVector___getitem},
    { "__setitem", _wrap_FloatVector___setitem},
    {0,0}
};

static swig_lua_attribute swig_FloatVector_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_FloatVector_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_FloatVector_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_FloatVector_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_FloatVector_Sf_SwigStatic = {
    "FloatVector",
    swig_FloatVector_Sf_SwigStatic_methods,
    swig_FloatVector_Sf_SwigStatic_attributes,
    swig_FloatVector_Sf_SwigStatic_constants,
    swig_FloatVector_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_FloatVector_bases[] = {0};
static const char *swig_FloatVector_base_names[] = {0};
static swig_lua_class _wrap_class_FloatVector = { "FloatVector", "FloatVector", &SWIGTYPE_p_std__vectorT_float_t,_proxy__wrap_new_FloatVector, swig_delete_FloatVector, swig_FloatVector_methods, swig_FloatVector_attributes, &swig_FloatVector_Sf_SwigStatic, swig_FloatVector_meta, swig_FloatVector_bases, swig_FloatVector_base_names };

static int _wrap_new_StringVector__SWIG_0(lua_State* L) { int SWIG_arg = 0; std::vector< std::string > *result = 0 ;
  SWIG_check_num_args("std::vector< std::string >::vector",0,0)
  result = (std::vector< std::string > *)new std::vector< std::string >();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorT_std__string_t,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_StringVector__SWIG_1(lua_State* L) { int SWIG_arg = 0; unsigned int arg1 ;
  std::vector< std::string > *result = 0 ; SWIG_check_num_args("std::vector< std::string >::vector",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("std::vector< std::string >::vector",1,"unsigned int");
  SWIG_contract_assert((lua_tonumber(L,1)>=0),"number must not be negative") arg1 = (unsigned int)lua_tonumber(L, 1);
  result = (std::vector< std::string > *)new std::vector< std::string >(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorT_std__string_t,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_StringVector__SWIG_2(lua_State* L) { int SWIG_arg = 0; std::vector< std::string > *arg1 = 0 ;
  std::vector< std::string > *result = 0 ; SWIG_check_num_args("std::vector< std::string >::vector",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("std::vector< std::string >::vector",1,"std::vector< std::string > const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_std__string_t,0))){
    SWIG_fail_ptr("new_StringVector",1,SWIGTYPE_p_std__vectorT_std__string_t); } 
  result = (std::vector< std::string > *)new std::vector< std::string >((std::vector< std::string > const &)*arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorT_std__string_t,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_StringVector__SWIG_3(lua_State* L) { int SWIG_arg = 0; unsigned int arg1 ; std::string arg2 ;
  std::vector< std::string > *result = 0 ; SWIG_check_num_args("std::vector< std::string >::vector",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("std::vector< std::string >::vector",1,"unsigned int");
  if(!lua_isstring(L,2)) SWIG_fail_arg("std::vector< std::string >::vector",2,"std::string");
  SWIG_contract_assert((lua_tonumber(L,1)>=0),"number must not be negative") arg1 = (unsigned int)lua_tonumber(L, 1);
  (&arg2)->assign(lua_tostring(L,2),lua_rawlen(L,2));
  result = (std::vector< std::string > *)new std::vector< std::string >(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorT_std__string_t,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_StringVector(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 0) {
    return _wrap_new_StringVector__SWIG_0(L);}  if (argc == 1) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_std__vectorT_std__string_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_new_StringVector__SWIG_2(L);}  }  if (argc == 1) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { return _wrap_new_StringVector__SWIG_1(L);}  }  if (argc == 2) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isstring(L,argv[1]); }  if (_v) {
        return _wrap_new_StringVector__SWIG_3(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_StringVector'\n" "  Possible C/C++ prototypes are:\n"
  "    std::vector< std::string >::vector()\n" "    std::vector< std::string >::vector(unsigned int)\n"
  "    std::vector< std::string >::vector(std::vector< std::string > const &)\n"
  "    std::vector< std::string >::vector(unsigned int,std::string)\n"); lua_error(L);return 0; }
static int _wrap_StringVector_size(lua_State* L) { int SWIG_arg = 0;
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ; unsigned int result;
  SWIG_check_num_args("std::vector< std::string >::size",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< std::string >::size",1,"std::vector< std::string > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_std__string_t,0))){
    SWIG_fail_ptr("StringVector_size",1,SWIGTYPE_p_std__vectorT_std__string_t); } 
  result = (unsigned int)((std::vector< std::string > const *)arg1)->size(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_StringVector_max_size(lua_State* L) { int SWIG_arg = 0;
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ; unsigned int result;
  SWIG_check_num_args("std::vector< std::string >::max_size",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< std::string >::max_size",1,"std::vector< std::string > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_std__string_t,0))){
    SWIG_fail_ptr("StringVector_max_size",1,SWIGTYPE_p_std__vectorT_std__string_t); } 
  result = (unsigned int)((std::vector< std::string > const *)arg1)->max_size();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_StringVector_empty(lua_State* L) { int SWIG_arg = 0;
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ; bool result;
  SWIG_check_num_args("std::vector< std::string >::empty",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< std::string >::empty",1,"std::vector< std::string > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_std__string_t,0))){
    SWIG_fail_ptr("StringVector_empty",1,SWIGTYPE_p_std__vectorT_std__string_t); } 
  result = (bool)((std::vector< std::string > const *)arg1)->empty(); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_StringVector_clear(lua_State* L) { int SWIG_arg = 0;
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ;
  SWIG_check_num_args("std::vector< std::string >::clear",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< std::string >::clear",1,"std::vector< std::string > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_std__string_t,0))){
    SWIG_fail_ptr("StringVector_clear",1,SWIGTYPE_p_std__vectorT_std__string_t); }  (arg1)->clear(); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_StringVector_push_back(lua_State* L) { int SWIG_arg = 0;
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ; std::string arg2 ;
  SWIG_check_num_args("std::vector< std::string >::push_back",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< std::string >::push_back",1,"std::vector< std::string > *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("std::vector< std::string >::push_back",2,"std::string");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_std__string_t,0))){
    SWIG_fail_ptr("StringVector_push_back",1,SWIGTYPE_p_std__vectorT_std__string_t); } 
  (&arg2)->assign(lua_tostring(L,2),lua_rawlen(L,2)); (arg1)->push_back(arg2); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_StringVector_pop_back(lua_State* L) { int SWIG_arg = 0;
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ;
  SWIG_check_num_args("std::vector< std::string >::pop_back",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< std::string >::pop_back",1,"std::vector< std::string > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_std__string_t,0))){
    SWIG_fail_ptr("StringVector_pop_back",1,SWIGTYPE_p_std__vectorT_std__string_t); }  (arg1)->pop_back(); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_StringVector_front(lua_State* L) { int SWIG_arg = 0;
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ; std::string result;
  SWIG_check_num_args("std::vector< std::string >::front",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< std::string >::front",1,"std::vector< std::string > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_std__string_t,0))){
    SWIG_fail_ptr("StringVector_front",1,SWIGTYPE_p_std__vectorT_std__string_t); } 
  result = ((std::vector< std::string > const *)arg1)->front();
  lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_StringVector_back(lua_State* L) { int SWIG_arg = 0;
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ; std::string result;
  SWIG_check_num_args("std::vector< std::string >::back",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< std::string >::back",1,"std::vector< std::string > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_std__string_t,0))){
    SWIG_fail_ptr("StringVector_back",1,SWIGTYPE_p_std__vectorT_std__string_t); } 
  result = ((std::vector< std::string > const *)arg1)->back();
  lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_StringVector___getitem(lua_State* L) { int SWIG_arg = 0;
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ; unsigned int arg2 ; std::string result;
  SWIG_check_num_args("std::vector< std::string >::__getitem__",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< std::string >::__getitem__",1,"std::vector< std::string > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("std::vector< std::string >::__getitem__",2,"unsigned int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_std__string_t,0))){
    SWIG_fail_ptr("StringVector___getitem",1,SWIGTYPE_p_std__vectorT_std__string_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (unsigned int)lua_tonumber(L, 2); try {
    result = std_vector_Sl_std_string_Sg____getitem__(arg1,arg2);}  catch(std::out_of_range &_e) {
    SWIG_exception(SWIG_IndexError, (&_e)->what()); }  lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_StringVector___setitem(lua_State* L) { int SWIG_arg = 0;
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ; unsigned int arg2 ; std::string arg3 ;
  SWIG_check_num_args("std::vector< std::string >::__setitem__",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< std::string >::__setitem__",1,"std::vector< std::string > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("std::vector< std::string >::__setitem__",2,"unsigned int");
  if(!lua_isstring(L,3)) SWIG_fail_arg("std::vector< std::string >::__setitem__",3,"std::string");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_std__string_t,0))){
    SWIG_fail_ptr("StringVector___setitem",1,SWIGTYPE_p_std__vectorT_std__string_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (unsigned int)lua_tonumber(L, 2);
  (&arg3)->assign(lua_tostring(L,3),lua_rawlen(L,3)); try { std_vector_Sl_std_string_Sg____setitem__(arg1,arg2,arg3);} 
  catch(std::out_of_range &_e) { SWIG_exception(SWIG_IndexError, (&_e)->what()); }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static void swig_delete_StringVector(void *obj) {
std::vector< std::string > *arg1 = (std::vector< std::string > *) obj;
delete arg1;
}
static int _proxy__wrap_new_StringVector(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_StringVector);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_StringVector_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_StringVector_methods[]= {
    { "size", _wrap_StringVector_size},
    { "max_size", _wrap_StringVector_max_size},
    { "empty", _wrap_StringVector_empty},
    { "clear", _wrap_StringVector_clear},
    { "push_back", _wrap_StringVector_push_back},
    { "pop_back", _wrap_StringVector_pop_back},
    { "front", _wrap_StringVector_front},
    { "back", _wrap_StringVector_back},
    { "__getitem", _wrap_StringVector___getitem},
    { "__setitem", _wrap_StringVector___setitem},
    {0,0}
};
static swig_lua_method swig_StringVector_meta[] = {
    { "__getitem", _wrap_StringVector___getitem},
    { "__setitem", _wrap_StringVector___setitem},
    {0,0}
};

static swig_lua_attribute swig_StringVector_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_StringVector_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_StringVector_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_StringVector_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_StringVector_Sf_SwigStatic = {
    "StringVector",
    swig_StringVector_Sf_SwigStatic_methods,
    swig_StringVector_Sf_SwigStatic_attributes,
    swig_StringVector_Sf_SwigStatic_constants,
    swig_StringVector_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_StringVector_bases[] = {0};
static const char *swig_StringVector_base_names[] = {0};
static swig_lua_class _wrap_class_StringVector = { "StringVector", "StringVector", &SWIGTYPE_p_std__vectorT_std__string_t,_proxy__wrap_new_StringVector, swig_delete_StringVector, swig_StringVector_methods, swig_StringVector_attributes, &swig_StringVector_Sf_SwigStatic, swig_StringVector_meta, swig_StringVector_bases, swig_StringVector_base_names };

static int _wrap_new_UCharVector__SWIG_0(lua_State* L) { int SWIG_arg = 0; std::vector< unsigned char > *result = 0 ;
  SWIG_check_num_args("std::vector< unsigned char >::vector",0,0)
  result = (std::vector< unsigned char > *)new std::vector< unsigned char >();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorT_unsigned_char_t,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_UCharVector__SWIG_1(lua_State* L) { int SWIG_arg = 0; unsigned int arg1 ;
  std::vector< unsigned char > *result = 0 ; SWIG_check_num_args("std::vector< unsigned char >::vector",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("std::vector< unsigned char >::vector",1,"unsigned int");
  SWIG_contract_assert((lua_tonumber(L,1)>=0),"number must not be negative") arg1 = (unsigned int)lua_tonumber(L, 1);
  result = (std::vector< unsigned char > *)new std::vector< unsigned char >(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorT_unsigned_char_t,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_UCharVector__SWIG_2(lua_State* L) { int SWIG_arg = 0; std::vector< unsigned char > *arg1 = 0 ;
  std::vector< unsigned char > *result = 0 ; SWIG_check_num_args("std::vector< unsigned char >::vector",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("std::vector< unsigned char >::vector",1,"std::vector< unsigned char > const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_unsigned_char_t,0))){
    SWIG_fail_ptr("new_UCharVector",1,SWIGTYPE_p_std__vectorT_unsigned_char_t); } 
  result = (std::vector< unsigned char > *)new std::vector< unsigned char >((std::vector< unsigned char > const &)*arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorT_unsigned_char_t,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_UCharVector__SWIG_3(lua_State* L) { int SWIG_arg = 0; unsigned int arg1 ; unsigned char arg2 ;
  std::vector< unsigned char > *result = 0 ; SWIG_check_num_args("std::vector< unsigned char >::vector",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("std::vector< unsigned char >::vector",1,"unsigned int");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("std::vector< unsigned char >::vector",2,"unsigned char");
  SWIG_contract_assert((lua_tonumber(L,1)>=0),"number must not be negative") arg1 = (unsigned int)lua_tonumber(L, 1);
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (unsigned char)lua_tonumber(L, 2);
  result = (std::vector< unsigned char > *)new std::vector< unsigned char >(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorT_unsigned_char_t,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_UCharVector(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 0) {
    return _wrap_new_UCharVector__SWIG_0(L);}  if (argc == 1) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_std__vectorT_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_new_UCharVector__SWIG_2(L);}  }  if (argc == 1) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { return _wrap_new_UCharVector__SWIG_1(L);}  }  if (argc == 2) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_new_UCharVector__SWIG_3(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_UCharVector'\n" "  Possible C/C++ prototypes are:\n"
  "    std::vector< unsigned char >::vector()\n" "    std::vector< unsigned char >::vector(unsigned int)\n"
  "    std::vector< unsigned char >::vector(std::vector< unsigned char > const &)\n"
  "    std::vector< unsigned char >::vector(unsigned int,unsigned char)\n"); lua_error(L);return 0; }
static int _wrap_UCharVector_size(lua_State* L) { int SWIG_arg = 0;
  std::vector< unsigned char > *arg1 = (std::vector< unsigned char > *) 0 ; unsigned int result;
  SWIG_check_num_args("std::vector< unsigned char >::size",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< unsigned char >::size",1,"std::vector< unsigned char > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_unsigned_char_t,0))){
    SWIG_fail_ptr("UCharVector_size",1,SWIGTYPE_p_std__vectorT_unsigned_char_t); } 
  result = (unsigned int)((std::vector< unsigned char > const *)arg1)->size();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_UCharVector_max_size(lua_State* L) { int SWIG_arg = 0;
  std::vector< unsigned char > *arg1 = (std::vector< unsigned char > *) 0 ; unsigned int result;
  SWIG_check_num_args("std::vector< unsigned char >::max_size",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< unsigned char >::max_size",1,"std::vector< unsigned char > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_unsigned_char_t,0))){
    SWIG_fail_ptr("UCharVector_max_size",1,SWIGTYPE_p_std__vectorT_unsigned_char_t); } 
  result = (unsigned int)((std::vector< unsigned char > const *)arg1)->max_size();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_UCharVector_empty(lua_State* L) { int SWIG_arg = 0;
  std::vector< unsigned char > *arg1 = (std::vector< unsigned char > *) 0 ; bool result;
  SWIG_check_num_args("std::vector< unsigned char >::empty",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< unsigned char >::empty",1,"std::vector< unsigned char > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_unsigned_char_t,0))){
    SWIG_fail_ptr("UCharVector_empty",1,SWIGTYPE_p_std__vectorT_unsigned_char_t); } 
  result = (bool)((std::vector< unsigned char > const *)arg1)->empty(); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_UCharVector_clear(lua_State* L) { int SWIG_arg = 0;
  std::vector< unsigned char > *arg1 = (std::vector< unsigned char > *) 0 ;
  SWIG_check_num_args("std::vector< unsigned char >::clear",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< unsigned char >::clear",1,"std::vector< unsigned char > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_unsigned_char_t,0))){
    SWIG_fail_ptr("UCharVector_clear",1,SWIGTYPE_p_std__vectorT_unsigned_char_t); }  (arg1)->clear(); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_UCharVector_push_back(lua_State* L) { int SWIG_arg = 0;
  std::vector< unsigned char > *arg1 = (std::vector< unsigned char > *) 0 ; unsigned char arg2 ;
  SWIG_check_num_args("std::vector< unsigned char >::push_back",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< unsigned char >::push_back",1,"std::vector< unsigned char > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("std::vector< unsigned char >::push_back",2,"unsigned char");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_unsigned_char_t,0))){
    SWIG_fail_ptr("UCharVector_push_back",1,SWIGTYPE_p_std__vectorT_unsigned_char_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (unsigned char)lua_tonumber(L, 2);
  (arg1)->push_back(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_UCharVector_pop_back(lua_State* L) { int SWIG_arg = 0;
  std::vector< unsigned char > *arg1 = (std::vector< unsigned char > *) 0 ;
  SWIG_check_num_args("std::vector< unsigned char >::pop_back",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< unsigned char >::pop_back",1,"std::vector< unsigned char > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_unsigned_char_t,0))){
    SWIG_fail_ptr("UCharVector_pop_back",1,SWIGTYPE_p_std__vectorT_unsigned_char_t); }  (arg1)->pop_back(); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_UCharVector_front(lua_State* L) { int SWIG_arg = 0;
  std::vector< unsigned char > *arg1 = (std::vector< unsigned char > *) 0 ; unsigned char result;
  SWIG_check_num_args("std::vector< unsigned char >::front",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< unsigned char >::front",1,"std::vector< unsigned char > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_unsigned_char_t,0))){
    SWIG_fail_ptr("UCharVector_front",1,SWIGTYPE_p_std__vectorT_unsigned_char_t); } 
  result = (unsigned char)((std::vector< unsigned char > const *)arg1)->front();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_UCharVector_back(lua_State* L) { int SWIG_arg = 0;
  std::vector< unsigned char > *arg1 = (std::vector< unsigned char > *) 0 ; unsigned char result;
  SWIG_check_num_args("std::vector< unsigned char >::back",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< unsigned char >::back",1,"std::vector< unsigned char > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_unsigned_char_t,0))){
    SWIG_fail_ptr("UCharVector_back",1,SWIGTYPE_p_std__vectorT_unsigned_char_t); } 
  result = (unsigned char)((std::vector< unsigned char > const *)arg1)->back();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_UCharVector___getitem(lua_State* L) { int SWIG_arg = 0;
  std::vector< unsigned char > *arg1 = (std::vector< unsigned char > *) 0 ; unsigned int arg2 ; unsigned char result;
  SWIG_check_num_args("std::vector< unsigned char >::__getitem__",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< unsigned char >::__getitem__",1,"std::vector< unsigned char > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("std::vector< unsigned char >::__getitem__",2,"unsigned int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_unsigned_char_t,0))){
    SWIG_fail_ptr("UCharVector___getitem",1,SWIGTYPE_p_std__vectorT_unsigned_char_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (unsigned int)lua_tonumber(L, 2); try {
    result = (unsigned char)std_vector_Sl_unsigned_SS_char_Sg____getitem__(arg1,arg2);}  catch(std::out_of_range &_e) {
    SWIG_exception(SWIG_IndexError, (&_e)->what()); }  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_UCharVector___setitem(lua_State* L) { int SWIG_arg = 0;
  std::vector< unsigned char > *arg1 = (std::vector< unsigned char > *) 0 ; unsigned int arg2 ; unsigned char arg3 ;
  SWIG_check_num_args("std::vector< unsigned char >::__setitem__",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< unsigned char >::__setitem__",1,"std::vector< unsigned char > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("std::vector< unsigned char >::__setitem__",2,"unsigned int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("std::vector< unsigned char >::__setitem__",3,"unsigned char");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_unsigned_char_t,0))){
    SWIG_fail_ptr("UCharVector___setitem",1,SWIGTYPE_p_std__vectorT_unsigned_char_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (unsigned int)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (unsigned char)lua_tonumber(L, 3); try {
    std_vector_Sl_unsigned_SS_char_Sg____setitem__(arg1,arg2,arg3);}  catch(std::out_of_range &_e) {
    SWIG_exception(SWIG_IndexError, (&_e)->what()); }  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static void swig_delete_UCharVector(void *obj) {
std::vector< unsigned char > *arg1 = (std::vector< unsigned char > *) obj;
delete arg1;
}
static int _proxy__wrap_new_UCharVector(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_UCharVector);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_UCharVector_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_UCharVector_methods[]= {
    { "size", _wrap_UCharVector_size},
    { "max_size", _wrap_UCharVector_max_size},
    { "empty", _wrap_UCharVector_empty},
    { "clear", _wrap_UCharVector_clear},
    { "push_back", _wrap_UCharVector_push_back},
    { "pop_back", _wrap_UCharVector_pop_back},
    { "front", _wrap_UCharVector_front},
    { "back", _wrap_UCharVector_back},
    { "__getitem", _wrap_UCharVector___getitem},
    { "__setitem", _wrap_UCharVector___setitem},
    {0,0}
};
static swig_lua_method swig_UCharVector_meta[] = {
    { "__getitem", _wrap_UCharVector___getitem},
    { "__setitem", _wrap_UCharVector___setitem},
    {0,0}
};

static swig_lua_attribute swig_UCharVector_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_UCharVector_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_UCharVector_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_UCharVector_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_UCharVector_Sf_SwigStatic = {
    "UCharVector",
    swig_UCharVector_Sf_SwigStatic_methods,
    swig_UCharVector_Sf_SwigStatic_attributes,
    swig_UCharVector_Sf_SwigStatic_constants,
    swig_UCharVector_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_UCharVector_bases[] = {0};
static const char *swig_UCharVector_base_names[] = {0};
static swig_lua_class _wrap_class_UCharVector = { "UCharVector", "UCharVector", &SWIGTYPE_p_std__vectorT_unsigned_char_t,_proxy__wrap_new_UCharVector, swig_delete_UCharVector, swig_UCharVector_methods, swig_UCharVector_attributes, &swig_UCharVector_Sf_SwigStatic, swig_UCharVector_meta, swig_UCharVector_bases, swig_UCharVector_base_names };

static int _wrap_new_VideoDeviceVector__SWIG_0(lua_State* L) { int SWIG_arg = 0; std::vector< ofVideoDevice > *result = 0 ;
  SWIG_check_num_args("std::vector< ofVideoDevice >::vector",0,0)
  result = (std::vector< ofVideoDevice > *)new std::vector< ofVideoDevice >();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorT_ofVideoDevice_t,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_VideoDeviceVector__SWIG_1(lua_State* L) { int SWIG_arg = 0; unsigned int arg1 ;
  std::vector< ofVideoDevice > *result = 0 ; SWIG_check_num_args("std::vector< ofVideoDevice >::vector",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("std::vector< ofVideoDevice >::vector",1,"unsigned int");
  SWIG_contract_assert((lua_tonumber(L,1)>=0),"number must not be negative") arg1 = (unsigned int)lua_tonumber(L, 1);
  result = (std::vector< ofVideoDevice > *)new std::vector< ofVideoDevice >(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorT_ofVideoDevice_t,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_VideoDeviceVector__SWIG_2(lua_State* L) { int SWIG_arg = 0; std::vector< ofVideoDevice > *arg1 = 0 ;
  std::vector< ofVideoDevice > *result = 0 ; SWIG_check_num_args("std::vector< ofVideoDevice >::vector",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("std::vector< ofVideoDevice >::vector",1,"std::vector< ofVideoDevice > const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_ofVideoDevice_t,0))){
    SWIG_fail_ptr("new_VideoDeviceVector",1,SWIGTYPE_p_std__vectorT_ofVideoDevice_t); } 
  result = (std::vector< ofVideoDevice > *)new std::vector< ofVideoDevice >((std::vector< ofVideoDevice > const &)*arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorT_ofVideoDevice_t,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_VideoDeviceVector__SWIG_3(lua_State* L) { int SWIG_arg = 0; unsigned int arg1 ; ofVideoDevice arg2 ;
  ofVideoDevice *argp2 ; std::vector< ofVideoDevice > *result = 0 ;
  SWIG_check_num_args("std::vector< ofVideoDevice >::vector",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("std::vector< ofVideoDevice >::vector",1,"unsigned int");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("std::vector< ofVideoDevice >::vector",2,"ofVideoDevice");
  SWIG_contract_assert((lua_tonumber(L,1)>=0),"number must not be negative") arg1 = (unsigned int)lua_tonumber(L, 1);
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_ofVideoDevice,0))){
    SWIG_fail_ptr("new_VideoDeviceVector",2,SWIGTYPE_p_ofVideoDevice); }  arg2 = *argp2;
  result = (std::vector< ofVideoDevice > *)new std::vector< ofVideoDevice >(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorT_ofVideoDevice_t,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_VideoDeviceVector(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 0) {
    return _wrap_new_VideoDeviceVector__SWIG_0(L);}  if (argc == 1) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_std__vectorT_ofVideoDevice_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_new_VideoDeviceVector__SWIG_2(L);}  }  if (argc == 1) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { return _wrap_new_VideoDeviceVector__SWIG_1(L);}  }  if (argc == 2) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofVideoDevice, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_new_VideoDeviceVector__SWIG_3(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_VideoDeviceVector'\n"
  "  Possible C/C++ prototypes are:\n" "    std::vector< ofVideoDevice >::vector()\n"
  "    std::vector< ofVideoDevice >::vector(unsigned int)\n"
  "    std::vector< ofVideoDevice >::vector(std::vector< ofVideoDevice > const &)\n"
  "    std::vector< ofVideoDevice >::vector(unsigned int,ofVideoDevice)\n"); lua_error(L);return 0; }
static int _wrap_VideoDeviceVector_size(lua_State* L) { int SWIG_arg = 0;
  std::vector< ofVideoDevice > *arg1 = (std::vector< ofVideoDevice > *) 0 ; unsigned int result;
  SWIG_check_num_args("std::vector< ofVideoDevice >::size",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< ofVideoDevice >::size",1,"std::vector< ofVideoDevice > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_ofVideoDevice_t,0))){
    SWIG_fail_ptr("VideoDeviceVector_size",1,SWIGTYPE_p_std__vectorT_ofVideoDevice_t); } 
  result = (unsigned int)((std::vector< ofVideoDevice > const *)arg1)->size();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_VideoDeviceVector_max_size(lua_State* L) { int SWIG_arg = 0;
  std::vector< ofVideoDevice > *arg1 = (std::vector< ofVideoDevice > *) 0 ; unsigned int result;
  SWIG_check_num_args("std::vector< ofVideoDevice >::max_size",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< ofVideoDevice >::max_size",1,"std::vector< ofVideoDevice > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_ofVideoDevice_t,0))){
    SWIG_fail_ptr("VideoDeviceVector_max_size",1,SWIGTYPE_p_std__vectorT_ofVideoDevice_t); } 
  result = (unsigned int)((std::vector< ofVideoDevice > const *)arg1)->max_size();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_VideoDeviceVector_empty(lua_State* L) { int SWIG_arg = 0;
  std::vector< ofVideoDevice > *arg1 = (std::vector< ofVideoDevice > *) 0 ; bool result;
  SWIG_check_num_args("std::vector< ofVideoDevice >::empty",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< ofVideoDevice >::empty",1,"std::vector< ofVideoDevice > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_ofVideoDevice_t,0))){
    SWIG_fail_ptr("VideoDeviceVector_empty",1,SWIGTYPE_p_std__vectorT_ofVideoDevice_t); } 
  result = (bool)((std::vector< ofVideoDevice > const *)arg1)->empty(); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_VideoDeviceVector_clear(lua_State* L) { int SWIG_arg = 0;
  std::vector< ofVideoDevice > *arg1 = (std::vector< ofVideoDevice > *) 0 ;
  SWIG_check_num_args("std::vector< ofVideoDevice >::clear",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< ofVideoDevice >::clear",1,"std::vector< ofVideoDevice > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_ofVideoDevice_t,0))){
    SWIG_fail_ptr("VideoDeviceVector_clear",1,SWIGTYPE_p_std__vectorT_ofVideoDevice_t); }  (arg1)->clear(); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_VideoDeviceVector_push_back(lua_State* L) { int SWIG_arg = 0;
  std::vector< ofVideoDevice > *arg1 = (std::vector< ofVideoDevice > *) 0 ; ofVideoDevice arg2 ; ofVideoDevice *argp2 ;
  SWIG_check_num_args("std::vector< ofVideoDevice >::push_back",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< ofVideoDevice >::push_back",1,"std::vector< ofVideoDevice > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("std::vector< ofVideoDevice >::push_back",2,"ofVideoDevice");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_ofVideoDevice_t,0))){
    SWIG_fail_ptr("VideoDeviceVector_push_back",1,SWIGTYPE_p_std__vectorT_ofVideoDevice_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_ofVideoDevice,0))){
    SWIG_fail_ptr("VideoDeviceVector_push_back",2,SWIGTYPE_p_ofVideoDevice); }  arg2 = *argp2; (arg1)->push_back(arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_VideoDeviceVector_pop_back(lua_State* L) { int SWIG_arg = 0;
  std::vector< ofVideoDevice > *arg1 = (std::vector< ofVideoDevice > *) 0 ;
  SWIG_check_num_args("std::vector< ofVideoDevice >::pop_back",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< ofVideoDevice >::pop_back",1,"std::vector< ofVideoDevice > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_ofVideoDevice_t,0))){
    SWIG_fail_ptr("VideoDeviceVector_pop_back",1,SWIGTYPE_p_std__vectorT_ofVideoDevice_t); }  (arg1)->pop_back();
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_VideoDeviceVector_front(lua_State* L) { int SWIG_arg = 0;
  std::vector< ofVideoDevice > *arg1 = (std::vector< ofVideoDevice > *) 0 ; ofVideoDevice result;
  SWIG_check_num_args("std::vector< ofVideoDevice >::front",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< ofVideoDevice >::front",1,"std::vector< ofVideoDevice > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_ofVideoDevice_t,0))){
    SWIG_fail_ptr("VideoDeviceVector_front",1,SWIGTYPE_p_std__vectorT_ofVideoDevice_t); } 
  result = ((std::vector< ofVideoDevice > const *)arg1)->front(); {
    ofVideoDevice * resultptr = new ofVideoDevice((const ofVideoDevice &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVideoDevice,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_VideoDeviceVector_back(lua_State* L) { int SWIG_arg = 0;
  std::vector< ofVideoDevice > *arg1 = (std::vector< ofVideoDevice > *) 0 ; ofVideoDevice result;
  SWIG_check_num_args("std::vector< ofVideoDevice >::back",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< ofVideoDevice >::back",1,"std::vector< ofVideoDevice > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_ofVideoDevice_t,0))){
    SWIG_fail_ptr("VideoDeviceVector_back",1,SWIGTYPE_p_std__vectorT_ofVideoDevice_t); } 
  result = ((std::vector< ofVideoDevice > const *)arg1)->back(); {
    ofVideoDevice * resultptr = new ofVideoDevice((const ofVideoDevice &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVideoDevice,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_VideoDeviceVector___getitem(lua_State* L) { int SWIG_arg = 0;
  std::vector< ofVideoDevice > *arg1 = (std::vector< ofVideoDevice > *) 0 ; unsigned int arg2 ; ofVideoDevice result;
  SWIG_check_num_args("std::vector< ofVideoDevice >::__getitem__",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< ofVideoDevice >::__getitem__",1,"std::vector< ofVideoDevice > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("std::vector< ofVideoDevice >::__getitem__",2,"unsigned int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_ofVideoDevice_t,0))){
    SWIG_fail_ptr("VideoDeviceVector___getitem",1,SWIGTYPE_p_std__vectorT_ofVideoDevice_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (unsigned int)lua_tonumber(L, 2); try {
    result = std_vector_Sl_ofVideoDevice_Sg____getitem__(arg1,arg2);}  catch(std::out_of_range &_e) {
    SWIG_exception(SWIG_IndexError, (&_e)->what()); }  {
    ofVideoDevice * resultptr = new ofVideoDevice((const ofVideoDevice &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVideoDevice,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_VideoDeviceVector___setitem(lua_State* L) { int SWIG_arg = 0;
  std::vector< ofVideoDevice > *arg1 = (std::vector< ofVideoDevice > *) 0 ; unsigned int arg2 ; ofVideoDevice arg3 ;
  ofVideoDevice *argp3 ; SWIG_check_num_args("std::vector< ofVideoDevice >::__setitem__",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< ofVideoDevice >::__setitem__",1,"std::vector< ofVideoDevice > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("std::vector< ofVideoDevice >::__setitem__",2,"unsigned int");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("std::vector< ofVideoDevice >::__setitem__",3,"ofVideoDevice");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_ofVideoDevice_t,0))){
    SWIG_fail_ptr("VideoDeviceVector___setitem",1,SWIGTYPE_p_std__vectorT_ofVideoDevice_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (unsigned int)lua_tonumber(L, 2);
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_ofVideoDevice,0))){
    SWIG_fail_ptr("VideoDeviceVector___setitem",3,SWIGTYPE_p_ofVideoDevice); }  arg3 = *argp3; try {
    std_vector_Sl_ofVideoDevice_Sg____setitem__(arg1,arg2,arg3);}  catch(std::out_of_range &_e) {
    SWIG_exception(SWIG_IndexError, (&_e)->what()); }  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static void swig_delete_VideoDeviceVector(void *obj) {
std::vector< ofVideoDevice > *arg1 = (std::vector< ofVideoDevice > *) obj;
delete arg1;
}
static int _proxy__wrap_new_VideoDeviceVector(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_VideoDeviceVector);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_VideoDeviceVector_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_VideoDeviceVector_methods[]= {
    { "size", _wrap_VideoDeviceVector_size},
    { "max_size", _wrap_VideoDeviceVector_max_size},
    { "empty", _wrap_VideoDeviceVector_empty},
    { "clear", _wrap_VideoDeviceVector_clear},
    { "push_back", _wrap_VideoDeviceVector_push_back},
    { "pop_back", _wrap_VideoDeviceVector_pop_back},
    { "front", _wrap_VideoDeviceVector_front},
    { "back", _wrap_VideoDeviceVector_back},
    { "__getitem", _wrap_VideoDeviceVector___getitem},
    { "__setitem", _wrap_VideoDeviceVector___setitem},
    {0,0}
};
static swig_lua_method swig_VideoDeviceVector_meta[] = {
    { "__getitem", _wrap_VideoDeviceVector___getitem},
    { "__setitem", _wrap_VideoDeviceVector___setitem},
    {0,0}
};

static swig_lua_attribute swig_VideoDeviceVector_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_VideoDeviceVector_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_VideoDeviceVector_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_VideoDeviceVector_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_VideoDeviceVector_Sf_SwigStatic = {
    "VideoDeviceVector",
    swig_VideoDeviceVector_Sf_SwigStatic_methods,
    swig_VideoDeviceVector_Sf_SwigStatic_attributes,
    swig_VideoDeviceVector_Sf_SwigStatic_constants,
    swig_VideoDeviceVector_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_VideoDeviceVector_bases[] = {0};
static const char *swig_VideoDeviceVector_base_names[] = {0};
static swig_lua_class _wrap_class_VideoDeviceVector = { "VideoDeviceVector", "VideoDeviceVector", &SWIGTYPE_p_std__vectorT_ofVideoDevice_t,_proxy__wrap_new_VideoDeviceVector, swig_delete_VideoDeviceVector, swig_VideoDeviceVector_methods, swig_VideoDeviceVector_attributes, &swig_VideoDeviceVector_Sf_SwigStatic, swig_VideoDeviceVector_meta, swig_VideoDeviceVector_bases, swig_VideoDeviceVector_base_names };

static int _wrap_new_TextureVector__SWIG_0(lua_State* L) { int SWIG_arg = 0; std::vector< ofTexture > *result = 0 ;
  SWIG_check_num_args("std::vector< ofTexture >::vector",0,0)
  result = (std::vector< ofTexture > *)new std::vector< ofTexture >();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorT_ofTexture_t,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_TextureVector__SWIG_1(lua_State* L) { int SWIG_arg = 0; unsigned int arg1 ;
  std::vector< ofTexture > *result = 0 ; SWIG_check_num_args("std::vector< ofTexture >::vector",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("std::vector< ofTexture >::vector",1,"unsigned int");
  SWIG_contract_assert((lua_tonumber(L,1)>=0),"number must not be negative") arg1 = (unsigned int)lua_tonumber(L, 1);
  result = (std::vector< ofTexture > *)new std::vector< ofTexture >(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorT_ofTexture_t,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_TextureVector__SWIG_2(lua_State* L) { int SWIG_arg = 0; std::vector< ofTexture > *arg1 = 0 ;
  std::vector< ofTexture > *result = 0 ; SWIG_check_num_args("std::vector< ofTexture >::vector",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("std::vector< ofTexture >::vector",1,"std::vector< ofTexture > const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_ofTexture_t,0))){
    SWIG_fail_ptr("new_TextureVector",1,SWIGTYPE_p_std__vectorT_ofTexture_t); } 
  result = (std::vector< ofTexture > *)new std::vector< ofTexture >((std::vector< ofTexture > const &)*arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorT_ofTexture_t,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_TextureVector__SWIG_3(lua_State* L) { int SWIG_arg = 0; unsigned int arg1 ; ofTexture arg2 ;
  ofTexture *argp2 ; std::vector< ofTexture > *result = 0 ; SWIG_check_num_args("std::vector< ofTexture >::vector",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("std::vector< ofTexture >::vector",1,"unsigned int");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("std::vector< ofTexture >::vector",2,"ofTexture");
  SWIG_contract_assert((lua_tonumber(L,1)>=0),"number must not be negative") arg1 = (unsigned int)lua_tonumber(L, 1);
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("new_TextureVector",2,SWIGTYPE_p_ofTexture); }  arg2 = *argp2;
  result = (std::vector< ofTexture > *)new std::vector< ofTexture >(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorT_ofTexture_t,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_TextureVector(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 0) {
    return _wrap_new_TextureVector__SWIG_0(L);}  if (argc == 1) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_std__vectorT_ofTexture_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_new_TextureVector__SWIG_2(L);}  }  if (argc == 1) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { return _wrap_new_TextureVector__SWIG_1(L);}  }  if (argc == 2) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofTexture, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_new_TextureVector__SWIG_3(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_TextureVector'\n" "  Possible C/C++ prototypes are:\n"
  "    std::vector< ofTexture >::vector()\n" "    std::vector< ofTexture >::vector(unsigned int)\n"
  "    std::vector< ofTexture >::vector(std::vector< ofTexture > const &)\n"
  "    std::vector< ofTexture >::vector(unsigned int,ofTexture)\n"); lua_error(L);return 0; }
static int _wrap_TextureVector_size(lua_State* L) { int SWIG_arg = 0;
  std::vector< ofTexture > *arg1 = (std::vector< ofTexture > *) 0 ; unsigned int result;
  SWIG_check_num_args("std::vector< ofTexture >::size",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< ofTexture >::size",1,"std::vector< ofTexture > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_ofTexture_t,0))){
    SWIG_fail_ptr("TextureVector_size",1,SWIGTYPE_p_std__vectorT_ofTexture_t); } 
  result = (unsigned int)((std::vector< ofTexture > const *)arg1)->size(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TextureVector_max_size(lua_State* L) { int SWIG_arg = 0;
  std::vector< ofTexture > *arg1 = (std::vector< ofTexture > *) 0 ; unsigned int result;
  SWIG_check_num_args("std::vector< ofTexture >::max_size",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< ofTexture >::max_size",1,"std::vector< ofTexture > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_ofTexture_t,0))){
    SWIG_fail_ptr("TextureVector_max_size",1,SWIGTYPE_p_std__vectorT_ofTexture_t); } 
  result = (unsigned int)((std::vector< ofTexture > const *)arg1)->max_size();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TextureVector_empty(lua_State* L) { int SWIG_arg = 0;
  std::vector< ofTexture > *arg1 = (std::vector< ofTexture > *) 0 ; bool result;
  SWIG_check_num_args("std::vector< ofTexture >::empty",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< ofTexture >::empty",1,"std::vector< ofTexture > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_ofTexture_t,0))){
    SWIG_fail_ptr("TextureVector_empty",1,SWIGTYPE_p_std__vectorT_ofTexture_t); } 
  result = (bool)((std::vector< ofTexture > const *)arg1)->empty(); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TextureVector_clear(lua_State* L) { int SWIG_arg = 0;
  std::vector< ofTexture > *arg1 = (std::vector< ofTexture > *) 0 ; SWIG_check_num_args("std::vector< ofTexture >::clear",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< ofTexture >::clear",1,"std::vector< ofTexture > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_ofTexture_t,0))){
    SWIG_fail_ptr("TextureVector_clear",1,SWIGTYPE_p_std__vectorT_ofTexture_t); }  (arg1)->clear(); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TextureVector_push_back(lua_State* L) { int SWIG_arg = 0;
  std::vector< ofTexture > *arg1 = (std::vector< ofTexture > *) 0 ; ofTexture arg2 ; ofTexture *argp2 ;
  SWIG_check_num_args("std::vector< ofTexture >::push_back",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< ofTexture >::push_back",1,"std::vector< ofTexture > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("std::vector< ofTexture >::push_back",2,"ofTexture");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_ofTexture_t,0))){
    SWIG_fail_ptr("TextureVector_push_back",1,SWIGTYPE_p_std__vectorT_ofTexture_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("TextureVector_push_back",2,SWIGTYPE_p_ofTexture); }  arg2 = *argp2; (arg1)->push_back(arg2); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TextureVector_pop_back(lua_State* L) { int SWIG_arg = 0;
  std::vector< ofTexture > *arg1 = (std::vector< ofTexture > *) 0 ;
  SWIG_check_num_args("std::vector< ofTexture >::pop_back",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< ofTexture >::pop_back",1,"std::vector< ofTexture > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_ofTexture_t,0))){
    SWIG_fail_ptr("TextureVector_pop_back",1,SWIGTYPE_p_std__vectorT_ofTexture_t); }  (arg1)->pop_back(); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TextureVector_front(lua_State* L) { int SWIG_arg = 0;
  std::vector< ofTexture > *arg1 = (std::vector< ofTexture > *) 0 ; ofTexture result;
  SWIG_check_num_args("std::vector< ofTexture >::front",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< ofTexture >::front",1,"std::vector< ofTexture > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_ofTexture_t,0))){
    SWIG_fail_ptr("TextureVector_front",1,SWIGTYPE_p_std__vectorT_ofTexture_t); } 
  result = ((std::vector< ofTexture > const *)arg1)->front(); {
    ofTexture * resultptr = new ofTexture((const ofTexture &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofTexture,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_TextureVector_back(lua_State* L) { int SWIG_arg = 0;
  std::vector< ofTexture > *arg1 = (std::vector< ofTexture > *) 0 ; ofTexture result;
  SWIG_check_num_args("std::vector< ofTexture >::back",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< ofTexture >::back",1,"std::vector< ofTexture > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_ofTexture_t,0))){
    SWIG_fail_ptr("TextureVector_back",1,SWIGTYPE_p_std__vectorT_ofTexture_t); } 
  result = ((std::vector< ofTexture > const *)arg1)->back(); {
    ofTexture * resultptr = new ofTexture((const ofTexture &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofTexture,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_TextureVector___getitem(lua_State* L) { int SWIG_arg = 0;
  std::vector< ofTexture > *arg1 = (std::vector< ofTexture > *) 0 ; unsigned int arg2 ; ofTexture result;
  SWIG_check_num_args("std::vector< ofTexture >::__getitem__",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< ofTexture >::__getitem__",1,"std::vector< ofTexture > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("std::vector< ofTexture >::__getitem__",2,"unsigned int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_ofTexture_t,0))){
    SWIG_fail_ptr("TextureVector___getitem",1,SWIGTYPE_p_std__vectorT_ofTexture_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (unsigned int)lua_tonumber(L, 2); try {
    result = std_vector_Sl_ofTexture_Sg____getitem__(arg1,arg2);}  catch(std::out_of_range &_e) {
    SWIG_exception(SWIG_IndexError, (&_e)->what()); }  { ofTexture * resultptr = new ofTexture((const ofTexture &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofTexture,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_TextureVector___setitem(lua_State* L) { int SWIG_arg = 0;
  std::vector< ofTexture > *arg1 = (std::vector< ofTexture > *) 0 ; unsigned int arg2 ; ofTexture arg3 ; ofTexture *argp3 ;
  SWIG_check_num_args("std::vector< ofTexture >::__setitem__",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< ofTexture >::__setitem__",1,"std::vector< ofTexture > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("std::vector< ofTexture >::__setitem__",2,"unsigned int");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("std::vector< ofTexture >::__setitem__",3,"ofTexture");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_ofTexture_t,0))){
    SWIG_fail_ptr("TextureVector___setitem",1,SWIGTYPE_p_std__vectorT_ofTexture_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (unsigned int)lua_tonumber(L, 2);
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("TextureVector___setitem",3,SWIGTYPE_p_ofTexture); }  arg3 = *argp3; try {
    std_vector_Sl_ofTexture_Sg____setitem__(arg1,arg2,arg3);}  catch(std::out_of_range &_e) {
    SWIG_exception(SWIG_IndexError, (&_e)->what()); }  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static void swig_delete_TextureVector(void *obj) {
std::vector< ofTexture > *arg1 = (std::vector< ofTexture > *) obj;
delete arg1;
}
static int _proxy__wrap_new_TextureVector(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_TextureVector);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_TextureVector_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_TextureVector_methods[]= {
    { "size", _wrap_TextureVector_size},
    { "max_size", _wrap_TextureVector_max_size},
    { "empty", _wrap_TextureVector_empty},
    { "clear", _wrap_TextureVector_clear},
    { "push_back", _wrap_TextureVector_push_back},
    { "pop_back", _wrap_TextureVector_pop_back},
    { "front", _wrap_TextureVector_front},
    { "back", _wrap_TextureVector_back},
    { "__getitem", _wrap_TextureVector___getitem},
    { "__setitem", _wrap_TextureVector___setitem},
    {0,0}
};
static swig_lua_method swig_TextureVector_meta[] = {
    { "__getitem", _wrap_TextureVector___getitem},
    { "__setitem", _wrap_TextureVector___setitem},
    {0,0}
};

static swig_lua_attribute swig_TextureVector_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_TextureVector_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_TextureVector_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_TextureVector_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_TextureVector_Sf_SwigStatic = {
    "TextureVector",
    swig_TextureVector_Sf_SwigStatic_methods,
    swig_TextureVector_Sf_SwigStatic_attributes,
    swig_TextureVector_Sf_SwigStatic_constants,
    swig_TextureVector_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_TextureVector_bases[] = {0};
static const char *swig_TextureVector_base_names[] = {0};
static swig_lua_class _wrap_class_TextureVector = { "TextureVector", "TextureVector", &SWIGTYPE_p_std__vectorT_ofTexture_t,_proxy__wrap_new_TextureVector, swig_delete_TextureVector, swig_TextureVector_methods, swig_TextureVector_attributes, &swig_TextureVector_Sf_SwigStatic, swig_TextureVector_meta, swig_TextureVector_bases, swig_TextureVector_base_names };

static int _wrap_resetElapsedTimeCounter(lua_State* L) { int SWIG_arg = 0; SWIG_check_num_args("ofResetElapsedTimeCounter",0,0)
  ofResetElapsedTimeCounter(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_getElapsedTimef(lua_State* L) { int SWIG_arg = 0; float result; SWIG_check_num_args("ofGetElapsedTimef",0,0)
  result = (float)ofGetElapsedTimef(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_getElapsedTimeMillis(lua_State* L) { int SWIG_arg = 0; uint64_t result;
  SWIG_check_num_args("ofGetElapsedTimeMillis",0,0) result = (uint64_t)ofGetElapsedTimeMillis();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_getElapsedTimeMicros(lua_State* L) { int SWIG_arg = 0; uint64_t result;
  SWIG_check_num_args("ofGetElapsedTimeMicros",0,0) result = (uint64_t)ofGetElapsedTimeMicros();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_getFrameNum(lua_State* L) { int SWIG_arg = 0; uint64_t result; SWIG_check_num_args("ofGetFrameNum",0,0)
  result = (uint64_t)ofGetFrameNum(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_getSeconds(lua_State* L) { int SWIG_arg = 0; int result; SWIG_check_num_args("ofGetSeconds",0,0)
  result = (int)ofGetSeconds(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_getMinutes(lua_State* L) { int SWIG_arg = 0; int result; SWIG_check_num_args("ofGetMinutes",0,0)
  result = (int)ofGetMinutes(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_getHours(lua_State* L) { int SWIG_arg = 0; int result; SWIG_check_num_args("ofGetHours",0,0)
  result = (int)ofGetHours(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_getUnixTime(lua_State* L) { int SWIG_arg = 0; unsigned int result; SWIG_check_num_args("ofGetUnixTime",0,0)
  result = (unsigned int)ofGetUnixTime(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_getSystemTimeMillis(lua_State* L) { int SWIG_arg = 0; uint64_t result;
  SWIG_check_num_args("ofGetSystemTimeMillis",0,0) result = (uint64_t)ofGetSystemTimeMillis();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_getSystemTimeMicros(lua_State* L) { int SWIG_arg = 0; uint64_t result;
  SWIG_check_num_args("ofGetSystemTimeMicros",0,0) result = (uint64_t)ofGetSystemTimeMicros();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_getCurrentTime(lua_State* L) { int SWIG_arg = 0; ofTime result; SWIG_check_num_args("ofGetCurrentTime",0,0)
  result = ofGetCurrentTime(); { ofTime * resultptr = new ofTime((const ofTime &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofTime,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_sleepMillis(lua_State* L) { int SWIG_arg = 0; int arg1 ; SWIG_check_num_args("ofSleepMillis",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofSleepMillis",1,"int"); arg1 = (int)lua_tonumber(L, 1); ofSleepMillis(arg1);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_getTimestampString__SWIG_0(lua_State* L) { int SWIG_arg = 0; std::string result;
  SWIG_check_num_args("ofGetTimestampString",0,0) result = ofGetTimestampString();
  lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_getTimestampString__SWIG_1(lua_State* L) { int SWIG_arg = 0; std::string *arg1 = 0 ; std::string temp1 ;
  std::string result; SWIG_check_num_args("ofGetTimestampString",1,1)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofGetTimestampString",1,"std::string const &");
  temp1.assign(lua_tostring(L,1),lua_rawlen(L,1)); arg1=&temp1; result = ofGetTimestampString((std::string const &)*arg1);
  lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_getTimestampString(lua_State* L) { int argc; int argv[2]={ 1,2} ; argc = lua_gettop(L); if (argc == 0) {
    return _wrap_getTimestampString__SWIG_0(L);}  if (argc == 1) { int _v; { _v = lua_isstring(L,argv[0]); }  if (_v) {
      return _wrap_getTimestampString__SWIG_1(L);}  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'getTimestampString'\n" "  Possible C/C++ prototypes are:\n"
  "    ofGetTimestampString()\n" "    ofGetTimestampString(std::string const &)\n"); lua_error(L);return 0; }
static int _wrap_getYear(lua_State* L) { int SWIG_arg = 0; int result; SWIG_check_num_args("ofGetYear",0,0)
  result = (int)ofGetYear(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_getMonth(lua_State* L) { int SWIG_arg = 0; int result; SWIG_check_num_args("ofGetMonth",0,0)
  result = (int)ofGetMonth(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_getDay(lua_State* L) { int SWIG_arg = 0; int result; SWIG_check_num_args("ofGetDay",0,0)
  result = (int)ofGetDay(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_getWeekday(lua_State* L) { int SWIG_arg = 0; int result; SWIG_check_num_args("ofGetWeekday",0,0)
  result = (int)ofGetWeekday(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_enableDataPath(lua_State* L) { int SWIG_arg = 0; SWIG_check_num_args("ofEnableDataPath",0,0)
  ofEnableDataPath(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_disableDataPath(lua_State* L) { int SWIG_arg = 0; SWIG_check_num_args("ofDisableDataPath",0,0)
  ofDisableDataPath(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_toDataPath__SWIG_0(lua_State* L) { int SWIG_arg = 0; std::filesystem::path *arg1 = 0 ; bool arg2 ;
  std::filesystem::path temp1 ; std::string result; SWIG_check_num_args("ofToDataPath",2,2)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofToDataPath",1,"std::filesystem::path const &");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofToDataPath",2,"bool"); { size_t len = lua_rawlen(L, 1);
    temp1 = lua_tolstring(L, 1, &len); arg1 = &temp1; }  arg2 = (lua_toboolean(L, 2)!=0);
  result = ofToDataPath((boost::filesystem::path const &)*arg1,arg2);
  lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_toDataPath__SWIG_1(lua_State* L) { int SWIG_arg = 0; std::filesystem::path *arg1 = 0 ;
  std::filesystem::path temp1 ; std::string result; SWIG_check_num_args("ofToDataPath",1,1)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofToDataPath",1,"std::filesystem::path const &"); { size_t len = lua_rawlen(L, 1);
    temp1 = lua_tolstring(L, 1, &len); arg1 = &temp1; }  result = ofToDataPath((boost::filesystem::path const &)*arg1);
  lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_toDataPath(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 1) { int _v; {
      _v = lua_isstring(L, argv[0]); }  if (_v) { return _wrap_toDataPath__SWIG_1(L);}  }  if (argc == 2) { int _v; {
      _v = lua_isstring(L, argv[0]); }  if (_v) { { _v = lua_isboolean(L,argv[1]); }  if (_v) {
        return _wrap_toDataPath__SWIG_0(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'toDataPath'\n" "  Possible C/C++ prototypes are:\n"
  "    ofToDataPath(std::filesystem::path const &,bool)\n" "    ofToDataPath(std::filesystem::path const &)\n");
  lua_error(L);return 0; }
static int _wrap_restoreWorkingDirectoryToDefault(lua_State* L) { int SWIG_arg = 0; bool result;
  SWIG_check_num_args("ofRestoreWorkingDirectoryToDefault",0,0) result = (bool)ofRestoreWorkingDirectoryToDefault();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_setDataPathRoot(lua_State* L) { int SWIG_arg = 0; std::filesystem::path *arg1 = 0 ;
  std::filesystem::path temp1 ; SWIG_check_num_args("ofSetDataPathRoot",1,1)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofSetDataPathRoot",1,"std::filesystem::path const &"); { size_t len = lua_rawlen(L, 1);
    temp1 = lua_tolstring(L, 1, &len); arg1 = &temp1; }  ofSetDataPathRoot((boost::filesystem::path const &)*arg1);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_splitString__SWIG_0(lua_State* L) { int SWIG_arg = 0; std::string *arg1 = 0 ; std::string *arg2 = 0 ;
  bool arg3 ; bool arg4 ; std::string temp1 ; std::string temp2 ; std::vector< std::string > result;
  SWIG_check_num_args("ofSplitString",4,4) if(!lua_isstring(L,1)) SWIG_fail_arg("ofSplitString",1,"std::string const &");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofSplitString",2,"std::string const &");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("ofSplitString",3,"bool");
  if(!lua_isboolean(L,4)) SWIG_fail_arg("ofSplitString",4,"bool"); temp1.assign(lua_tostring(L,1),lua_rawlen(L,1)); arg1=&temp1;
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2; arg3 = (lua_toboolean(L, 3)!=0);
  arg4 = (lua_toboolean(L, 4)!=0); result = ofSplitString((std::string const &)*arg1,(std::string const &)*arg2,arg3,arg4); {
    std::vector< std::string > * resultptr = new std::vector< std::string >((const std::vector< std::string > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_std__vectorT_std__string_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_splitString__SWIG_1(lua_State* L) { int SWIG_arg = 0; std::string *arg1 = 0 ; std::string *arg2 = 0 ;
  bool arg3 ; std::string temp1 ; std::string temp2 ; std::vector< std::string > result;
  SWIG_check_num_args("ofSplitString",3,3) if(!lua_isstring(L,1)) SWIG_fail_arg("ofSplitString",1,"std::string const &");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofSplitString",2,"std::string const &");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("ofSplitString",3,"bool"); temp1.assign(lua_tostring(L,1),lua_rawlen(L,1)); arg1=&temp1;
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2; arg3 = (lua_toboolean(L, 3)!=0);
  result = ofSplitString((std::string const &)*arg1,(std::string const &)*arg2,arg3); {
    std::vector< std::string > * resultptr = new std::vector< std::string >((const std::vector< std::string > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_std__vectorT_std__string_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_splitString__SWIG_2(lua_State* L) { int SWIG_arg = 0; std::string *arg1 = 0 ; std::string *arg2 = 0 ;
  std::string temp1 ; std::string temp2 ; std::vector< std::string > result; SWIG_check_num_args("ofSplitString",2,2)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofSplitString",1,"std::string const &");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofSplitString",2,"std::string const &");
  temp1.assign(lua_tostring(L,1),lua_rawlen(L,1)); arg1=&temp1; temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  result = ofSplitString((std::string const &)*arg1,(std::string const &)*arg2); {
    std::vector< std::string > * resultptr = new std::vector< std::string >((const std::vector< std::string > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_std__vectorT_std__string_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_splitString(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L); if (argc == 2) { int _v;
    { _v = lua_isstring(L,argv[0]); }  if (_v) { { _v = lua_isstring(L,argv[1]); }  if (_v) {
        return _wrap_splitString__SWIG_2(L);}  }  }  if (argc == 3) { int _v; { _v = lua_isstring(L,argv[0]); }  if (_v) { {
        _v = lua_isstring(L,argv[1]); }  if (_v) { { _v = lua_isboolean(L,argv[2]); }  if (_v) {
          return _wrap_splitString__SWIG_1(L);}  }  }  }  if (argc == 4) { int _v; { _v = lua_isstring(L,argv[0]); }  if (_v) {
      { _v = lua_isstring(L,argv[1]); }  if (_v) { { _v = lua_isboolean(L,argv[2]); }  if (_v) { {
            _v = lua_isboolean(L,argv[3]); }  if (_v) { return _wrap_splitString__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'splitString'\n" "  Possible C/C++ prototypes are:\n"
  "    ofSplitString(std::string const &,std::string const &,bool,bool)\n"
  "    ofSplitString(std::string const &,std::string const &,bool)\n"
  "    ofSplitString(std::string const &,std::string const &)\n"); lua_error(L);return 0; }
static int _wrap_joinString(lua_State* L) { int SWIG_arg = 0; std::vector< std::string > *arg1 = 0 ; std::string *arg2 = 0 ;
  std::string temp2 ; std::string result; SWIG_check_num_args("ofJoinString",2,2)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofJoinString",1,"std::vector< std::string > const &");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofJoinString",2,"std::string const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_std__string_t,0))){
    SWIG_fail_ptr("joinString",1,SWIGTYPE_p_std__vectorT_std__string_t); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  result = ofJoinString((std::vector< std::string > const &)*arg1,(std::string const &)*arg2);
  lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_stringReplace(lua_State* L) { int SWIG_arg = 0; std::string *arg1 = 0 ; std::string *arg2 = 0 ;
  std::string *arg3 = 0 ; std::string temp2 ; std::string temp3 ; SWIG_check_num_args("ofStringReplace",3,3)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofStringReplace",1,"std::string &");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofStringReplace",2,"std::string const &");
  if(!lua_isstring(L,3)) SWIG_fail_arg("ofStringReplace",3,"std::string const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__string,0))){
    SWIG_fail_ptr("stringReplace",1,SWIGTYPE_p_std__string); }  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  temp3.assign(lua_tostring(L,3),lua_rawlen(L,3)); arg3=&temp3;
  ofStringReplace(*arg1,(std::string const &)*arg2,(std::string const &)*arg3); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_isStringInString(lua_State* L) { int SWIG_arg = 0; std::string *arg1 = 0 ; std::string *arg2 = 0 ;
  std::string temp1 ; std::string temp2 ; bool result; SWIG_check_num_args("ofIsStringInString",2,2)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofIsStringInString",1,"std::string const &");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofIsStringInString",2,"std::string const &");
  temp1.assign(lua_tostring(L,1),lua_rawlen(L,1)); arg1=&temp1; temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  result = (bool)ofIsStringInString((std::string const &)*arg1,(std::string const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_stringTimesInString(lua_State* L) { int SWIG_arg = 0; std::string *arg1 = 0 ; std::string *arg2 = 0 ;
  std::string temp1 ; std::string temp2 ; std::size_t result; SWIG_check_num_args("ofStringTimesInString",2,2)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofStringTimesInString",1,"std::string const &");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofStringTimesInString",2,"std::string const &");
  temp1.assign(lua_tostring(L,1),lua_rawlen(L,1)); arg1=&temp1; temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  result = (std::size_t)ofStringTimesInString((std::string const &)*arg1,(std::string const &)*arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_toLower__SWIG_0(lua_State* L) { int SWIG_arg = 0; std::string *arg1 = 0 ; std::string *arg2 = 0 ;
  std::string temp1 ; std::string temp2 ; std::string result; SWIG_check_num_args("ofToLower",2,2)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofToLower",1,"std::string const &");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofToLower",2,"std::string const &");
  temp1.assign(lua_tostring(L,1),lua_rawlen(L,1)); arg1=&temp1; temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  result = ofToLower((std::string const &)*arg1,(std::string const &)*arg2);
  lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_toLower__SWIG_1(lua_State* L) { int SWIG_arg = 0; std::string *arg1 = 0 ; std::string temp1 ;
  std::string result; SWIG_check_num_args("ofToLower",1,1)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofToLower",1,"std::string const &");
  temp1.assign(lua_tostring(L,1),lua_rawlen(L,1)); arg1=&temp1; result = ofToLower((std::string const &)*arg1);
  lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_toLower(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 1) { int _v; {
      _v = lua_isstring(L,argv[0]); }  if (_v) { return _wrap_toLower__SWIG_1(L);}  }  if (argc == 2) { int _v; {
      _v = lua_isstring(L,argv[0]); }  if (_v) { { _v = lua_isstring(L,argv[1]); }  if (_v) { return _wrap_toLower__SWIG_0(L);}
       }  }  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'toLower'\n" "  Possible C/C++ prototypes are:\n"
  "    ofToLower(std::string const &,std::string const &)\n" "    ofToLower(std::string const &)\n"); lua_error(L);return 0; }
static int _wrap_toUpper__SWIG_0(lua_State* L) { int SWIG_arg = 0; std::string *arg1 = 0 ; std::string *arg2 = 0 ;
  std::string temp1 ; std::string temp2 ; std::string result; SWIG_check_num_args("ofToUpper",2,2)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofToUpper",1,"std::string const &");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofToUpper",2,"std::string const &");
  temp1.assign(lua_tostring(L,1),lua_rawlen(L,1)); arg1=&temp1; temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  result = ofToUpper((std::string const &)*arg1,(std::string const &)*arg2);
  lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_toUpper__SWIG_1(lua_State* L) { int SWIG_arg = 0; std::string *arg1 = 0 ; std::string temp1 ;
  std::string result; SWIG_check_num_args("ofToUpper",1,1)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofToUpper",1,"std::string const &");
  temp1.assign(lua_tostring(L,1),lua_rawlen(L,1)); arg1=&temp1; result = ofToUpper((std::string const &)*arg1);
  lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_toUpper(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 1) { int _v; {
      _v = lua_isstring(L,argv[0]); }  if (_v) { return _wrap_toUpper__SWIG_1(L);}  }  if (argc == 2) { int _v; {
      _v = lua_isstring(L,argv[0]); }  if (_v) { { _v = lua_isstring(L,argv[1]); }  if (_v) { return _wrap_toUpper__SWIG_0(L);}
       }  }  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'toUpper'\n" "  Possible C/C++ prototypes are:\n"
  "    ofToUpper(std::string const &,std::string const &)\n" "    ofToUpper(std::string const &)\n"); lua_error(L);return 0; }
static int _wrap_trimFront__SWIG_0(lua_State* L) { int SWIG_arg = 0; std::string *arg1 = 0 ; std::string *arg2 = 0 ;
  std::string temp1 ; std::string temp2 ; std::string result; SWIG_check_num_args("ofTrimFront",2,2)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofTrimFront",1,"std::string const &");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofTrimFront",2,"std::string const &");
  temp1.assign(lua_tostring(L,1),lua_rawlen(L,1)); arg1=&temp1; temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  result = ofTrimFront((std::string const &)*arg1,(std::string const &)*arg2);
  lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_trimFront__SWIG_1(lua_State* L) { int SWIG_arg = 0; std::string *arg1 = 0 ; std::string temp1 ;
  std::string result; SWIG_check_num_args("ofTrimFront",1,1)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofTrimFront",1,"std::string const &");
  temp1.assign(lua_tostring(L,1),lua_rawlen(L,1)); arg1=&temp1; result = ofTrimFront((std::string const &)*arg1);
  lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_trimFront(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 1) { int _v; {
      _v = lua_isstring(L,argv[0]); }  if (_v) { return _wrap_trimFront__SWIG_1(L);}  }  if (argc == 2) { int _v; {
      _v = lua_isstring(L,argv[0]); }  if (_v) { { _v = lua_isstring(L,argv[1]); }  if (_v) { return _wrap_trimFront__SWIG_0(L);}
       }  }  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'trimFront'\n"
  "  Possible C/C++ prototypes are:\n" "    ofTrimFront(std::string const &,std::string const &)\n"
  "    ofTrimFront(std::string const &)\n"); lua_error(L);return 0; }
static int _wrap_trimBack__SWIG_0(lua_State* L) { int SWIG_arg = 0; std::string *arg1 = 0 ; std::string *arg2 = 0 ;
  std::string temp1 ; std::string temp2 ; std::string result; SWIG_check_num_args("ofTrimBack",2,2)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofTrimBack",1,"std::string const &");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofTrimBack",2,"std::string const &");
  temp1.assign(lua_tostring(L,1),lua_rawlen(L,1)); arg1=&temp1; temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  result = ofTrimBack((std::string const &)*arg1,(std::string const &)*arg2);
  lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_trimBack__SWIG_1(lua_State* L) { int SWIG_arg = 0; std::string *arg1 = 0 ; std::string temp1 ;
  std::string result; SWIG_check_num_args("ofTrimBack",1,1)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofTrimBack",1,"std::string const &");
  temp1.assign(lua_tostring(L,1),lua_rawlen(L,1)); arg1=&temp1; result = ofTrimBack((std::string const &)*arg1);
  lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_trimBack(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 1) { int _v; {
      _v = lua_isstring(L,argv[0]); }  if (_v) { return _wrap_trimBack__SWIG_1(L);}  }  if (argc == 2) { int _v; {
      _v = lua_isstring(L,argv[0]); }  if (_v) { { _v = lua_isstring(L,argv[1]); }  if (_v) { return _wrap_trimBack__SWIG_0(L);}
       }  }  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'trimBack'\n"
  "  Possible C/C++ prototypes are:\n" "    ofTrimBack(std::string const &,std::string const &)\n"
  "    ofTrimBack(std::string const &)\n"); lua_error(L);return 0; }
static int _wrap_trim__SWIG_0(lua_State* L) { int SWIG_arg = 0; std::string *arg1 = 0 ; std::string *arg2 = 0 ;
  std::string temp1 ; std::string temp2 ; std::string result; SWIG_check_num_args("ofTrim",2,2)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofTrim",1,"std::string const &");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofTrim",2,"std::string const &");
  temp1.assign(lua_tostring(L,1),lua_rawlen(L,1)); arg1=&temp1; temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  result = ofTrim((std::string const &)*arg1,(std::string const &)*arg2);
  lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_trim__SWIG_1(lua_State* L) { int SWIG_arg = 0; std::string *arg1 = 0 ; std::string temp1 ; std::string result;
  SWIG_check_num_args("ofTrim",1,1) if(!lua_isstring(L,1)) SWIG_fail_arg("ofTrim",1,"std::string const &");
  temp1.assign(lua_tostring(L,1),lua_rawlen(L,1)); arg1=&temp1; result = ofTrim((std::string const &)*arg1);
  lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_trim(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 1) { int _v; {
      _v = lua_isstring(L,argv[0]); }  if (_v) { return _wrap_trim__SWIG_1(L);}  }  if (argc == 2) { int _v; {
      _v = lua_isstring(L,argv[0]); }  if (_v) { { _v = lua_isstring(L,argv[1]); }  if (_v) { return _wrap_trim__SWIG_0(L);}  }
     }  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'trim'\n" "  Possible C/C++ prototypes are:\n"
  "    ofTrim(std::string const &,std::string const &)\n" "    ofTrim(std::string const &)\n"); lua_error(L);return 0; }
static int _wrap_UTF8Append(lua_State* L) { int SWIG_arg = 0; std::string *arg1 = 0 ; uint32_t arg2 ; uint32_t *argp2 ;
  SWIG_check_num_args("ofUTF8Append",2,2) if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofUTF8Append",1,"std::string &");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofUTF8Append",2,"uint32_t");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__string,0))){
    SWIG_fail_ptr("UTF8Append",1,SWIGTYPE_p_std__string); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_uint32_t,0))){
    SWIG_fail_ptr("UTF8Append",2,SWIGTYPE_p_uint32_t); }  arg2 = *argp2; ofUTF8Append(*arg1,arg2); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_UTF8Insert(lua_State* L) { int SWIG_arg = 0; std::string *arg1 = 0 ; size_t arg2 ; uint32_t arg3 ;
  uint32_t *argp3 ; SWIG_check_num_args("ofUTF8Insert",3,3)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofUTF8Insert",1,"std::string &");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofUTF8Insert",2,"size_t");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofUTF8Insert",3,"uint32_t");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__string,0))){
    SWIG_fail_ptr("UTF8Insert",1,SWIGTYPE_p_std__string); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (size_t)lua_tonumber(L, 2);
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_uint32_t,0))){
    SWIG_fail_ptr("UTF8Insert",3,SWIGTYPE_p_uint32_t); }  arg3 = *argp3; ofUTF8Insert(*arg1,arg2,arg3); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_UTF8Erase(lua_State* L) { int SWIG_arg = 0; std::string *arg1 = 0 ; size_t arg2 ; size_t arg3 ;
  SWIG_check_num_args("ofUTF8Erase",3,3) if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofUTF8Erase",1,"std::string &");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofUTF8Erase",2,"size_t");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofUTF8Erase",3,"size_t");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__string,0))){
    SWIG_fail_ptr("UTF8Erase",1,SWIGTYPE_p_std__string); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (size_t)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (size_t)lua_tonumber(L, 3);
  ofUTF8Erase(*arg1,arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_UTF8Substring(lua_State* L) { int SWIG_arg = 0; std::string *arg1 = 0 ; size_t arg2 ; size_t arg3 ;
  std::string temp1 ; std::string result; SWIG_check_num_args("ofUTF8Substring",3,3)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofUTF8Substring",1,"std::string const &");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofUTF8Substring",2,"size_t");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofUTF8Substring",3,"size_t");
  temp1.assign(lua_tostring(L,1),lua_rawlen(L,1)); arg1=&temp1;
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (size_t)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (size_t)lua_tonumber(L, 3);
  result = ofUTF8Substring((std::string const &)*arg1,arg2,arg3);
  lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_UTF8ToString(lua_State* L) { int SWIG_arg = 0; uint32_t arg1 ; uint32_t *argp1 ; std::string result;
  SWIG_check_num_args("ofUTF8ToString",1,1) if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofUTF8ToString",1,"uint32_t");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&argp1,SWIGTYPE_p_uint32_t,0))){
    SWIG_fail_ptr("UTF8ToString",1,SWIGTYPE_p_uint32_t); }  arg1 = *argp1; result = ofUTF8ToString(arg1);
  lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_UTF8Length(lua_State* L) { int SWIG_arg = 0; std::string *arg1 = 0 ; std::string temp1 ; size_t result;
  SWIG_check_num_args("ofUTF8Length",1,1) if(!lua_isstring(L,1)) SWIG_fail_arg("ofUTF8Length",1,"std::string const &");
  temp1.assign(lua_tostring(L,1),lua_rawlen(L,1)); arg1=&temp1; result = (size_t)ofUTF8Length((std::string const &)*arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_toInt(lua_State* L) { int SWIG_arg = 0; std::string *arg1 = 0 ; std::string temp1 ; int result;
  SWIG_check_num_args("ofToInt",1,1) if(!lua_isstring(L,1)) SWIG_fail_arg("ofToInt",1,"std::string const &");
  temp1.assign(lua_tostring(L,1),lua_rawlen(L,1)); arg1=&temp1; result = (int)ofToInt((std::string const &)*arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_toInt64(lua_State* L) { int SWIG_arg = 0; std::string *arg1 = 0 ; std::string temp1 ; int64_t result;
  SWIG_check_num_args("ofToInt64",1,1) if(!lua_isstring(L,1)) SWIG_fail_arg("ofToInt64",1,"std::string const &");
  temp1.assign(lua_tostring(L,1),lua_rawlen(L,1)); arg1=&temp1; result = (int64_t)ofToInt64((std::string const &)*arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_toFloat(lua_State* L) { int SWIG_arg = 0; std::string *arg1 = 0 ; std::string temp1 ; float result;
  SWIG_check_num_args("ofToFloat",1,1) if(!lua_isstring(L,1)) SWIG_fail_arg("ofToFloat",1,"std::string const &");
  temp1.assign(lua_tostring(L,1),lua_rawlen(L,1)); arg1=&temp1; result = (float)ofToFloat((std::string const &)*arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_toDouble(lua_State* L) { int SWIG_arg = 0; std::string *arg1 = 0 ; std::string temp1 ; double result;
  SWIG_check_num_args("ofToDouble",1,1) if(!lua_isstring(L,1)) SWIG_fail_arg("ofToDouble",1,"std::string const &");
  temp1.assign(lua_tostring(L,1),lua_rawlen(L,1)); arg1=&temp1; result = (double)ofToDouble((std::string const &)*arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_toBool(lua_State* L) { int SWIG_arg = 0; std::string *arg1 = 0 ; std::string temp1 ; bool result;
  SWIG_check_num_args("ofToBool",1,1) if(!lua_isstring(L,1)) SWIG_fail_arg("ofToBool",1,"std::string const &");
  temp1.assign(lua_tostring(L,1),lua_rawlen(L,1)); arg1=&temp1; result = (bool)ofToBool((std::string const &)*arg1);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_toHex(lua_State* L) { int SWIG_arg = 0; char *arg1 = (char *) 0 ; std::string result;
  SWIG_check_num_args("ofToHex",1,1) if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("ofToHex",1,"char const *");
  arg1 = (char *)lua_tostring(L, 1); result = ofToHex((char const *)arg1);
  lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_hexToInt(lua_State* L) { int SWIG_arg = 0; std::string *arg1 = 0 ; std::string temp1 ; int result;
  SWIG_check_num_args("ofHexToInt",1,1) if(!lua_isstring(L,1)) SWIG_fail_arg("ofHexToInt",1,"std::string const &");
  temp1.assign(lua_tostring(L,1),lua_rawlen(L,1)); arg1=&temp1; result = (int)ofHexToInt((std::string const &)*arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_hexToChar(lua_State* L) { int SWIG_arg = 0; std::string *arg1 = 0 ; std::string temp1 ; char result;
  SWIG_check_num_args("ofHexToChar",1,1) if(!lua_isstring(L,1)) SWIG_fail_arg("ofHexToChar",1,"std::string const &");
  temp1.assign(lua_tostring(L,1),lua_rawlen(L,1)); arg1=&temp1; result = (char)ofHexToChar((std::string const &)*arg1);
  lua_pushlstring(L, &result, 1); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_hexToFloat(lua_State* L) { int SWIG_arg = 0; std::string *arg1 = 0 ; std::string temp1 ; float result;
  SWIG_check_num_args("ofHexToFloat",1,1) if(!lua_isstring(L,1)) SWIG_fail_arg("ofHexToFloat",1,"std::string const &");
  temp1.assign(lua_tostring(L,1),lua_rawlen(L,1)); arg1=&temp1; result = (float)ofHexToFloat((std::string const &)*arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_hexToString(lua_State* L) { int SWIG_arg = 0; std::string *arg1 = 0 ; std::string temp1 ; std::string result;
  SWIG_check_num_args("ofHexToString",1,1) if(!lua_isstring(L,1)) SWIG_fail_arg("ofHexToString",1,"std::string const &");
  temp1.assign(lua_tostring(L,1),lua_rawlen(L,1)); arg1=&temp1; result = ofHexToString((std::string const &)*arg1);
  lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_toChar(lua_State* L) { int SWIG_arg = 0; std::string *arg1 = 0 ; std::string temp1 ; char result;
  SWIG_check_num_args("ofToChar",1,1) if(!lua_isstring(L,1)) SWIG_fail_arg("ofToChar",1,"std::string const &");
  temp1.assign(lua_tostring(L,1),lua_rawlen(L,1)); arg1=&temp1; result = (char)ofToChar((std::string const &)*arg1);
  lua_pushlstring(L, &result, 1); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_toBinary(lua_State* L) { int SWIG_arg = 0; char *arg1 = (char *) 0 ; std::string result;
  SWIG_check_num_args("ofToBinary",1,1) if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("ofToBinary",1,"char const *");
  arg1 = (char *)lua_tostring(L, 1); result = ofToBinary((char const *)arg1);
  lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_binaryToInt(lua_State* L) { int SWIG_arg = 0; std::string *arg1 = 0 ; std::string temp1 ; int result;
  SWIG_check_num_args("ofBinaryToInt",1,1) if(!lua_isstring(L,1)) SWIG_fail_arg("ofBinaryToInt",1,"std::string const &");
  temp1.assign(lua_tostring(L,1),lua_rawlen(L,1)); arg1=&temp1; result = (int)ofBinaryToInt((std::string const &)*arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_binaryToChar(lua_State* L) { int SWIG_arg = 0; std::string *arg1 = 0 ; std::string temp1 ; char result;
  SWIG_check_num_args("ofBinaryToChar",1,1) if(!lua_isstring(L,1)) SWIG_fail_arg("ofBinaryToChar",1,"std::string const &");
  temp1.assign(lua_tostring(L,1),lua_rawlen(L,1)); arg1=&temp1; result = (char)ofBinaryToChar((std::string const &)*arg1);
  lua_pushlstring(L, &result, 1); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_binaryToFloat(lua_State* L) { int SWIG_arg = 0; std::string *arg1 = 0 ; std::string temp1 ; float result;
  SWIG_check_num_args("ofBinaryToFloat",1,1) if(!lua_isstring(L,1)) SWIG_fail_arg("ofBinaryToFloat",1,"std::string const &");
  temp1.assign(lua_tostring(L,1),lua_rawlen(L,1)); arg1=&temp1; result = (float)ofBinaryToFloat((std::string const &)*arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_binaryToString(lua_State* L) { int SWIG_arg = 0; std::string *arg1 = 0 ; std::string temp1 ;
  std::string result; SWIG_check_num_args("ofBinaryToString",1,1)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofBinaryToString",1,"std::string const &");
  temp1.assign(lua_tostring(L,1),lua_rawlen(L,1)); arg1=&temp1; result = ofBinaryToString((std::string const &)*arg1);
  lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_getVersionInfo(lua_State* L) { int SWIG_arg = 0; std::string result;
  SWIG_check_num_args("ofGetVersionInfo",0,0) result = ofGetVersionInfo();
  lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_getVersionMajor(lua_State* L) { int SWIG_arg = 0; unsigned int result;
  SWIG_check_num_args("ofGetVersionMajor",0,0) result = (unsigned int)ofGetVersionMajor();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_getVersionMinor(lua_State* L) { int SWIG_arg = 0; unsigned int result;
  SWIG_check_num_args("ofGetVersionMinor",0,0) result = (unsigned int)ofGetVersionMinor();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_getVersionPatch(lua_State* L) { int SWIG_arg = 0; unsigned int result;
  SWIG_check_num_args("ofGetVersionPatch",0,0) result = (unsigned int)ofGetVersionPatch();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_getVersionPreRelease(lua_State* L) { int SWIG_arg = 0; std::string result;
  SWIG_check_num_args("ofGetVersionPreRelease",0,0) result = ofGetVersionPreRelease();
  lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_saveScreen(lua_State* L) { int SWIG_arg = 0; std::string *arg1 = 0 ; std::string temp1 ;
  SWIG_check_num_args("ofSaveScreen",1,1) if(!lua_isstring(L,1)) SWIG_fail_arg("ofSaveScreen",1,"std::string const &");
  temp1.assign(lua_tostring(L,1),lua_rawlen(L,1)); arg1=&temp1; ofSaveScreen((std::string const &)*arg1); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_saveFrame__SWIG_0(lua_State* L) { int SWIG_arg = 0; bool arg1 ; SWIG_check_num_args("ofSaveFrame",1,1)
  if(!lua_isboolean(L,1)) SWIG_fail_arg("ofSaveFrame",1,"bool"); arg1 = (lua_toboolean(L, 1)!=0); ofSaveFrame(arg1);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_saveFrame__SWIG_1(lua_State* L) { int SWIG_arg = 0; SWIG_check_num_args("ofSaveFrame",0,0) ofSaveFrame();
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_saveFrame(lua_State* L) { int argc; int argv[2]={ 1,2} ; argc = lua_gettop(L); if (argc == 0) {
    return _wrap_saveFrame__SWIG_1(L);}  if (argc == 1) { int _v; { _v = lua_isboolean(L,argv[0]); }  if (_v) {
      return _wrap_saveFrame__SWIG_0(L);}  }  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'saveFrame'\n"
  "  Possible C/C++ prototypes are:\n" "    ofSaveFrame(bool)\n" "    ofSaveFrame()\n"); lua_error(L);return 0; }
static int _wrap_saveViewport(lua_State* L) { int SWIG_arg = 0; std::string *arg1 = 0 ; std::string temp1 ;
  SWIG_check_num_args("ofSaveViewport",1,1) if(!lua_isstring(L,1)) SWIG_fail_arg("ofSaveViewport",1,"std::string const &");
  temp1.assign(lua_tostring(L,1),lua_rawlen(L,1)); arg1=&temp1; ofSaveViewport((std::string const &)*arg1); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_launchBrowser__SWIG_0(lua_State* L) { int SWIG_arg = 0; std::string *arg1 = 0 ; bool arg2 ; std::string temp1 ;
  SWIG_check_num_args("ofLaunchBrowser",2,2) if(!lua_isstring(L,1)) SWIG_fail_arg("ofLaunchBrowser",1,"std::string const &");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofLaunchBrowser",2,"bool");
  temp1.assign(lua_tostring(L,1),lua_rawlen(L,1)); arg1=&temp1; arg2 = (lua_toboolean(L, 2)!=0);
  ofLaunchBrowser((std::string const &)*arg1,arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_launchBrowser__SWIG_1(lua_State* L) { int SWIG_arg = 0; std::string *arg1 = 0 ; std::string temp1 ;
  SWIG_check_num_args("ofLaunchBrowser",1,1) if(!lua_isstring(L,1)) SWIG_fail_arg("ofLaunchBrowser",1,"std::string const &");
  temp1.assign(lua_tostring(L,1),lua_rawlen(L,1)); arg1=&temp1; ofLaunchBrowser((std::string const &)*arg1); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_launchBrowser(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 1) { int _v; {
      _v = lua_isstring(L,argv[0]); }  if (_v) { return _wrap_launchBrowser__SWIG_1(L);}  }  if (argc == 2) { int _v; {
      _v = lua_isstring(L,argv[0]); }  if (_v) { { _v = lua_isboolean(L,argv[1]); }  if (_v) {
        return _wrap_launchBrowser__SWIG_0(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'launchBrowser'\n" "  Possible C/C++ prototypes are:\n"
  "    ofLaunchBrowser(std::string const &,bool)\n" "    ofLaunchBrowser(std::string const &)\n"); lua_error(L);return 0; }
static int _wrap_system(lua_State* L) { int SWIG_arg = 0; std::string *arg1 = 0 ; std::string temp1 ; std::string result;
  SWIG_check_num_args("ofSystem",1,1) if(!lua_isstring(L,1)) SWIG_fail_arg("ofSystem",1,"std::string const &");
  temp1.assign(lua_tostring(L,1),lua_rawlen(L,1)); arg1=&temp1; result = ofSystem((std::string const &)*arg1);
  lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_getTargetPlatform(lua_State* L) { int SWIG_arg = 0; ofTargetPlatform result;
  SWIG_check_num_args("ofGetTargetPlatform",0,0) result = (ofTargetPlatform)ofGetTargetPlatform();
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_getEnv(lua_State* L) { int SWIG_arg = 0; std::string *arg1 = 0 ; std::string temp1 ; std::string result;
  SWIG_check_num_args("ofGetEnv",1,1) if(!lua_isstring(L,1)) SWIG_fail_arg("ofGetEnv",1,"std::string const &");
  temp1.assign(lua_tostring(L,1),lua_rawlen(L,1)); arg1=&temp1; result = ofGetEnv((std::string const &)*arg1);
  lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_FboModeOr(lua_State* L) { int SWIG_arg = 0; ofFboMode arg1 ; ofFboMode arg2 ; ofFboMode result;
  SWIG_check_num_args("operator |",2,2) if(!lua_isnumber(L,1)) SWIG_fail_arg("operator |",1,"ofFboMode");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("operator |",2,"ofFboMode"); arg1 = (ofFboMode)(int)lua_tonumber(L, 1);
  arg2 = (ofFboMode)(int)lua_tonumber(L, 2); result = (ofFboMode)operator |(arg1,arg2);
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_FboModeAnd(lua_State* L) { int SWIG_arg = 0; ofFboMode arg1 ; ofFboMode arg2 ; bool result;
  SWIG_check_num_args("operator &",2,2) if(!lua_isnumber(L,1)) SWIG_fail_arg("operator &",1,"ofFboMode");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("operator &",2,"ofFboMode"); arg1 = (ofFboMode)(int)lua_tonumber(L, 1);
  arg2 = (ofFboMode)(int)lua_tonumber(L, 2); result = (bool)operator &(arg1,arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_new_Fbo__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofFbo *result = 0 ; SWIG_check_num_args("ofFbo::ofFbo",0,0)
  result = (ofFbo *)new ofFbo(); SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofFbo,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_new_Fbo__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofFbo *arg1 = 0 ; ofFbo *result = 0 ;
  SWIG_check_num_args("ofFbo::ofFbo",1,1) if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofFbo::ofFbo",1,"ofFbo &&");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFbo,0))){ SWIG_fail_ptr("new_Fbo",1,SWIGTYPE_p_ofFbo); } 
  result = (ofFbo *)new ofFbo((ofFbo &&)*arg1); SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofFbo,1); SWIG_arg++;  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_new_Fbo(lua_State* L) { int argc; int argv[2]={ 1,2} ; argc = lua_gettop(L); if (argc == 0) {
    return _wrap_new_Fbo__SWIG_0(L);}  if (argc == 1) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofFbo, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { return _wrap_new_Fbo__SWIG_1(L);}  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_Fbo'\n" "  Possible C/C++ prototypes are:\n"
  "    ofFbo::ofFbo()\n" "    ofFbo::ofFbo(ofFbo &&)\n"); lua_error(L);return 0; }
static int _wrap_Fbo_allocate__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofFbo *arg1 = (ofFbo *) 0 ; int arg2 ; int arg3 ;
  int arg4 ; int arg5 ; SWIG_check_num_args("ofFbo::allocate",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFbo::allocate",1,"ofFbo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofFbo::allocate",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofFbo::allocate",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofFbo::allocate",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofFbo::allocate",5,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFbo,0))){ SWIG_fail_ptr("Fbo_allocate",1,SWIGTYPE_p_ofFbo); } 
  arg2 = (int)lua_tonumber(L, 2); arg3 = (int)lua_tonumber(L, 3); arg4 = (int)lua_tonumber(L, 4);
  arg5 = (int)lua_tonumber(L, 5); (arg1)->allocate(arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Fbo_allocate__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofFbo *arg1 = (ofFbo *) 0 ; int arg2 ; int arg3 ;
  int arg4 ; SWIG_check_num_args("ofFbo::allocate",4,4) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFbo::allocate",1,"ofFbo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofFbo::allocate",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofFbo::allocate",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofFbo::allocate",4,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFbo,0))){ SWIG_fail_ptr("Fbo_allocate",1,SWIGTYPE_p_ofFbo); } 
  arg2 = (int)lua_tonumber(L, 2); arg3 = (int)lua_tonumber(L, 3); arg4 = (int)lua_tonumber(L, 4);
  (arg1)->allocate(arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Fbo_allocate__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofFbo *arg1 = (ofFbo *) 0 ; int arg2 ; int arg3 ;
  SWIG_check_num_args("ofFbo::allocate",3,3) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFbo::allocate",1,"ofFbo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofFbo::allocate",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofFbo::allocate",3,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFbo,0))){ SWIG_fail_ptr("Fbo_allocate",1,SWIGTYPE_p_ofFbo); } 
  arg2 = (int)lua_tonumber(L, 2); arg3 = (int)lua_tonumber(L, 3); (arg1)->allocate(arg2,arg3); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Fbo_allocate__SWIG_3(lua_State* L) { int SWIG_arg = 0; ofFbo *arg1 = (ofFbo *) 0 ;
  SWIG_check_num_args("ofFbo::allocate",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFbo::allocate",1,"ofFbo *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFbo,0))){ SWIG_fail_ptr("Fbo_allocate",1,SWIGTYPE_p_ofFbo); } 
  (arg1)->allocate(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Fbo_allocate(lua_State* L) { int argc; int argv[6]={ 1,2,3,4,5,6} ; argc = lua_gettop(L); if (argc == 1) {
    int _v; { void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofFbo, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Fbo_allocate__SWIG_3(L);}  }  if (argc == 3) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofFbo, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_Fbo_allocate__SWIG_2(L);}  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofFbo, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { {
            _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_Fbo_allocate__SWIG_1(L);}  }  }  }  }  if (argc == 5) {
    int _v; { void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofFbo, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) {
              return _wrap_Fbo_allocate__SWIG_0(L);}  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Fbo_allocate'\n" "  Possible C/C++ prototypes are:\n"
  "    ofFbo::allocate(int,int,int,int)\n" "    ofFbo::allocate(int,int,int)\n" "    ofFbo::allocate(int,int)\n"
  "    ofFbo::allocate()\n"); lua_error(L);return 0; }
static int _wrap_Fbo_isAllocated(lua_State* L) { int SWIG_arg = 0; ofFbo *arg1 = (ofFbo *) 0 ; bool result;
  SWIG_check_num_args("ofFbo::isAllocated",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFbo::isAllocated",1,"ofFbo const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFbo,0))){ SWIG_fail_ptr("Fbo_isAllocated",1,SWIGTYPE_p_ofFbo); }
   result = (bool)((ofFbo const *)arg1)->isAllocated(); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Fbo_clear(lua_State* L) { int SWIG_arg = 0; ofFbo *arg1 = (ofFbo *) 0 ; SWIG_check_num_args("ofFbo::clear",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFbo::clear",1,"ofFbo *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFbo,0))){ SWIG_fail_ptr("Fbo_clear",1,SWIGTYPE_p_ofFbo); } 
  (arg1)->clear(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Fbo_clearColorBuffer__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofFbo *arg1 = (ofFbo *) 0 ;
  ofFloatColor *arg2 = 0 ; SWIG_check_num_args("ofFbo::clearColorBuffer",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFbo::clearColorBuffer",1,"ofFbo *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofFbo::clearColorBuffer",2,"ofFloatColor const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFbo,0))){
    SWIG_fail_ptr("Fbo_clearColorBuffer",1,SWIGTYPE_p_ofFbo); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("Fbo_clearColorBuffer",2,SWIGTYPE_p_ofColor_T_float_t); } 
  (arg1)->clearColorBuffer((ofFloatColor const &)*arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Fbo_clearColorBuffer__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofFbo *arg1 = (ofFbo *) 0 ; size_t arg2 ;
  ofFloatColor *arg3 = 0 ; SWIG_check_num_args("ofFbo::clearColorBuffer",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFbo::clearColorBuffer",1,"ofFbo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofFbo::clearColorBuffer",2,"size_t");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofFbo::clearColorBuffer",3,"ofFloatColor const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFbo,0))){
    SWIG_fail_ptr("Fbo_clearColorBuffer",1,SWIGTYPE_p_ofFbo); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (size_t)lua_tonumber(L, 2);
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("Fbo_clearColorBuffer",3,SWIGTYPE_p_ofColor_T_float_t); } 
  (arg1)->clearColorBuffer(arg2,(ofFloatColor const &)*arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Fbo_clearColorBuffer(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofFbo, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofColor_T_float_t, 0)) {
          _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Fbo_clearColorBuffer__SWIG_0(L);}  }  }  if (argc == 3) {
    int _v; { void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofFbo, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_ofColor_T_float_t, 0)) {
            _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Fbo_clearColorBuffer__SWIG_1(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Fbo_clearColorBuffer'\n"
  "  Possible C/C++ prototypes are:\n" "    ofFbo::clearColorBuffer(ofFloatColor const &)\n"
  "    ofFbo::clearColorBuffer(size_t,ofFloatColor const &)\n"); lua_error(L);return 0; }
static int _wrap_Fbo_clearDepthBuffer(lua_State* L) { int SWIG_arg = 0; ofFbo *arg1 = (ofFbo *) 0 ; float arg2 ;
  SWIG_check_num_args("ofFbo::clearDepthBuffer",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFbo::clearDepthBuffer",1,"ofFbo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofFbo::clearDepthBuffer",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFbo,0))){
    SWIG_fail_ptr("Fbo_clearDepthBuffer",1,SWIGTYPE_p_ofFbo); }  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->clearDepthBuffer(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Fbo_clearStencilBuffer(lua_State* L) { int SWIG_arg = 0; ofFbo *arg1 = (ofFbo *) 0 ; int arg2 ;
  SWIG_check_num_args("ofFbo::clearStencilBuffer",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFbo::clearStencilBuffer",1,"ofFbo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofFbo::clearStencilBuffer",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFbo,0))){
    SWIG_fail_ptr("Fbo_clearStencilBuffer",1,SWIGTYPE_p_ofFbo); }  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->clearStencilBuffer(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Fbo_clearDepthStencilBuffer(lua_State* L) { int SWIG_arg = 0; ofFbo *arg1 = (ofFbo *) 0 ; float arg2 ;
  int arg3 ; SWIG_check_num_args("ofFbo::clearDepthStencilBuffer",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFbo::clearDepthStencilBuffer",1,"ofFbo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofFbo::clearDepthStencilBuffer",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofFbo::clearDepthStencilBuffer",3,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFbo,0))){
    SWIG_fail_ptr("Fbo_clearDepthStencilBuffer",1,SWIGTYPE_p_ofFbo); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3); (arg1)->clearDepthStencilBuffer(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Fbo_draw__SWIG_0_0(lua_State* L) { int SWIG_arg = 0; ofFbo *arg1 = (ofFbo *) 0 ; glm::vec2 *arg2 = 0 ;
  SWIG_check_num_args("draw",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("draw",1,"ofFbo const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("draw",2,"glm::vec2 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFbo,0))){ SWIG_fail_ptr("Fbo_draw",1,SWIGTYPE_p_ofFbo); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec2,0))){ SWIG_fail_ptr("Fbo_draw",2,SWIGTYPE_p_glm__vec2); }
   ((ofFbo const *)arg1)->draw((glm::vec2 const &)*arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Fbo_draw__SWIG_0_1(lua_State* L) { int SWIG_arg = 0; ofFbo *arg1 = (ofFbo *) 0 ; ofRectangle *arg2 = 0 ;
  SWIG_check_num_args("draw",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("draw",1,"ofFbo const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("draw",2,"ofRectangle const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFbo,0))){ SWIG_fail_ptr("Fbo_draw",1,SWIGTYPE_p_ofFbo); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Fbo_draw",2,SWIGTYPE_p_ofRectangle); }  ((ofFbo const *)arg1)->draw((ofRectangle const &)*arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Fbo_draw__SWIG_0_2(lua_State* L) { int SWIG_arg = 0; ofFbo *arg1 = (ofFbo *) 0 ; glm::vec2 *arg2 = 0 ;
  float arg3 ; float arg4 ; SWIG_check_num_args("draw",4,4) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("draw",1,"ofFbo const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("draw",2,"glm::vec2 const &"); if(!lua_isnumber(L,3)) SWIG_fail_arg("draw",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("draw",4,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFbo,0))){ SWIG_fail_ptr("Fbo_draw",1,SWIGTYPE_p_ofFbo); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec2,0))){ SWIG_fail_ptr("Fbo_draw",2,SWIGTYPE_p_glm__vec2); }
   arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  ((ofFbo const *)arg1)->draw((glm::vec2 const &)*arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Fbo_draw__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofFbo *arg1 = (ofFbo *) 0 ; float arg2 ; float arg3 ;
  SWIG_check_num_args("ofFbo::draw",3,3) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFbo::draw",1,"ofFbo const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofFbo::draw",2,"float"); if(!lua_isnumber(L,3)) SWIG_fail_arg("ofFbo::draw",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFbo,0))){ SWIG_fail_ptr("Fbo_draw",1,SWIGTYPE_p_ofFbo); } 
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); ((ofFbo const *)arg1)->draw(arg2,arg3); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Fbo_draw__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofFbo *arg1 = (ofFbo *) 0 ; float arg2 ; float arg3 ;
  float arg4 ; float arg5 ; SWIG_check_num_args("ofFbo::draw",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFbo::draw",1,"ofFbo const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofFbo::draw",2,"float"); if(!lua_isnumber(L,3)) SWIG_fail_arg("ofFbo::draw",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofFbo::draw",4,"float"); if(!lua_isnumber(L,5)) SWIG_fail_arg("ofFbo::draw",5,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFbo,0))){ SWIG_fail_ptr("Fbo_draw",1,SWIGTYPE_p_ofFbo); } 
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  arg5 = (float)lua_tonumber(L, 5); ((ofFbo const *)arg1)->draw(arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Fbo_draw(lua_State* L) { int argc; int argv[6]={ 1,2,3,4,5,6} ; argc = lua_gettop(L); if (argc == 2) { int _v;
    { void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofFbo, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec2, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Fbo_draw__SWIG_0_0(L);}  }  }  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofFbo, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Fbo_draw__SWIG_0_1(L);}  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofFbo, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_Fbo_draw__SWIG_1(L);}  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofFbo, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec2, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); } 
          if (_v) { return _wrap_Fbo_draw__SWIG_0_2(L);}  }  }  }  }  if (argc == 5) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofFbo, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { {
            _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) {
              return _wrap_Fbo_draw__SWIG_2(L);}  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Fbo_draw'\n" "  Possible C/C++ prototypes are:\n"
  "    draw(glm::vec2 const &) const\n" "    draw(ofRectangle const &) const\n"
  "    draw(glm::vec2 const &,float,float) const\n" "    ofFbo::draw(float,float) const\n"
  "    ofFbo::draw(float,float,float,float) const\n"); lua_error(L);return 0; }
static int _wrap_Fbo_setAnchorPercent(lua_State* L) { int SWIG_arg = 0; ofFbo *arg1 = (ofFbo *) 0 ; float arg2 ; float arg3 ;
  SWIG_check_num_args("ofFbo::setAnchorPercent",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFbo::setAnchorPercent",1,"ofFbo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofFbo::setAnchorPercent",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofFbo::setAnchorPercent",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFbo,0))){
    SWIG_fail_ptr("Fbo_setAnchorPercent",1,SWIGTYPE_p_ofFbo); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); (arg1)->setAnchorPercent(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Fbo_setAnchorPoint(lua_State* L) { int SWIG_arg = 0; ofFbo *arg1 = (ofFbo *) 0 ; float arg2 ; float arg3 ;
  SWIG_check_num_args("ofFbo::setAnchorPoint",3,3) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFbo::setAnchorPoint",1,"ofFbo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofFbo::setAnchorPoint",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofFbo::setAnchorPoint",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFbo,0))){
    SWIG_fail_ptr("Fbo_setAnchorPoint",1,SWIGTYPE_p_ofFbo); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); (arg1)->setAnchorPoint(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Fbo_resetAnchor(lua_State* L) { int SWIG_arg = 0; ofFbo *arg1 = (ofFbo *) 0 ;
  SWIG_check_num_args("ofFbo::resetAnchor",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFbo::resetAnchor",1,"ofFbo *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFbo,0))){ SWIG_fail_ptr("Fbo_resetAnchor",1,SWIGTYPE_p_ofFbo); }
   (arg1)->resetAnchor(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Fbo_setDefaultTextureIndex(lua_State* L) { int SWIG_arg = 0; ofFbo *arg1 = (ofFbo *) 0 ; int arg2 ;
  SWIG_check_num_args("ofFbo::setDefaultTextureIndex",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFbo::setDefaultTextureIndex",1,"ofFbo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofFbo::setDefaultTextureIndex",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFbo,0))){
    SWIG_fail_ptr("Fbo_setDefaultTextureIndex",1,SWIGTYPE_p_ofFbo); }  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setDefaultTextureIndex(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Fbo_getDefaultTextureIndex(lua_State* L) { int SWIG_arg = 0; ofFbo *arg1 = (ofFbo *) 0 ; int result;
  SWIG_check_num_args("ofFbo::getDefaultTextureIndex",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFbo::getDefaultTextureIndex",1,"ofFbo const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFbo,0))){
    SWIG_fail_ptr("Fbo_getDefaultTextureIndex",1,SWIGTYPE_p_ofFbo); } 
  result = (int)((ofFbo const *)arg1)->getDefaultTextureIndex(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Fbo_getTexture__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofFbo *arg1 = (ofFbo *) 0 ; ofTexture *result = 0 ;
  SWIG_check_num_args("ofFbo::getTexture",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFbo::getTexture",1,"ofFbo *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFbo,0))){ SWIG_fail_ptr("Fbo_getTexture",1,SWIGTYPE_p_ofFbo); } 
  result = (ofTexture *) &(arg1)->getTexture(); SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofTexture,0); SWIG_arg++; 
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Fbo_getTexture__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofFbo *arg1 = (ofFbo *) 0 ; int arg2 ;
  ofTexture *result = 0 ; SWIG_check_num_args("ofFbo::getTexture",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFbo::getTexture",1,"ofFbo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofFbo::getTexture",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFbo,0))){ SWIG_fail_ptr("Fbo_getTexture",1,SWIGTYPE_p_ofFbo); } 
  arg2 = (int)lua_tonumber(L, 2); result = (ofTexture *) &(arg1)->getTexture(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofTexture,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Fbo_getDepthTexture__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofFbo *arg1 = (ofFbo *) 0 ;
  ofTexture *result = 0 ; SWIG_check_num_args("ofFbo::getDepthTexture",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFbo::getDepthTexture",1,"ofFbo *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFbo,0))){
    SWIG_fail_ptr("Fbo_getDepthTexture",1,SWIGTYPE_p_ofFbo); }  result = (ofTexture *) &(arg1)->getDepthTexture();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofTexture,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Fbo_getTexture__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofFbo *arg1 = (ofFbo *) 0 ; ofTexture *result = 0 ;
  SWIG_check_num_args("ofFbo::getTexture",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFbo::getTexture",1,"ofFbo const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFbo,0))){ SWIG_fail_ptr("Fbo_getTexture",1,SWIGTYPE_p_ofFbo); } 
  result = (ofTexture *) &((ofFbo const *)arg1)->getTexture(); SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofTexture,0); SWIG_arg++; 
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Fbo_getTexture__SWIG_3(lua_State* L) { int SWIG_arg = 0; ofFbo *arg1 = (ofFbo *) 0 ; int arg2 ;
  ofTexture *result = 0 ; SWIG_check_num_args("ofFbo::getTexture",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFbo::getTexture",1,"ofFbo const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofFbo::getTexture",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFbo,0))){ SWIG_fail_ptr("Fbo_getTexture",1,SWIGTYPE_p_ofFbo); } 
  arg2 = (int)lua_tonumber(L, 2); result = (ofTexture *) &((ofFbo const *)arg1)->getTexture(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofTexture,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Fbo_getTexture(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 1) { int _v;
    { void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofFbo, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { return _wrap_Fbo_getTexture__SWIG_0(L);}  }  if (argc == 1) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofFbo, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { return _wrap_Fbo_getTexture__SWIG_2(L);}  }  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofFbo, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { return _wrap_Fbo_getTexture__SWIG_1(L);}  }  } 
  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofFbo, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { return _wrap_Fbo_getTexture__SWIG_3(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Fbo_getTexture'\n" "  Possible C/C++ prototypes are:\n"
  "    ofFbo::getTexture()\n" "    ofFbo::getTexture(int)\n" "    ofFbo::getTexture() const\n"
  "    ofFbo::getTexture(int) const\n"); lua_error(L);return 0; }
static int _wrap_Fbo_getDepthTexture__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofFbo *arg1 = (ofFbo *) 0 ;
  ofTexture *result = 0 ; SWIG_check_num_args("ofFbo::getDepthTexture",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFbo::getDepthTexture",1,"ofFbo const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFbo,0))){
    SWIG_fail_ptr("Fbo_getDepthTexture",1,SWIGTYPE_p_ofFbo); } 
  result = (ofTexture *) &((ofFbo const *)arg1)->getDepthTexture();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofTexture,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Fbo_getDepthTexture(lua_State* L) { int argc; int argv[2]={ 1,2} ; argc = lua_gettop(L); if (argc == 1) {
    int _v; { void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofFbo, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Fbo_getDepthTexture__SWIG_0(L);}  }  if (argc == 1) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofFbo, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { return _wrap_Fbo_getDepthTexture__SWIG_1(L);}  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Fbo_getDepthTexture'\n"
  "  Possible C/C++ prototypes are:\n" "    ofFbo::getDepthTexture()\n" "    ofFbo::getDepthTexture() const\n");
  lua_error(L);return 0; }
static int _wrap_Fbo_beginFbo__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofFbo *arg1 = (ofFbo *) 0 ; ofFboMode arg2 ;
  SWIG_check_num_args("ofFbo::begin",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFbo::begin",1,"ofFbo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofFbo::begin",2,"ofFboMode");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFbo,0))){ SWIG_fail_ptr("Fbo_beginFbo",1,SWIGTYPE_p_ofFbo); } 
  arg2 = (ofFboMode)(int)lua_tonumber(L, 2); (arg1)->begin(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Fbo_beginFbo__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofFbo *arg1 = (ofFbo *) 0 ;
  SWIG_check_num_args("ofFbo::begin",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFbo::begin",1,"ofFbo *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFbo,0))){ SWIG_fail_ptr("Fbo_beginFbo",1,SWIGTYPE_p_ofFbo); } 
  (arg1)->begin(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Fbo_beginFbo(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 1) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofFbo, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { return _wrap_Fbo_beginFbo__SWIG_1(L);}  }  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofFbo, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { return _wrap_Fbo_beginFbo__SWIG_0(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Fbo_beginFbo'\n" "  Possible C/C++ prototypes are:\n"
  "    ofFbo::begin(ofFboMode)\n" "    ofFbo::begin()\n"); lua_error(L);return 0; }
static int _wrap_Fbo_endFbo(lua_State* L) { int SWIG_arg = 0; ofFbo *arg1 = (ofFbo *) 0 ; SWIG_check_num_args("ofFbo::end",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFbo::end",1,"ofFbo const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFbo,0))){ SWIG_fail_ptr("Fbo_endFbo",1,SWIGTYPE_p_ofFbo); } 
  ((ofFbo const *)arg1)->end(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Fbo_readToPixels__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofFbo *arg1 = (ofFbo *) 0 ; ofPixels *arg2 = 0 ;
  int arg3 ; SWIG_check_num_args("ofFbo::readToPixels",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFbo::readToPixels",1,"ofFbo const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofFbo::readToPixels",2,"ofPixels &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofFbo::readToPixels",3,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFbo,0))){ SWIG_fail_ptr("Fbo_readToPixels",1,SWIGTYPE_p_ofFbo); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Fbo_readToPixels",2,SWIGTYPE_p_ofPixels_T_unsigned_char_t); }  arg3 = (int)lua_tonumber(L, 3);
  ((ofFbo const *)arg1)->readToPixels(*arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Fbo_readToPixels__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofFbo *arg1 = (ofFbo *) 0 ; ofPixels *arg2 = 0 ;
  SWIG_check_num_args("ofFbo::readToPixels",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFbo::readToPixels",1,"ofFbo const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofFbo::readToPixels",2,"ofPixels &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFbo,0))){ SWIG_fail_ptr("Fbo_readToPixels",1,SWIGTYPE_p_ofFbo); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Fbo_readToPixels",2,SWIGTYPE_p_ofPixels_T_unsigned_char_t); }  ((ofFbo const *)arg1)->readToPixels(*arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Fbo_readToPixels__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofFbo *arg1 = (ofFbo *) 0 ;
  ofShortPixels *arg2 = 0 ; int arg3 ; SWIG_check_num_args("ofFbo::readToPixels",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFbo::readToPixels",1,"ofFbo const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofFbo::readToPixels",2,"ofShortPixels &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofFbo::readToPixels",3,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFbo,0))){ SWIG_fail_ptr("Fbo_readToPixels",1,SWIGTYPE_p_ofFbo); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofPixels_T_unsigned_short_t,0))){
    SWIG_fail_ptr("Fbo_readToPixels",2,SWIGTYPE_p_ofPixels_T_unsigned_short_t); }  arg3 = (int)lua_tonumber(L, 3);
  ((ofFbo const *)arg1)->readToPixels(*arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Fbo_readToPixels__SWIG_3(lua_State* L) { int SWIG_arg = 0; ofFbo *arg1 = (ofFbo *) 0 ;
  ofShortPixels *arg2 = 0 ; SWIG_check_num_args("ofFbo::readToPixels",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFbo::readToPixels",1,"ofFbo const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofFbo::readToPixels",2,"ofShortPixels &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFbo,0))){ SWIG_fail_ptr("Fbo_readToPixels",1,SWIGTYPE_p_ofFbo); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofPixels_T_unsigned_short_t,0))){
    SWIG_fail_ptr("Fbo_readToPixels",2,SWIGTYPE_p_ofPixels_T_unsigned_short_t); }  ((ofFbo const *)arg1)->readToPixels(*arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Fbo_readToPixels__SWIG_4(lua_State* L) { int SWIG_arg = 0; ofFbo *arg1 = (ofFbo *) 0 ;
  ofFloatPixels *arg2 = 0 ; int arg3 ; SWIG_check_num_args("ofFbo::readToPixels",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFbo::readToPixels",1,"ofFbo const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofFbo::readToPixels",2,"ofFloatPixels &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofFbo::readToPixels",3,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFbo,0))){ SWIG_fail_ptr("Fbo_readToPixels",1,SWIGTYPE_p_ofFbo); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofPixels_T_float_t,0))){
    SWIG_fail_ptr("Fbo_readToPixels",2,SWIGTYPE_p_ofPixels_T_float_t); }  arg3 = (int)lua_tonumber(L, 3);
  ((ofFbo const *)arg1)->readToPixels(*arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Fbo_readToPixels__SWIG_5(lua_State* L) { int SWIG_arg = 0; ofFbo *arg1 = (ofFbo *) 0 ;
  ofFloatPixels *arg2 = 0 ; SWIG_check_num_args("ofFbo::readToPixels",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFbo::readToPixels",1,"ofFbo const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofFbo::readToPixels",2,"ofFloatPixels &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFbo,0))){ SWIG_fail_ptr("Fbo_readToPixels",1,SWIGTYPE_p_ofFbo); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofPixels_T_float_t,0))){
    SWIG_fail_ptr("Fbo_readToPixels",2,SWIGTYPE_p_ofPixels_T_float_t); }  ((ofFbo const *)arg1)->readToPixels(*arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Fbo_readToPixels(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofFbo, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofPixels_T_unsigned_char_t, 0)) {
          _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Fbo_readToPixels__SWIG_1(L);}  }  }  if (argc == 2) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofFbo, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofPixels_T_unsigned_short_t, 0)) {
          _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Fbo_readToPixels__SWIG_3(L);}  }  }  if (argc == 2) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofFbo, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofPixels_T_float_t, 0)) {
          _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Fbo_readToPixels__SWIG_5(L);}  }  }  if (argc == 3) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofFbo, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofPixels_T_unsigned_char_t, 0)) {
          _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_Fbo_readToPixels__SWIG_0(L);}  }  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofFbo, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofPixels_T_float_t, 0)) {
          _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_Fbo_readToPixels__SWIG_4(L);}  }  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofFbo, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofPixels_T_unsigned_short_t, 0)) {
          _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_Fbo_readToPixels__SWIG_2(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Fbo_readToPixels'\n" "  Possible C/C++ prototypes are:\n"
  "    ofFbo::readToPixels(ofPixels &,int) const\n" "    ofFbo::readToPixels(ofPixels &) const\n"
  "    ofFbo::readToPixels(ofShortPixels &,int) const\n" "    ofFbo::readToPixels(ofShortPixels &) const\n"
  "    ofFbo::readToPixels(ofFloatPixels &,int) const\n" "    ofFbo::readToPixels(ofFloatPixels &) const\n");
  lua_error(L);return 0; }
static int _wrap_Fbo_copyTo(lua_State* L) { int SWIG_arg = 0; ofFbo *arg1 = (ofFbo *) 0 ; ofBufferObject *arg2 = 0 ;
  SWIG_check_num_args("ofFbo::copyTo",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFbo::copyTo",1,"ofFbo const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofFbo::copyTo",2,"ofBufferObject &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFbo,0))){ SWIG_fail_ptr("Fbo_copyTo",1,SWIGTYPE_p_ofFbo); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofBufferObject,0))){
    SWIG_fail_ptr("Fbo_copyTo",2,SWIGTYPE_p_ofBufferObject); }  ((ofFbo const *)arg1)->copyTo(*arg2); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Fbo_getWidth(lua_State* L) { int SWIG_arg = 0; ofFbo *arg1 = (ofFbo *) 0 ; float result;
  SWIG_check_num_args("ofFbo::getWidth",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFbo::getWidth",1,"ofFbo const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFbo,0))){ SWIG_fail_ptr("Fbo_getWidth",1,SWIGTYPE_p_ofFbo); } 
  result = (float)((ofFbo const *)arg1)->getWidth(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Fbo_getHeight(lua_State* L) { int SWIG_arg = 0; ofFbo *arg1 = (ofFbo *) 0 ; float result;
  SWIG_check_num_args("ofFbo::getHeight",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFbo::getHeight",1,"ofFbo const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFbo,0))){ SWIG_fail_ptr("Fbo_getHeight",1,SWIGTYPE_p_ofFbo); } 
  result = (float)((ofFbo const *)arg1)->getHeight(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Fbo_bind(lua_State* L) { int SWIG_arg = 0; ofFbo *arg1 = (ofFbo *) 0 ; SWIG_check_num_args("ofFbo::bind",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFbo::bind",1,"ofFbo const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFbo,0))){ SWIG_fail_ptr("Fbo_bind",1,SWIGTYPE_p_ofFbo); } 
  ((ofFbo const *)arg1)->bind(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Fbo_unbind(lua_State* L) { int SWIG_arg = 0; ofFbo *arg1 = (ofFbo *) 0 ;
  SWIG_check_num_args("ofFbo::unbind",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFbo::unbind",1,"ofFbo const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFbo,0))){ SWIG_fail_ptr("Fbo_unbind",1,SWIGTYPE_p_ofFbo); } 
  ((ofFbo const *)arg1)->unbind(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Fbo_flagDirty(lua_State* L) { int SWIG_arg = 0; ofFbo *arg1 = (ofFbo *) 0 ;
  SWIG_check_num_args("ofFbo::flagDirty",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFbo::flagDirty",1,"ofFbo const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFbo,0))){ SWIG_fail_ptr("Fbo_flagDirty",1,SWIGTYPE_p_ofFbo); } 
  ((ofFbo const *)arg1)->flagDirty(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Fbo_updateTexture(lua_State* L) { int SWIG_arg = 0; ofFbo *arg1 = (ofFbo *) 0 ; int arg2 ;
  SWIG_check_num_args("ofFbo::updateTexture",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFbo::updateTexture",1,"ofFbo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofFbo::updateTexture",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFbo,0))){
    SWIG_fail_ptr("Fbo_updateTexture",1,SWIGTYPE_p_ofFbo); }  arg2 = (int)lua_tonumber(L, 2); (arg1)->updateTexture(arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Fbo_checkStatus(lua_State* L) { int SWIG_arg = 0; ofFbo *arg1 = (ofFbo *) 0 ; bool result;
  SWIG_check_num_args("ofFbo::checkStatus",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFbo::checkStatus",1,"ofFbo const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFbo,0))){ SWIG_fail_ptr("Fbo_checkStatus",1,SWIGTYPE_p_ofFbo); }
   result = (bool)((ofFbo const *)arg1)->checkStatus(); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Fbo_createAndAttachTexture(lua_State* L) { int SWIG_arg = 0; ofFbo *arg1 = (ofFbo *) 0 ; GLenum arg2 ;
  GLenum arg3 ; SWIG_check_num_args("ofFbo::createAndAttachTexture",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFbo::createAndAttachTexture",1,"ofFbo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofFbo::createAndAttachTexture",2,"GLenum");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofFbo::createAndAttachTexture",3,"GLenum");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFbo,0))){
    SWIG_fail_ptr("Fbo_createAndAttachTexture",1,SWIGTYPE_p_ofFbo); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (GLenum)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (GLenum)lua_tonumber(L, 3);
  (arg1)->createAndAttachTexture(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Fbo_attachTexture(lua_State* L) { int SWIG_arg = 0; ofFbo *arg1 = (ofFbo *) 0 ; ofTexture *arg2 = 0 ;
  GLenum arg3 ; GLenum arg4 ; SWIG_check_num_args("ofFbo::attachTexture",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFbo::attachTexture",1,"ofFbo *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofFbo::attachTexture",2,"ofTexture &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofFbo::attachTexture",3,"GLenum");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofFbo::attachTexture",4,"GLenum");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFbo,0))){
    SWIG_fail_ptr("Fbo_attachTexture",1,SWIGTYPE_p_ofFbo); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Fbo_attachTexture",2,SWIGTYPE_p_ofTexture); } 
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (GLenum)lua_tonumber(L, 3);
  SWIG_contract_assert((lua_tonumber(L,4)>=0),"number must not be negative") arg4 = (GLenum)lua_tonumber(L, 4);
  (arg1)->attachTexture(*arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Fbo_createAndAttachRenderbuffer(lua_State* L) { int SWIG_arg = 0; ofFbo *arg1 = (ofFbo *) 0 ; GLenum arg2 ;
  GLenum arg3 ; GLuint result; SWIG_check_num_args("ofFbo::createAndAttachRenderbuffer",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFbo::createAndAttachRenderbuffer",1,"ofFbo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofFbo::createAndAttachRenderbuffer",2,"GLenum");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofFbo::createAndAttachRenderbuffer",3,"GLenum");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFbo,0))){
    SWIG_fail_ptr("Fbo_createAndAttachRenderbuffer",1,SWIGTYPE_p_ofFbo); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (GLenum)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (GLenum)lua_tonumber(L, 3);
  result = (GLuint)(arg1)->createAndAttachRenderbuffer(arg2,arg3); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Fbo_createAndAttachDepthStencilTexture__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofFbo *arg1 = (ofFbo *) 0 ;
  GLenum arg2 ; GLint arg3 ; GLenum arg4 ; SWIG_check_num_args("ofFbo::createAndAttachDepthStencilTexture",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFbo::createAndAttachDepthStencilTexture",1,"ofFbo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofFbo::createAndAttachDepthStencilTexture",2,"GLenum");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofFbo::createAndAttachDepthStencilTexture",3,"GLint");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofFbo::createAndAttachDepthStencilTexture",4,"GLenum");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFbo,0))){
    SWIG_fail_ptr("Fbo_createAndAttachDepthStencilTexture",1,SWIGTYPE_p_ofFbo); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (GLenum)lua_tonumber(L, 2);
  arg3 = (GLint)lua_tonumber(L, 3); SWIG_contract_assert((lua_tonumber(L,4)>=0),"number must not be negative")
  arg4 = (GLenum)lua_tonumber(L, 4); (arg1)->createAndAttachDepthStencilTexture(arg2,arg3,arg4); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Fbo_createAndAttachDepthStencilTexture__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofFbo *arg1 = (ofFbo *) 0 ;
  GLenum arg2 ; GLint arg3 ; GLenum arg4 ; GLenum arg5 ; GLenum arg6 ;
  SWIG_check_num_args("ofFbo::createAndAttachDepthStencilTexture",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFbo::createAndAttachDepthStencilTexture",1,"ofFbo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofFbo::createAndAttachDepthStencilTexture",2,"GLenum");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofFbo::createAndAttachDepthStencilTexture",3,"GLint");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofFbo::createAndAttachDepthStencilTexture",4,"GLenum");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofFbo::createAndAttachDepthStencilTexture",5,"GLenum");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofFbo::createAndAttachDepthStencilTexture",6,"GLenum");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFbo,0))){
    SWIG_fail_ptr("Fbo_createAndAttachDepthStencilTexture",1,SWIGTYPE_p_ofFbo); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (GLenum)lua_tonumber(L, 2);
  arg3 = (GLint)lua_tonumber(L, 3); SWIG_contract_assert((lua_tonumber(L,4)>=0),"number must not be negative")
  arg4 = (GLenum)lua_tonumber(L, 4); SWIG_contract_assert((lua_tonumber(L,5)>=0),"number must not be negative")
  arg5 = (GLenum)lua_tonumber(L, 5); SWIG_contract_assert((lua_tonumber(L,6)>=0),"number must not be negative")
  arg6 = (GLenum)lua_tonumber(L, 6); (arg1)->createAndAttachDepthStencilTexture(arg2,arg3,arg4,arg5,arg6); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Fbo_createAndAttachDepthStencilTexture(lua_State* L) { int argc; int argv[7]={ 1,2,3,4,5,6,7} ;
  argc = lua_gettop(L); if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofFbo, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { {
            _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_Fbo_createAndAttachDepthStencilTexture__SWIG_0(L);}  }  }  }
     }  if (argc == 6) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofFbo, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { {
            _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) { {
                _v = lua_isnumber(L,argv[5]); }  if (_v) { return _wrap_Fbo_createAndAttachDepthStencilTexture__SWIG_1(L);}  }  }
           }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Fbo_createAndAttachDepthStencilTexture'\n"
  "  Possible C/C++ prototypes are:\n" "    ofFbo::createAndAttachDepthStencilTexture(GLenum,GLint,GLenum)\n"
  "    ofFbo::createAndAttachDepthStencilTexture(GLenum,GLint,GLenum,GLenum,GLenum)\n"); lua_error(L);return 0; }
static int _wrap_Fbo_getNumTextures(lua_State* L) { int SWIG_arg = 0; ofFbo *arg1 = (ofFbo *) 0 ; int result;
  SWIG_check_num_args("ofFbo::getNumTextures",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFbo::getNumTextures",1,"ofFbo const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFbo,0))){
    SWIG_fail_ptr("Fbo_getNumTextures",1,SWIGTYPE_p_ofFbo); }  result = (int)((ofFbo const *)arg1)->getNumTextures();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Fbo_setActiveDrawBuffer(lua_State* L) { int SWIG_arg = 0; ofFbo *arg1 = (ofFbo *) 0 ; int arg2 ;
  SWIG_check_num_args("ofFbo::setActiveDrawBuffer",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFbo::setActiveDrawBuffer",1,"ofFbo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofFbo::setActiveDrawBuffer",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFbo,0))){
    SWIG_fail_ptr("Fbo_setActiveDrawBuffer",1,SWIGTYPE_p_ofFbo); }  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setActiveDrawBuffer(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Fbo_setActiveDrawBuffers(lua_State* L) { int SWIG_arg = 0; ofFbo *arg1 = (ofFbo *) 0 ;
  std::vector< int > *arg2 = 0 ; SWIG_check_num_args("ofFbo::setActiveDrawBuffers",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFbo::setActiveDrawBuffers",1,"ofFbo *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofFbo::setActiveDrawBuffers",2,"std::vector< int > const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFbo,0))){
    SWIG_fail_ptr("Fbo_setActiveDrawBuffers",1,SWIGTYPE_p_ofFbo); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_std__vectorT_int_t,0))){
    SWIG_fail_ptr("Fbo_setActiveDrawBuffers",2,SWIGTYPE_p_std__vectorT_int_t); } 
  (arg1)->setActiveDrawBuffers((std::vector< int > const &)*arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Fbo_activateAllDrawBuffers(lua_State* L) { int SWIG_arg = 0; ofFbo *arg1 = (ofFbo *) 0 ;
  SWIG_check_num_args("ofFbo::activateAllDrawBuffers",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFbo::activateAllDrawBuffers",1,"ofFbo *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFbo,0))){
    SWIG_fail_ptr("Fbo_activateAllDrawBuffers",1,SWIGTYPE_p_ofFbo); }  (arg1)->activateAllDrawBuffers(); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Fbo_getId(lua_State* L) { int SWIG_arg = 0; ofFbo *arg1 = (ofFbo *) 0 ; GLuint result;
  SWIG_check_num_args("ofFbo::getId",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFbo::getId",1,"ofFbo const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFbo,0))){ SWIG_fail_ptr("Fbo_getId",1,SWIGTYPE_p_ofFbo); } 
  result = (GLuint)((ofFbo const *)arg1)->getId(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Fbo_getIdDrawBuffer(lua_State* L) { int SWIG_arg = 0; ofFbo *arg1 = (ofFbo *) 0 ; GLuint result;
  SWIG_check_num_args("ofFbo::getIdDrawBuffer",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFbo::getIdDrawBuffer",1,"ofFbo const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFbo,0))){
    SWIG_fail_ptr("Fbo_getIdDrawBuffer",1,SWIGTYPE_p_ofFbo); }  result = (GLuint)((ofFbo const *)arg1)->getIdDrawBuffer();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Fbo_checkGLSupport(lua_State* L) { int SWIG_arg = 0; bool result;
  SWIG_check_num_args("ofFbo::checkGLSupport",0,0) result = (bool)ofFbo::checkGLSupport();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Fbo_maxColorAttachments(lua_State* L) { int SWIG_arg = 0; int result;
  SWIG_check_num_args("ofFbo::maxColorAttachments",0,0) result = (int)ofFbo::maxColorAttachments();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Fbo_maxDrawBuffers(lua_State* L) { int SWIG_arg = 0; int result;
  SWIG_check_num_args("ofFbo::maxDrawBuffers",0,0) result = (int)ofFbo::maxDrawBuffers();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Fbo_maxSamples(lua_State* L) { int SWIG_arg = 0; int result; SWIG_check_num_args("ofFbo::maxSamples",0,0)
  result = (int)ofFbo::maxSamples(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Fbo_getDepthBuffer(lua_State* L) { int SWIG_arg = 0; ofFbo *arg1 = (ofFbo *) 0 ; GLuint result;
  SWIG_check_num_args("ofFbo::getDepthBuffer",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFbo::getDepthBuffer",1,"ofFbo const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFbo,0))){
    SWIG_fail_ptr("Fbo_getDepthBuffer",1,SWIGTYPE_p_ofFbo); }  result = (GLuint)((ofFbo const *)arg1)->getDepthBuffer();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Fbo_getStencilBuffer(lua_State* L) { int SWIG_arg = 0; ofFbo *arg1 = (ofFbo *) 0 ; GLuint result;
  SWIG_check_num_args("ofFbo::getStencilBuffer",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFbo::getStencilBuffer",1,"ofFbo const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFbo,0))){
    SWIG_fail_ptr("Fbo_getStencilBuffer",1,SWIGTYPE_p_ofFbo); }  result = (GLuint)((ofFbo const *)arg1)->getStencilBuffer();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static void swig_delete_Fbo(void *obj) {
ofFbo *arg1 = (ofFbo *) obj;
delete arg1;
}
static int _proxy__wrap_new_Fbo(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_Fbo);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_Fbo_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_Fbo_methods[]= {
    { "allocate", _wrap_Fbo_allocate},
    { "isAllocated", _wrap_Fbo_isAllocated},
    { "clear", _wrap_Fbo_clear},
    { "clearColorBuffer", _wrap_Fbo_clearColorBuffer},
    { "clearDepthBuffer", _wrap_Fbo_clearDepthBuffer},
    { "clearStencilBuffer", _wrap_Fbo_clearStencilBuffer},
    { "clearDepthStencilBuffer", _wrap_Fbo_clearDepthStencilBuffer},
    { "draw", _wrap_Fbo_draw},
    { "setAnchorPercent", _wrap_Fbo_setAnchorPercent},
    { "setAnchorPoint", _wrap_Fbo_setAnchorPoint},
    { "resetAnchor", _wrap_Fbo_resetAnchor},
    { "setDefaultTextureIndex", _wrap_Fbo_setDefaultTextureIndex},
    { "getDefaultTextureIndex", _wrap_Fbo_getDefaultTextureIndex},
    { "getTexture", _wrap_Fbo_getTexture},
    { "getDepthTexture", _wrap_Fbo_getDepthTexture},
    { "beginFbo", _wrap_Fbo_beginFbo},
    { "endFbo", _wrap_Fbo_endFbo},
    { "readToPixels", _wrap_Fbo_readToPixels},
    { "copyTo", _wrap_Fbo_copyTo},
    { "getWidth", _wrap_Fbo_getWidth},
    { "getHeight", _wrap_Fbo_getHeight},
    { "bind", _wrap_Fbo_bind},
    { "unbind", _wrap_Fbo_unbind},
    { "flagDirty", _wrap_Fbo_flagDirty},
    { "updateTexture", _wrap_Fbo_updateTexture},
    { "checkStatus", _wrap_Fbo_checkStatus},
    { "createAndAttachTexture", _wrap_Fbo_createAndAttachTexture},
    { "attachTexture", _wrap_Fbo_attachTexture},
    { "createAndAttachRenderbuffer", _wrap_Fbo_createAndAttachRenderbuffer},
    { "createAndAttachDepthStencilTexture", _wrap_Fbo_createAndAttachDepthStencilTexture},
    { "getNumTextures", _wrap_Fbo_getNumTextures},
    { "setActiveDrawBuffer", _wrap_Fbo_setActiveDrawBuffer},
    { "setActiveDrawBuffers", _wrap_Fbo_setActiveDrawBuffers},
    { "activateAllDrawBuffers", _wrap_Fbo_activateAllDrawBuffers},
    { "getId", _wrap_Fbo_getId},
    { "getIdDrawBuffer", _wrap_Fbo_getIdDrawBuffer},
    { "getDepthBuffer", _wrap_Fbo_getDepthBuffer},
    { "getStencilBuffer", _wrap_Fbo_getStencilBuffer},
    {0,0}
};
static swig_lua_method swig_Fbo_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_Fbo_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_Fbo_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_Fbo_Sf_SwigStatic_methods[]= {
    { "checkGLSupport", _wrap_Fbo_checkGLSupport},
    { "maxColorAttachments", _wrap_Fbo_maxColorAttachments},
    { "maxDrawBuffers", _wrap_Fbo_maxDrawBuffers},
    { "maxSamples", _wrap_Fbo_maxSamples},
    {0,0}
};
static swig_lua_class* swig_Fbo_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_Fbo_Sf_SwigStatic = {
    "Fbo",
    swig_Fbo_Sf_SwigStatic_methods,
    swig_Fbo_Sf_SwigStatic_attributes,
    swig_Fbo_Sf_SwigStatic_constants,
    swig_Fbo_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_Fbo_bases[] = {0};
static const char *swig_Fbo_base_names[] = {0};
static swig_lua_class _wrap_class_Fbo = { "Fbo", "Fbo", &SWIGTYPE_p_ofFbo,_proxy__wrap_new_Fbo, swig_delete_Fbo, swig_Fbo_methods, swig_Fbo_attributes, &swig_Fbo_Sf_SwigStatic, swig_Fbo_meta, swig_Fbo_bases, swig_Fbo_base_names };

static int _wrap_getUsingArbTex(lua_State* L) { int SWIG_arg = 0; bool result; SWIG_check_num_args("ofGetUsingArbTex",0,0)
  result = (bool)ofGetUsingArbTex(); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_enableArbTex(lua_State* L) { int SWIG_arg = 0; SWIG_check_num_args("ofEnableArbTex",0,0) ofEnableArbTex();
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_disableArbTex(lua_State* L) { int SWIG_arg = 0; SWIG_check_num_args("ofDisableArbTex",0,0) ofDisableArbTex();
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_getUsingNormalizedTexCoords(lua_State* L) { int SWIG_arg = 0; bool result;
  SWIG_check_num_args("ofGetUsingNormalizedTexCoords",0,0) result = (bool)ofGetUsingNormalizedTexCoords();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_enableNormalizedTexCoords(lua_State* L) { int SWIG_arg = 0;
  SWIG_check_num_args("ofEnableNormalizedTexCoords",0,0) ofEnableNormalizedTexCoords(); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_disableNormalizedTexCoords(lua_State* L) { int SWIG_arg = 0;
  SWIG_check_num_args("ofDisableNormalizedTexCoords",0,0) ofDisableNormalizedTexCoords(); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_new_TextureData(lua_State* L) { int SWIG_arg = 0; ofTextureData *result = 0 ;
  SWIG_check_num_args("ofTextureData::ofTextureData",0,0) result = (ofTextureData *)new ofTextureData();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofTextureData,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_TextureData_textureID_set(lua_State* L) { int SWIG_arg = 0; ofTextureData *arg1 = (ofTextureData *) 0 ;
  unsigned int arg2 ; SWIG_check_num_args("ofTextureData::textureID",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTextureData::textureID",1,"ofTextureData *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofTextureData::textureID",2,"unsigned int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTextureData,0))){
    SWIG_fail_ptr("TextureData_textureID_set",1,SWIGTYPE_p_ofTextureData); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->textureID = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TextureData_textureID_get(lua_State* L) { int SWIG_arg = 0; ofTextureData *arg1 = (ofTextureData *) 0 ;
  unsigned int result; SWIG_check_num_args("ofTextureData::textureID",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTextureData::textureID",1,"ofTextureData *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTextureData,0))){
    SWIG_fail_ptr("TextureData_textureID_get",1,SWIGTYPE_p_ofTextureData); }  result = (unsigned int) ((arg1)->textureID);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TextureData_textureTarget_set(lua_State* L) { int SWIG_arg = 0; ofTextureData *arg1 = (ofTextureData *) 0 ;
  int arg2 ; SWIG_check_num_args("ofTextureData::textureTarget",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTextureData::textureTarget",1,"ofTextureData *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofTextureData::textureTarget",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTextureData,0))){
    SWIG_fail_ptr("TextureData_textureTarget_set",1,SWIGTYPE_p_ofTextureData); }  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->textureTarget = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TextureData_textureTarget_get(lua_State* L) { int SWIG_arg = 0; ofTextureData *arg1 = (ofTextureData *) 0 ;
  int result; SWIG_check_num_args("ofTextureData::textureTarget",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTextureData::textureTarget",1,"ofTextureData *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTextureData,0))){
    SWIG_fail_ptr("TextureData_textureTarget_get",1,SWIGTYPE_p_ofTextureData); }  result = (int) ((arg1)->textureTarget);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TextureData_glInternalFormat_set(lua_State* L) { int SWIG_arg = 0; ofTextureData *arg1 = (ofTextureData *) 0 ;
  int arg2 ; SWIG_check_num_args("ofTextureData::glInternalFormat",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTextureData::glInternalFormat",1,"ofTextureData *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofTextureData::glInternalFormat",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTextureData,0))){
    SWIG_fail_ptr("TextureData_glInternalFormat_set",1,SWIGTYPE_p_ofTextureData); }  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->glInternalFormat = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TextureData_glInternalFormat_get(lua_State* L) { int SWIG_arg = 0; ofTextureData *arg1 = (ofTextureData *) 0 ;
  int result; SWIG_check_num_args("ofTextureData::glInternalFormat",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTextureData::glInternalFormat",1,"ofTextureData *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTextureData,0))){
    SWIG_fail_ptr("TextureData_glInternalFormat_get",1,SWIGTYPE_p_ofTextureData); }  result = (int) ((arg1)->glInternalFormat);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TextureData_tex_t_set(lua_State* L) { int SWIG_arg = 0; ofTextureData *arg1 = (ofTextureData *) 0 ;
  float arg2 ; SWIG_check_num_args("ofTextureData::tex_t",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTextureData::tex_t",1,"ofTextureData *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofTextureData::tex_t",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTextureData,0))){
    SWIG_fail_ptr("TextureData_tex_t_set",1,SWIGTYPE_p_ofTextureData); }  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->tex_t = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TextureData_tex_t_get(lua_State* L) { int SWIG_arg = 0; ofTextureData *arg1 = (ofTextureData *) 0 ;
  float result; SWIG_check_num_args("ofTextureData::tex_t",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTextureData::tex_t",1,"ofTextureData *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTextureData,0))){
    SWIG_fail_ptr("TextureData_tex_t_get",1,SWIGTYPE_p_ofTextureData); }  result = (float) ((arg1)->tex_t);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TextureData_tex_u_set(lua_State* L) { int SWIG_arg = 0; ofTextureData *arg1 = (ofTextureData *) 0 ;
  float arg2 ; SWIG_check_num_args("ofTextureData::tex_u",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTextureData::tex_u",1,"ofTextureData *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofTextureData::tex_u",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTextureData,0))){
    SWIG_fail_ptr("TextureData_tex_u_set",1,SWIGTYPE_p_ofTextureData); }  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->tex_u = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TextureData_tex_u_get(lua_State* L) { int SWIG_arg = 0; ofTextureData *arg1 = (ofTextureData *) 0 ;
  float result; SWIG_check_num_args("ofTextureData::tex_u",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTextureData::tex_u",1,"ofTextureData *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTextureData,0))){
    SWIG_fail_ptr("TextureData_tex_u_get",1,SWIGTYPE_p_ofTextureData); }  result = (float) ((arg1)->tex_u);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TextureData_tex_w_set(lua_State* L) { int SWIG_arg = 0; ofTextureData *arg1 = (ofTextureData *) 0 ;
  float arg2 ; SWIG_check_num_args("ofTextureData::tex_w",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTextureData::tex_w",1,"ofTextureData *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofTextureData::tex_w",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTextureData,0))){
    SWIG_fail_ptr("TextureData_tex_w_set",1,SWIGTYPE_p_ofTextureData); }  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->tex_w = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TextureData_tex_w_get(lua_State* L) { int SWIG_arg = 0; ofTextureData *arg1 = (ofTextureData *) 0 ;
  float result; SWIG_check_num_args("ofTextureData::tex_w",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTextureData::tex_w",1,"ofTextureData *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTextureData,0))){
    SWIG_fail_ptr("TextureData_tex_w_get",1,SWIGTYPE_p_ofTextureData); }  result = (float) ((arg1)->tex_w);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TextureData_tex_h_set(lua_State* L) { int SWIG_arg = 0; ofTextureData *arg1 = (ofTextureData *) 0 ;
  float arg2 ; SWIG_check_num_args("ofTextureData::tex_h",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTextureData::tex_h",1,"ofTextureData *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofTextureData::tex_h",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTextureData,0))){
    SWIG_fail_ptr("TextureData_tex_h_set",1,SWIGTYPE_p_ofTextureData); }  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->tex_h = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TextureData_tex_h_get(lua_State* L) { int SWIG_arg = 0; ofTextureData *arg1 = (ofTextureData *) 0 ;
  float result; SWIG_check_num_args("ofTextureData::tex_h",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTextureData::tex_h",1,"ofTextureData *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTextureData,0))){
    SWIG_fail_ptr("TextureData_tex_h_get",1,SWIGTYPE_p_ofTextureData); }  result = (float) ((arg1)->tex_h);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TextureData_width_set(lua_State* L) { int SWIG_arg = 0; ofTextureData *arg1 = (ofTextureData *) 0 ;
  float arg2 ; SWIG_check_num_args("ofTextureData::width",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTextureData::width",1,"ofTextureData *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofTextureData::width",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTextureData,0))){
    SWIG_fail_ptr("TextureData_width_set",1,SWIGTYPE_p_ofTextureData); }  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->width = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TextureData_width_get(lua_State* L) { int SWIG_arg = 0; ofTextureData *arg1 = (ofTextureData *) 0 ;
  float result; SWIG_check_num_args("ofTextureData::width",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTextureData::width",1,"ofTextureData *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTextureData,0))){
    SWIG_fail_ptr("TextureData_width_get",1,SWIGTYPE_p_ofTextureData); }  result = (float) ((arg1)->width);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TextureData_height_set(lua_State* L) { int SWIG_arg = 0; ofTextureData *arg1 = (ofTextureData *) 0 ;
  float arg2 ; SWIG_check_num_args("ofTextureData::height",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTextureData::height",1,"ofTextureData *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofTextureData::height",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTextureData,0))){
    SWIG_fail_ptr("TextureData_height_set",1,SWIGTYPE_p_ofTextureData); }  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->height = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TextureData_height_get(lua_State* L) { int SWIG_arg = 0; ofTextureData *arg1 = (ofTextureData *) 0 ;
  float result; SWIG_check_num_args("ofTextureData::height",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTextureData::height",1,"ofTextureData *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTextureData,0))){
    SWIG_fail_ptr("TextureData_height_get",1,SWIGTYPE_p_ofTextureData); }  result = (float) ((arg1)->height);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TextureData_bFlipTexture_set(lua_State* L) { int SWIG_arg = 0; ofTextureData *arg1 = (ofTextureData *) 0 ;
  bool arg2 ; SWIG_check_num_args("ofTextureData::bFlipTexture",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTextureData::bFlipTexture",1,"ofTextureData *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofTextureData::bFlipTexture",2,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTextureData,0))){
    SWIG_fail_ptr("TextureData_bFlipTexture_set",1,SWIGTYPE_p_ofTextureData); }  arg2 = (lua_toboolean(L, 2)!=0);
  if (arg1) (arg1)->bFlipTexture = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TextureData_bFlipTexture_get(lua_State* L) { int SWIG_arg = 0; ofTextureData *arg1 = (ofTextureData *) 0 ;
  bool result; SWIG_check_num_args("ofTextureData::bFlipTexture",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTextureData::bFlipTexture",1,"ofTextureData *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTextureData,0))){
    SWIG_fail_ptr("TextureData_bFlipTexture_get",1,SWIGTYPE_p_ofTextureData); }  result = (bool) ((arg1)->bFlipTexture);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TextureData_compressionType_set(lua_State* L) { int SWIG_arg = 0; ofTextureData *arg1 = (ofTextureData *) 0 ;
  ofTexCompression arg2 ; SWIG_check_num_args("ofTextureData::compressionType",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTextureData::compressionType",1,"ofTextureData *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofTextureData::compressionType",2,"ofTexCompression");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTextureData,0))){
    SWIG_fail_ptr("TextureData_compressionType_set",1,SWIGTYPE_p_ofTextureData); } 
  arg2 = (ofTexCompression)(int)lua_tonumber(L, 2); if (arg1) (arg1)->compressionType = arg2; return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_TextureData_compressionType_get(lua_State* L) { int SWIG_arg = 0; ofTextureData *arg1 = (ofTextureData *) 0 ;
  ofTexCompression result; SWIG_check_num_args("ofTextureData::compressionType",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTextureData::compressionType",1,"ofTextureData *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTextureData,0))){
    SWIG_fail_ptr("TextureData_compressionType_get",1,SWIGTYPE_p_ofTextureData); } 
  result = (ofTexCompression) ((arg1)->compressionType); lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TextureData_bAllocated_set(lua_State* L) { int SWIG_arg = 0; ofTextureData *arg1 = (ofTextureData *) 0 ;
  bool arg2 ; SWIG_check_num_args("ofTextureData::bAllocated",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTextureData::bAllocated",1,"ofTextureData *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofTextureData::bAllocated",2,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTextureData,0))){
    SWIG_fail_ptr("TextureData_bAllocated_set",1,SWIGTYPE_p_ofTextureData); }  arg2 = (lua_toboolean(L, 2)!=0);
  if (arg1) (arg1)->bAllocated = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TextureData_bAllocated_get(lua_State* L) { int SWIG_arg = 0; ofTextureData *arg1 = (ofTextureData *) 0 ;
  bool result; SWIG_check_num_args("ofTextureData::bAllocated",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTextureData::bAllocated",1,"ofTextureData *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTextureData,0))){
    SWIG_fail_ptr("TextureData_bAllocated_get",1,SWIGTYPE_p_ofTextureData); }  result = (bool) ((arg1)->bAllocated);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TextureData_minFilter_set(lua_State* L) { int SWIG_arg = 0; ofTextureData *arg1 = (ofTextureData *) 0 ;
  GLint arg2 ; SWIG_check_num_args("ofTextureData::minFilter",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTextureData::minFilter",1,"ofTextureData *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofTextureData::minFilter",2,"GLint");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTextureData,0))){
    SWIG_fail_ptr("TextureData_minFilter_set",1,SWIGTYPE_p_ofTextureData); }  arg2 = (GLint)lua_tonumber(L, 2);
  if (arg1) (arg1)->minFilter = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TextureData_minFilter_get(lua_State* L) { int SWIG_arg = 0; ofTextureData *arg1 = (ofTextureData *) 0 ;
  GLint result; SWIG_check_num_args("ofTextureData::minFilter",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTextureData::minFilter",1,"ofTextureData *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTextureData,0))){
    SWIG_fail_ptr("TextureData_minFilter_get",1,SWIGTYPE_p_ofTextureData); }  result = (GLint) ((arg1)->minFilter);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TextureData_magFilter_set(lua_State* L) { int SWIG_arg = 0; ofTextureData *arg1 = (ofTextureData *) 0 ;
  GLint arg2 ; SWIG_check_num_args("ofTextureData::magFilter",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTextureData::magFilter",1,"ofTextureData *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofTextureData::magFilter",2,"GLint");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTextureData,0))){
    SWIG_fail_ptr("TextureData_magFilter_set",1,SWIGTYPE_p_ofTextureData); }  arg2 = (GLint)lua_tonumber(L, 2);
  if (arg1) (arg1)->magFilter = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TextureData_magFilter_get(lua_State* L) { int SWIG_arg = 0; ofTextureData *arg1 = (ofTextureData *) 0 ;
  GLint result; SWIG_check_num_args("ofTextureData::magFilter",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTextureData::magFilter",1,"ofTextureData *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTextureData,0))){
    SWIG_fail_ptr("TextureData_magFilter_get",1,SWIGTYPE_p_ofTextureData); }  result = (GLint) ((arg1)->magFilter);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TextureData_wrapModeHorizontal_set(lua_State* L) { int SWIG_arg = 0;
  ofTextureData *arg1 = (ofTextureData *) 0 ; GLint arg2 ; SWIG_check_num_args("ofTextureData::wrapModeHorizontal",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTextureData::wrapModeHorizontal",1,"ofTextureData *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofTextureData::wrapModeHorizontal",2,"GLint");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTextureData,0))){
    SWIG_fail_ptr("TextureData_wrapModeHorizontal_set",1,SWIGTYPE_p_ofTextureData); }  arg2 = (GLint)lua_tonumber(L, 2);
  if (arg1) (arg1)->wrapModeHorizontal = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TextureData_wrapModeHorizontal_get(lua_State* L) { int SWIG_arg = 0;
  ofTextureData *arg1 = (ofTextureData *) 0 ; GLint result; SWIG_check_num_args("ofTextureData::wrapModeHorizontal",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTextureData::wrapModeHorizontal",1,"ofTextureData *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTextureData,0))){
    SWIG_fail_ptr("TextureData_wrapModeHorizontal_get",1,SWIGTYPE_p_ofTextureData); } 
  result = (GLint) ((arg1)->wrapModeHorizontal); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TextureData_wrapModeVertical_set(lua_State* L) { int SWIG_arg = 0; ofTextureData *arg1 = (ofTextureData *) 0 ;
  GLint arg2 ; SWIG_check_num_args("ofTextureData::wrapModeVertical",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTextureData::wrapModeVertical",1,"ofTextureData *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofTextureData::wrapModeVertical",2,"GLint");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTextureData,0))){
    SWIG_fail_ptr("TextureData_wrapModeVertical_set",1,SWIGTYPE_p_ofTextureData); }  arg2 = (GLint)lua_tonumber(L, 2);
  if (arg1) (arg1)->wrapModeVertical = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TextureData_wrapModeVertical_get(lua_State* L) { int SWIG_arg = 0; ofTextureData *arg1 = (ofTextureData *) 0 ;
  GLint result; SWIG_check_num_args("ofTextureData::wrapModeVertical",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTextureData::wrapModeVertical",1,"ofTextureData *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTextureData,0))){
    SWIG_fail_ptr("TextureData_wrapModeVertical_get",1,SWIGTYPE_p_ofTextureData); } 
  result = (GLint) ((arg1)->wrapModeVertical); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TextureData_bufferId_set(lua_State* L) { int SWIG_arg = 0; ofTextureData *arg1 = (ofTextureData *) 0 ;
  unsigned int arg2 ; SWIG_check_num_args("ofTextureData::bufferId",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTextureData::bufferId",1,"ofTextureData *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofTextureData::bufferId",2,"unsigned int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTextureData,0))){
    SWIG_fail_ptr("TextureData_bufferId_set",1,SWIGTYPE_p_ofTextureData); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->bufferId = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TextureData_bufferId_get(lua_State* L) { int SWIG_arg = 0; ofTextureData *arg1 = (ofTextureData *) 0 ;
  unsigned int result; SWIG_check_num_args("ofTextureData::bufferId",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTextureData::bufferId",1,"ofTextureData *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTextureData,0))){
    SWIG_fail_ptr("TextureData_bufferId_get",1,SWIGTYPE_p_ofTextureData); }  result = (unsigned int) ((arg1)->bufferId);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static void swig_delete_TextureData(void *obj) {
ofTextureData *arg1 = (ofTextureData *) obj;
delete arg1;
}
static int _proxy__wrap_new_TextureData(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_TextureData);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_TextureData_attributes[] = {
    { "textureID", _wrap_TextureData_textureID_get, _wrap_TextureData_textureID_set },
    { "textureTarget", _wrap_TextureData_textureTarget_get, _wrap_TextureData_textureTarget_set },
    { "glInternalFormat", _wrap_TextureData_glInternalFormat_get, _wrap_TextureData_glInternalFormat_set },
    { "tex_t", _wrap_TextureData_tex_t_get, _wrap_TextureData_tex_t_set },
    { "tex_u", _wrap_TextureData_tex_u_get, _wrap_TextureData_tex_u_set },
    { "tex_w", _wrap_TextureData_tex_w_get, _wrap_TextureData_tex_w_set },
    { "tex_h", _wrap_TextureData_tex_h_get, _wrap_TextureData_tex_h_set },
    { "width", _wrap_TextureData_width_get, _wrap_TextureData_width_set },
    { "height", _wrap_TextureData_height_get, _wrap_TextureData_height_set },
    { "bFlipTexture", _wrap_TextureData_bFlipTexture_get, _wrap_TextureData_bFlipTexture_set },
    { "compressionType", _wrap_TextureData_compressionType_get, _wrap_TextureData_compressionType_set },
    { "bAllocated", _wrap_TextureData_bAllocated_get, _wrap_TextureData_bAllocated_set },
    { "minFilter", _wrap_TextureData_minFilter_get, _wrap_TextureData_minFilter_set },
    { "magFilter", _wrap_TextureData_magFilter_get, _wrap_TextureData_magFilter_set },
    { "wrapModeHorizontal", _wrap_TextureData_wrapModeHorizontal_get, _wrap_TextureData_wrapModeHorizontal_set },
    { "wrapModeVertical", _wrap_TextureData_wrapModeVertical_get, _wrap_TextureData_wrapModeVertical_set },
    { "bufferId", _wrap_TextureData_bufferId_get, _wrap_TextureData_bufferId_set },
    {0,0,0}
};
static swig_lua_method swig_TextureData_methods[]= {
    {0,0}
};
static swig_lua_method swig_TextureData_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_TextureData_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_TextureData_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_TextureData_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_TextureData_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_TextureData_Sf_SwigStatic = {
    "TextureData",
    swig_TextureData_Sf_SwigStatic_methods,
    swig_TextureData_Sf_SwigStatic_attributes,
    swig_TextureData_Sf_SwigStatic_constants,
    swig_TextureData_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_TextureData_bases[] = {0};
static const char *swig_TextureData_base_names[] = {0};
static swig_lua_class _wrap_class_TextureData = { "TextureData", "TextureData", &SWIGTYPE_p_ofTextureData,_proxy__wrap_new_TextureData, swig_delete_TextureData, swig_TextureData_methods, swig_TextureData_attributes, &swig_TextureData_Sf_SwigStatic, swig_TextureData_meta, swig_TextureData_bases, swig_TextureData_base_names };

static int _wrap_enableTextureEdgeHack(lua_State* L) { int SWIG_arg = 0; SWIG_check_num_args("ofEnableTextureEdgeHack",0,0)
  ofEnableTextureEdgeHack(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_disableTextureEdgeHack(lua_State* L) { int SWIG_arg = 0; SWIG_check_num_args("ofDisableTextureEdgeHack",0,0)
  ofDisableTextureEdgeHack(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_isTextureEdgeHackEnabled(lua_State* L) { int SWIG_arg = 0; bool result;
  SWIG_check_num_args("ofIsTextureEdgeHackEnabled",0,0) result = (bool)ofIsTextureEdgeHackEnabled();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_new_Texture__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofTexture *result = 0 ;
  SWIG_check_num_args("ofTexture::ofTexture",0,0) result = (ofTexture *)new ofTexture();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofTexture,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_Texture__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = 0 ; ofTexture *result = 0 ;
  SWIG_check_num_args("ofTexture::ofTexture",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofTexture::ofTexture",1,"ofTexture &&");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("new_Texture",1,SWIGTYPE_p_ofTexture); }  result = (ofTexture *)new ofTexture((ofTexture &&)*arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofTexture,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_Texture(lua_State* L) { int argc; int argv[2]={ 1,2} ; argc = lua_gettop(L); if (argc == 0) {
    return _wrap_new_Texture__SWIG_0(L);}  if (argc == 1) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofTexture, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { return _wrap_new_Texture__SWIG_1(L);}  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_Texture'\n" "  Possible C/C++ prototypes are:\n"
  "    ofTexture::ofTexture()\n" "    ofTexture::ofTexture(ofTexture &&)\n"); lua_error(L);return 0; }
static int _wrap_Texture_allocate__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ;
  ofTextureData *arg2 = 0 ; SWIG_check_num_args("ofTexture::allocate",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::allocate",1,"ofTexture *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofTexture::allocate",2,"ofTextureData const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_allocate",1,SWIGTYPE_p_ofTexture); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofTextureData,0))){
    SWIG_fail_ptr("Texture_allocate",2,SWIGTYPE_p_ofTextureData); }  (arg1)->allocate((ofTextureData const &)*arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Texture_allocate__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ;
  ofTextureData *arg2 = 0 ; int arg3 ; int arg4 ; SWIG_check_num_args("ofTexture::allocate",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::allocate",1,"ofTexture *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofTexture::allocate",2,"ofTextureData const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofTexture::allocate",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofTexture::allocate",4,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_allocate",1,SWIGTYPE_p_ofTexture); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofTextureData,0))){
    SWIG_fail_ptr("Texture_allocate",2,SWIGTYPE_p_ofTextureData); }  arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4); (arg1)->allocate((ofTextureData const &)*arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Texture_allocate__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ; int arg2 ;
  int arg3 ; int arg4 ; SWIG_check_num_args("ofTexture::allocate",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::allocate",1,"ofTexture *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofTexture::allocate",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofTexture::allocate",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofTexture::allocate",4,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_allocate",1,SWIGTYPE_p_ofTexture); }  arg2 = (int)lua_tonumber(L, 2); arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4); (arg1)->allocate(arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Texture_allocate__SWIG_3(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ; int arg2 ;
  int arg3 ; int arg4 ; int arg5 ; int arg6 ; SWIG_check_num_args("ofTexture::allocate",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::allocate",1,"ofTexture *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofTexture::allocate",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofTexture::allocate",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofTexture::allocate",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofTexture::allocate",5,"int");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofTexture::allocate",6,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_allocate",1,SWIGTYPE_p_ofTexture); }  arg2 = (int)lua_tonumber(L, 2); arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4); arg5 = (int)lua_tonumber(L, 5); arg6 = (int)lua_tonumber(L, 6);
  (arg1)->allocate(arg2,arg3,arg4,arg5,arg6); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Texture_allocate__SWIG_4(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ; int arg2 ;
  int arg3 ; int arg4 ; bool arg5 ; SWIG_check_num_args("ofTexture::allocate",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::allocate",1,"ofTexture *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofTexture::allocate",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofTexture::allocate",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofTexture::allocate",4,"int");
  if(!lua_isboolean(L,5)) SWIG_fail_arg("ofTexture::allocate",5,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_allocate",1,SWIGTYPE_p_ofTexture); }  arg2 = (int)lua_tonumber(L, 2); arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4); arg5 = (lua_toboolean(L, 5)!=0); (arg1)->allocate(arg2,arg3,arg4,arg5); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Texture_allocate__SWIG_5(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ; int arg2 ;
  int arg3 ; int arg4 ; bool arg5 ; int arg6 ; int arg7 ; SWIG_check_num_args("ofTexture::allocate",7,7)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::allocate",1,"ofTexture *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofTexture::allocate",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofTexture::allocate",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofTexture::allocate",4,"int");
  if(!lua_isboolean(L,5)) SWIG_fail_arg("ofTexture::allocate",5,"bool");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofTexture::allocate",6,"int");
  if(!lua_isnumber(L,7)) SWIG_fail_arg("ofTexture::allocate",7,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_allocate",1,SWIGTYPE_p_ofTexture); }  arg2 = (int)lua_tonumber(L, 2); arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4); arg5 = (lua_toboolean(L, 5)!=0); arg6 = (int)lua_tonumber(L, 6);
  arg7 = (int)lua_tonumber(L, 7); (arg1)->allocate(arg2,arg3,arg4,arg5,arg6,arg7); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Texture_allocate__SWIG_6(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ;
  ofPixels *arg2 = 0 ; SWIG_check_num_args("ofTexture::allocate",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::allocate",1,"ofTexture *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofTexture::allocate",2,"ofPixels const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_allocate",1,SWIGTYPE_p_ofTexture); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Texture_allocate",2,SWIGTYPE_p_ofPixels_T_unsigned_char_t); }  (arg1)->allocate((ofPixels const &)*arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Texture_allocate__SWIG_7(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ;
  ofPixels *arg2 = 0 ; bool arg3 ; SWIG_check_num_args("ofTexture::allocate",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::allocate",1,"ofTexture *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofTexture::allocate",2,"ofPixels const &");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("ofTexture::allocate",3,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_allocate",1,SWIGTYPE_p_ofTexture); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Texture_allocate",2,SWIGTYPE_p_ofPixels_T_unsigned_char_t); }  arg3 = (lua_toboolean(L, 3)!=0);
  (arg1)->allocate((ofPixels const &)*arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Texture_allocate__SWIG_8(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ;
  ofShortPixels *arg2 = 0 ; SWIG_check_num_args("ofTexture::allocate",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::allocate",1,"ofTexture *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofTexture::allocate",2,"ofShortPixels const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_allocate",1,SWIGTYPE_p_ofTexture); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofPixels_T_unsigned_short_t,0))){
    SWIG_fail_ptr("Texture_allocate",2,SWIGTYPE_p_ofPixels_T_unsigned_short_t); } 
  (arg1)->allocate((ofShortPixels const &)*arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Texture_allocate__SWIG_9(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ;
  ofShortPixels *arg2 = 0 ; bool arg3 ; SWIG_check_num_args("ofTexture::allocate",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::allocate",1,"ofTexture *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofTexture::allocate",2,"ofShortPixels const &");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("ofTexture::allocate",3,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_allocate",1,SWIGTYPE_p_ofTexture); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofPixels_T_unsigned_short_t,0))){
    SWIG_fail_ptr("Texture_allocate",2,SWIGTYPE_p_ofPixels_T_unsigned_short_t); }  arg3 = (lua_toboolean(L, 3)!=0);
  (arg1)->allocate((ofShortPixels const &)*arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Texture_allocate__SWIG_10(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ;
  ofFloatPixels *arg2 = 0 ; SWIG_check_num_args("ofTexture::allocate",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::allocate",1,"ofTexture *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofTexture::allocate",2,"ofFloatPixels const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_allocate",1,SWIGTYPE_p_ofTexture); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofPixels_T_float_t,0))){
    SWIG_fail_ptr("Texture_allocate",2,SWIGTYPE_p_ofPixels_T_float_t); }  (arg1)->allocate((ofFloatPixels const &)*arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Texture_allocate__SWIG_11(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ;
  ofFloatPixels *arg2 = 0 ; bool arg3 ; SWIG_check_num_args("ofTexture::allocate",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::allocate",1,"ofTexture *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofTexture::allocate",2,"ofFloatPixels const &");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("ofTexture::allocate",3,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_allocate",1,SWIGTYPE_p_ofTexture); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofPixels_T_float_t,0))){
    SWIG_fail_ptr("Texture_allocate",2,SWIGTYPE_p_ofPixels_T_float_t); }  arg3 = (lua_toboolean(L, 3)!=0);
  (arg1)->allocate((ofFloatPixels const &)*arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Texture_allocate(lua_State* L) { int argc; int argv[8]={ 1,2,3,4,5,6,7,8} ; argc = lua_gettop(L);
  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofTexture, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofTextureData, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Texture_allocate__SWIG_0(L);}  }  }  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofTexture, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofPixels_T_unsigned_char_t, 0)) {
          _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Texture_allocate__SWIG_6(L);}  }  }  if (argc == 2) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofTexture, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofPixels_T_unsigned_short_t, 0)) {
          _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Texture_allocate__SWIG_8(L);}  }  }  if (argc == 2) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofTexture, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofPixels_T_float_t, 0)) {
          _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Texture_allocate__SWIG_10(L);}  }  }  if (argc == 3) { int _v;
    { void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofTexture, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofPixels_T_unsigned_short_t, 0)) {
          _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isboolean(L,argv[2]); }  if (_v) {
          return _wrap_Texture_allocate__SWIG_9(L);}  }  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofTexture, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofPixels_T_unsigned_char_t, 0)) {
          _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isboolean(L,argv[2]); }  if (_v) {
          return _wrap_Texture_allocate__SWIG_7(L);}  }  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofTexture, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofPixels_T_float_t, 0)) {
          _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isboolean(L,argv[2]); }  if (_v) {
          return _wrap_Texture_allocate__SWIG_11(L);}  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofTexture, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofTextureData, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); } 
          if (_v) { return _wrap_Texture_allocate__SWIG_1(L);}  }  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofTexture, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          { _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_Texture_allocate__SWIG_2(L);}  }  }  }  }  if (argc == 5) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofTexture, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isboolean(L,argv[4]); }  if (_v) {
              return _wrap_Texture_allocate__SWIG_4(L);}  }  }  }  }  }  if (argc == 6) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofTexture, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) { {
                _v = lua_isnumber(L,argv[5]); }  if (_v) { return _wrap_Texture_allocate__SWIG_3(L);}  }  }  }  }  }  } 
  if (argc == 7) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofTexture, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isboolean(L,argv[4]); }  if (_v) { {
                _v = lua_isnumber(L,argv[5]); }  if (_v) { { _v = lua_isnumber(L,argv[6]); }  if (_v) {
                  return _wrap_Texture_allocate__SWIG_5(L);}  }  }  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Texture_allocate'\n" "  Possible C/C++ prototypes are:\n"
  "    ofTexture::allocate(ofTextureData const &)\n" "    ofTexture::allocate(ofTextureData const &,int,int)\n"
  "    ofTexture::allocate(int,int,int)\n" "    ofTexture::allocate(int,int,int,int,int)\n"
  "    ofTexture::allocate(int,int,int,bool)\n" "    ofTexture::allocate(int,int,int,bool,int,int)\n"
  "    ofTexture::allocate(ofPixels const &)\n" "    ofTexture::allocate(ofPixels const &,bool)\n"
  "    ofTexture::allocate(ofShortPixels const &)\n" "    ofTexture::allocate(ofShortPixels const &,bool)\n"
  "    ofTexture::allocate(ofFloatPixels const &)\n" "    ofTexture::allocate(ofFloatPixels const &,bool)\n");
  lua_error(L);return 0; }
static int _wrap_Texture_allocateAsBufferTexture(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ;
  ofBufferObject *arg2 = 0 ; int arg3 ; SWIG_check_num_args("ofTexture::allocateAsBufferTexture",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::allocateAsBufferTexture",1,"ofTexture *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofTexture::allocateAsBufferTexture",2,"ofBufferObject const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofTexture::allocateAsBufferTexture",3,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_allocateAsBufferTexture",1,SWIGTYPE_p_ofTexture); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofBufferObject,0))){
    SWIG_fail_ptr("Texture_allocateAsBufferTexture",2,SWIGTYPE_p_ofBufferObject); }  arg3 = (int)lua_tonumber(L, 3);
  (arg1)->allocateAsBufferTexture((ofBufferObject const &)*arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Texture_isAllocated(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ; bool result;
  SWIG_check_num_args("ofTexture::isAllocated",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::isAllocated",1,"ofTexture const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_isAllocated",1,SWIGTYPE_p_ofTexture); }  result = (bool)((ofTexture const *)arg1)->isAllocated();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Texture_clear(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ;
  SWIG_check_num_args("ofTexture::clear",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::clear",1,"ofTexture *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_clear",1,SWIGTYPE_p_ofTexture); }  (arg1)->clear(); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Texture_setUseExternalTextureID(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ;
  GLuint arg2 ; SWIG_check_num_args("ofTexture::setUseExternalTextureID",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::setUseExternalTextureID",1,"ofTexture *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofTexture::setUseExternalTextureID",2,"GLuint");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_setUseExternalTextureID",1,SWIGTYPE_p_ofTexture); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (GLuint)lua_tonumber(L, 2);
  (arg1)->setUseExternalTextureID(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Texture_loadData__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ;
  uint8_t *arg2 = (uint8_t *) (uint8_t *)0 ; int arg3 ; int arg4 ; int arg5 ; SWIG_check_num_args("ofTexture::loadData",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::loadData",1,"ofTexture *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofTexture::loadData",2,"uint8_t const *const");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofTexture::loadData",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofTexture::loadData",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofTexture::loadData",5,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_loadData",1,SWIGTYPE_p_ofTexture); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_uint8_t,0))){
    SWIG_fail_ptr("Texture_loadData",2,SWIGTYPE_p_uint8_t); }  arg3 = (int)lua_tonumber(L, 3); arg4 = (int)lua_tonumber(L, 4);
  arg5 = (int)lua_tonumber(L, 5); (arg1)->loadData((uint8_t const *)arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Texture_loadData__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ;
  uint16_t *arg2 = (uint16_t *) 0 ; int arg3 ; int arg4 ; int arg5 ; SWIG_check_num_args("ofTexture::loadData",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::loadData",1,"ofTexture *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofTexture::loadData",2,"uint16_t const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofTexture::loadData",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofTexture::loadData",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofTexture::loadData",5,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_loadData",1,SWIGTYPE_p_ofTexture); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_uint16_t,0))){
    SWIG_fail_ptr("Texture_loadData",2,SWIGTYPE_p_uint16_t); }  arg3 = (int)lua_tonumber(L, 3); arg4 = (int)lua_tonumber(L, 4);
  arg5 = (int)lua_tonumber(L, 5); (arg1)->loadData((uint16_t const *)arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Texture_loadData__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ;
  uint32_t *arg2 = (uint32_t *) 0 ; int arg3 ; int arg4 ; int arg5 ; SWIG_check_num_args("ofTexture::loadData",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::loadData",1,"ofTexture *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofTexture::loadData",2,"uint32_t const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofTexture::loadData",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofTexture::loadData",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofTexture::loadData",5,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_loadData",1,SWIGTYPE_p_ofTexture); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_uint32_t,0))){
    SWIG_fail_ptr("Texture_loadData",2,SWIGTYPE_p_uint32_t); }  arg3 = (int)lua_tonumber(L, 3); arg4 = (int)lua_tonumber(L, 4);
  arg5 = (int)lua_tonumber(L, 5); (arg1)->loadData((uint32_t const *)arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Texture_loadData__SWIG_3(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ;
  int8_t *arg2 = (int8_t *) 0 ; int arg3 ; int arg4 ; int arg5 ; SWIG_check_num_args("ofTexture::loadData",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::loadData",1,"ofTexture *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofTexture::loadData",2,"int8_t const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofTexture::loadData",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofTexture::loadData",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofTexture::loadData",5,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_loadData",1,SWIGTYPE_p_ofTexture); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_int8_t,0))){
    SWIG_fail_ptr("Texture_loadData",2,SWIGTYPE_p_int8_t); }  arg3 = (int)lua_tonumber(L, 3); arg4 = (int)lua_tonumber(L, 4);
  arg5 = (int)lua_tonumber(L, 5); (arg1)->loadData((int8_t const *)arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Texture_loadData__SWIG_4(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ;
  int16_t *arg2 = (int16_t *) 0 ; int arg3 ; int arg4 ; int arg5 ; SWIG_check_num_args("ofTexture::loadData",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::loadData",1,"ofTexture *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofTexture::loadData",2,"int16_t const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofTexture::loadData",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofTexture::loadData",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofTexture::loadData",5,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_loadData",1,SWIGTYPE_p_ofTexture); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_int16_t,0))){
    SWIG_fail_ptr("Texture_loadData",2,SWIGTYPE_p_int16_t); }  arg3 = (int)lua_tonumber(L, 3); arg4 = (int)lua_tonumber(L, 4);
  arg5 = (int)lua_tonumber(L, 5); (arg1)->loadData((int16_t const *)arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Texture_loadData__SWIG_5(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ;
  int32_t *arg2 = (int32_t *) 0 ; int arg3 ; int arg4 ; int arg5 ; SWIG_check_num_args("ofTexture::loadData",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::loadData",1,"ofTexture *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofTexture::loadData",2,"int32_t const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofTexture::loadData",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofTexture::loadData",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofTexture::loadData",5,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_loadData",1,SWIGTYPE_p_ofTexture); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_int32_t,0))){
    SWIG_fail_ptr("Texture_loadData",2,SWIGTYPE_p_int32_t); }  arg3 = (int)lua_tonumber(L, 3); arg4 = (int)lua_tonumber(L, 4);
  arg5 = (int)lua_tonumber(L, 5); (arg1)->loadData((int32_t const *)arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Texture_loadData__SWIG_6(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ;
  float *arg2 = (float *) 0 ; int arg3 ; int arg4 ; int arg5 ; SWIG_check_num_args("ofTexture::loadData",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::loadData",1,"ofTexture *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofTexture::loadData",2,"float const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofTexture::loadData",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofTexture::loadData",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofTexture::loadData",5,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_loadData",1,SWIGTYPE_p_ofTexture); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_float,0))){ SWIG_fail_ptr("Texture_loadData",2,SWIGTYPE_p_float); }
   arg3 = (int)lua_tonumber(L, 3); arg4 = (int)lua_tonumber(L, 4); arg5 = (int)lua_tonumber(L, 5);
  (arg1)->loadData((float const *)arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Texture_loadData__SWIG_7(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ;
  ofPixels *arg2 = 0 ; SWIG_check_num_args("ofTexture::loadData",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::loadData",1,"ofTexture *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofTexture::loadData",2,"ofPixels const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_loadData",1,SWIGTYPE_p_ofTexture); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Texture_loadData",2,SWIGTYPE_p_ofPixels_T_unsigned_char_t); }  (arg1)->loadData((ofPixels const &)*arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Texture_loadData__SWIG_8(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ;
  ofShortPixels *arg2 = 0 ; SWIG_check_num_args("ofTexture::loadData",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::loadData",1,"ofTexture *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofTexture::loadData",2,"ofShortPixels const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_loadData",1,SWIGTYPE_p_ofTexture); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofPixels_T_unsigned_short_t,0))){
    SWIG_fail_ptr("Texture_loadData",2,SWIGTYPE_p_ofPixels_T_unsigned_short_t); } 
  (arg1)->loadData((ofShortPixels const &)*arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Texture_loadData__SWIG_9(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ;
  ofFloatPixels *arg2 = 0 ; SWIG_check_num_args("ofTexture::loadData",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::loadData",1,"ofTexture *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofTexture::loadData",2,"ofFloatPixels const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_loadData",1,SWIGTYPE_p_ofTexture); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofPixels_T_float_t,0))){
    SWIG_fail_ptr("Texture_loadData",2,SWIGTYPE_p_ofPixels_T_float_t); }  (arg1)->loadData((ofFloatPixels const &)*arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Texture_loadData__SWIG_10(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ;
  ofPixels *arg2 = 0 ; int arg3 ; SWIG_check_num_args("ofTexture::loadData",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::loadData",1,"ofTexture *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofTexture::loadData",2,"ofPixels const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofTexture::loadData",3,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_loadData",1,SWIGTYPE_p_ofTexture); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Texture_loadData",2,SWIGTYPE_p_ofPixels_T_unsigned_char_t); }  arg3 = (int)lua_tonumber(L, 3);
  (arg1)->loadData((ofPixels const &)*arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Texture_loadData__SWIG_11(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ;
  ofShortPixels *arg2 = 0 ; int arg3 ; SWIG_check_num_args("ofTexture::loadData",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::loadData",1,"ofTexture *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofTexture::loadData",2,"ofShortPixels const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofTexture::loadData",3,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_loadData",1,SWIGTYPE_p_ofTexture); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofPixels_T_unsigned_short_t,0))){
    SWIG_fail_ptr("Texture_loadData",2,SWIGTYPE_p_ofPixels_T_unsigned_short_t); }  arg3 = (int)lua_tonumber(L, 3);
  (arg1)->loadData((ofShortPixels const &)*arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Texture_loadData__SWIG_12(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ;
  ofFloatPixels *arg2 = 0 ; int arg3 ; SWIG_check_num_args("ofTexture::loadData",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::loadData",1,"ofTexture *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofTexture::loadData",2,"ofFloatPixels const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofTexture::loadData",3,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_loadData",1,SWIGTYPE_p_ofTexture); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofPixels_T_float_t,0))){
    SWIG_fail_ptr("Texture_loadData",2,SWIGTYPE_p_ofPixels_T_float_t); }  arg3 = (int)lua_tonumber(L, 3);
  (arg1)->loadData((ofFloatPixels const &)*arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Texture_loadData__SWIG_13(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ;
  void *arg2 = (void *) 0 ; int arg3 ; int arg4 ; int arg5 ; int arg6 ; SWIG_check_num_args("ofTexture::loadData",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::loadData",1,"ofTexture *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofTexture::loadData",2,"void const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofTexture::loadData",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofTexture::loadData",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofTexture::loadData",5,"int");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofTexture::loadData",6,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_loadData",1,SWIGTYPE_p_ofTexture); }  arg2=(void *)SWIG_MustGetPtr(L,2,0,0,2,"Texture_loadData");
  arg3 = (int)lua_tonumber(L, 3); arg4 = (int)lua_tonumber(L, 4); arg5 = (int)lua_tonumber(L, 5);
  arg6 = (int)lua_tonumber(L, 6); (arg1)->loadData((void const *)arg2,arg3,arg4,arg5,arg6); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Texture_loadData__SWIG_14(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ;
  ofBufferObject *arg2 = 0 ; int arg3 ; int arg4 ; SWIG_check_num_args("ofTexture::loadData",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::loadData",1,"ofTexture *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofTexture::loadData",2,"ofBufferObject const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofTexture::loadData",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofTexture::loadData",4,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_loadData",1,SWIGTYPE_p_ofTexture); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofBufferObject,0))){
    SWIG_fail_ptr("Texture_loadData",2,SWIGTYPE_p_ofBufferObject); }  arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4); (arg1)->loadData((ofBufferObject const &)*arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Texture_loadData(lua_State* L) { int argc; int argv[7]={ 1,2,3,4,5,6,7} ; argc = lua_gettop(L);
  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofTexture, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofPixels_T_unsigned_char_t, 0)) {
          _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Texture_loadData__SWIG_7(L);}  }  }  if (argc == 2) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofTexture, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofPixels_T_unsigned_short_t, 0)) {
          _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Texture_loadData__SWIG_8(L);}  }  }  if (argc == 2) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofTexture, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofPixels_T_float_t, 0)) {
          _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Texture_loadData__SWIG_9(L);}  }  }  if (argc == 3) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofTexture, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofPixels_T_unsigned_char_t, 0)) {
          _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_Texture_loadData__SWIG_10(L);}  }  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofTexture, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofPixels_T_unsigned_short_t, 0)) {
          _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_Texture_loadData__SWIG_11(L);}  }  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofTexture, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofPixels_T_float_t, 0)) {
          _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_Texture_loadData__SWIG_12(L);}  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofTexture, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofBufferObject, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); } 
          if (_v) { return _wrap_Texture_loadData__SWIG_14(L);}  }  }  }  }  if (argc == 5) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofTexture, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_uint8_t, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); } 
          if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) { return _wrap_Texture_loadData__SWIG_0(L);}  }  }  }  }  } 
  if (argc == 5) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofTexture, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_uint16_t, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); } 
          if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) { return _wrap_Texture_loadData__SWIG_1(L);}  }  }  }  }  } 
  if (argc == 5) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofTexture, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_uint32_t, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); } 
          if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) { return _wrap_Texture_loadData__SWIG_2(L);}  }  }  }  }  } 
  if (argc == 5) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofTexture, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_int8_t, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); } 
          if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) { return _wrap_Texture_loadData__SWIG_3(L);}  }  }  }  }  } 
  if (argc == 5) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofTexture, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_int16_t, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); } 
          if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) { return _wrap_Texture_loadData__SWIG_4(L);}  }  }  }  }  } 
  if (argc == 5) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofTexture, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_int32_t, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); } 
          if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) { return _wrap_Texture_loadData__SWIG_5(L);}  }  }  }  }  } 
  if (argc == 5) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofTexture, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_float, 0)) { _v = 0; }  else {
          _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { {
              _v = lua_isnumber(L,argv[4]); }  if (_v) { return _wrap_Texture_loadData__SWIG_6(L);}  }  }  }  }  } 
  if (argc == 6) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofTexture, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, 0, 0)) { _v = 0; }  else { _v = 1; }  } 
      if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { {
              _v = lua_isnumber(L,argv[4]); }  if (_v) { { _v = lua_isnumber(L,argv[5]); }  if (_v) {
                return _wrap_Texture_loadData__SWIG_13(L);}  }  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Texture_loadData'\n" "  Possible C/C++ prototypes are:\n"
  "    ofTexture::loadData(uint8_t const *const,int,int,int)\n" "    ofTexture::loadData(uint16_t const *,int,int,int)\n"
  "    ofTexture::loadData(uint32_t const *,int,int,int)\n" "    ofTexture::loadData(int8_t const *,int,int,int)\n"
  "    ofTexture::loadData(int16_t const *,int,int,int)\n" "    ofTexture::loadData(int32_t const *,int,int,int)\n"
  "    ofTexture::loadData(float const *,int,int,int)\n" "    ofTexture::loadData(ofPixels const &)\n"
  "    ofTexture::loadData(ofShortPixels const &)\n" "    ofTexture::loadData(ofFloatPixels const &)\n"
  "    ofTexture::loadData(ofPixels const &,int)\n" "    ofTexture::loadData(ofShortPixels const &,int)\n"
  "    ofTexture::loadData(ofFloatPixels const &,int)\n" "    ofTexture::loadData(void const *,int,int,int,int)\n"
  "    ofTexture::loadData(ofBufferObject const &,int,int)\n"); lua_error(L);return 0; }
static int _wrap_Texture_loadScreenData(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ; int arg2 ;
  int arg3 ; int arg4 ; int arg5 ; SWIG_check_num_args("ofTexture::loadScreenData",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::loadScreenData",1,"ofTexture *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofTexture::loadScreenData",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofTexture::loadScreenData",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofTexture::loadScreenData",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofTexture::loadScreenData",5,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_loadScreenData",1,SWIGTYPE_p_ofTexture); }  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3); arg4 = (int)lua_tonumber(L, 4); arg5 = (int)lua_tonumber(L, 5);
  (arg1)->loadScreenData(arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Texture_draw__SWIG_0_0(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ;
  glm::vec2 *arg2 = 0 ; SWIG_check_num_args("draw",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("draw",1,"ofTexture const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("draw",2,"glm::vec2 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_draw",1,SWIGTYPE_p_ofTexture); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec2,0))){
    SWIG_fail_ptr("Texture_draw",2,SWIGTYPE_p_glm__vec2); }  ((ofTexture const *)arg1)->draw((glm::vec2 const &)*arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Texture_draw__SWIG_0_1(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ;
  ofRectangle *arg2 = 0 ; SWIG_check_num_args("draw",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("draw",1,"ofTexture const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("draw",2,"ofRectangle const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_draw",1,SWIGTYPE_p_ofTexture); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Texture_draw",2,SWIGTYPE_p_ofRectangle); }  ((ofTexture const *)arg1)->draw((ofRectangle const &)*arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Texture_draw__SWIG_0_2(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ;
  glm::vec2 *arg2 = 0 ; float arg3 ; float arg4 ; SWIG_check_num_args("draw",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("draw",1,"ofTexture const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("draw",2,"glm::vec2 const &"); if(!lua_isnumber(L,3)) SWIG_fail_arg("draw",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("draw",4,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_draw",1,SWIGTYPE_p_ofTexture); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec2,0))){
    SWIG_fail_ptr("Texture_draw",2,SWIGTYPE_p_glm__vec2); }  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  ((ofTexture const *)arg1)->draw((glm::vec2 const &)*arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Texture_draw__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ; float arg2 ;
  float arg3 ; SWIG_check_num_args("ofTexture::draw",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::draw",1,"ofTexture const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofTexture::draw",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofTexture::draw",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_draw",1,SWIGTYPE_p_ofTexture); }  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3);
  ((ofTexture const *)arg1)->draw(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Texture_draw__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ; float arg2 ;
  float arg3 ; float arg4 ; SWIG_check_num_args("ofTexture::draw",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::draw",1,"ofTexture const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofTexture::draw",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofTexture::draw",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofTexture::draw",4,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_draw",1,SWIGTYPE_p_ofTexture); }  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4); ((ofTexture const *)arg1)->draw(arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Texture_draw__SWIG_3(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ;
  glm::vec3 *arg2 = 0 ; SWIG_check_num_args("ofTexture::draw",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::draw",1,"ofTexture const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofTexture::draw",2,"glm::vec3 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_draw",1,SWIGTYPE_p_ofTexture); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("Texture_draw",2,SWIGTYPE_p_glm__vec3); }  ((ofTexture const *)arg1)->draw((glm::vec3 const &)*arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Texture_draw__SWIG_4(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ; float arg2 ;
  float arg3 ; float arg4 ; float arg5 ; SWIG_check_num_args("ofTexture::draw",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::draw",1,"ofTexture const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofTexture::draw",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofTexture::draw",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofTexture::draw",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofTexture::draw",5,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_draw",1,SWIGTYPE_p_ofTexture); }  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4); arg5 = (float)lua_tonumber(L, 5); ((ofTexture const *)arg1)->draw(arg2,arg3,arg4,arg5);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Texture_draw__SWIG_5(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ; float arg2 ;
  float arg3 ; float arg4 ; float arg5 ; float arg6 ; SWIG_check_num_args("ofTexture::draw",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::draw",1,"ofTexture const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofTexture::draw",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofTexture::draw",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofTexture::draw",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofTexture::draw",5,"float");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofTexture::draw",6,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_draw",1,SWIGTYPE_p_ofTexture); }  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4); arg5 = (float)lua_tonumber(L, 5); arg6 = (float)lua_tonumber(L, 6);
  ((ofTexture const *)arg1)->draw(arg2,arg3,arg4,arg5,arg6); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Texture_draw__SWIG_6(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ;
  glm::vec3 *arg2 = 0 ; float arg3 ; float arg4 ; SWIG_check_num_args("ofTexture::draw",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::draw",1,"ofTexture const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofTexture::draw",2,"glm::vec3 const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofTexture::draw",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofTexture::draw",4,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_draw",1,SWIGTYPE_p_ofTexture); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("Texture_draw",2,SWIGTYPE_p_glm__vec3); }  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  ((ofTexture const *)arg1)->draw((glm::vec3 const &)*arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Texture_draw__SWIG_7(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ;
  glm::vec3 *arg2 = 0 ; glm::vec3 *arg3 = 0 ; glm::vec3 *arg4 = 0 ; glm::vec3 *arg5 = 0 ;
  SWIG_check_num_args("ofTexture::draw",5,5) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::draw",1,"ofTexture const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofTexture::draw",2,"glm::vec3 const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofTexture::draw",3,"glm::vec3 const &");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("ofTexture::draw",4,"glm::vec3 const &");
  if(!lua_isuserdata(L,5)) SWIG_fail_arg("ofTexture::draw",5,"glm::vec3 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_draw",1,SWIGTYPE_p_ofTexture); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("Texture_draw",2,SWIGTYPE_p_glm__vec3); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("Texture_draw",3,SWIGTYPE_p_glm__vec3); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("Texture_draw",4,SWIGTYPE_p_glm__vec3); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&arg5,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("Texture_draw",5,SWIGTYPE_p_glm__vec3); } 
  ((ofTexture const *)arg1)->draw((glm::vec3 const &)*arg2,(glm::vec3 const &)*arg3,(glm::vec3 const &)*arg4,(glm::vec3 const &)*arg5);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Texture_draw(lua_State* L) { int argc; int argv[7]={ 1,2,3,4,5,6,7} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofTexture, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec2, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Texture_draw__SWIG_0_0(L);}  }  }  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofTexture, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Texture_draw__SWIG_0_1(L);}  }  }  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofTexture, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Texture_draw__SWIG_3(L);}  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofTexture, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_Texture_draw__SWIG_1(L);}  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofTexture, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec2, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); } 
          if (_v) { return _wrap_Texture_draw__SWIG_0_2(L);}  }  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofTexture, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); } 
          if (_v) { return _wrap_Texture_draw__SWIG_6(L);}  }  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofTexture, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          { _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_Texture_draw__SWIG_2(L);}  }  }  }  }  if (argc == 5) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofTexture, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
           else { _v = 1; }  }  if (_v) { { void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
             else { _v = 1; }  }  if (_v) { { void *ptr;
              if (lua_isuserdata(L,argv[4])==0 || SWIG_ConvertPtr(L,argv[4], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) {
                _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Texture_draw__SWIG_7(L);}  }  }  }  }  } 
  if (argc == 5) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofTexture, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) {
              return _wrap_Texture_draw__SWIG_4(L);}  }  }  }  }  }  if (argc == 6) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofTexture, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) { {
                _v = lua_isnumber(L,argv[5]); }  if (_v) { return _wrap_Texture_draw__SWIG_5(L);}  }  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Texture_draw'\n" "  Possible C/C++ prototypes are:\n"
  "    draw(glm::vec2 const &) const\n" "    draw(ofRectangle const &) const\n"
  "    draw(glm::vec2 const &,float,float) const\n" "    ofTexture::draw(float,float) const\n"
  "    ofTexture::draw(float,float,float) const\n" "    ofTexture::draw(glm::vec3 const &) const\n"
  "    ofTexture::draw(float,float,float,float) const\n" "    ofTexture::draw(float,float,float,float,float) const\n"
  "    ofTexture::draw(glm::vec3 const &,float,float) const\n"
  "    ofTexture::draw(glm::vec3 const &,glm::vec3 const &,glm::vec3 const &,glm::vec3 const &) const\n");
  lua_error(L);return 0; }
static int _wrap_Texture_drawSubsection__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ;
  float arg2 ; float arg3 ; float arg4 ; float arg5 ; float arg6 ; float arg7 ;
  SWIG_check_num_args("ofTexture::drawSubsection",7,7)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::drawSubsection",1,"ofTexture const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofTexture::drawSubsection",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofTexture::drawSubsection",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofTexture::drawSubsection",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofTexture::drawSubsection",5,"float");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofTexture::drawSubsection",6,"float");
  if(!lua_isnumber(L,7)) SWIG_fail_arg("ofTexture::drawSubsection",7,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_drawSubsection",1,SWIGTYPE_p_ofTexture); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); arg5 = (float)lua_tonumber(L, 5);
  arg6 = (float)lua_tonumber(L, 6); arg7 = (float)lua_tonumber(L, 7);
  ((ofTexture const *)arg1)->drawSubsection(arg2,arg3,arg4,arg5,arg6,arg7); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Texture_drawSubsection__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ;
  float arg2 ; float arg3 ; float arg4 ; float arg5 ; float arg6 ; float arg7 ; float arg8 ;
  SWIG_check_num_args("ofTexture::drawSubsection",8,8)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::drawSubsection",1,"ofTexture const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofTexture::drawSubsection",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofTexture::drawSubsection",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofTexture::drawSubsection",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofTexture::drawSubsection",5,"float");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofTexture::drawSubsection",6,"float");
  if(!lua_isnumber(L,7)) SWIG_fail_arg("ofTexture::drawSubsection",7,"float");
  if(!lua_isnumber(L,8)) SWIG_fail_arg("ofTexture::drawSubsection",8,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_drawSubsection",1,SWIGTYPE_p_ofTexture); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); arg5 = (float)lua_tonumber(L, 5);
  arg6 = (float)lua_tonumber(L, 6); arg7 = (float)lua_tonumber(L, 7); arg8 = (float)lua_tonumber(L, 8);
  ((ofTexture const *)arg1)->drawSubsection(arg2,arg3,arg4,arg5,arg6,arg7,arg8); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Texture_drawSubsection__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ;
  float arg2 ; float arg3 ; float arg4 ; float arg5 ; float arg6 ; float arg7 ; float arg8 ; float arg9 ;
  SWIG_check_num_args("ofTexture::drawSubsection",9,9)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::drawSubsection",1,"ofTexture const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofTexture::drawSubsection",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofTexture::drawSubsection",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofTexture::drawSubsection",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofTexture::drawSubsection",5,"float");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofTexture::drawSubsection",6,"float");
  if(!lua_isnumber(L,7)) SWIG_fail_arg("ofTexture::drawSubsection",7,"float");
  if(!lua_isnumber(L,8)) SWIG_fail_arg("ofTexture::drawSubsection",8,"float");
  if(!lua_isnumber(L,9)) SWIG_fail_arg("ofTexture::drawSubsection",9,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_drawSubsection",1,SWIGTYPE_p_ofTexture); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); arg5 = (float)lua_tonumber(L, 5);
  arg6 = (float)lua_tonumber(L, 6); arg7 = (float)lua_tonumber(L, 7); arg8 = (float)lua_tonumber(L, 8);
  arg9 = (float)lua_tonumber(L, 9); ((ofTexture const *)arg1)->drawSubsection(arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Texture_drawSubsection__SWIG_3(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ;
  ofRectangle *arg2 = 0 ; ofRectangle *arg3 = 0 ; SWIG_check_num_args("ofTexture::drawSubsection",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::drawSubsection",1,"ofTexture const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofTexture::drawSubsection",2,"ofRectangle const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofTexture::drawSubsection",3,"ofRectangle const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_drawSubsection",1,SWIGTYPE_p_ofTexture); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Texture_drawSubsection",2,SWIGTYPE_p_ofRectangle); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Texture_drawSubsection",3,SWIGTYPE_p_ofRectangle); } 
  ((ofTexture const *)arg1)->drawSubsection((ofRectangle const &)*arg2,(ofRectangle const &)*arg3); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Texture_drawSubsection__SWIG_4(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ;
  float arg2 ; float arg3 ; float arg4 ; float arg5 ; float arg6 ; float arg7 ; float arg8 ; float arg9 ; float arg10 ;
  SWIG_check_num_args("ofTexture::drawSubsection",10,10)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::drawSubsection",1,"ofTexture const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofTexture::drawSubsection",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofTexture::drawSubsection",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofTexture::drawSubsection",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofTexture::drawSubsection",5,"float");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofTexture::drawSubsection",6,"float");
  if(!lua_isnumber(L,7)) SWIG_fail_arg("ofTexture::drawSubsection",7,"float");
  if(!lua_isnumber(L,8)) SWIG_fail_arg("ofTexture::drawSubsection",8,"float");
  if(!lua_isnumber(L,9)) SWIG_fail_arg("ofTexture::drawSubsection",9,"float");
  if(!lua_isnumber(L,10)) SWIG_fail_arg("ofTexture::drawSubsection",10,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_drawSubsection",1,SWIGTYPE_p_ofTexture); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); arg5 = (float)lua_tonumber(L, 5);
  arg6 = (float)lua_tonumber(L, 6); arg7 = (float)lua_tonumber(L, 7); arg8 = (float)lua_tonumber(L, 8);
  arg9 = (float)lua_tonumber(L, 9); arg10 = (float)lua_tonumber(L, 10);
  ((ofTexture const *)arg1)->drawSubsection(arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Texture_drawSubsection(lua_State* L) { int argc; int argv[11]={ 1,2,3,4,5,6,7,8,9,10,11} ;
  argc = lua_gettop(L); if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofTexture, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
           else { _v = 1; }  }  if (_v) { return _wrap_Texture_drawSubsection__SWIG_3(L);}  }  }  }  if (argc == 7) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofTexture, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) { {
                _v = lua_isnumber(L,argv[5]); }  if (_v) { { _v = lua_isnumber(L,argv[6]); }  if (_v) {
                  return _wrap_Texture_drawSubsection__SWIG_0(L);}  }  }  }  }  }  }  }  if (argc == 8) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofTexture, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) { {
                _v = lua_isnumber(L,argv[5]); }  if (_v) { { _v = lua_isnumber(L,argv[6]); }  if (_v) { {
                    _v = lua_isnumber(L,argv[7]); }  if (_v) { return _wrap_Texture_drawSubsection__SWIG_1(L);}  }  }  }  }  }  }
       }  }  if (argc == 9) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofTexture, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) { {
                _v = lua_isnumber(L,argv[5]); }  if (_v) { { _v = lua_isnumber(L,argv[6]); }  if (_v) { {
                    _v = lua_isnumber(L,argv[7]); }  if (_v) { { _v = lua_isnumber(L,argv[8]); }  if (_v) {
                      return _wrap_Texture_drawSubsection__SWIG_2(L);}  }  }  }  }  }  }  }  }  }  if (argc == 10) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofTexture, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) { {
                _v = lua_isnumber(L,argv[5]); }  if (_v) { { _v = lua_isnumber(L,argv[6]); }  if (_v) { {
                    _v = lua_isnumber(L,argv[7]); }  if (_v) { { _v = lua_isnumber(L,argv[8]); }  if (_v) { {
                        _v = lua_isnumber(L,argv[9]); }  if (_v) { return _wrap_Texture_drawSubsection__SWIG_4(L);}  }  }  }  }
               }  }  }  }  }  }  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Texture_drawSubsection'\n"
  "  Possible C/C++ prototypes are:\n" "    ofTexture::drawSubsection(float,float,float,float,float,float) const\n"
  "    ofTexture::drawSubsection(float,float,float,float,float,float,float) const\n"
  "    ofTexture::drawSubsection(float,float,float,float,float,float,float,float) const\n"
  "    ofTexture::drawSubsection(ofRectangle const &,ofRectangle const &) const\n"
  "    ofTexture::drawSubsection(float,float,float,float,float,float,float,float,float) const\n"); lua_error(L);return 0; }
static int _wrap_Texture_getQuad(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ; glm::vec3 *arg2 = 0 ;
  glm::vec3 *arg3 = 0 ; glm::vec3 *arg4 = 0 ; glm::vec3 *arg5 = 0 ; ofMesh result; SWIG_check_num_args("ofTexture::getQuad",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::getQuad",1,"ofTexture const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofTexture::getQuad",2,"glm::vec3 const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofTexture::getQuad",3,"glm::vec3 const &");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("ofTexture::getQuad",4,"glm::vec3 const &");
  if(!lua_isuserdata(L,5)) SWIG_fail_arg("ofTexture::getQuad",5,"glm::vec3 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_getQuad",1,SWIGTYPE_p_ofTexture); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("Texture_getQuad",2,SWIGTYPE_p_glm__vec3); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("Texture_getQuad",3,SWIGTYPE_p_glm__vec3); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("Texture_getQuad",4,SWIGTYPE_p_glm__vec3); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&arg5,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("Texture_getQuad",5,SWIGTYPE_p_glm__vec3); } 
  result = ((ofTexture const *)arg1)->getQuad((glm::vec3 const &)*arg2,(glm::vec3 const &)*arg3,(glm::vec3 const &)*arg4,(glm::vec3 const &)*arg5);
  { ofMesh * resultptr = new ofMesh((const ofMesh &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,1); SWIG_arg++; }
   return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Texture_getMeshForSubsection(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ; float arg2 ;
  float arg3 ; float arg4 ; float arg5 ; float arg6 ; float arg7 ; float arg8 ; float arg9 ; float arg10 ; bool arg11 ;
  ofRectMode arg12 ; ofMesh result; SWIG_check_num_args("ofTexture::getMeshForSubsection",12,12)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::getMeshForSubsection",1,"ofTexture const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofTexture::getMeshForSubsection",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofTexture::getMeshForSubsection",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofTexture::getMeshForSubsection",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofTexture::getMeshForSubsection",5,"float");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofTexture::getMeshForSubsection",6,"float");
  if(!lua_isnumber(L,7)) SWIG_fail_arg("ofTexture::getMeshForSubsection",7,"float");
  if(!lua_isnumber(L,8)) SWIG_fail_arg("ofTexture::getMeshForSubsection",8,"float");
  if(!lua_isnumber(L,9)) SWIG_fail_arg("ofTexture::getMeshForSubsection",9,"float");
  if(!lua_isnumber(L,10)) SWIG_fail_arg("ofTexture::getMeshForSubsection",10,"float");
  if(!lua_isboolean(L,11)) SWIG_fail_arg("ofTexture::getMeshForSubsection",11,"bool");
  if(!lua_isnumber(L,12)) SWIG_fail_arg("ofTexture::getMeshForSubsection",12,"ofRectMode");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_getMeshForSubsection",1,SWIGTYPE_p_ofTexture); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); arg5 = (float)lua_tonumber(L, 5);
  arg6 = (float)lua_tonumber(L, 6); arg7 = (float)lua_tonumber(L, 7); arg8 = (float)lua_tonumber(L, 8);
  arg9 = (float)lua_tonumber(L, 9); arg10 = (float)lua_tonumber(L, 10); arg11 = (lua_toboolean(L, 11)!=0);
  arg12 = (ofRectMode)(int)lua_tonumber(L, 12);
  result = ((ofTexture const *)arg1)->getMeshForSubsection(arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12); {
    ofMesh * resultptr = new ofMesh((const ofMesh &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,1); SWIG_arg++; }
   return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Texture_bind__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ; int arg2 ;
  SWIG_check_num_args("ofTexture::bind",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::bind",1,"ofTexture const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofTexture::bind",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_bind",1,SWIGTYPE_p_ofTexture); }  arg2 = (int)lua_tonumber(L, 2);
  ((ofTexture const *)arg1)->bind(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Texture_bind__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ;
  SWIG_check_num_args("ofTexture::bind",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::bind",1,"ofTexture const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_bind",1,SWIGTYPE_p_ofTexture); }  ((ofTexture const *)arg1)->bind(); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Texture_bind(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 1) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofTexture, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Texture_bind__SWIG_1(L);}  }  if (argc == 2) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofTexture, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_Texture_bind__SWIG_0(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Texture_bind'\n" "  Possible C/C++ prototypes are:\n"
  "    ofTexture::bind(int) const\n" "    ofTexture::bind() const\n"); lua_error(L);return 0; }
static int _wrap_Texture_unbind__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ; int arg2 ;
  SWIG_check_num_args("ofTexture::unbind",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::unbind",1,"ofTexture const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofTexture::unbind",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_unbind",1,SWIGTYPE_p_ofTexture); }  arg2 = (int)lua_tonumber(L, 2);
  ((ofTexture const *)arg1)->unbind(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Texture_unbind__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ;
  SWIG_check_num_args("ofTexture::unbind",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::unbind",1,"ofTexture const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_unbind",1,SWIGTYPE_p_ofTexture); }  ((ofTexture const *)arg1)->unbind(); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Texture_unbind(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 1) { int _v;
    { void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofTexture, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Texture_unbind__SWIG_1(L);}  }  if (argc == 2) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofTexture, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_Texture_unbind__SWIG_0(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Texture_unbind'\n" "  Possible C/C++ prototypes are:\n"
  "    ofTexture::unbind(int) const\n" "    ofTexture::unbind() const\n"); lua_error(L);return 0; }
static int _wrap_Texture_getAlphaMask(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ;
  ofTexture *result = 0 ; SWIG_check_num_args("ofTexture::getAlphaMask",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::getAlphaMask",1,"ofTexture const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_getAlphaMask",1,SWIGTYPE_p_ofTexture); } 
  result = (ofTexture *)((ofTexture const *)arg1)->getAlphaMask();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofTexture,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Texture_getHeight(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ; float result;
  SWIG_check_num_args("ofTexture::getHeight",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::getHeight",1,"ofTexture const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_getHeight",1,SWIGTYPE_p_ofTexture); }  result = (float)((ofTexture const *)arg1)->getHeight();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Texture_getWidth(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ; float result;
  SWIG_check_num_args("ofTexture::getWidth",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::getWidth",1,"ofTexture const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_getWidth",1,SWIGTYPE_p_ofTexture); }  result = (float)((ofTexture const *)arg1)->getWidth();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Texture_setAnchorPercent(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ; float arg2 ;
  float arg3 ; SWIG_check_num_args("ofTexture::setAnchorPercent",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::setAnchorPercent",1,"ofTexture *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofTexture::setAnchorPercent",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofTexture::setAnchorPercent",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_setAnchorPercent",1,SWIGTYPE_p_ofTexture); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); (arg1)->setAnchorPercent(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Texture_setAnchorPoint(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ; float arg2 ;
  float arg3 ; SWIG_check_num_args("ofTexture::setAnchorPoint",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::setAnchorPoint",1,"ofTexture *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofTexture::setAnchorPoint",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofTexture::setAnchorPoint",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_setAnchorPoint",1,SWIGTYPE_p_ofTexture); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); (arg1)->setAnchorPoint(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Texture_resetAnchor(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ;
  SWIG_check_num_args("ofTexture::resetAnchor",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::resetAnchor",1,"ofTexture *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_resetAnchor",1,SWIGTYPE_p_ofTexture); }  (arg1)->resetAnchor(); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Texture_getCoordFromPoint(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ; float arg2 ;
  float arg3 ; glm::vec2 result; SWIG_check_num_args("ofTexture::getCoordFromPoint",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::getCoordFromPoint",1,"ofTexture const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofTexture::getCoordFromPoint",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofTexture::getCoordFromPoint",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_getCoordFromPoint",1,SWIGTYPE_p_ofTexture); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); result = ((ofTexture const *)arg1)->getCoordFromPoint(arg2,arg3); {
    glm::vec2 * resultptr = new glm::vec2((const glm::vec2 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_glm__vec2,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Texture_getCoordFromPercent(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ; float arg2 ;
  float arg3 ; glm::vec2 result; SWIG_check_num_args("ofTexture::getCoordFromPercent",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::getCoordFromPercent",1,"ofTexture const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofTexture::getCoordFromPercent",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofTexture::getCoordFromPercent",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_getCoordFromPercent",1,SWIGTYPE_p_ofTexture); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); result = ((ofTexture const *)arg1)->getCoordFromPercent(arg2,arg3); {
    glm::vec2 * resultptr = new glm::vec2((const glm::vec2 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_glm__vec2,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Texture_setAlphaMask(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ;
  ofTexture *arg2 = 0 ; SWIG_check_num_args("ofTexture::setAlphaMask",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::setAlphaMask",1,"ofTexture *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofTexture::setAlphaMask",2,"ofTexture &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_setAlphaMask",1,SWIGTYPE_p_ofTexture); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_setAlphaMask",2,SWIGTYPE_p_ofTexture); }  (arg1)->setAlphaMask(*arg2); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Texture_disableAlphaMask(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ;
  SWIG_check_num_args("ofTexture::disableAlphaMask",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::disableAlphaMask",1,"ofTexture *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_disableAlphaMask",1,SWIGTYPE_p_ofTexture); }  (arg1)->disableAlphaMask(); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Texture_setTextureWrap(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ; GLint arg2 ;
  GLint arg3 ; SWIG_check_num_args("ofTexture::setTextureWrap",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::setTextureWrap",1,"ofTexture *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofTexture::setTextureWrap",2,"GLint");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofTexture::setTextureWrap",3,"GLint");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_setTextureWrap",1,SWIGTYPE_p_ofTexture); }  arg2 = (GLint)lua_tonumber(L, 2);
  arg3 = (GLint)lua_tonumber(L, 3); (arg1)->setTextureWrap(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Texture_setTextureMinMagFilter(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ;
  GLint arg2 ; GLint arg3 ; SWIG_check_num_args("ofTexture::setTextureMinMagFilter",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::setTextureMinMagFilter",1,"ofTexture *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofTexture::setTextureMinMagFilter",2,"GLint");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofTexture::setTextureMinMagFilter",3,"GLint");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_setTextureMinMagFilter",1,SWIGTYPE_p_ofTexture); }  arg2 = (GLint)lua_tonumber(L, 2);
  arg3 = (GLint)lua_tonumber(L, 3); (arg1)->setTextureMinMagFilter(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Texture_setTextureMatrix(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ;
  glm::mat4 *arg2 = 0 ; SWIG_check_num_args("ofTexture::setTextureMatrix",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::setTextureMatrix",1,"ofTexture *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofTexture::setTextureMatrix",2,"glm::mat4 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_setTextureMatrix",1,SWIGTYPE_p_ofTexture); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__mat4,0))){
    SWIG_fail_ptr("Texture_setTextureMatrix",2,SWIGTYPE_p_glm__mat4); }  (arg1)->setTextureMatrix((glm::mat4 const &)*arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Texture_getTextureMatrix(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ;
  glm::mat4 *result = 0 ; SWIG_check_num_args("ofTexture::getTextureMatrix",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::getTextureMatrix",1,"ofTexture const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_getTextureMatrix",1,SWIGTYPE_p_ofTexture); } 
  result = (glm::mat4 *) &((ofTexture const *)arg1)->getTextureMatrix();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_glm__mat4,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Texture_isUsingTextureMatrix(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ; bool result;
  SWIG_check_num_args("ofTexture::isUsingTextureMatrix",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::isUsingTextureMatrix",1,"ofTexture const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_isUsingTextureMatrix",1,SWIGTYPE_p_ofTexture); } 
  result = (bool)((ofTexture const *)arg1)->isUsingTextureMatrix(); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Texture_disableTextureMatrix(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ;
  SWIG_check_num_args("ofTexture::disableTextureMatrix",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::disableTextureMatrix",1,"ofTexture *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_disableTextureMatrix",1,SWIGTYPE_p_ofTexture); }  (arg1)->disableTextureMatrix(); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Texture_setCompression(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ;
  ofTexCompression arg2 ; SWIG_check_num_args("ofTexture::setCompression",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::setCompression",1,"ofTexture *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofTexture::setCompression",2,"ofTexCompression");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_setCompression",1,SWIGTYPE_p_ofTexture); }  arg2 = (ofTexCompression)(int)lua_tonumber(L, 2);
  (arg1)->setCompression(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Texture_setRGToRGBASwizzles(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ; bool arg2 ;
  SWIG_check_num_args("ofTexture::setRGToRGBASwizzles",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::setRGToRGBASwizzles",1,"ofTexture *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofTexture::setRGToRGBASwizzles",2,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_setRGToRGBASwizzles",1,SWIGTYPE_p_ofTexture); }  arg2 = (lua_toboolean(L, 2)!=0);
  (arg1)->setRGToRGBASwizzles(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Texture_setSwizzle(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ; GLenum arg2 ;
  GLenum arg3 ; SWIG_check_num_args("ofTexture::setSwizzle",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::setSwizzle",1,"ofTexture *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofTexture::setSwizzle",2,"GLenum");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofTexture::setSwizzle",3,"GLenum");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_setSwizzle",1,SWIGTYPE_p_ofTexture); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (GLenum)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (GLenum)lua_tonumber(L, 3);
  (arg1)->setSwizzle(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Texture_readToPixels__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ;
  ofPixels *arg2 = 0 ; SWIG_check_num_args("ofTexture::readToPixels",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::readToPixels",1,"ofTexture const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofTexture::readToPixels",2,"ofPixels &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_readToPixels",1,SWIGTYPE_p_ofTexture); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Texture_readToPixels",2,SWIGTYPE_p_ofPixels_T_unsigned_char_t); } 
  ((ofTexture const *)arg1)->readToPixels(*arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Texture_readToPixels__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ;
  ofShortPixels *arg2 = 0 ; SWIG_check_num_args("ofTexture::readToPixels",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::readToPixels",1,"ofTexture const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofTexture::readToPixels",2,"ofShortPixels &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_readToPixels",1,SWIGTYPE_p_ofTexture); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofPixels_T_unsigned_short_t,0))){
    SWIG_fail_ptr("Texture_readToPixels",2,SWIGTYPE_p_ofPixels_T_unsigned_short_t); } 
  ((ofTexture const *)arg1)->readToPixels(*arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Texture_readToPixels__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ;
  ofFloatPixels *arg2 = 0 ; SWIG_check_num_args("ofTexture::readToPixels",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::readToPixels",1,"ofTexture const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofTexture::readToPixels",2,"ofFloatPixels &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_readToPixels",1,SWIGTYPE_p_ofTexture); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofPixels_T_float_t,0))){
    SWIG_fail_ptr("Texture_readToPixels",2,SWIGTYPE_p_ofPixels_T_float_t); }  ((ofTexture const *)arg1)->readToPixels(*arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Texture_readToPixels(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofTexture, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofPixels_T_unsigned_char_t, 0)) {
          _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Texture_readToPixels__SWIG_0(L);}  }  }  if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofTexture, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofPixels_T_unsigned_short_t, 0)) {
          _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Texture_readToPixels__SWIG_1(L);}  }  }  if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofTexture, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofPixels_T_float_t, 0)) {
          _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Texture_readToPixels__SWIG_2(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Texture_readToPixels'\n"
  "  Possible C/C++ prototypes are:\n" "    ofTexture::readToPixels(ofPixels &) const\n"
  "    ofTexture::readToPixels(ofShortPixels &) const\n" "    ofTexture::readToPixels(ofFloatPixels &) const\n");
  lua_error(L);return 0; }
static int _wrap_Texture_copyTo(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ; ofBufferObject *arg2 = 0 ;
  SWIG_check_num_args("ofTexture::copyTo",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::copyTo",1,"ofTexture const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofTexture::copyTo",2,"ofBufferObject &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_copyTo",1,SWIGTYPE_p_ofTexture); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofBufferObject,0))){
    SWIG_fail_ptr("Texture_copyTo",2,SWIGTYPE_p_ofBufferObject); }  ((ofTexture const *)arg1)->copyTo(*arg2); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Texture_getTextureData__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ;
  ofTextureData *result = 0 ; SWIG_check_num_args("ofTexture::getTextureData",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::getTextureData",1,"ofTexture *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_getTextureData",1,SWIGTYPE_p_ofTexture); }  result = (ofTextureData *) &(arg1)->getTextureData();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofTextureData,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Texture_getTextureData__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ;
  ofTextureData *result = 0 ; SWIG_check_num_args("ofTexture::getTextureData",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::getTextureData",1,"ofTexture const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_getTextureData",1,SWIGTYPE_p_ofTexture); } 
  result = (ofTextureData *) &((ofTexture const *)arg1)->getTextureData();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofTextureData,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Texture_getTextureData(lua_State* L) { int argc; int argv[2]={ 1,2} ; argc = lua_gettop(L); if (argc == 1) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofTexture, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { return _wrap_Texture_getTextureData__SWIG_0(L);}  }  if (argc == 1) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofTexture, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { return _wrap_Texture_getTextureData__SWIG_1(L);}  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Texture_getTextureData'\n"
  "  Possible C/C++ prototypes are:\n" "    ofTexture::getTextureData()\n" "    ofTexture::getTextureData() const\n");
  lua_error(L);return 0; }
static int _wrap_Texture_enableMipmap(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ;
  SWIG_check_num_args("ofTexture::enableMipmap",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::enableMipmap",1,"ofTexture *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_enableMipmap",1,SWIGTYPE_p_ofTexture); }  (arg1)->enableMipmap(); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Texture_disableMipmap(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ;
  SWIG_check_num_args("ofTexture::disableMipmap",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::disableMipmap",1,"ofTexture *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_disableMipmap",1,SWIGTYPE_p_ofTexture); }  (arg1)->disableMipmap(); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Texture_generateMipmap(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ;
  SWIG_check_num_args("ofTexture::generateMipmap",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::generateMipmap",1,"ofTexture *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_generateMipmap",1,SWIGTYPE_p_ofTexture); }  (arg1)->generateMipmap(); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Texture_hasMipmap(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ; bool result;
  SWIG_check_num_args("ofTexture::hasMipmap",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::hasMipmap",1,"ofTexture const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_hasMipmap",1,SWIGTYPE_p_ofTexture); }  result = (bool)((ofTexture const *)arg1)->hasMipmap();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Texture_texData_set(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ;
  ofTextureData *arg2 = (ofTextureData *) 0 ; SWIG_check_num_args("ofTexture::texData",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::texData",1,"ofTexture *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofTexture::texData",2,"ofTextureData *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_texData_set",1,SWIGTYPE_p_ofTexture); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofTextureData,0))){
    SWIG_fail_ptr("Texture_texData_set",2,SWIGTYPE_p_ofTextureData); }  if (arg1) (arg1)->texData = *arg2; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Texture_texData_get(lua_State* L) { int SWIG_arg = 0; ofTexture *arg1 = (ofTexture *) 0 ;
  ofTextureData *result = 0 ; SWIG_check_num_args("ofTexture::texData",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTexture::texData",1,"ofTexture *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Texture_texData_get",1,SWIGTYPE_p_ofTexture); }  result = (ofTextureData *)& ((arg1)->texData);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofTextureData,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static void swig_delete_Texture(void *obj) {
ofTexture *arg1 = (ofTexture *) obj;
delete arg1;
}
static int _proxy__wrap_new_Texture(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_Texture);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_Texture_attributes[] = {
    { "texData", _wrap_Texture_texData_get, _wrap_Texture_texData_set },
    {0,0,0}
};
static swig_lua_method swig_Texture_methods[]= {
    { "allocate", _wrap_Texture_allocate},
    { "allocateAsBufferTexture", _wrap_Texture_allocateAsBufferTexture},
    { "isAllocated", _wrap_Texture_isAllocated},
    { "clear", _wrap_Texture_clear},
    { "setUseExternalTextureID", _wrap_Texture_setUseExternalTextureID},
    { "loadData", _wrap_Texture_loadData},
    { "loadScreenData", _wrap_Texture_loadScreenData},
    { "draw", _wrap_Texture_draw},
    { "drawSubsection", _wrap_Texture_drawSubsection},
    { "getQuad", _wrap_Texture_getQuad},
    { "getMeshForSubsection", _wrap_Texture_getMeshForSubsection},
    { "bind", _wrap_Texture_bind},
    { "unbind", _wrap_Texture_unbind},
    { "getAlphaMask", _wrap_Texture_getAlphaMask},
    { "getHeight", _wrap_Texture_getHeight},
    { "getWidth", _wrap_Texture_getWidth},
    { "setAnchorPercent", _wrap_Texture_setAnchorPercent},
    { "setAnchorPoint", _wrap_Texture_setAnchorPoint},
    { "resetAnchor", _wrap_Texture_resetAnchor},
    { "getCoordFromPoint", _wrap_Texture_getCoordFromPoint},
    { "getCoordFromPercent", _wrap_Texture_getCoordFromPercent},
    { "setAlphaMask", _wrap_Texture_setAlphaMask},
    { "disableAlphaMask", _wrap_Texture_disableAlphaMask},
    { "setTextureWrap", _wrap_Texture_setTextureWrap},
    { "setTextureMinMagFilter", _wrap_Texture_setTextureMinMagFilter},
    { "setTextureMatrix", _wrap_Texture_setTextureMatrix},
    { "getTextureMatrix", _wrap_Texture_getTextureMatrix},
    { "isUsingTextureMatrix", _wrap_Texture_isUsingTextureMatrix},
    { "disableTextureMatrix", _wrap_Texture_disableTextureMatrix},
    { "setCompression", _wrap_Texture_setCompression},
    { "setRGToRGBASwizzles", _wrap_Texture_setRGToRGBASwizzles},
    { "setSwizzle", _wrap_Texture_setSwizzle},
    { "readToPixels", _wrap_Texture_readToPixels},
    { "copyTo", _wrap_Texture_copyTo},
    { "getTextureData", _wrap_Texture_getTextureData},
    { "enableMipmap", _wrap_Texture_enableMipmap},
    { "disableMipmap", _wrap_Texture_disableMipmap},
    { "generateMipmap", _wrap_Texture_generateMipmap},
    { "hasMipmap", _wrap_Texture_hasMipmap},
    {0,0}
};
static swig_lua_method swig_Texture_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_Texture_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_Texture_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_Texture_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_Texture_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_Texture_Sf_SwigStatic = {
    "Texture",
    swig_Texture_Sf_SwigStatic_methods,
    swig_Texture_Sf_SwigStatic_attributes,
    swig_Texture_Sf_SwigStatic_constants,
    swig_Texture_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_Texture_bases[] = {0};
static const char *swig_Texture_base_names[] = {0};
static swig_lua_class _wrap_class_Texture = { "Texture", "Texture", &SWIGTYPE_p_ofTexture,_proxy__wrap_new_Texture, swig_delete_Texture, swig_Texture_methods, swig_Texture_attributes, &swig_Texture_Sf_SwigStatic, swig_Texture_meta, swig_Texture_bases, swig_Texture_base_names };

static int _wrap_imageFormatExtension(lua_State* L) { int SWIG_arg = 0; ofImageFormat arg1 ; std::string result;
  SWIG_check_num_args("ofImageFormatExtension",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofImageFormatExtension",1,"ofImageFormat");
  arg1 = (ofImageFormat)(int)lua_tonumber(L, 1); result = ofImageFormatExtension(arg1);
  lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_ImageLoadSettings_accurate_set(lua_State* L) { int SWIG_arg = 0;
  ofImageLoadSettings *arg1 = (ofImageLoadSettings *) 0 ; bool arg2 ; SWIG_check_num_args("ofImageLoadSettings::accurate",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImageLoadSettings::accurate",1,"ofImageLoadSettings *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofImageLoadSettings::accurate",2,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImageLoadSettings,0))){
    SWIG_fail_ptr("ImageLoadSettings_accurate_set",1,SWIGTYPE_p_ofImageLoadSettings); }  arg2 = (lua_toboolean(L, 2)!=0);
  if (arg1) (arg1)->accurate = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ImageLoadSettings_accurate_get(lua_State* L) { int SWIG_arg = 0;
  ofImageLoadSettings *arg1 = (ofImageLoadSettings *) 0 ; bool result; SWIG_check_num_args("ofImageLoadSettings::accurate",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImageLoadSettings::accurate",1,"ofImageLoadSettings *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImageLoadSettings,0))){
    SWIG_fail_ptr("ImageLoadSettings_accurate_get",1,SWIGTYPE_p_ofImageLoadSettings); }  result = (bool) ((arg1)->accurate);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ImageLoadSettings_exifRotate_set(lua_State* L) { int SWIG_arg = 0;
  ofImageLoadSettings *arg1 = (ofImageLoadSettings *) 0 ; bool arg2 ; SWIG_check_num_args("ofImageLoadSettings::exifRotate",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImageLoadSettings::exifRotate",1,"ofImageLoadSettings *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofImageLoadSettings::exifRotate",2,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImageLoadSettings,0))){
    SWIG_fail_ptr("ImageLoadSettings_exifRotate_set",1,SWIGTYPE_p_ofImageLoadSettings); }  arg2 = (lua_toboolean(L, 2)!=0);
  if (arg1) (arg1)->exifRotate = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ImageLoadSettings_exifRotate_get(lua_State* L) { int SWIG_arg = 0;
  ofImageLoadSettings *arg1 = (ofImageLoadSettings *) 0 ; bool result;
  SWIG_check_num_args("ofImageLoadSettings::exifRotate",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImageLoadSettings::exifRotate",1,"ofImageLoadSettings *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImageLoadSettings,0))){
    SWIG_fail_ptr("ImageLoadSettings_exifRotate_get",1,SWIGTYPE_p_ofImageLoadSettings); }  result = (bool) ((arg1)->exifRotate);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ImageLoadSettings_grayscale_set(lua_State* L) { int SWIG_arg = 0;
  ofImageLoadSettings *arg1 = (ofImageLoadSettings *) 0 ; bool arg2 ; SWIG_check_num_args("ofImageLoadSettings::grayscale",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImageLoadSettings::grayscale",1,"ofImageLoadSettings *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofImageLoadSettings::grayscale",2,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImageLoadSettings,0))){
    SWIG_fail_ptr("ImageLoadSettings_grayscale_set",1,SWIGTYPE_p_ofImageLoadSettings); }  arg2 = (lua_toboolean(L, 2)!=0);
  if (arg1) (arg1)->grayscale = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ImageLoadSettings_grayscale_get(lua_State* L) { int SWIG_arg = 0;
  ofImageLoadSettings *arg1 = (ofImageLoadSettings *) 0 ; bool result; SWIG_check_num_args("ofImageLoadSettings::grayscale",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImageLoadSettings::grayscale",1,"ofImageLoadSettings *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImageLoadSettings,0))){
    SWIG_fail_ptr("ImageLoadSettings_grayscale_get",1,SWIGTYPE_p_ofImageLoadSettings); }  result = (bool) ((arg1)->grayscale);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ImageLoadSettings_separateCMYK_set(lua_State* L) { int SWIG_arg = 0;
  ofImageLoadSettings *arg1 = (ofImageLoadSettings *) 0 ; bool arg2 ;
  SWIG_check_num_args("ofImageLoadSettings::separateCMYK",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImageLoadSettings::separateCMYK",1,"ofImageLoadSettings *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofImageLoadSettings::separateCMYK",2,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImageLoadSettings,0))){
    SWIG_fail_ptr("ImageLoadSettings_separateCMYK_set",1,SWIGTYPE_p_ofImageLoadSettings); }  arg2 = (lua_toboolean(L, 2)!=0);
  if (arg1) (arg1)->separateCMYK = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ImageLoadSettings_separateCMYK_get(lua_State* L) { int SWIG_arg = 0;
  ofImageLoadSettings *arg1 = (ofImageLoadSettings *) 0 ; bool result;
  SWIG_check_num_args("ofImageLoadSettings::separateCMYK",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImageLoadSettings::separateCMYK",1,"ofImageLoadSettings *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImageLoadSettings,0))){
    SWIG_fail_ptr("ImageLoadSettings_separateCMYK_get",1,SWIGTYPE_p_ofImageLoadSettings); } 
  result = (bool) ((arg1)->separateCMYK); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_new_ImageLoadSettings(lua_State* L) { int SWIG_arg = 0; ofImageLoadSettings *result = 0 ;
  SWIG_check_num_args("ofImageLoadSettings::ofImageLoadSettings",0,0) result = (ofImageLoadSettings *)new ofImageLoadSettings();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofImageLoadSettings,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static void swig_delete_ImageLoadSettings(void *obj) {
ofImageLoadSettings *arg1 = (ofImageLoadSettings *) obj;
delete arg1;
}
static int _proxy__wrap_new_ImageLoadSettings(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_ImageLoadSettings);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_ImageLoadSettings_attributes[] = {
    { "accurate", _wrap_ImageLoadSettings_accurate_get, _wrap_ImageLoadSettings_accurate_set },
    { "exifRotate", _wrap_ImageLoadSettings_exifRotate_get, _wrap_ImageLoadSettings_exifRotate_set },
    { "grayscale", _wrap_ImageLoadSettings_grayscale_get, _wrap_ImageLoadSettings_grayscale_set },
    { "separateCMYK", _wrap_ImageLoadSettings_separateCMYK_get, _wrap_ImageLoadSettings_separateCMYK_set },
    {0,0,0}
};
static swig_lua_method swig_ImageLoadSettings_methods[]= {
    {0,0}
};
static swig_lua_method swig_ImageLoadSettings_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_ImageLoadSettings_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_ImageLoadSettings_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_ImageLoadSettings_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_ImageLoadSettings_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_ImageLoadSettings_Sf_SwigStatic = {
    "ImageLoadSettings",
    swig_ImageLoadSettings_Sf_SwigStatic_methods,
    swig_ImageLoadSettings_Sf_SwigStatic_attributes,
    swig_ImageLoadSettings_Sf_SwigStatic_constants,
    swig_ImageLoadSettings_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_ImageLoadSettings_bases[] = {0};
static const char *swig_ImageLoadSettings_base_names[] = {0};
static swig_lua_class _wrap_class_ImageLoadSettings = { "ImageLoadSettings", "ImageLoadSettings", &SWIGTYPE_p_ofImageLoadSettings,_proxy__wrap_new_ImageLoadSettings, swig_delete_ImageLoadSettings, swig_ImageLoadSettings_methods, swig_ImageLoadSettings_attributes, &swig_ImageLoadSettings_Sf_SwigStatic, swig_ImageLoadSettings_meta, swig_ImageLoadSettings_bases, swig_ImageLoadSettings_base_names };

static int _wrap_new_Image__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofImage_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofImage_< unsigned char >::ofImage_",0,0)
  result = (ofImage_< unsigned char > *)new ofImage_< unsigned char >();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofImage_T_unsigned_char_t,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_Image__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofPixels_< unsigned char > *arg1 = 0 ;
  ofImage_< unsigned char > *result = 0 ; SWIG_check_num_args("ofImage_< unsigned char >::ofImage_",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofImage_< unsigned char >::ofImage_",1,"ofPixels_< unsigned char > const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0))){
    SWIG_fail_ptr("new_Image",1,SWIGTYPE_p_ofPixels_T_unsigned_char_t); } 
  result = (ofImage_< unsigned char > *)new ofImage_< unsigned char >((ofPixels_< unsigned char > const &)*arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofImage_T_unsigned_char_t,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_Image__SWIG_2(lua_State* L) { int SWIG_arg = 0; std::filesystem::path *arg1 = 0 ;
  ofImageLoadSettings *arg2 = 0 ; std::filesystem::path temp1 ; ofImage_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofImage_< unsigned char >::ofImage_",2,2)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofImage_< unsigned char >::ofImage_",1,"std::filesystem::path const &");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofImage_< unsigned char >::ofImage_",2,"ofImageLoadSettings const &"); {
    size_t len = lua_rawlen(L, 1); temp1 = lua_tolstring(L, 1, &len); arg1 = &temp1; } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofImageLoadSettings,0))){
    SWIG_fail_ptr("new_Image",2,SWIGTYPE_p_ofImageLoadSettings); } 
  result = (ofImage_< unsigned char > *)new ofImage_< unsigned char >((std::filesystem::path const &)*arg1,(ofImageLoadSettings const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofImage_T_unsigned_char_t,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_Image__SWIG_3(lua_State* L) { int SWIG_arg = 0; std::filesystem::path *arg1 = 0 ;
  std::filesystem::path temp1 ; ofImage_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofImage_< unsigned char >::ofImage_",1,1)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofImage_< unsigned char >::ofImage_",1,"std::filesystem::path const &"); {
    size_t len = lua_rawlen(L, 1); temp1 = lua_tolstring(L, 1, &len); arg1 = &temp1; } 
  result = (ofImage_< unsigned char > *)new ofImage_< unsigned char >((std::filesystem::path const &)*arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofImage_T_unsigned_char_t,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_Image__SWIG_4(lua_State* L) { int SWIG_arg = 0; ofImage_< unsigned char > *arg1 = 0 ;
  ofImage_< unsigned char > *result = 0 ; SWIG_check_num_args("ofImage_< unsigned char >::ofImage_",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofImage_< unsigned char >::ofImage_",1,"ofImage_< unsigned char > &&");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_char_t,0))){
    SWIG_fail_ptr("new_Image",1,SWIGTYPE_p_ofImage_T_unsigned_char_t); } 
  result = (ofImage_< unsigned char > *)new ofImage_< unsigned char >((ofImage_< unsigned char > &&)*arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofImage_T_unsigned_char_t,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_Image(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 0) {
    return _wrap_new_Image__SWIG_0(L);}  if (argc == 1) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofPixels_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_new_Image__SWIG_1(L);}  }  if (argc == 1) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_new_Image__SWIG_4(L);}  }  if (argc == 1) { int _v; {
      _v = lua_isstring(L, argv[0]); }  if (_v) { return _wrap_new_Image__SWIG_3(L);}  }  if (argc == 2) { int _v; {
      _v = lua_isstring(L, argv[0]); }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofImageLoadSettings, 0)) {
          _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_new_Image__SWIG_2(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_Image'\n" "  Possible C/C++ prototypes are:\n"
  "    ofImage_< unsigned char >::ofImage_()\n" "    ofImage_< unsigned char >::ofImage_(ofPixels_< unsigned char > const &)\n"
  "    ofImage_< unsigned char >::ofImage_(std::filesystem::path const &,ofImageLoadSettings const &)\n"
  "    ofImage_< unsigned char >::ofImage_(std::filesystem::path const &)\n"
  "    ofImage_< unsigned char >::ofImage_(ofImage_< unsigned char > &&)\n"); lua_error(L);return 0; }
static int _wrap_Image_allocate(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned char > *arg1 = (ofImage_< unsigned char > *) 0 ; int arg2 ; int arg3 ; ofImageType arg4 ;
  SWIG_check_num_args("ofImage_< unsigned char >::allocate",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned char >::allocate",1,"ofImage_< unsigned char > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofImage_< unsigned char >::allocate",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofImage_< unsigned char >::allocate",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofImage_< unsigned char >::allocate",4,"ofImageType");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Image_allocate",1,SWIGTYPE_p_ofImage_T_unsigned_char_t); }  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3); arg4 = (ofImageType)(int)lua_tonumber(L, 4); (arg1)->allocate(arg2,arg3,arg4);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Image_isAllocated(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned char > *arg1 = (ofImage_< unsigned char > *) 0 ; bool result;
  SWIG_check_num_args("ofImage_< unsigned char >::isAllocated",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned char >::isAllocated",1,"ofImage_< unsigned char > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Image_isAllocated",1,SWIGTYPE_p_ofImage_T_unsigned_char_t); } 
  result = (bool)((ofImage_< unsigned char > const *)arg1)->isAllocated(); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Image_clear(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned char > *arg1 = (ofImage_< unsigned char > *) 0 ;
  SWIG_check_num_args("ofImage_< unsigned char >::clear",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned char >::clear",1,"ofImage_< unsigned char > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Image_clear",1,SWIGTYPE_p_ofImage_T_unsigned_char_t); }  (arg1)->clear(); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Image_load__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned char > *arg1 = (ofImage_< unsigned char > *) 0 ; std::filesystem::path *arg2 = 0 ;
  ofImageLoadSettings *arg3 = 0 ; std::filesystem::path temp2 ; bool result;
  SWIG_check_num_args("ofImage_< unsigned char >::load",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned char >::load",1,"ofImage_< unsigned char > *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofImage_< unsigned char >::load",2,"std::filesystem::path const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofImage_< unsigned char >::load",3,"ofImageLoadSettings const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Image_load",1,SWIGTYPE_p_ofImage_T_unsigned_char_t); }  { size_t len = lua_rawlen(L, 2);
    temp2 = lua_tolstring(L, 2, &len); arg2 = &temp2; } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_ofImageLoadSettings,0))){
    SWIG_fail_ptr("Image_load",3,SWIGTYPE_p_ofImageLoadSettings); } 
  result = (bool)(arg1)->load((std::filesystem::path const &)*arg2,(ofImageLoadSettings const &)*arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Image_load__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned char > *arg1 = (ofImage_< unsigned char > *) 0 ; std::filesystem::path *arg2 = 0 ;
  std::filesystem::path temp2 ; bool result; SWIG_check_num_args("ofImage_< unsigned char >::load",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned char >::load",1,"ofImage_< unsigned char > *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofImage_< unsigned char >::load",2,"std::filesystem::path const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Image_load",1,SWIGTYPE_p_ofImage_T_unsigned_char_t); }  { size_t len = lua_rawlen(L, 2);
    temp2 = lua_tolstring(L, 2, &len); arg2 = &temp2; }  result = (bool)(arg1)->load((std::filesystem::path const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Image_load__SWIG_2(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned char > *arg1 = (ofImage_< unsigned char > *) 0 ; ofBuffer *arg2 = 0 ; ofImageLoadSettings *arg3 = 0 ;
  bool result; SWIG_check_num_args("ofImage_< unsigned char >::load",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned char >::load",1,"ofImage_< unsigned char > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofImage_< unsigned char >::load",2,"ofBuffer const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofImage_< unsigned char >::load",3,"ofImageLoadSettings const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Image_load",1,SWIGTYPE_p_ofImage_T_unsigned_char_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofBuffer,0))){ SWIG_fail_ptr("Image_load",2,SWIGTYPE_p_ofBuffer); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_ofImageLoadSettings,0))){
    SWIG_fail_ptr("Image_load",3,SWIGTYPE_p_ofImageLoadSettings); } 
  result = (bool)(arg1)->load((ofBuffer const &)*arg2,(ofImageLoadSettings const &)*arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Image_load__SWIG_3(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned char > *arg1 = (ofImage_< unsigned char > *) 0 ; ofBuffer *arg2 = 0 ; bool result;
  SWIG_check_num_args("ofImage_< unsigned char >::load",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned char >::load",1,"ofImage_< unsigned char > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofImage_< unsigned char >::load",2,"ofBuffer const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Image_load",1,SWIGTYPE_p_ofImage_T_unsigned_char_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofBuffer,0))){ SWIG_fail_ptr("Image_load",2,SWIGTYPE_p_ofBuffer); }
   result = (bool)(arg1)->load((ofBuffer const &)*arg2); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Image_load(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 2) { int _v; {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofBuffer, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Image_load__SWIG_3(L);}  }  }  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L, argv[1]); }  if (_v) {
        return _wrap_Image_load__SWIG_1(L);}  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofBuffer, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_ofImageLoadSettings, 0)) {
            _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Image_load__SWIG_2(L);}  }  }  }  if (argc == 3) { int _v; {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L, argv[1]); }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_ofImageLoadSettings, 0)) {
            _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Image_load__SWIG_0(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Image_load'\n" "  Possible C/C++ prototypes are:\n"
  "    ofImage_< unsigned char >::load(std::filesystem::path const &,ofImageLoadSettings const &)\n"
  "    ofImage_< unsigned char >::load(std::filesystem::path const &)\n"
  "    ofImage_< unsigned char >::load(ofBuffer const &,ofImageLoadSettings const &)\n"
  "    ofImage_< unsigned char >::load(ofBuffer const &)\n"); lua_error(L);return 0; }
static int _wrap_Image_draw__SWIG_0_0(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned char > *arg1 = (ofImage_< unsigned char > *) 0 ; glm::vec2 *arg2 = 0 ; SWIG_check_num_args("draw",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("draw",1,"ofImage_< unsigned char > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("draw",2,"glm::vec2 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Image_draw",1,SWIGTYPE_p_ofImage_T_unsigned_char_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec2,0))){
    SWIG_fail_ptr("Image_draw",2,SWIGTYPE_p_glm__vec2); } 
  ((ofImage_< unsigned char > const *)arg1)->draw((glm::vec2 const &)*arg2); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Image_draw__SWIG_0_1(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned char > *arg1 = (ofImage_< unsigned char > *) 0 ; ofRectangle *arg2 = 0 ; SWIG_check_num_args("draw",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("draw",1,"ofImage_< unsigned char > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("draw",2,"ofRectangle const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Image_draw",1,SWIGTYPE_p_ofImage_T_unsigned_char_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Image_draw",2,SWIGTYPE_p_ofRectangle); } 
  ((ofImage_< unsigned char > const *)arg1)->draw((ofRectangle const &)*arg2); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Image_draw__SWIG_0_2(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned char > *arg1 = (ofImage_< unsigned char > *) 0 ; glm::vec2 *arg2 = 0 ; float arg3 ; float arg4 ;
  SWIG_check_num_args("draw",4,4) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("draw",1,"ofImage_< unsigned char > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("draw",2,"glm::vec2 const &"); if(!lua_isnumber(L,3)) SWIG_fail_arg("draw",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("draw",4,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Image_draw",1,SWIGTYPE_p_ofImage_T_unsigned_char_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec2,0))){
    SWIG_fail_ptr("Image_draw",2,SWIGTYPE_p_glm__vec2); }  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  ((ofImage_< unsigned char > const *)arg1)->draw((glm::vec2 const &)*arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Image_draw__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned char > *arg1 = (ofImage_< unsigned char > *) 0 ; float arg2 ; float arg3 ;
  SWIG_check_num_args("ofImage_< unsigned char >::draw",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned char >::draw",1,"ofImage_< unsigned char > const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofImage_< unsigned char >::draw",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofImage_< unsigned char >::draw",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Image_draw",1,SWIGTYPE_p_ofImage_T_unsigned_char_t); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); ((ofImage_< unsigned char > const *)arg1)->draw(arg2,arg3); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Image_draw__SWIG_2(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned char > *arg1 = (ofImage_< unsigned char > *) 0 ; float arg2 ; float arg3 ; float arg4 ;
  SWIG_check_num_args("ofImage_< unsigned char >::draw",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned char >::draw",1,"ofImage_< unsigned char > const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofImage_< unsigned char >::draw",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofImage_< unsigned char >::draw",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofImage_< unsigned char >::draw",4,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Image_draw",1,SWIGTYPE_p_ofImage_T_unsigned_char_t); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  ((ofImage_< unsigned char > const *)arg1)->draw(arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Image_draw__SWIG_3(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned char > *arg1 = (ofImage_< unsigned char > *) 0 ; glm::vec3 *arg2 = 0 ;
  SWIG_check_num_args("ofImage_< unsigned char >::draw",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned char >::draw",1,"ofImage_< unsigned char > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofImage_< unsigned char >::draw",2,"glm::vec3 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Image_draw",1,SWIGTYPE_p_ofImage_T_unsigned_char_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("Image_draw",2,SWIGTYPE_p_glm__vec3); } 
  ((ofImage_< unsigned char > const *)arg1)->draw((glm::vec3 const &)*arg2); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Image_draw__SWIG_4(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned char > *arg1 = (ofImage_< unsigned char > *) 0 ; float arg2 ; float arg3 ; float arg4 ; float arg5 ;
  SWIG_check_num_args("ofImage_< unsigned char >::draw",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned char >::draw",1,"ofImage_< unsigned char > const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofImage_< unsigned char >::draw",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofImage_< unsigned char >::draw",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofImage_< unsigned char >::draw",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofImage_< unsigned char >::draw",5,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Image_draw",1,SWIGTYPE_p_ofImage_T_unsigned_char_t); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); arg5 = (float)lua_tonumber(L, 5);
  ((ofImage_< unsigned char > const *)arg1)->draw(arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Image_draw__SWIG_5(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned char > *arg1 = (ofImage_< unsigned char > *) 0 ; float arg2 ; float arg3 ; float arg4 ; float arg5 ;
  float arg6 ; SWIG_check_num_args("ofImage_< unsigned char >::draw",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned char >::draw",1,"ofImage_< unsigned char > const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofImage_< unsigned char >::draw",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofImage_< unsigned char >::draw",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofImage_< unsigned char >::draw",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofImage_< unsigned char >::draw",5,"float");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofImage_< unsigned char >::draw",6,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Image_draw",1,SWIGTYPE_p_ofImage_T_unsigned_char_t); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); arg5 = (float)lua_tonumber(L, 5);
  arg6 = (float)lua_tonumber(L, 6); ((ofImage_< unsigned char > const *)arg1)->draw(arg2,arg3,arg4,arg5,arg6); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Image_draw__SWIG_6(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned char > *arg1 = (ofImage_< unsigned char > *) 0 ; glm::vec3 *arg2 = 0 ; float arg3 ; float arg4 ;
  SWIG_check_num_args("ofImage_< unsigned char >::draw",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned char >::draw",1,"ofImage_< unsigned char > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofImage_< unsigned char >::draw",2,"glm::vec3 const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofImage_< unsigned char >::draw",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofImage_< unsigned char >::draw",4,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Image_draw",1,SWIGTYPE_p_ofImage_T_unsigned_char_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("Image_draw",2,SWIGTYPE_p_glm__vec3); }  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  ((ofImage_< unsigned char > const *)arg1)->draw((glm::vec3 const &)*arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Image_draw(lua_State* L) { int argc; int argv[7]={ 1,2,3,4,5,6,7} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec2, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Image_draw__SWIG_0_0(L);}  }  }  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Image_draw__SWIG_0_1(L);}  }  }  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Image_draw__SWIG_3(L);}  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { return _wrap_Image_draw__SWIG_1(L);}  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec2, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); } 
          if (_v) { return _wrap_Image_draw__SWIG_0_2(L);}  }  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); } 
          if (_v) { return _wrap_Image_draw__SWIG_6(L);}  }  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_Image_draw__SWIG_2(L);}  }  }  }  } 
  if (argc == 5) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) {
              return _wrap_Image_draw__SWIG_4(L);}  }  }  }  }  }  if (argc == 6) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) { {
                _v = lua_isnumber(L,argv[5]); }  if (_v) { return _wrap_Image_draw__SWIG_5(L);}  }  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Image_draw'\n" "  Possible C/C++ prototypes are:\n"
  "    draw(glm::vec2 const &) const\n" "    draw(ofRectangle const &) const\n"
  "    draw(glm::vec2 const &,float,float) const\n" "    ofImage_< unsigned char >::draw(float,float) const\n"
  "    ofImage_< unsigned char >::draw(float,float,float) const\n"
  "    ofImage_< unsigned char >::draw(glm::vec3 const &) const\n"
  "    ofImage_< unsigned char >::draw(float,float,float,float) const\n"
  "    ofImage_< unsigned char >::draw(float,float,float,float,float) const\n"
  "    ofImage_< unsigned char >::draw(glm::vec3 const &,float,float) const\n"); lua_error(L);return 0; }
static int _wrap_Image_drawSubsection__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned char > *arg1 = (ofImage_< unsigned char > *) 0 ; float arg2 ; float arg3 ; float arg4 ; float arg5 ;
  float arg6 ; float arg7 ; SWIG_check_num_args("ofImage_< unsigned char >::drawSubsection",7,7)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned char >::drawSubsection",1,"ofImage_< unsigned char > const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofImage_< unsigned char >::drawSubsection",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofImage_< unsigned char >::drawSubsection",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofImage_< unsigned char >::drawSubsection",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofImage_< unsigned char >::drawSubsection",5,"float");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofImage_< unsigned char >::drawSubsection",6,"float");
  if(!lua_isnumber(L,7)) SWIG_fail_arg("ofImage_< unsigned char >::drawSubsection",7,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Image_drawSubsection",1,SWIGTYPE_p_ofImage_T_unsigned_char_t); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); arg5 = (float)lua_tonumber(L, 5);
  arg6 = (float)lua_tonumber(L, 6); arg7 = (float)lua_tonumber(L, 7);
  ((ofImage_< unsigned char > const *)arg1)->drawSubsection(arg2,arg3,arg4,arg5,arg6,arg7); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Image_drawSubsection__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned char > *arg1 = (ofImage_< unsigned char > *) 0 ; float arg2 ; float arg3 ; float arg4 ; float arg5 ;
  float arg6 ; float arg7 ; float arg8 ; SWIG_check_num_args("ofImage_< unsigned char >::drawSubsection",8,8)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned char >::drawSubsection",1,"ofImage_< unsigned char > const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofImage_< unsigned char >::drawSubsection",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofImage_< unsigned char >::drawSubsection",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofImage_< unsigned char >::drawSubsection",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofImage_< unsigned char >::drawSubsection",5,"float");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofImage_< unsigned char >::drawSubsection",6,"float");
  if(!lua_isnumber(L,7)) SWIG_fail_arg("ofImage_< unsigned char >::drawSubsection",7,"float");
  if(!lua_isnumber(L,8)) SWIG_fail_arg("ofImage_< unsigned char >::drawSubsection",8,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Image_drawSubsection",1,SWIGTYPE_p_ofImage_T_unsigned_char_t); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); arg5 = (float)lua_tonumber(L, 5);
  arg6 = (float)lua_tonumber(L, 6); arg7 = (float)lua_tonumber(L, 7); arg8 = (float)lua_tonumber(L, 8);
  ((ofImage_< unsigned char > const *)arg1)->drawSubsection(arg2,arg3,arg4,arg5,arg6,arg7,arg8); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Image_drawSubsection__SWIG_2(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned char > *arg1 = (ofImage_< unsigned char > *) 0 ; float arg2 ; float arg3 ; float arg4 ; float arg5 ;
  float arg6 ; float arg7 ; float arg8 ; float arg9 ; SWIG_check_num_args("ofImage_< unsigned char >::drawSubsection",9,9)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned char >::drawSubsection",1,"ofImage_< unsigned char > const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofImage_< unsigned char >::drawSubsection",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofImage_< unsigned char >::drawSubsection",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofImage_< unsigned char >::drawSubsection",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofImage_< unsigned char >::drawSubsection",5,"float");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofImage_< unsigned char >::drawSubsection",6,"float");
  if(!lua_isnumber(L,7)) SWIG_fail_arg("ofImage_< unsigned char >::drawSubsection",7,"float");
  if(!lua_isnumber(L,8)) SWIG_fail_arg("ofImage_< unsigned char >::drawSubsection",8,"float");
  if(!lua_isnumber(L,9)) SWIG_fail_arg("ofImage_< unsigned char >::drawSubsection",9,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Image_drawSubsection",1,SWIGTYPE_p_ofImage_T_unsigned_char_t); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); arg5 = (float)lua_tonumber(L, 5);
  arg6 = (float)lua_tonumber(L, 6); arg7 = (float)lua_tonumber(L, 7); arg8 = (float)lua_tonumber(L, 8);
  arg9 = (float)lua_tonumber(L, 9);
  ((ofImage_< unsigned char > const *)arg1)->drawSubsection(arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Image_drawSubsection__SWIG_3(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned char > *arg1 = (ofImage_< unsigned char > *) 0 ; float arg2 ; float arg3 ; float arg4 ; float arg5 ;
  float arg6 ; float arg7 ; float arg8 ; float arg9 ; float arg10 ;
  SWIG_check_num_args("ofImage_< unsigned char >::drawSubsection",10,10)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned char >::drawSubsection",1,"ofImage_< unsigned char > const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofImage_< unsigned char >::drawSubsection",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofImage_< unsigned char >::drawSubsection",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofImage_< unsigned char >::drawSubsection",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofImage_< unsigned char >::drawSubsection",5,"float");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofImage_< unsigned char >::drawSubsection",6,"float");
  if(!lua_isnumber(L,7)) SWIG_fail_arg("ofImage_< unsigned char >::drawSubsection",7,"float");
  if(!lua_isnumber(L,8)) SWIG_fail_arg("ofImage_< unsigned char >::drawSubsection",8,"float");
  if(!lua_isnumber(L,9)) SWIG_fail_arg("ofImage_< unsigned char >::drawSubsection",9,"float");
  if(!lua_isnumber(L,10)) SWIG_fail_arg("ofImage_< unsigned char >::drawSubsection",10,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Image_drawSubsection",1,SWIGTYPE_p_ofImage_T_unsigned_char_t); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); arg5 = (float)lua_tonumber(L, 5);
  arg6 = (float)lua_tonumber(L, 6); arg7 = (float)lua_tonumber(L, 7); arg8 = (float)lua_tonumber(L, 8);
  arg9 = (float)lua_tonumber(L, 9); arg10 = (float)lua_tonumber(L, 10);
  ((ofImage_< unsigned char > const *)arg1)->drawSubsection(arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Image_drawSubsection(lua_State* L) { int argc; int argv[11]={ 1,2,3,4,5,6,7,8,9,10,11} ; argc = lua_gettop(L);
  if (argc == 7) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) { {
                _v = lua_isnumber(L,argv[5]); }  if (_v) { { _v = lua_isnumber(L,argv[6]); }  if (_v) {
                  return _wrap_Image_drawSubsection__SWIG_0(L);}  }  }  }  }  }  }  }  if (argc == 8) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) { {
                _v = lua_isnumber(L,argv[5]); }  if (_v) { { _v = lua_isnumber(L,argv[6]); }  if (_v) { {
                    _v = lua_isnumber(L,argv[7]); }  if (_v) { return _wrap_Image_drawSubsection__SWIG_1(L);}  }  }  }  }  }  }
       }  }  if (argc == 9) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) { {
                _v = lua_isnumber(L,argv[5]); }  if (_v) { { _v = lua_isnumber(L,argv[6]); }  if (_v) { {
                    _v = lua_isnumber(L,argv[7]); }  if (_v) { { _v = lua_isnumber(L,argv[8]); }  if (_v) {
                      return _wrap_Image_drawSubsection__SWIG_2(L);}  }  }  }  }  }  }  }  }  }  if (argc == 10) { int _v; {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) { {
                _v = lua_isnumber(L,argv[5]); }  if (_v) { { _v = lua_isnumber(L,argv[6]); }  if (_v) { {
                    _v = lua_isnumber(L,argv[7]); }  if (_v) { { _v = lua_isnumber(L,argv[8]); }  if (_v) { {
                        _v = lua_isnumber(L,argv[9]); }  if (_v) { return _wrap_Image_drawSubsection__SWIG_3(L);}  }  }  }  }  }
             }  }  }  }  }  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Image_drawSubsection'\n"
  "  Possible C/C++ prototypes are:\n"
  "    ofImage_< unsigned char >::drawSubsection(float,float,float,float,float,float) const\n"
  "    ofImage_< unsigned char >::drawSubsection(float,float,float,float,float,float,float) const\n"
  "    ofImage_< unsigned char >::drawSubsection(float,float,float,float,float,float,float,float) const\n"
  "    ofImage_< unsigned char >::drawSubsection(float,float,float,float,float,float,float,float,float) const\n");
  lua_error(L);return 0; }
static int _wrap_Image_update(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned char > *arg1 = (ofImage_< unsigned char > *) 0 ;
  SWIG_check_num_args("ofImage_< unsigned char >::update",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned char >::update",1,"ofImage_< unsigned char > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Image_update",1,SWIGTYPE_p_ofImage_T_unsigned_char_t); }  (arg1)->update(); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Image_setUseTexture(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned char > *arg1 = (ofImage_< unsigned char > *) 0 ; bool arg2 ;
  SWIG_check_num_args("ofImage_< unsigned char >::setUseTexture",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned char >::setUseTexture",1,"ofImage_< unsigned char > *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofImage_< unsigned char >::setUseTexture",2,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Image_setUseTexture",1,SWIGTYPE_p_ofImage_T_unsigned_char_t); }  arg2 = (lua_toboolean(L, 2)!=0);
  (arg1)->setUseTexture(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Image_isUsingTexture(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned char > *arg1 = (ofImage_< unsigned char > *) 0 ; bool result;
  SWIG_check_num_args("ofImage_< unsigned char >::isUsingTexture",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned char >::isUsingTexture",1,"ofImage_< unsigned char > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Image_isUsingTexture",1,SWIGTYPE_p_ofImage_T_unsigned_char_t); } 
  result = (bool)((ofImage_< unsigned char > const *)arg1)->isUsingTexture(); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Image_getTexture__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned char > *arg1 = (ofImage_< unsigned char > *) 0 ; ofTexture *result = 0 ;
  SWIG_check_num_args("ofImage_< unsigned char >::getTexture",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned char >::getTexture",1,"ofImage_< unsigned char > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Image_getTexture",1,SWIGTYPE_p_ofImage_T_unsigned_char_t); }  result = (ofTexture *) &(arg1)->getTexture();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofTexture,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Image_getTexture__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned char > *arg1 = (ofImage_< unsigned char > *) 0 ; ofTexture *result = 0 ;
  SWIG_check_num_args("ofImage_< unsigned char >::getTexture",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned char >::getTexture",1,"ofImage_< unsigned char > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Image_getTexture",1,SWIGTYPE_p_ofImage_T_unsigned_char_t); } 
  result = (ofTexture *) &((ofImage_< unsigned char > const *)arg1)->getTexture();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofTexture,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Image_getTexture(lua_State* L) { int argc; int argv[2]={ 1,2} ; argc = lua_gettop(L); if (argc == 1) { int _v;
    { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Image_getTexture__SWIG_0(L);}  }  if (argc == 1) { int _v; {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Image_getTexture__SWIG_1(L);}  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Image_getTexture'\n" "  Possible C/C++ prototypes are:\n"
  "    ofImage_< unsigned char >::getTexture()\n" "    ofImage_< unsigned char >::getTexture() const\n");
  lua_error(L);return 0; }
static int _wrap_Image_bind__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned char > *arg1 = (ofImage_< unsigned char > *) 0 ; int arg2 ;
  SWIG_check_num_args("ofImage_< unsigned char >::bind",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned char >::bind",1,"ofImage_< unsigned char > const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofImage_< unsigned char >::bind",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Image_bind",1,SWIGTYPE_p_ofImage_T_unsigned_char_t); }  arg2 = (int)lua_tonumber(L, 2);
  ((ofImage_< unsigned char > const *)arg1)->bind(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Image_bind__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned char > *arg1 = (ofImage_< unsigned char > *) 0 ; SWIG_check_num_args("ofImage_< unsigned char >::bind",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned char >::bind",1,"ofImage_< unsigned char > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Image_bind",1,SWIGTYPE_p_ofImage_T_unsigned_char_t); }  ((ofImage_< unsigned char > const *)arg1)->bind();
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Image_bind(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 1) { int _v; {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Image_bind__SWIG_1(L);}  }  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_Image_bind__SWIG_0(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Image_bind'\n" "  Possible C/C++ prototypes are:\n"
  "    ofImage_< unsigned char >::bind(int) const\n" "    ofImage_< unsigned char >::bind() const\n"); lua_error(L);return 0; }
static int _wrap_Image_unbind__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned char > *arg1 = (ofImage_< unsigned char > *) 0 ; int arg2 ;
  SWIG_check_num_args("ofImage_< unsigned char >::unbind",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned char >::unbind",1,"ofImage_< unsigned char > const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofImage_< unsigned char >::unbind",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Image_unbind",1,SWIGTYPE_p_ofImage_T_unsigned_char_t); }  arg2 = (int)lua_tonumber(L, 2);
  ((ofImage_< unsigned char > const *)arg1)->unbind(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Image_unbind__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned char > *arg1 = (ofImage_< unsigned char > *) 0 ;
  SWIG_check_num_args("ofImage_< unsigned char >::unbind",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned char >::unbind",1,"ofImage_< unsigned char > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Image_unbind",1,SWIGTYPE_p_ofImage_T_unsigned_char_t); } 
  ((ofImage_< unsigned char > const *)arg1)->unbind(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Image_unbind(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 1) { int _v; {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Image_unbind__SWIG_1(L);}  }  if (argc == 2) { int _v; {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_Image_unbind__SWIG_0(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Image_unbind'\n" "  Possible C/C++ prototypes are:\n"
  "    ofImage_< unsigned char >::unbind(int) const\n" "    ofImage_< unsigned char >::unbind() const\n");
  lua_error(L);return 0; }
static int _wrap_Image_setCompression(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned char > *arg1 = (ofImage_< unsigned char > *) 0 ; ofTexCompression arg2 ;
  SWIG_check_num_args("ofImage_< unsigned char >::setCompression",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned char >::setCompression",1,"ofImage_< unsigned char > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofImage_< unsigned char >::setCompression",2,"ofTexCompression");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Image_setCompression",1,SWIGTYPE_p_ofImage_T_unsigned_char_t); } 
  arg2 = (ofTexCompression)(int)lua_tonumber(L, 2); (arg1)->setCompression(arg2); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Image_getPixels__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned char > *arg1 = (ofImage_< unsigned char > *) 0 ; ofPixels_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofImage_< unsigned char >::getPixels",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned char >::getPixels",1,"ofImage_< unsigned char > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Image_getPixels",1,SWIGTYPE_p_ofImage_T_unsigned_char_t); } 
  result = (ofPixels_< unsigned char > *) &(arg1)->getPixels();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Image_getPixels__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned char > *arg1 = (ofImage_< unsigned char > *) 0 ; ofPixels_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofImage_< unsigned char >::getPixels",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned char >::getPixels",1,"ofImage_< unsigned char > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Image_getPixels",1,SWIGTYPE_p_ofImage_T_unsigned_char_t); } 
  result = (ofPixels_< unsigned char > *) &((ofImage_< unsigned char > const *)arg1)->getPixels();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Image_getPixels(lua_State* L) { int argc; int argv[2]={ 1,2} ; argc = lua_gettop(L); if (argc == 1) { int _v; {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Image_getPixels__SWIG_0(L);}  }  if (argc == 1) { int _v; {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Image_getPixels__SWIG_1(L);}  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Image_getPixels'\n" "  Possible C/C++ prototypes are:\n"
  "    ofImage_< unsigned char >::getPixels()\n" "    ofImage_< unsigned char >::getPixels() const\n"); lua_error(L);return 0; }
static int _wrap_Image_getColor__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned char > *arg1 = (ofImage_< unsigned char > *) 0 ; int arg2 ; int arg3 ; ofColor_< unsigned char > result;
  SWIG_check_num_args("ofImage_< unsigned char >::getColor",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned char >::getColor",1,"ofImage_< unsigned char > const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofImage_< unsigned char >::getColor",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofImage_< unsigned char >::getColor",3,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Image_getColor",1,SWIGTYPE_p_ofImage_T_unsigned_char_t); }  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3); result = ((ofImage_< unsigned char > const *)arg1)->getColor(arg2,arg3); {
    ofColor_< unsigned char > * resultptr = new ofColor_< unsigned char >((const ofColor_< unsigned char > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofColor_T_unsigned_char_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Image_getColor__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned char > *arg1 = (ofImage_< unsigned char > *) 0 ; int arg2 ; ofColor_< unsigned char > result;
  SWIG_check_num_args("ofImage_< unsigned char >::getColor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned char >::getColor",1,"ofImage_< unsigned char > const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofImage_< unsigned char >::getColor",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Image_getColor",1,SWIGTYPE_p_ofImage_T_unsigned_char_t); }  arg2 = (int)lua_tonumber(L, 2);
  result = ((ofImage_< unsigned char > const *)arg1)->getColor(arg2); {
    ofColor_< unsigned char > * resultptr = new ofColor_< unsigned char >((const ofColor_< unsigned char > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofColor_T_unsigned_char_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Image_getColor(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_Image_getColor__SWIG_1(L);}  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { return _wrap_Image_getColor__SWIG_0(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Image_getColor'\n" "  Possible C/C++ prototypes are:\n"
  "    ofImage_< unsigned char >::getColor(int,int) const\n" "    ofImage_< unsigned char >::getColor(int) const\n");
  lua_error(L);return 0; }
static int _wrap_Image_getHeight(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned char > *arg1 = (ofImage_< unsigned char > *) 0 ; float result;
  SWIG_check_num_args("ofImage_< unsigned char >::getHeight",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned char >::getHeight",1,"ofImage_< unsigned char > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Image_getHeight",1,SWIGTYPE_p_ofImage_T_unsigned_char_t); } 
  result = (float)((ofImage_< unsigned char > const *)arg1)->getHeight(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Image_getWidth(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned char > *arg1 = (ofImage_< unsigned char > *) 0 ; float result;
  SWIG_check_num_args("ofImage_< unsigned char >::getWidth",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned char >::getWidth",1,"ofImage_< unsigned char > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Image_getWidth",1,SWIGTYPE_p_ofImage_T_unsigned_char_t); } 
  result = (float)((ofImage_< unsigned char > const *)arg1)->getWidth(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Image_setColor__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned char > *arg1 = (ofImage_< unsigned char > *) 0 ; int arg2 ; int arg3 ;
  ofColor_< unsigned char > *arg4 = 0 ; SWIG_check_num_args("ofImage_< unsigned char >::setColor",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned char >::setColor",1,"ofImage_< unsigned char > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofImage_< unsigned char >::setColor",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofImage_< unsigned char >::setColor",3,"int");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("ofImage_< unsigned char >::setColor",4,"ofColor_< unsigned char > const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Image_setColor",1,SWIGTYPE_p_ofImage_T_unsigned_char_t); }  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3); if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Image_setColor",4,SWIGTYPE_p_ofColor_T_unsigned_char_t); } 
  (arg1)->setColor(arg2,arg3,(ofColor_< unsigned char > const &)*arg4); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Image_setColor__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned char > *arg1 = (ofImage_< unsigned char > *) 0 ; int arg2 ; ofColor_< unsigned char > *arg3 = 0 ;
  SWIG_check_num_args("ofImage_< unsigned char >::setColor",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned char >::setColor",1,"ofImage_< unsigned char > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofImage_< unsigned char >::setColor",2,"int");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofImage_< unsigned char >::setColor",3,"ofColor_< unsigned char > const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Image_setColor",1,SWIGTYPE_p_ofImage_T_unsigned_char_t); }  arg2 = (int)lua_tonumber(L, 2);
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Image_setColor",3,SWIGTYPE_p_ofColor_T_unsigned_char_t); } 
  (arg1)->setColor(arg2,(ofColor_< unsigned char > const &)*arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Image_setColor__SWIG_2(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned char > *arg1 = (ofImage_< unsigned char > *) 0 ; ofColor_< unsigned char > *arg2 = 0 ;
  SWIG_check_num_args("ofImage_< unsigned char >::setColor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned char >::setColor",1,"ofImage_< unsigned char > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofImage_< unsigned char >::setColor",2,"ofColor_< unsigned char > const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Image_setColor",1,SWIGTYPE_p_ofImage_T_unsigned_char_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Image_setColor",2,SWIGTYPE_p_ofColor_T_unsigned_char_t); } 
  (arg1)->setColor((ofColor_< unsigned char > const &)*arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Image_setColor(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofColor_T_unsigned_char_t, 0)) {
          _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Image_setColor__SWIG_2(L);}  }  }  if (argc == 3) { int _v; {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_ofColor_T_unsigned_char_t, 0)) {
            _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Image_setColor__SWIG_1(L);}  }  }  }  if (argc == 4) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { { void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_ofColor_T_unsigned_char_t, 0)) {
              _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Image_setColor__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Image_setColor'\n" "  Possible C/C++ prototypes are:\n"
  "    ofImage_< unsigned char >::setColor(int,int,ofColor_< unsigned char > const &)\n"
  "    ofImage_< unsigned char >::setColor(int,ofColor_< unsigned char > const &)\n"
  "    ofImage_< unsigned char >::setColor(ofColor_< unsigned char > const &)\n"); lua_error(L);return 0; }
static int _wrap_Image_setFromPixels__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned char > *arg1 = (ofImage_< unsigned char > *) 0 ; unsigned char *arg2 = (unsigned char *) 0 ; int arg3 ;
  int arg4 ; ofImageType arg5 ; bool arg6 ; SWIG_check_num_args("ofImage_< unsigned char >::setFromPixels",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned char >::setFromPixels",1,"ofImage_< unsigned char > *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofImage_< unsigned char >::setFromPixels",2,"unsigned char const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofImage_< unsigned char >::setFromPixels",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofImage_< unsigned char >::setFromPixels",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofImage_< unsigned char >::setFromPixels",5,"ofImageType");
  if(!lua_isboolean(L,6)) SWIG_fail_arg("ofImage_< unsigned char >::setFromPixels",6,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Image_setFromPixels",1,SWIGTYPE_p_ofImage_T_unsigned_char_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_unsigned_char,0))){
    SWIG_fail_ptr("Image_setFromPixels",2,SWIGTYPE_p_unsigned_char); }  arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4); arg5 = (ofImageType)(int)lua_tonumber(L, 5); arg6 = (lua_toboolean(L, 6)!=0);
  (arg1)->setFromPixels((unsigned char const *)arg2,arg3,arg4,arg5,arg6); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Image_setFromPixels__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned char > *arg1 = (ofImage_< unsigned char > *) 0 ; unsigned char *arg2 = (unsigned char *) 0 ; int arg3 ;
  int arg4 ; ofImageType arg5 ; SWIG_check_num_args("ofImage_< unsigned char >::setFromPixels",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned char >::setFromPixels",1,"ofImage_< unsigned char > *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofImage_< unsigned char >::setFromPixels",2,"unsigned char const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofImage_< unsigned char >::setFromPixels",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofImage_< unsigned char >::setFromPixels",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofImage_< unsigned char >::setFromPixels",5,"ofImageType");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Image_setFromPixels",1,SWIGTYPE_p_ofImage_T_unsigned_char_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_unsigned_char,0))){
    SWIG_fail_ptr("Image_setFromPixels",2,SWIGTYPE_p_unsigned_char); }  arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4); arg5 = (ofImageType)(int)lua_tonumber(L, 5);
  (arg1)->setFromPixels((unsigned char const *)arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Image_setFromPixels__SWIG_2(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned char > *arg1 = (ofImage_< unsigned char > *) 0 ; ofPixels_< unsigned char > *arg2 = 0 ;
  SWIG_check_num_args("ofImage_< unsigned char >::setFromPixels",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned char >::setFromPixels",1,"ofImage_< unsigned char > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofImage_< unsigned char >::setFromPixels",2,"ofPixels_< unsigned char > const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Image_setFromPixels",1,SWIGTYPE_p_ofImage_T_unsigned_char_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Image_setFromPixels",2,SWIGTYPE_p_ofPixels_T_unsigned_char_t); } 
  (arg1)->setFromPixels((ofPixels_< unsigned char > const &)*arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Image_setFromPixels(lua_State* L) { int argc; int argv[7]={ 1,2,3,4,5,6,7} ; argc = lua_gettop(L);
  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofPixels_T_unsigned_char_t, 0)) {
          _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Image_setFromPixels__SWIG_2(L);}  }  }  if (argc == 5) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_unsigned_char, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); } 
          if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) { return _wrap_Image_setFromPixels__SWIG_1(L);}  }  }  }  }  } 
  if (argc == 6) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_unsigned_char, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); } 
          if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) { { _v = lua_isboolean(L,argv[5]); }  if (_v) {
                return _wrap_Image_setFromPixels__SWIG_0(L);}  }  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Image_setFromPixels'\n"
  "  Possible C/C++ prototypes are:\n"
  "    ofImage_< unsigned char >::setFromPixels(unsigned char const *,int,int,ofImageType,bool)\n"
  "    ofImage_< unsigned char >::setFromPixels(unsigned char const *,int,int,ofImageType)\n"
  "    ofImage_< unsigned char >::setFromPixels(ofPixels_< unsigned char > const &)\n"); lua_error(L);return 0; }
static int _wrap_Image_grabScreen(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned char > *arg1 = (ofImage_< unsigned char > *) 0 ; int arg2 ; int arg3 ; int arg4 ; int arg5 ;
  SWIG_check_num_args("ofImage_< unsigned char >::grabScreen",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned char >::grabScreen",1,"ofImage_< unsigned char > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofImage_< unsigned char >::grabScreen",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofImage_< unsigned char >::grabScreen",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofImage_< unsigned char >::grabScreen",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofImage_< unsigned char >::grabScreen",5,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Image_grabScreen",1,SWIGTYPE_p_ofImage_T_unsigned_char_t); }  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3); arg4 = (int)lua_tonumber(L, 4); arg5 = (int)lua_tonumber(L, 5);
  (arg1)->grabScreen(arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Image_setImageType(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned char > *arg1 = (ofImage_< unsigned char > *) 0 ; ofImageType arg2 ;
  SWIG_check_num_args("ofImage_< unsigned char >::setImageType",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned char >::setImageType",1,"ofImage_< unsigned char > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofImage_< unsigned char >::setImageType",2,"ofImageType");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Image_setImageType",1,SWIGTYPE_p_ofImage_T_unsigned_char_t); }  arg2 = (ofImageType)(int)lua_tonumber(L, 2);
  (arg1)->setImageType(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Image_getImageType(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned char > *arg1 = (ofImage_< unsigned char > *) 0 ; ofImageType result;
  SWIG_check_num_args("ofImage_< unsigned char >::getImageType",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned char >::getImageType",1,"ofImage_< unsigned char > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Image_getImageType",1,SWIGTYPE_p_ofImage_T_unsigned_char_t); } 
  result = (ofImageType)((ofImage_< unsigned char > const *)arg1)->getImageType();
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Image_resize(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned char > *arg1 = (ofImage_< unsigned char > *) 0 ; int arg2 ; int arg3 ;
  SWIG_check_num_args("ofImage_< unsigned char >::resize",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned char >::resize",1,"ofImage_< unsigned char > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofImage_< unsigned char >::resize",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofImage_< unsigned char >::resize",3,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Image_resize",1,SWIGTYPE_p_ofImage_T_unsigned_char_t); }  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3); (arg1)->resize(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Image_crop(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned char > *arg1 = (ofImage_< unsigned char > *) 0 ; int arg2 ; int arg3 ; int arg4 ; int arg5 ;
  SWIG_check_num_args("ofImage_< unsigned char >::crop",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned char >::crop",1,"ofImage_< unsigned char > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofImage_< unsigned char >::crop",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofImage_< unsigned char >::crop",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofImage_< unsigned char >::crop",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofImage_< unsigned char >::crop",5,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Image_crop",1,SWIGTYPE_p_ofImage_T_unsigned_char_t); }  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3); arg4 = (int)lua_tonumber(L, 4); arg5 = (int)lua_tonumber(L, 5);
  (arg1)->crop(arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Image_cropFrom(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned char > *arg1 = (ofImage_< unsigned char > *) 0 ; ofImage_< unsigned char > *arg2 = 0 ; int arg3 ;
  int arg4 ; int arg5 ; int arg6 ; SWIG_check_num_args("ofImage_< unsigned char >::cropFrom",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned char >::cropFrom",1,"ofImage_< unsigned char > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofImage_< unsigned char >::cropFrom",2,"ofImage_< unsigned char > const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofImage_< unsigned char >::cropFrom",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofImage_< unsigned char >::cropFrom",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofImage_< unsigned char >::cropFrom",5,"int");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofImage_< unsigned char >::cropFrom",6,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Image_cropFrom",1,SWIGTYPE_p_ofImage_T_unsigned_char_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofImage_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Image_cropFrom",2,SWIGTYPE_p_ofImage_T_unsigned_char_t); }  arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4); arg5 = (int)lua_tonumber(L, 5); arg6 = (int)lua_tonumber(L, 6);
  (arg1)->cropFrom((ofImage_< unsigned char > const &)*arg2,arg3,arg4,arg5,arg6); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Image_rotate90(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned char > *arg1 = (ofImage_< unsigned char > *) 0 ; int arg2 ;
  SWIG_check_num_args("ofImage_< unsigned char >::rotate90",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned char >::rotate90",1,"ofImage_< unsigned char > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofImage_< unsigned char >::rotate90",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Image_rotate90",1,SWIGTYPE_p_ofImage_T_unsigned_char_t); }  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->rotate90(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Image_mirror(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned char > *arg1 = (ofImage_< unsigned char > *) 0 ; bool arg2 ; bool arg3 ;
  SWIG_check_num_args("ofImage_< unsigned char >::mirror",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned char >::mirror",1,"ofImage_< unsigned char > *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofImage_< unsigned char >::mirror",2,"bool");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("ofImage_< unsigned char >::mirror",3,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Image_mirror",1,SWIGTYPE_p_ofImage_T_unsigned_char_t); }  arg2 = (lua_toboolean(L, 2)!=0);
  arg3 = (lua_toboolean(L, 3)!=0); (arg1)->mirror(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Image_setAnchorPercent(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned char > *arg1 = (ofImage_< unsigned char > *) 0 ; float arg2 ; float arg3 ;
  SWIG_check_num_args("ofImage_< unsigned char >::setAnchorPercent",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned char >::setAnchorPercent",1,"ofImage_< unsigned char > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofImage_< unsigned char >::setAnchorPercent",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofImage_< unsigned char >::setAnchorPercent",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Image_setAnchorPercent",1,SWIGTYPE_p_ofImage_T_unsigned_char_t); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); (arg1)->setAnchorPercent(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Image_setAnchorPoint(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned char > *arg1 = (ofImage_< unsigned char > *) 0 ; float arg2 ; float arg3 ;
  SWIG_check_num_args("ofImage_< unsigned char >::setAnchorPoint",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned char >::setAnchorPoint",1,"ofImage_< unsigned char > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofImage_< unsigned char >::setAnchorPoint",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofImage_< unsigned char >::setAnchorPoint",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Image_setAnchorPoint",1,SWIGTYPE_p_ofImage_T_unsigned_char_t); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); (arg1)->setAnchorPoint(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Image_resetAnchor(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned char > *arg1 = (ofImage_< unsigned char > *) 0 ;
  SWIG_check_num_args("ofImage_< unsigned char >::resetAnchor",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned char >::resetAnchor",1,"ofImage_< unsigned char > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Image_resetAnchor",1,SWIGTYPE_p_ofImage_T_unsigned_char_t); }  (arg1)->resetAnchor(); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Image_save__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned char > *arg1 = (ofImage_< unsigned char > *) 0 ; std::filesystem::path *arg2 = 0 ;
  ofImageQualityType arg3 ; std::filesystem::path temp2 ; bool result;
  SWIG_check_num_args("ofImage_< unsigned char >::save",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned char >::save",1,"ofImage_< unsigned char > const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofImage_< unsigned char >::save",2,"std::filesystem::path const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofImage_< unsigned char >::save",3,"ofImageQualityType");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Image_save",1,SWIGTYPE_p_ofImage_T_unsigned_char_t); }  { size_t len = lua_rawlen(L, 2);
    temp2 = lua_tolstring(L, 2, &len); arg2 = &temp2; }  arg3 = (ofImageQualityType)(int)lua_tonumber(L, 3);
  result = (bool)((ofImage_< unsigned char > const *)arg1)->save((std::filesystem::path const &)*arg2,arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Image_save__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned char > *arg1 = (ofImage_< unsigned char > *) 0 ; std::filesystem::path *arg2 = 0 ;
  std::filesystem::path temp2 ; bool result; SWIG_check_num_args("ofImage_< unsigned char >::save",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned char >::save",1,"ofImage_< unsigned char > const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofImage_< unsigned char >::save",2,"std::filesystem::path const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Image_save",1,SWIGTYPE_p_ofImage_T_unsigned_char_t); }  { size_t len = lua_rawlen(L, 2);
    temp2 = lua_tolstring(L, 2, &len); arg2 = &temp2; } 
  result = (bool)((ofImage_< unsigned char > const *)arg1)->save((std::filesystem::path const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Image_save__SWIG_2(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned char > *arg1 = (ofImage_< unsigned char > *) 0 ; ofBuffer *arg2 = 0 ; ofImageFormat arg3 ;
  ofImageQualityType arg4 ; bool result; SWIG_check_num_args("ofImage_< unsigned char >::save",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned char >::save",1,"ofImage_< unsigned char > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofImage_< unsigned char >::save",2,"ofBuffer &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofImage_< unsigned char >::save",3,"ofImageFormat");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofImage_< unsigned char >::save",4,"ofImageQualityType");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Image_save",1,SWIGTYPE_p_ofImage_T_unsigned_char_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofBuffer,0))){ SWIG_fail_ptr("Image_save",2,SWIGTYPE_p_ofBuffer); }
   arg3 = (ofImageFormat)(int)lua_tonumber(L, 3); arg4 = (ofImageQualityType)(int)lua_tonumber(L, 4);
  result = (bool)((ofImage_< unsigned char > const *)arg1)->save(*arg2,arg3,arg4);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Image_save__SWIG_3(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned char > *arg1 = (ofImage_< unsigned char > *) 0 ; ofBuffer *arg2 = 0 ; ofImageFormat arg3 ; bool result;
  SWIG_check_num_args("ofImage_< unsigned char >::save",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned char >::save",1,"ofImage_< unsigned char > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofImage_< unsigned char >::save",2,"ofBuffer &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofImage_< unsigned char >::save",3,"ofImageFormat");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Image_save",1,SWIGTYPE_p_ofImage_T_unsigned_char_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofBuffer,0))){ SWIG_fail_ptr("Image_save",2,SWIGTYPE_p_ofBuffer); }
   arg3 = (ofImageFormat)(int)lua_tonumber(L, 3); result = (bool)((ofImage_< unsigned char > const *)arg1)->save(*arg2,arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Image_save__SWIG_4(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned char > *arg1 = (ofImage_< unsigned char > *) 0 ; ofBuffer *arg2 = 0 ; bool result;
  SWIG_check_num_args("ofImage_< unsigned char >::save",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned char >::save",1,"ofImage_< unsigned char > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofImage_< unsigned char >::save",2,"ofBuffer &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Image_save",1,SWIGTYPE_p_ofImage_T_unsigned_char_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofBuffer,0))){ SWIG_fail_ptr("Image_save",2,SWIGTYPE_p_ofBuffer); }
   result = (bool)((ofImage_< unsigned char > const *)arg1)->save(*arg2); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Image_save(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L); if (argc == 2) { int _v;
    { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofBuffer, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Image_save__SWIG_4(L);}  }  }  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L, argv[1]); }  if (_v) {
        return _wrap_Image_save__SWIG_1(L);}  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofBuffer, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { return _wrap_Image_save__SWIG_3(L);}  }  }
     }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L, argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { return _wrap_Image_save__SWIG_0(L);}  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofBuffer, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); } 
          if (_v) { return _wrap_Image_save__SWIG_2(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Image_save'\n" "  Possible C/C++ prototypes are:\n"
  "    ofImage_< unsigned char >::save(std::filesystem::path const &,ofImageQualityType) const\n"
  "    ofImage_< unsigned char >::save(std::filesystem::path const &) const\n"
  "    ofImage_< unsigned char >::save(ofBuffer &,ofImageFormat,ofImageQualityType) const\n"
  "    ofImage_< unsigned char >::save(ofBuffer &,ofImageFormat) const\n"
  "    ofImage_< unsigned char >::save(ofBuffer &) const\n"); lua_error(L);return 0; }
static void swig_delete_Image(void *obj) {
ofImage_< unsigned char > *arg1 = (ofImage_< unsigned char > *) obj;
delete arg1;
}
static int _proxy__wrap_new_Image(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_Image);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_Image_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_Image_methods[]= {
    { "allocate", _wrap_Image_allocate},
    { "isAllocated", _wrap_Image_isAllocated},
    { "clear", _wrap_Image_clear},
    { "load", _wrap_Image_load},
    { "draw", _wrap_Image_draw},
    { "drawSubsection", _wrap_Image_drawSubsection},
    { "update", _wrap_Image_update},
    { "setUseTexture", _wrap_Image_setUseTexture},
    { "isUsingTexture", _wrap_Image_isUsingTexture},
    { "getTexture", _wrap_Image_getTexture},
    { "bind", _wrap_Image_bind},
    { "unbind", _wrap_Image_unbind},
    { "setCompression", _wrap_Image_setCompression},
    { "getPixels", _wrap_Image_getPixels},
    { "getColor", _wrap_Image_getColor},
    { "getHeight", _wrap_Image_getHeight},
    { "getWidth", _wrap_Image_getWidth},
    { "setColor", _wrap_Image_setColor},
    { "setFromPixels", _wrap_Image_setFromPixels},
    { "grabScreen", _wrap_Image_grabScreen},
    { "setImageType", _wrap_Image_setImageType},
    { "getImageType", _wrap_Image_getImageType},
    { "resize", _wrap_Image_resize},
    { "crop", _wrap_Image_crop},
    { "cropFrom", _wrap_Image_cropFrom},
    { "rotate90", _wrap_Image_rotate90},
    { "mirror", _wrap_Image_mirror},
    { "setAnchorPercent", _wrap_Image_setAnchorPercent},
    { "setAnchorPoint", _wrap_Image_setAnchorPoint},
    { "resetAnchor", _wrap_Image_resetAnchor},
    { "save", _wrap_Image_save},
    {0,0}
};
static swig_lua_method swig_Image_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_Image_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_Image_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_Image_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_Image_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_Image_Sf_SwigStatic = {
    "Image",
    swig_Image_Sf_SwigStatic_methods,
    swig_Image_Sf_SwigStatic_attributes,
    swig_Image_Sf_SwigStatic_constants,
    swig_Image_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_Image_bases[] = {0};
static const char *swig_Image_base_names[] = {0};
static swig_lua_class _wrap_class_Image = { "Image", "Image", &SWIGTYPE_p_ofImage_T_unsigned_char_t,_proxy__wrap_new_Image, swig_delete_Image, swig_Image_methods, swig_Image_attributes, &swig_Image_Sf_SwigStatic, swig_Image_meta, swig_Image_bases, swig_Image_base_names };

static int _wrap_new_FloatImage__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofImage_< float > *result = 0 ;
  SWIG_check_num_args("ofImage_< float >::ofImage_",0,0) result = (ofImage_< float > *)new ofImage_< float >();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofImage_T_float_t,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_FloatImage__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofPixels_< float > *arg1 = 0 ;
  ofImage_< float > *result = 0 ; SWIG_check_num_args("ofImage_< float >::ofImage_",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofImage_< float >::ofImage_",1,"ofPixels_< float > const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_float_t,0))){
    SWIG_fail_ptr("new_FloatImage",1,SWIGTYPE_p_ofPixels_T_float_t); } 
  result = (ofImage_< float > *)new ofImage_< float >((ofPixels_< float > const &)*arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofImage_T_float_t,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_FloatImage__SWIG_2(lua_State* L) { int SWIG_arg = 0; std::filesystem::path *arg1 = 0 ;
  ofImageLoadSettings *arg2 = 0 ; std::filesystem::path temp1 ; ofImage_< float > *result = 0 ;
  SWIG_check_num_args("ofImage_< float >::ofImage_",2,2)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofImage_< float >::ofImage_",1,"std::filesystem::path const &");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofImage_< float >::ofImage_",2,"ofImageLoadSettings const &"); {
    size_t len = lua_rawlen(L, 1); temp1 = lua_tolstring(L, 1, &len); arg1 = &temp1; } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofImageLoadSettings,0))){
    SWIG_fail_ptr("new_FloatImage",2,SWIGTYPE_p_ofImageLoadSettings); } 
  result = (ofImage_< float > *)new ofImage_< float >((std::filesystem::path const &)*arg1,(ofImageLoadSettings const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofImage_T_float_t,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_FloatImage__SWIG_3(lua_State* L) { int SWIG_arg = 0; std::filesystem::path *arg1 = 0 ;
  std::filesystem::path temp1 ; ofImage_< float > *result = 0 ; SWIG_check_num_args("ofImage_< float >::ofImage_",1,1)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofImage_< float >::ofImage_",1,"std::filesystem::path const &"); {
    size_t len = lua_rawlen(L, 1); temp1 = lua_tolstring(L, 1, &len); arg1 = &temp1; } 
  result = (ofImage_< float > *)new ofImage_< float >((std::filesystem::path const &)*arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofImage_T_float_t,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_FloatImage__SWIG_4(lua_State* L) { int SWIG_arg = 0; ofImage_< float > *arg1 = 0 ;
  ofImage_< float > *result = 0 ; SWIG_check_num_args("ofImage_< float >::ofImage_",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofImage_< float >::ofImage_",1,"ofImage_< float > &&");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_float_t,0))){
    SWIG_fail_ptr("new_FloatImage",1,SWIGTYPE_p_ofImage_T_float_t); } 
  result = (ofImage_< float > *)new ofImage_< float >((ofImage_< float > &&)*arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofImage_T_float_t,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_FloatImage(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 0) {
    return _wrap_new_FloatImage__SWIG_0(L);}  if (argc == 1) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofPixels_T_float_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_new_FloatImage__SWIG_1(L);}  }  if (argc == 1) { int _v; {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_float_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_new_FloatImage__SWIG_4(L);}  }  if (argc == 1) { int _v; {
      _v = lua_isstring(L, argv[0]); }  if (_v) { return _wrap_new_FloatImage__SWIG_3(L);}  }  if (argc == 2) { int _v; {
      _v = lua_isstring(L, argv[0]); }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofImageLoadSettings, 0)) {
          _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_new_FloatImage__SWIG_2(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_FloatImage'\n" "  Possible C/C++ prototypes are:\n"
  "    ofImage_< float >::ofImage_()\n" "    ofImage_< float >::ofImage_(ofPixels_< float > const &)\n"
  "    ofImage_< float >::ofImage_(std::filesystem::path const &,ofImageLoadSettings const &)\n"
  "    ofImage_< float >::ofImage_(std::filesystem::path const &)\n" "    ofImage_< float >::ofImage_(ofImage_< float > &&)\n");
  lua_error(L);return 0; }
static int _wrap_FloatImage_allocate(lua_State* L) { int SWIG_arg = 0; ofImage_< float > *arg1 = (ofImage_< float > *) 0 ;
  int arg2 ; int arg3 ; ofImageType arg4 ; SWIG_check_num_args("ofImage_< float >::allocate",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< float >::allocate",1,"ofImage_< float > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofImage_< float >::allocate",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofImage_< float >::allocate",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofImage_< float >::allocate",4,"ofImageType");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_float_t,0))){
    SWIG_fail_ptr("FloatImage_allocate",1,SWIGTYPE_p_ofImage_T_float_t); }  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3); arg4 = (ofImageType)(int)lua_tonumber(L, 4); (arg1)->allocate(arg2,arg3,arg4);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatImage_isAllocated(lua_State* L) { int SWIG_arg = 0; ofImage_< float > *arg1 = (ofImage_< float > *) 0 ;
  bool result; SWIG_check_num_args("ofImage_< float >::isAllocated",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< float >::isAllocated",1,"ofImage_< float > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_float_t,0))){
    SWIG_fail_ptr("FloatImage_isAllocated",1,SWIGTYPE_p_ofImage_T_float_t); } 
  result = (bool)((ofImage_< float > const *)arg1)->isAllocated(); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatImage_clear(lua_State* L) { int SWIG_arg = 0; ofImage_< float > *arg1 = (ofImage_< float > *) 0 ;
  SWIG_check_num_args("ofImage_< float >::clear",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< float >::clear",1,"ofImage_< float > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_float_t,0))){
    SWIG_fail_ptr("FloatImage_clear",1,SWIGTYPE_p_ofImage_T_float_t); }  (arg1)->clear(); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatImage_load__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofImage_< float > *arg1 = (ofImage_< float > *) 0 ;
  std::filesystem::path *arg2 = 0 ; ofImageLoadSettings *arg3 = 0 ; std::filesystem::path temp2 ; bool result;
  SWIG_check_num_args("ofImage_< float >::load",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< float >::load",1,"ofImage_< float > *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofImage_< float >::load",2,"std::filesystem::path const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofImage_< float >::load",3,"ofImageLoadSettings const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_float_t,0))){
    SWIG_fail_ptr("FloatImage_load",1,SWIGTYPE_p_ofImage_T_float_t); }  { size_t len = lua_rawlen(L, 2);
    temp2 = lua_tolstring(L, 2, &len); arg2 = &temp2; } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_ofImageLoadSettings,0))){
    SWIG_fail_ptr("FloatImage_load",3,SWIGTYPE_p_ofImageLoadSettings); } 
  result = (bool)(arg1)->load((std::filesystem::path const &)*arg2,(ofImageLoadSettings const &)*arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatImage_load__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofImage_< float > *arg1 = (ofImage_< float > *) 0 ;
  std::filesystem::path *arg2 = 0 ; std::filesystem::path temp2 ; bool result;
  SWIG_check_num_args("ofImage_< float >::load",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< float >::load",1,"ofImage_< float > *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofImage_< float >::load",2,"std::filesystem::path const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_float_t,0))){
    SWIG_fail_ptr("FloatImage_load",1,SWIGTYPE_p_ofImage_T_float_t); }  { size_t len = lua_rawlen(L, 2);
    temp2 = lua_tolstring(L, 2, &len); arg2 = &temp2; }  result = (bool)(arg1)->load((std::filesystem::path const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatImage_load__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofImage_< float > *arg1 = (ofImage_< float > *) 0 ;
  ofBuffer *arg2 = 0 ; ofImageLoadSettings *arg3 = 0 ; bool result; SWIG_check_num_args("ofImage_< float >::load",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< float >::load",1,"ofImage_< float > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofImage_< float >::load",2,"ofBuffer const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofImage_< float >::load",3,"ofImageLoadSettings const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_float_t,0))){
    SWIG_fail_ptr("FloatImage_load",1,SWIGTYPE_p_ofImage_T_float_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofBuffer,0))){
    SWIG_fail_ptr("FloatImage_load",2,SWIGTYPE_p_ofBuffer); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_ofImageLoadSettings,0))){
    SWIG_fail_ptr("FloatImage_load",3,SWIGTYPE_p_ofImageLoadSettings); } 
  result = (bool)(arg1)->load((ofBuffer const &)*arg2,(ofImageLoadSettings const &)*arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatImage_load__SWIG_3(lua_State* L) { int SWIG_arg = 0; ofImage_< float > *arg1 = (ofImage_< float > *) 0 ;
  ofBuffer *arg2 = 0 ; bool result; SWIG_check_num_args("ofImage_< float >::load",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< float >::load",1,"ofImage_< float > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofImage_< float >::load",2,"ofBuffer const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_float_t,0))){
    SWIG_fail_ptr("FloatImage_load",1,SWIGTYPE_p_ofImage_T_float_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofBuffer,0))){
    SWIG_fail_ptr("FloatImage_load",2,SWIGTYPE_p_ofBuffer); }  result = (bool)(arg1)->load((ofBuffer const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatImage_load(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_float_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofBuffer, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_FloatImage_load__SWIG_3(L);}  }  }  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_float_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L, argv[1]); }  if (_v) {
        return _wrap_FloatImage_load__SWIG_1(L);}  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_float_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofBuffer, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_ofImageLoadSettings, 0)) {
            _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_FloatImage_load__SWIG_2(L);}  }  }  }  if (argc == 3) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_float_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L, argv[1]); }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_ofImageLoadSettings, 0)) {
            _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_FloatImage_load__SWIG_0(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'FloatImage_load'\n" "  Possible C/C++ prototypes are:\n"
  "    ofImage_< float >::load(std::filesystem::path const &,ofImageLoadSettings const &)\n"
  "    ofImage_< float >::load(std::filesystem::path const &)\n"
  "    ofImage_< float >::load(ofBuffer const &,ofImageLoadSettings const &)\n"
  "    ofImage_< float >::load(ofBuffer const &)\n"); lua_error(L);return 0; }
static int _wrap_FloatImage_draw__SWIG_0_0(lua_State* L) { int SWIG_arg = 0; ofImage_< float > *arg1 = (ofImage_< float > *) 0 ;
  glm::vec2 *arg2 = 0 ; SWIG_check_num_args("draw",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("draw",1,"ofImage_< float > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("draw",2,"glm::vec2 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_float_t,0))){
    SWIG_fail_ptr("FloatImage_draw",1,SWIGTYPE_p_ofImage_T_float_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec2,0))){
    SWIG_fail_ptr("FloatImage_draw",2,SWIGTYPE_p_glm__vec2); } 
  ((ofImage_< float > const *)arg1)->draw((glm::vec2 const &)*arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_FloatImage_draw__SWIG_0_1(lua_State* L) { int SWIG_arg = 0; ofImage_< float > *arg1 = (ofImage_< float > *) 0 ;
  ofRectangle *arg2 = 0 ; SWIG_check_num_args("draw",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("draw",1,"ofImage_< float > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("draw",2,"ofRectangle const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_float_t,0))){
    SWIG_fail_ptr("FloatImage_draw",1,SWIGTYPE_p_ofImage_T_float_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("FloatImage_draw",2,SWIGTYPE_p_ofRectangle); } 
  ((ofImage_< float > const *)arg1)->draw((ofRectangle const &)*arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_FloatImage_draw__SWIG_0_2(lua_State* L) { int SWIG_arg = 0; ofImage_< float > *arg1 = (ofImage_< float > *) 0 ;
  glm::vec2 *arg2 = 0 ; float arg3 ; float arg4 ; SWIG_check_num_args("draw",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("draw",1,"ofImage_< float > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("draw",2,"glm::vec2 const &"); if(!lua_isnumber(L,3)) SWIG_fail_arg("draw",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("draw",4,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_float_t,0))){
    SWIG_fail_ptr("FloatImage_draw",1,SWIGTYPE_p_ofImage_T_float_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec2,0))){
    SWIG_fail_ptr("FloatImage_draw",2,SWIGTYPE_p_glm__vec2); }  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4); ((ofImage_< float > const *)arg1)->draw((glm::vec2 const &)*arg2,arg3,arg4);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatImage_draw__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofImage_< float > *arg1 = (ofImage_< float > *) 0 ;
  float arg2 ; float arg3 ; SWIG_check_num_args("ofImage_< float >::draw",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< float >::draw",1,"ofImage_< float > const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofImage_< float >::draw",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofImage_< float >::draw",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_float_t,0))){
    SWIG_fail_ptr("FloatImage_draw",1,SWIGTYPE_p_ofImage_T_float_t); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); ((ofImage_< float > const *)arg1)->draw(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatImage_draw__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofImage_< float > *arg1 = (ofImage_< float > *) 0 ;
  float arg2 ; float arg3 ; float arg4 ; SWIG_check_num_args("ofImage_< float >::draw",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< float >::draw",1,"ofImage_< float > const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofImage_< float >::draw",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofImage_< float >::draw",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofImage_< float >::draw",4,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_float_t,0))){
    SWIG_fail_ptr("FloatImage_draw",1,SWIGTYPE_p_ofImage_T_float_t); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); ((ofImage_< float > const *)arg1)->draw(arg2,arg3,arg4);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatImage_draw__SWIG_3(lua_State* L) { int SWIG_arg = 0; ofImage_< float > *arg1 = (ofImage_< float > *) 0 ;
  glm::vec3 *arg2 = 0 ; SWIG_check_num_args("ofImage_< float >::draw",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< float >::draw",1,"ofImage_< float > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofImage_< float >::draw",2,"glm::vec3 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_float_t,0))){
    SWIG_fail_ptr("FloatImage_draw",1,SWIGTYPE_p_ofImage_T_float_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("FloatImage_draw",2,SWIGTYPE_p_glm__vec3); } 
  ((ofImage_< float > const *)arg1)->draw((glm::vec3 const &)*arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_FloatImage_draw__SWIG_4(lua_State* L) { int SWIG_arg = 0; ofImage_< float > *arg1 = (ofImage_< float > *) 0 ;
  float arg2 ; float arg3 ; float arg4 ; float arg5 ; SWIG_check_num_args("ofImage_< float >::draw",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< float >::draw",1,"ofImage_< float > const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofImage_< float >::draw",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofImage_< float >::draw",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofImage_< float >::draw",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofImage_< float >::draw",5,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_float_t,0))){
    SWIG_fail_ptr("FloatImage_draw",1,SWIGTYPE_p_ofImage_T_float_t); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); arg5 = (float)lua_tonumber(L, 5);
  ((ofImage_< float > const *)arg1)->draw(arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_FloatImage_draw__SWIG_5(lua_State* L) { int SWIG_arg = 0; ofImage_< float > *arg1 = (ofImage_< float > *) 0 ;
  float arg2 ; float arg3 ; float arg4 ; float arg5 ; float arg6 ; SWIG_check_num_args("ofImage_< float >::draw",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< float >::draw",1,"ofImage_< float > const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofImage_< float >::draw",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofImage_< float >::draw",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofImage_< float >::draw",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofImage_< float >::draw",5,"float");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofImage_< float >::draw",6,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_float_t,0))){
    SWIG_fail_ptr("FloatImage_draw",1,SWIGTYPE_p_ofImage_T_float_t); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); arg5 = (float)lua_tonumber(L, 5);
  arg6 = (float)lua_tonumber(L, 6); ((ofImage_< float > const *)arg1)->draw(arg2,arg3,arg4,arg5,arg6); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatImage_draw__SWIG_6(lua_State* L) { int SWIG_arg = 0; ofImage_< float > *arg1 = (ofImage_< float > *) 0 ;
  glm::vec3 *arg2 = 0 ; float arg3 ; float arg4 ; SWIG_check_num_args("ofImage_< float >::draw",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< float >::draw",1,"ofImage_< float > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofImage_< float >::draw",2,"glm::vec3 const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofImage_< float >::draw",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofImage_< float >::draw",4,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_float_t,0))){
    SWIG_fail_ptr("FloatImage_draw",1,SWIGTYPE_p_ofImage_T_float_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("FloatImage_draw",2,SWIGTYPE_p_glm__vec3); }  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4); ((ofImage_< float > const *)arg1)->draw((glm::vec3 const &)*arg2,arg3,arg4);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatImage_draw(lua_State* L) { int argc; int argv[7]={ 1,2,3,4,5,6,7} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_float_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec2, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_FloatImage_draw__SWIG_0_0(L);}  }  }  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_float_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_FloatImage_draw__SWIG_0_1(L);}  }  }  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_float_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_FloatImage_draw__SWIG_3(L);}  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_float_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { return _wrap_FloatImage_draw__SWIG_1(L);}  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_float_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec2, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); } 
          if (_v) { return _wrap_FloatImage_draw__SWIG_0_2(L);}  }  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_float_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); } 
          if (_v) { return _wrap_FloatImage_draw__SWIG_6(L);}  }  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_float_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_FloatImage_draw__SWIG_2(L);}  }  }  }  } 
  if (argc == 5) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_float_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) {
              return _wrap_FloatImage_draw__SWIG_4(L);}  }  }  }  }  }  if (argc == 6) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_float_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) { {
                _v = lua_isnumber(L,argv[5]); }  if (_v) { return _wrap_FloatImage_draw__SWIG_5(L);}  }  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'FloatImage_draw'\n" "  Possible C/C++ prototypes are:\n"
  "    draw(glm::vec2 const &) const\n" "    draw(ofRectangle const &) const\n"
  "    draw(glm::vec2 const &,float,float) const\n" "    ofImage_< float >::draw(float,float) const\n"
  "    ofImage_< float >::draw(float,float,float) const\n" "    ofImage_< float >::draw(glm::vec3 const &) const\n"
  "    ofImage_< float >::draw(float,float,float,float) const\n"
  "    ofImage_< float >::draw(float,float,float,float,float) const\n"
  "    ofImage_< float >::draw(glm::vec3 const &,float,float) const\n"); lua_error(L);return 0; }
static int _wrap_FloatImage_drawSubsection__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofImage_< float > *arg1 = (ofImage_< float > *) 0 ; float arg2 ; float arg3 ; float arg4 ; float arg5 ; float arg6 ;
  float arg7 ; SWIG_check_num_args("ofImage_< float >::drawSubsection",7,7)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< float >::drawSubsection",1,"ofImage_< float > const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofImage_< float >::drawSubsection",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofImage_< float >::drawSubsection",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofImage_< float >::drawSubsection",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofImage_< float >::drawSubsection",5,"float");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofImage_< float >::drawSubsection",6,"float");
  if(!lua_isnumber(L,7)) SWIG_fail_arg("ofImage_< float >::drawSubsection",7,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_float_t,0))){
    SWIG_fail_ptr("FloatImage_drawSubsection",1,SWIGTYPE_p_ofImage_T_float_t); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); arg5 = (float)lua_tonumber(L, 5);
  arg6 = (float)lua_tonumber(L, 6); arg7 = (float)lua_tonumber(L, 7);
  ((ofImage_< float > const *)arg1)->drawSubsection(arg2,arg3,arg4,arg5,arg6,arg7); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatImage_drawSubsection__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofImage_< float > *arg1 = (ofImage_< float > *) 0 ; float arg2 ; float arg3 ; float arg4 ; float arg5 ; float arg6 ;
  float arg7 ; float arg8 ; SWIG_check_num_args("ofImage_< float >::drawSubsection",8,8)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< float >::drawSubsection",1,"ofImage_< float > const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofImage_< float >::drawSubsection",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofImage_< float >::drawSubsection",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofImage_< float >::drawSubsection",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofImage_< float >::drawSubsection",5,"float");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofImage_< float >::drawSubsection",6,"float");
  if(!lua_isnumber(L,7)) SWIG_fail_arg("ofImage_< float >::drawSubsection",7,"float");
  if(!lua_isnumber(L,8)) SWIG_fail_arg("ofImage_< float >::drawSubsection",8,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_float_t,0))){
    SWIG_fail_ptr("FloatImage_drawSubsection",1,SWIGTYPE_p_ofImage_T_float_t); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); arg5 = (float)lua_tonumber(L, 5);
  arg6 = (float)lua_tonumber(L, 6); arg7 = (float)lua_tonumber(L, 7); arg8 = (float)lua_tonumber(L, 8);
  ((ofImage_< float > const *)arg1)->drawSubsection(arg2,arg3,arg4,arg5,arg6,arg7,arg8); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatImage_drawSubsection__SWIG_2(lua_State* L) { int SWIG_arg = 0;
  ofImage_< float > *arg1 = (ofImage_< float > *) 0 ; float arg2 ; float arg3 ; float arg4 ; float arg5 ; float arg6 ;
  float arg7 ; float arg8 ; float arg9 ; SWIG_check_num_args("ofImage_< float >::drawSubsection",9,9)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< float >::drawSubsection",1,"ofImage_< float > const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofImage_< float >::drawSubsection",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofImage_< float >::drawSubsection",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofImage_< float >::drawSubsection",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofImage_< float >::drawSubsection",5,"float");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofImage_< float >::drawSubsection",6,"float");
  if(!lua_isnumber(L,7)) SWIG_fail_arg("ofImage_< float >::drawSubsection",7,"float");
  if(!lua_isnumber(L,8)) SWIG_fail_arg("ofImage_< float >::drawSubsection",8,"float");
  if(!lua_isnumber(L,9)) SWIG_fail_arg("ofImage_< float >::drawSubsection",9,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_float_t,0))){
    SWIG_fail_ptr("FloatImage_drawSubsection",1,SWIGTYPE_p_ofImage_T_float_t); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); arg5 = (float)lua_tonumber(L, 5);
  arg6 = (float)lua_tonumber(L, 6); arg7 = (float)lua_tonumber(L, 7); arg8 = (float)lua_tonumber(L, 8);
  arg9 = (float)lua_tonumber(L, 9); ((ofImage_< float > const *)arg1)->drawSubsection(arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatImage_drawSubsection__SWIG_3(lua_State* L) { int SWIG_arg = 0;
  ofImage_< float > *arg1 = (ofImage_< float > *) 0 ; float arg2 ; float arg3 ; float arg4 ; float arg5 ; float arg6 ;
  float arg7 ; float arg8 ; float arg9 ; float arg10 ; SWIG_check_num_args("ofImage_< float >::drawSubsection",10,10)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< float >::drawSubsection",1,"ofImage_< float > const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofImage_< float >::drawSubsection",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofImage_< float >::drawSubsection",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofImage_< float >::drawSubsection",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofImage_< float >::drawSubsection",5,"float");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofImage_< float >::drawSubsection",6,"float");
  if(!lua_isnumber(L,7)) SWIG_fail_arg("ofImage_< float >::drawSubsection",7,"float");
  if(!lua_isnumber(L,8)) SWIG_fail_arg("ofImage_< float >::drawSubsection",8,"float");
  if(!lua_isnumber(L,9)) SWIG_fail_arg("ofImage_< float >::drawSubsection",9,"float");
  if(!lua_isnumber(L,10)) SWIG_fail_arg("ofImage_< float >::drawSubsection",10,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_float_t,0))){
    SWIG_fail_ptr("FloatImage_drawSubsection",1,SWIGTYPE_p_ofImage_T_float_t); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); arg5 = (float)lua_tonumber(L, 5);
  arg6 = (float)lua_tonumber(L, 6); arg7 = (float)lua_tonumber(L, 7); arg8 = (float)lua_tonumber(L, 8);
  arg9 = (float)lua_tonumber(L, 9); arg10 = (float)lua_tonumber(L, 10);
  ((ofImage_< float > const *)arg1)->drawSubsection(arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatImage_drawSubsection(lua_State* L) { int argc; int argv[11]={ 1,2,3,4,5,6,7,8,9,10,11} ;
  argc = lua_gettop(L); if (argc == 7) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_float_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) { {
                _v = lua_isnumber(L,argv[5]); }  if (_v) { { _v = lua_isnumber(L,argv[6]); }  if (_v) {
                  return _wrap_FloatImage_drawSubsection__SWIG_0(L);}  }  }  }  }  }  }  }  if (argc == 8) { int _v; {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_float_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) { {
                _v = lua_isnumber(L,argv[5]); }  if (_v) { { _v = lua_isnumber(L,argv[6]); }  if (_v) { {
                    _v = lua_isnumber(L,argv[7]); }  if (_v) { return _wrap_FloatImage_drawSubsection__SWIG_1(L);}  }  }  }  }  }
         }  }  }  if (argc == 9) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_float_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) { {
                _v = lua_isnumber(L,argv[5]); }  if (_v) { { _v = lua_isnumber(L,argv[6]); }  if (_v) { {
                    _v = lua_isnumber(L,argv[7]); }  if (_v) { { _v = lua_isnumber(L,argv[8]); }  if (_v) {
                      return _wrap_FloatImage_drawSubsection__SWIG_2(L);}  }  }  }  }  }  }  }  }  }  if (argc == 10) { int _v;
    { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_float_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) { {
                _v = lua_isnumber(L,argv[5]); }  if (_v) { { _v = lua_isnumber(L,argv[6]); }  if (_v) { {
                    _v = lua_isnumber(L,argv[7]); }  if (_v) { { _v = lua_isnumber(L,argv[8]); }  if (_v) { {
                        _v = lua_isnumber(L,argv[9]); }  if (_v) { return _wrap_FloatImage_drawSubsection__SWIG_3(L);}  }  }  }
                 }  }  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'FloatImage_drawSubsection'\n"
  "  Possible C/C++ prototypes are:\n" "    ofImage_< float >::drawSubsection(float,float,float,float,float,float) const\n"
  "    ofImage_< float >::drawSubsection(float,float,float,float,float,float,float) const\n"
  "    ofImage_< float >::drawSubsection(float,float,float,float,float,float,float,float) const\n"
  "    ofImage_< float >::drawSubsection(float,float,float,float,float,float,float,float,float) const\n");
  lua_error(L);return 0; }
static int _wrap_FloatImage_update(lua_State* L) { int SWIG_arg = 0; ofImage_< float > *arg1 = (ofImage_< float > *) 0 ;
  SWIG_check_num_args("ofImage_< float >::update",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< float >::update",1,"ofImage_< float > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_float_t,0))){
    SWIG_fail_ptr("FloatImage_update",1,SWIGTYPE_p_ofImage_T_float_t); }  (arg1)->update(); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatImage_setUseTexture(lua_State* L) { int SWIG_arg = 0; ofImage_< float > *arg1 = (ofImage_< float > *) 0 ;
  bool arg2 ; SWIG_check_num_args("ofImage_< float >::setUseTexture",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< float >::setUseTexture",1,"ofImage_< float > *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofImage_< float >::setUseTexture",2,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_float_t,0))){
    SWIG_fail_ptr("FloatImage_setUseTexture",1,SWIGTYPE_p_ofImage_T_float_t); }  arg2 = (lua_toboolean(L, 2)!=0);
  (arg1)->setUseTexture(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatImage_isUsingTexture(lua_State* L) { int SWIG_arg = 0; ofImage_< float > *arg1 = (ofImage_< float > *) 0 ;
  bool result; SWIG_check_num_args("ofImage_< float >::isUsingTexture",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< float >::isUsingTexture",1,"ofImage_< float > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_float_t,0))){
    SWIG_fail_ptr("FloatImage_isUsingTexture",1,SWIGTYPE_p_ofImage_T_float_t); } 
  result = (bool)((ofImage_< float > const *)arg1)->isUsingTexture(); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatImage_getTexture__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofImage_< float > *arg1 = (ofImage_< float > *) 0 ; ofTexture *result = 0 ;
  SWIG_check_num_args("ofImage_< float >::getTexture",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< float >::getTexture",1,"ofImage_< float > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_float_t,0))){
    SWIG_fail_ptr("FloatImage_getTexture",1,SWIGTYPE_p_ofImage_T_float_t); }  result = (ofTexture *) &(arg1)->getTexture();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofTexture,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_FloatImage_getTexture__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofImage_< float > *arg1 = (ofImage_< float > *) 0 ; ofTexture *result = 0 ;
  SWIG_check_num_args("ofImage_< float >::getTexture",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< float >::getTexture",1,"ofImage_< float > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_float_t,0))){
    SWIG_fail_ptr("FloatImage_getTexture",1,SWIGTYPE_p_ofImage_T_float_t); } 
  result = (ofTexture *) &((ofImage_< float > const *)arg1)->getTexture();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofTexture,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_FloatImage_getTexture(lua_State* L) { int argc; int argv[2]={ 1,2} ; argc = lua_gettop(L); if (argc == 1) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_float_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_FloatImage_getTexture__SWIG_0(L);}  }  if (argc == 1) { int _v; {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_float_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_FloatImage_getTexture__SWIG_1(L);}  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'FloatImage_getTexture'\n"
  "  Possible C/C++ prototypes are:\n" "    ofImage_< float >::getTexture()\n" "    ofImage_< float >::getTexture() const\n");
  lua_error(L);return 0; }
static int _wrap_FloatImage_bind__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofImage_< float > *arg1 = (ofImage_< float > *) 0 ;
  int arg2 ; SWIG_check_num_args("ofImage_< float >::bind",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< float >::bind",1,"ofImage_< float > const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofImage_< float >::bind",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_float_t,0))){
    SWIG_fail_ptr("FloatImage_bind",1,SWIGTYPE_p_ofImage_T_float_t); }  arg2 = (int)lua_tonumber(L, 2);
  ((ofImage_< float > const *)arg1)->bind(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatImage_bind__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofImage_< float > *arg1 = (ofImage_< float > *) 0 ;
  SWIG_check_num_args("ofImage_< float >::bind",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< float >::bind",1,"ofImage_< float > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_float_t,0))){
    SWIG_fail_ptr("FloatImage_bind",1,SWIGTYPE_p_ofImage_T_float_t); }  ((ofImage_< float > const *)arg1)->bind();
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatImage_bind(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 1) { int _v;
    { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_float_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_FloatImage_bind__SWIG_1(L);}  }  if (argc == 2) { int _v; {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_float_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_FloatImage_bind__SWIG_0(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'FloatImage_bind'\n" "  Possible C/C++ prototypes are:\n"
  "    ofImage_< float >::bind(int) const\n" "    ofImage_< float >::bind() const\n"); lua_error(L);return 0; }
static int _wrap_FloatImage_unbind__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofImage_< float > *arg1 = (ofImage_< float > *) 0 ;
  int arg2 ; SWIG_check_num_args("ofImage_< float >::unbind",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< float >::unbind",1,"ofImage_< float > const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofImage_< float >::unbind",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_float_t,0))){
    SWIG_fail_ptr("FloatImage_unbind",1,SWIGTYPE_p_ofImage_T_float_t); }  arg2 = (int)lua_tonumber(L, 2);
  ((ofImage_< float > const *)arg1)->unbind(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatImage_unbind__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofImage_< float > *arg1 = (ofImage_< float > *) 0 ;
  SWIG_check_num_args("ofImage_< float >::unbind",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< float >::unbind",1,"ofImage_< float > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_float_t,0))){
    SWIG_fail_ptr("FloatImage_unbind",1,SWIGTYPE_p_ofImage_T_float_t); }  ((ofImage_< float > const *)arg1)->unbind();
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatImage_unbind(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 1) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_float_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_FloatImage_unbind__SWIG_1(L);}  }  if (argc == 2) { int _v; {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_float_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_FloatImage_unbind__SWIG_0(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'FloatImage_unbind'\n" "  Possible C/C++ prototypes are:\n"
  "    ofImage_< float >::unbind(int) const\n" "    ofImage_< float >::unbind() const\n"); lua_error(L);return 0; }
static int _wrap_FloatImage_setCompression(lua_State* L) { int SWIG_arg = 0; ofImage_< float > *arg1 = (ofImage_< float > *) 0 ;
  ofTexCompression arg2 ; SWIG_check_num_args("ofImage_< float >::setCompression",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< float >::setCompression",1,"ofImage_< float > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofImage_< float >::setCompression",2,"ofTexCompression");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_float_t,0))){
    SWIG_fail_ptr("FloatImage_setCompression",1,SWIGTYPE_p_ofImage_T_float_t); } 
  arg2 = (ofTexCompression)(int)lua_tonumber(L, 2); (arg1)->setCompression(arg2); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatImage_getPixels__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofImage_< float > *arg1 = (ofImage_< float > *) 0 ; ofPixels_< float > *result = 0 ;
  SWIG_check_num_args("ofImage_< float >::getPixels",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< float >::getPixels",1,"ofImage_< float > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_float_t,0))){
    SWIG_fail_ptr("FloatImage_getPixels",1,SWIGTYPE_p_ofImage_T_float_t); } 
  result = (ofPixels_< float > *) &(arg1)->getPixels();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofPixels_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatImage_getPixels__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofImage_< float > *arg1 = (ofImage_< float > *) 0 ; ofPixels_< float > *result = 0 ;
  SWIG_check_num_args("ofImage_< float >::getPixels",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< float >::getPixels",1,"ofImage_< float > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_float_t,0))){
    SWIG_fail_ptr("FloatImage_getPixels",1,SWIGTYPE_p_ofImage_T_float_t); } 
  result = (ofPixels_< float > *) &((ofImage_< float > const *)arg1)->getPixels();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofPixels_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatImage_getPixels(lua_State* L) { int argc; int argv[2]={ 1,2} ; argc = lua_gettop(L); if (argc == 1) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_float_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_FloatImage_getPixels__SWIG_0(L);}  }  if (argc == 1) { int _v; {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_float_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_FloatImage_getPixels__SWIG_1(L);}  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'FloatImage_getPixels'\n"
  "  Possible C/C++ prototypes are:\n" "    ofImage_< float >::getPixels()\n" "    ofImage_< float >::getPixels() const\n");
  lua_error(L);return 0; }
static int _wrap_FloatImage_getColor__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofImage_< float > *arg1 = (ofImage_< float > *) 0 ; int arg2 ; int arg3 ; ofColor_< float > result;
  SWIG_check_num_args("ofImage_< float >::getColor",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< float >::getColor",1,"ofImage_< float > const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofImage_< float >::getColor",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofImage_< float >::getColor",3,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_float_t,0))){
    SWIG_fail_ptr("FloatImage_getColor",1,SWIGTYPE_p_ofImage_T_float_t); }  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3); result = ((ofImage_< float > const *)arg1)->getColor(arg2,arg3); {
    ofColor_< float > * resultptr = new ofColor_< float >((const ofColor_< float > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofColor_T_float_t,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatImage_getColor__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofImage_< float > *arg1 = (ofImage_< float > *) 0 ; int arg2 ; ofColor_< float > result;
  SWIG_check_num_args("ofImage_< float >::getColor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< float >::getColor",1,"ofImage_< float > const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofImage_< float >::getColor",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_float_t,0))){
    SWIG_fail_ptr("FloatImage_getColor",1,SWIGTYPE_p_ofImage_T_float_t); }  arg2 = (int)lua_tonumber(L, 2);
  result = ((ofImage_< float > const *)arg1)->getColor(arg2); {
    ofColor_< float > * resultptr = new ofColor_< float >((const ofColor_< float > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofColor_T_float_t,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatImage_getColor(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_float_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_FloatImage_getColor__SWIG_1(L);}  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_float_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { return _wrap_FloatImage_getColor__SWIG_0(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'FloatImage_getColor'\n"
  "  Possible C/C++ prototypes are:\n" "    ofImage_< float >::getColor(int,int) const\n"
  "    ofImage_< float >::getColor(int) const\n"); lua_error(L);return 0; }
static int _wrap_FloatImage_getHeight(lua_State* L) { int SWIG_arg = 0; ofImage_< float > *arg1 = (ofImage_< float > *) 0 ;
  float result; SWIG_check_num_args("ofImage_< float >::getHeight",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< float >::getHeight",1,"ofImage_< float > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_float_t,0))){
    SWIG_fail_ptr("FloatImage_getHeight",1,SWIGTYPE_p_ofImage_T_float_t); } 
  result = (float)((ofImage_< float > const *)arg1)->getHeight(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatImage_getWidth(lua_State* L) { int SWIG_arg = 0; ofImage_< float > *arg1 = (ofImage_< float > *) 0 ;
  float result; SWIG_check_num_args("ofImage_< float >::getWidth",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< float >::getWidth",1,"ofImage_< float > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_float_t,0))){
    SWIG_fail_ptr("FloatImage_getWidth",1,SWIGTYPE_p_ofImage_T_float_t); } 
  result = (float)((ofImage_< float > const *)arg1)->getWidth(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatImage_setColor__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofImage_< float > *arg1 = (ofImage_< float > *) 0 ; int arg2 ; int arg3 ; ofColor_< float > *arg4 = 0 ;
  SWIG_check_num_args("ofImage_< float >::setColor",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< float >::setColor",1,"ofImage_< float > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofImage_< float >::setColor",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofImage_< float >::setColor",3,"int");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("ofImage_< float >::setColor",4,"ofColor_< float > const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_float_t,0))){
    SWIG_fail_ptr("FloatImage_setColor",1,SWIGTYPE_p_ofImage_T_float_t); }  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3); if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("FloatImage_setColor",4,SWIGTYPE_p_ofColor_T_float_t); } 
  (arg1)->setColor(arg2,arg3,(ofColor_< float > const &)*arg4); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_FloatImage_setColor__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofImage_< float > *arg1 = (ofImage_< float > *) 0 ; int arg2 ; ofColor_< float > *arg3 = 0 ;
  SWIG_check_num_args("ofImage_< float >::setColor",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< float >::setColor",1,"ofImage_< float > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofImage_< float >::setColor",2,"int");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofImage_< float >::setColor",3,"ofColor_< float > const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_float_t,0))){
    SWIG_fail_ptr("FloatImage_setColor",1,SWIGTYPE_p_ofImage_T_float_t); }  arg2 = (int)lua_tonumber(L, 2);
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("FloatImage_setColor",3,SWIGTYPE_p_ofColor_T_float_t); } 
  (arg1)->setColor(arg2,(ofColor_< float > const &)*arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_FloatImage_setColor__SWIG_2(lua_State* L) { int SWIG_arg = 0;
  ofImage_< float > *arg1 = (ofImage_< float > *) 0 ; ofColor_< float > *arg2 = 0 ;
  SWIG_check_num_args("ofImage_< float >::setColor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< float >::setColor",1,"ofImage_< float > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofImage_< float >::setColor",2,"ofColor_< float > const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_float_t,0))){
    SWIG_fail_ptr("FloatImage_setColor",1,SWIGTYPE_p_ofImage_T_float_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("FloatImage_setColor",2,SWIGTYPE_p_ofColor_T_float_t); }  (arg1)->setColor((ofColor_< float > const &)*arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatImage_setColor(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_float_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofColor_T_float_t, 0)) {
          _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_FloatImage_setColor__SWIG_2(L);}  }  }  if (argc == 3) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_float_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_ofColor_T_float_t, 0)) {
            _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_FloatImage_setColor__SWIG_1(L);}  }  }  }  if (argc == 4) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_float_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { { void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_ofColor_T_float_t, 0)) {
              _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_FloatImage_setColor__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'FloatImage_setColor'\n"
  "  Possible C/C++ prototypes are:\n" "    ofImage_< float >::setColor(int,int,ofColor_< float > const &)\n"
  "    ofImage_< float >::setColor(int,ofColor_< float > const &)\n"
  "    ofImage_< float >::setColor(ofColor_< float > const &)\n"); lua_error(L);return 0; }
static int _wrap_FloatImage_setFromPixels__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofImage_< float > *arg1 = (ofImage_< float > *) 0 ; float *arg2 = (float *) 0 ; int arg3 ; int arg4 ; ofImageType arg5 ;
  bool arg6 ; SWIG_check_num_args("ofImage_< float >::setFromPixels",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< float >::setFromPixels",1,"ofImage_< float > *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofImage_< float >::setFromPixels",2,"float const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofImage_< float >::setFromPixels",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofImage_< float >::setFromPixels",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofImage_< float >::setFromPixels",5,"ofImageType");
  if(!lua_isboolean(L,6)) SWIG_fail_arg("ofImage_< float >::setFromPixels",6,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_float_t,0))){
    SWIG_fail_ptr("FloatImage_setFromPixels",1,SWIGTYPE_p_ofImage_T_float_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("FloatImage_setFromPixels",2,SWIGTYPE_p_float); }  arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4); arg5 = (ofImageType)(int)lua_tonumber(L, 5); arg6 = (lua_toboolean(L, 6)!=0);
  (arg1)->setFromPixels((float const *)arg2,arg3,arg4,arg5,arg6); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_FloatImage_setFromPixels__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofImage_< float > *arg1 = (ofImage_< float > *) 0 ; float *arg2 = (float *) 0 ; int arg3 ; int arg4 ; ofImageType arg5 ;
  SWIG_check_num_args("ofImage_< float >::setFromPixels",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< float >::setFromPixels",1,"ofImage_< float > *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofImage_< float >::setFromPixels",2,"float const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofImage_< float >::setFromPixels",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofImage_< float >::setFromPixels",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofImage_< float >::setFromPixels",5,"ofImageType");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_float_t,0))){
    SWIG_fail_ptr("FloatImage_setFromPixels",1,SWIGTYPE_p_ofImage_T_float_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("FloatImage_setFromPixels",2,SWIGTYPE_p_float); }  arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4); arg5 = (ofImageType)(int)lua_tonumber(L, 5);
  (arg1)->setFromPixels((float const *)arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_FloatImage_setFromPixels__SWIG_2(lua_State* L) { int SWIG_arg = 0;
  ofImage_< float > *arg1 = (ofImage_< float > *) 0 ; ofPixels_< float > *arg2 = 0 ;
  SWIG_check_num_args("ofImage_< float >::setFromPixels",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< float >::setFromPixels",1,"ofImage_< float > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofImage_< float >::setFromPixels",2,"ofPixels_< float > const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_float_t,0))){
    SWIG_fail_ptr("FloatImage_setFromPixels",1,SWIGTYPE_p_ofImage_T_float_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofPixels_T_float_t,0))){
    SWIG_fail_ptr("FloatImage_setFromPixels",2,SWIGTYPE_p_ofPixels_T_float_t); } 
  (arg1)->setFromPixels((ofPixels_< float > const &)*arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_FloatImage_setFromPixels(lua_State* L) { int argc; int argv[7]={ 1,2,3,4,5,6,7} ; argc = lua_gettop(L);
  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_float_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofPixels_T_float_t, 0)) {
          _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_FloatImage_setFromPixels__SWIG_2(L);}  }  }  if (argc == 5) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_float_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_float, 0)) { _v = 0; }  else {
          _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { {
              _v = lua_isnumber(L,argv[4]); }  if (_v) { return _wrap_FloatImage_setFromPixels__SWIG_1(L);}  }  }  }  }  } 
  if (argc == 6) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_float_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_float, 0)) { _v = 0; }  else {
          _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { {
              _v = lua_isnumber(L,argv[4]); }  if (_v) { { _v = lua_isboolean(L,argv[5]); }  if (_v) {
                return _wrap_FloatImage_setFromPixels__SWIG_0(L);}  }  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'FloatImage_setFromPixels'\n"
  "  Possible C/C++ prototypes are:\n" "    ofImage_< float >::setFromPixels(float const *,int,int,ofImageType,bool)\n"
  "    ofImage_< float >::setFromPixels(float const *,int,int,ofImageType)\n"
  "    ofImage_< float >::setFromPixels(ofPixels_< float > const &)\n"); lua_error(L);return 0; }
static int _wrap_FloatImage_grabScreen(lua_State* L) { int SWIG_arg = 0; ofImage_< float > *arg1 = (ofImage_< float > *) 0 ;
  int arg2 ; int arg3 ; int arg4 ; int arg5 ; SWIG_check_num_args("ofImage_< float >::grabScreen",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< float >::grabScreen",1,"ofImage_< float > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofImage_< float >::grabScreen",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofImage_< float >::grabScreen",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofImage_< float >::grabScreen",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofImage_< float >::grabScreen",5,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_float_t,0))){
    SWIG_fail_ptr("FloatImage_grabScreen",1,SWIGTYPE_p_ofImage_T_float_t); }  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3); arg4 = (int)lua_tonumber(L, 4); arg5 = (int)lua_tonumber(L, 5);
  (arg1)->grabScreen(arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatImage_setImageType(lua_State* L) { int SWIG_arg = 0; ofImage_< float > *arg1 = (ofImage_< float > *) 0 ;
  ofImageType arg2 ; SWIG_check_num_args("ofImage_< float >::setImageType",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< float >::setImageType",1,"ofImage_< float > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofImage_< float >::setImageType",2,"ofImageType");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_float_t,0))){
    SWIG_fail_ptr("FloatImage_setImageType",1,SWIGTYPE_p_ofImage_T_float_t); }  arg2 = (ofImageType)(int)lua_tonumber(L, 2);
  (arg1)->setImageType(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatImage_getImageType(lua_State* L) { int SWIG_arg = 0; ofImage_< float > *arg1 = (ofImage_< float > *) 0 ;
  ofImageType result; SWIG_check_num_args("ofImage_< float >::getImageType",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< float >::getImageType",1,"ofImage_< float > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_float_t,0))){
    SWIG_fail_ptr("FloatImage_getImageType",1,SWIGTYPE_p_ofImage_T_float_t); } 
  result = (ofImageType)((ofImage_< float > const *)arg1)->getImageType();
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_FloatImage_resize(lua_State* L) { int SWIG_arg = 0; ofImage_< float > *arg1 = (ofImage_< float > *) 0 ;
  int arg2 ; int arg3 ; SWIG_check_num_args("ofImage_< float >::resize",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< float >::resize",1,"ofImage_< float > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofImage_< float >::resize",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofImage_< float >::resize",3,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_float_t,0))){
    SWIG_fail_ptr("FloatImage_resize",1,SWIGTYPE_p_ofImage_T_float_t); }  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3); (arg1)->resize(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_FloatImage_crop(lua_State* L) { int SWIG_arg = 0; ofImage_< float > *arg1 = (ofImage_< float > *) 0 ;
  int arg2 ; int arg3 ; int arg4 ; int arg5 ; SWIG_check_num_args("ofImage_< float >::crop",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< float >::crop",1,"ofImage_< float > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofImage_< float >::crop",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofImage_< float >::crop",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofImage_< float >::crop",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofImage_< float >::crop",5,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_float_t,0))){
    SWIG_fail_ptr("FloatImage_crop",1,SWIGTYPE_p_ofImage_T_float_t); }  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3); arg4 = (int)lua_tonumber(L, 4); arg5 = (int)lua_tonumber(L, 5);
  (arg1)->crop(arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatImage_cropFrom(lua_State* L) { int SWIG_arg = 0; ofImage_< float > *arg1 = (ofImage_< float > *) 0 ;
  ofImage_< float > *arg2 = 0 ; int arg3 ; int arg4 ; int arg5 ; int arg6 ;
  SWIG_check_num_args("ofImage_< float >::cropFrom",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< float >::cropFrom",1,"ofImage_< float > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofImage_< float >::cropFrom",2,"ofImage_< float > const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofImage_< float >::cropFrom",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofImage_< float >::cropFrom",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofImage_< float >::cropFrom",5,"int");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofImage_< float >::cropFrom",6,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_float_t,0))){
    SWIG_fail_ptr("FloatImage_cropFrom",1,SWIGTYPE_p_ofImage_T_float_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofImage_T_float_t,0))){
    SWIG_fail_ptr("FloatImage_cropFrom",2,SWIGTYPE_p_ofImage_T_float_t); }  arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4); arg5 = (int)lua_tonumber(L, 5); arg6 = (int)lua_tonumber(L, 6);
  (arg1)->cropFrom((ofImage_< float > const &)*arg2,arg3,arg4,arg5,arg6); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_FloatImage_rotate90(lua_State* L) { int SWIG_arg = 0; ofImage_< float > *arg1 = (ofImage_< float > *) 0 ;
  int arg2 ; SWIG_check_num_args("ofImage_< float >::rotate90",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< float >::rotate90",1,"ofImage_< float > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofImage_< float >::rotate90",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_float_t,0))){
    SWIG_fail_ptr("FloatImage_rotate90",1,SWIGTYPE_p_ofImage_T_float_t); }  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->rotate90(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatImage_mirror(lua_State* L) { int SWIG_arg = 0; ofImage_< float > *arg1 = (ofImage_< float > *) 0 ;
  bool arg2 ; bool arg3 ; SWIG_check_num_args("ofImage_< float >::mirror",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< float >::mirror",1,"ofImage_< float > *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofImage_< float >::mirror",2,"bool");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("ofImage_< float >::mirror",3,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_float_t,0))){
    SWIG_fail_ptr("FloatImage_mirror",1,SWIGTYPE_p_ofImage_T_float_t); }  arg2 = (lua_toboolean(L, 2)!=0);
  arg3 = (lua_toboolean(L, 3)!=0); (arg1)->mirror(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_FloatImage_setAnchorPercent(lua_State* L) { int SWIG_arg = 0;
  ofImage_< float > *arg1 = (ofImage_< float > *) 0 ; float arg2 ; float arg3 ;
  SWIG_check_num_args("ofImage_< float >::setAnchorPercent",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< float >::setAnchorPercent",1,"ofImage_< float > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofImage_< float >::setAnchorPercent",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofImage_< float >::setAnchorPercent",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_float_t,0))){
    SWIG_fail_ptr("FloatImage_setAnchorPercent",1,SWIGTYPE_p_ofImage_T_float_t); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); (arg1)->setAnchorPercent(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_FloatImage_setAnchorPoint(lua_State* L) { int SWIG_arg = 0; ofImage_< float > *arg1 = (ofImage_< float > *) 0 ;
  float arg2 ; float arg3 ; SWIG_check_num_args("ofImage_< float >::setAnchorPoint",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< float >::setAnchorPoint",1,"ofImage_< float > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofImage_< float >::setAnchorPoint",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofImage_< float >::setAnchorPoint",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_float_t,0))){
    SWIG_fail_ptr("FloatImage_setAnchorPoint",1,SWIGTYPE_p_ofImage_T_float_t); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); (arg1)->setAnchorPoint(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_FloatImage_resetAnchor(lua_State* L) { int SWIG_arg = 0; ofImage_< float > *arg1 = (ofImage_< float > *) 0 ;
  SWIG_check_num_args("ofImage_< float >::resetAnchor",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< float >::resetAnchor",1,"ofImage_< float > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_float_t,0))){
    SWIG_fail_ptr("FloatImage_resetAnchor",1,SWIGTYPE_p_ofImage_T_float_t); }  (arg1)->resetAnchor(); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatImage_save__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofImage_< float > *arg1 = (ofImage_< float > *) 0 ;
  std::filesystem::path *arg2 = 0 ; ofImageQualityType arg3 ; std::filesystem::path temp2 ; bool result;
  SWIG_check_num_args("ofImage_< float >::save",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< float >::save",1,"ofImage_< float > const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofImage_< float >::save",2,"std::filesystem::path const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofImage_< float >::save",3,"ofImageQualityType");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_float_t,0))){
    SWIG_fail_ptr("FloatImage_save",1,SWIGTYPE_p_ofImage_T_float_t); }  { size_t len = lua_rawlen(L, 2);
    temp2 = lua_tolstring(L, 2, &len); arg2 = &temp2; }  arg3 = (ofImageQualityType)(int)lua_tonumber(L, 3);
  result = (bool)((ofImage_< float > const *)arg1)->save((std::filesystem::path const &)*arg2,arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatImage_save__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofImage_< float > *arg1 = (ofImage_< float > *) 0 ;
  std::filesystem::path *arg2 = 0 ; std::filesystem::path temp2 ; bool result;
  SWIG_check_num_args("ofImage_< float >::save",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< float >::save",1,"ofImage_< float > const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofImage_< float >::save",2,"std::filesystem::path const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_float_t,0))){
    SWIG_fail_ptr("FloatImage_save",1,SWIGTYPE_p_ofImage_T_float_t); }  { size_t len = lua_rawlen(L, 2);
    temp2 = lua_tolstring(L, 2, &len); arg2 = &temp2; } 
  result = (bool)((ofImage_< float > const *)arg1)->save((std::filesystem::path const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatImage_save__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofImage_< float > *arg1 = (ofImage_< float > *) 0 ;
  ofBuffer *arg2 = 0 ; ofImageFormat arg3 ; ofImageQualityType arg4 ; bool result;
  SWIG_check_num_args("ofImage_< float >::save",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< float >::save",1,"ofImage_< float > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofImage_< float >::save",2,"ofBuffer &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofImage_< float >::save",3,"ofImageFormat");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofImage_< float >::save",4,"ofImageQualityType");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_float_t,0))){
    SWIG_fail_ptr("FloatImage_save",1,SWIGTYPE_p_ofImage_T_float_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofBuffer,0))){
    SWIG_fail_ptr("FloatImage_save",2,SWIGTYPE_p_ofBuffer); }  arg3 = (ofImageFormat)(int)lua_tonumber(L, 3);
  arg4 = (ofImageQualityType)(int)lua_tonumber(L, 4); result = (bool)((ofImage_< float > const *)arg1)->save(*arg2,arg3,arg4);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatImage_save__SWIG_3(lua_State* L) { int SWIG_arg = 0; ofImage_< float > *arg1 = (ofImage_< float > *) 0 ;
  ofBuffer *arg2 = 0 ; ofImageFormat arg3 ; bool result; SWIG_check_num_args("ofImage_< float >::save",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< float >::save",1,"ofImage_< float > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofImage_< float >::save",2,"ofBuffer &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofImage_< float >::save",3,"ofImageFormat");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_float_t,0))){
    SWIG_fail_ptr("FloatImage_save",1,SWIGTYPE_p_ofImage_T_float_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofBuffer,0))){
    SWIG_fail_ptr("FloatImage_save",2,SWIGTYPE_p_ofBuffer); }  arg3 = (ofImageFormat)(int)lua_tonumber(L, 3);
  result = (bool)((ofImage_< float > const *)arg1)->save(*arg2,arg3); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatImage_save__SWIG_4(lua_State* L) { int SWIG_arg = 0; ofImage_< float > *arg1 = (ofImage_< float > *) 0 ;
  ofBuffer *arg2 = 0 ; bool result; SWIG_check_num_args("ofImage_< float >::save",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< float >::save",1,"ofImage_< float > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofImage_< float >::save",2,"ofBuffer &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_float_t,0))){
    SWIG_fail_ptr("FloatImage_save",1,SWIGTYPE_p_ofImage_T_float_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofBuffer,0))){
    SWIG_fail_ptr("FloatImage_save",2,SWIGTYPE_p_ofBuffer); }  result = (bool)((ofImage_< float > const *)arg1)->save(*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatImage_save(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_float_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofBuffer, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_FloatImage_save__SWIG_4(L);}  }  }  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_float_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L, argv[1]); }  if (_v) {
        return _wrap_FloatImage_save__SWIG_1(L);}  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_float_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofBuffer, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { return _wrap_FloatImage_save__SWIG_3(L);}  }
       }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_float_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L, argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { return _wrap_FloatImage_save__SWIG_0(L);}  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_float_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofBuffer, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); } 
          if (_v) { return _wrap_FloatImage_save__SWIG_2(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'FloatImage_save'\n" "  Possible C/C++ prototypes are:\n"
  "    ofImage_< float >::save(std::filesystem::path const &,ofImageQualityType) const\n"
  "    ofImage_< float >::save(std::filesystem::path const &) const\n"
  "    ofImage_< float >::save(ofBuffer &,ofImageFormat,ofImageQualityType) const\n"
  "    ofImage_< float >::save(ofBuffer &,ofImageFormat) const\n" "    ofImage_< float >::save(ofBuffer &) const\n");
  lua_error(L);return 0; }
static void swig_delete_FloatImage(void *obj) {
ofImage_< float > *arg1 = (ofImage_< float > *) obj;
delete arg1;
}
static int _proxy__wrap_new_FloatImage(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_FloatImage);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_FloatImage_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_FloatImage_methods[]= {
    { "allocate", _wrap_FloatImage_allocate},
    { "isAllocated", _wrap_FloatImage_isAllocated},
    { "clear", _wrap_FloatImage_clear},
    { "load", _wrap_FloatImage_load},
    { "draw", _wrap_FloatImage_draw},
    { "drawSubsection", _wrap_FloatImage_drawSubsection},
    { "update", _wrap_FloatImage_update},
    { "setUseTexture", _wrap_FloatImage_setUseTexture},
    { "isUsingTexture", _wrap_FloatImage_isUsingTexture},
    { "getTexture", _wrap_FloatImage_getTexture},
    { "bind", _wrap_FloatImage_bind},
    { "unbind", _wrap_FloatImage_unbind},
    { "setCompression", _wrap_FloatImage_setCompression},
    { "getPixels", _wrap_FloatImage_getPixels},
    { "getColor", _wrap_FloatImage_getColor},
    { "getHeight", _wrap_FloatImage_getHeight},
    { "getWidth", _wrap_FloatImage_getWidth},
    { "setColor", _wrap_FloatImage_setColor},
    { "setFromPixels", _wrap_FloatImage_setFromPixels},
    { "grabScreen", _wrap_FloatImage_grabScreen},
    { "setImageType", _wrap_FloatImage_setImageType},
    { "getImageType", _wrap_FloatImage_getImageType},
    { "resize", _wrap_FloatImage_resize},
    { "crop", _wrap_FloatImage_crop},
    { "cropFrom", _wrap_FloatImage_cropFrom},
    { "rotate90", _wrap_FloatImage_rotate90},
    { "mirror", _wrap_FloatImage_mirror},
    { "setAnchorPercent", _wrap_FloatImage_setAnchorPercent},
    { "setAnchorPoint", _wrap_FloatImage_setAnchorPoint},
    { "resetAnchor", _wrap_FloatImage_resetAnchor},
    { "save", _wrap_FloatImage_save},
    {0,0}
};
static swig_lua_method swig_FloatImage_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_FloatImage_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_FloatImage_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_FloatImage_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_FloatImage_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_FloatImage_Sf_SwigStatic = {
    "FloatImage",
    swig_FloatImage_Sf_SwigStatic_methods,
    swig_FloatImage_Sf_SwigStatic_attributes,
    swig_FloatImage_Sf_SwigStatic_constants,
    swig_FloatImage_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_FloatImage_bases[] = {0};
static const char *swig_FloatImage_base_names[] = {0};
static swig_lua_class _wrap_class_FloatImage = { "FloatImage", "FloatImage", &SWIGTYPE_p_ofImage_T_float_t,_proxy__wrap_new_FloatImage, swig_delete_FloatImage, swig_FloatImage_methods, swig_FloatImage_attributes, &swig_FloatImage_Sf_SwigStatic, swig_FloatImage_meta, swig_FloatImage_bases, swig_FloatImage_base_names };

static int _wrap_new_ShortImage__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofImage_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofImage_< unsigned short >::ofImage_",0,0)
  result = (ofImage_< unsigned short > *)new ofImage_< unsigned short >();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofImage_T_unsigned_short_t,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_ShortImage__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofPixels_< unsigned short > *arg1 = 0 ;
  ofImage_< unsigned short > *result = 0 ; SWIG_check_num_args("ofImage_< unsigned short >::ofImage_",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofImage_< unsigned short >::ofImage_",1,"ofPixels_< unsigned short > const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_short_t,0))){
    SWIG_fail_ptr("new_ShortImage",1,SWIGTYPE_p_ofPixels_T_unsigned_short_t); } 
  result = (ofImage_< unsigned short > *)new ofImage_< unsigned short >((ofPixels_< unsigned short > const &)*arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofImage_T_unsigned_short_t,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_ShortImage__SWIG_2(lua_State* L) { int SWIG_arg = 0; std::filesystem::path *arg1 = 0 ;
  ofImageLoadSettings *arg2 = 0 ; std::filesystem::path temp1 ; ofImage_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofImage_< unsigned short >::ofImage_",2,2)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofImage_< unsigned short >::ofImage_",1,"std::filesystem::path const &");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofImage_< unsigned short >::ofImage_",2,"ofImageLoadSettings const &"); {
    size_t len = lua_rawlen(L, 1); temp1 = lua_tolstring(L, 1, &len); arg1 = &temp1; } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofImageLoadSettings,0))){
    SWIG_fail_ptr("new_ShortImage",2,SWIGTYPE_p_ofImageLoadSettings); } 
  result = (ofImage_< unsigned short > *)new ofImage_< unsigned short >((std::filesystem::path const &)*arg1,(ofImageLoadSettings const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofImage_T_unsigned_short_t,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_ShortImage__SWIG_3(lua_State* L) { int SWIG_arg = 0; std::filesystem::path *arg1 = 0 ;
  std::filesystem::path temp1 ; ofImage_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofImage_< unsigned short >::ofImage_",1,1)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofImage_< unsigned short >::ofImage_",1,"std::filesystem::path const &"); {
    size_t len = lua_rawlen(L, 1); temp1 = lua_tolstring(L, 1, &len); arg1 = &temp1; } 
  result = (ofImage_< unsigned short > *)new ofImage_< unsigned short >((std::filesystem::path const &)*arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofImage_T_unsigned_short_t,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_ShortImage__SWIG_4(lua_State* L) { int SWIG_arg = 0; ofImage_< unsigned short > *arg1 = 0 ;
  ofImage_< unsigned short > *result = 0 ; SWIG_check_num_args("ofImage_< unsigned short >::ofImage_",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofImage_< unsigned short >::ofImage_",1,"ofImage_< unsigned short > &&");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_short_t,0))){
    SWIG_fail_ptr("new_ShortImage",1,SWIGTYPE_p_ofImage_T_unsigned_short_t); } 
  result = (ofImage_< unsigned short > *)new ofImage_< unsigned short >((ofImage_< unsigned short > &&)*arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofImage_T_unsigned_short_t,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_ShortImage(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 0) {
    return _wrap_new_ShortImage__SWIG_0(L);}  if (argc == 1) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofPixels_T_unsigned_short_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_new_ShortImage__SWIG_1(L);}  }  if (argc == 1) { int _v; {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_short_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_new_ShortImage__SWIG_4(L);}  }  if (argc == 1) { int _v; {
      _v = lua_isstring(L, argv[0]); }  if (_v) { return _wrap_new_ShortImage__SWIG_3(L);}  }  if (argc == 2) { int _v; {
      _v = lua_isstring(L, argv[0]); }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofImageLoadSettings, 0)) {
          _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_new_ShortImage__SWIG_2(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_ShortImage'\n" "  Possible C/C++ prototypes are:\n"
  "    ofImage_< unsigned short >::ofImage_()\n"
  "    ofImage_< unsigned short >::ofImage_(ofPixels_< unsigned short > const &)\n"
  "    ofImage_< unsigned short >::ofImage_(std::filesystem::path const &,ofImageLoadSettings const &)\n"
  "    ofImage_< unsigned short >::ofImage_(std::filesystem::path const &)\n"
  "    ofImage_< unsigned short >::ofImage_(ofImage_< unsigned short > &&)\n"); lua_error(L);return 0; }
static int _wrap_ShortImage_allocate(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned short > *arg1 = (ofImage_< unsigned short > *) 0 ; int arg2 ; int arg3 ; ofImageType arg4 ;
  SWIG_check_num_args("ofImage_< unsigned short >::allocate",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned short >::allocate",1,"ofImage_< unsigned short > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofImage_< unsigned short >::allocate",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofImage_< unsigned short >::allocate",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofImage_< unsigned short >::allocate",4,"ofImageType");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortImage_allocate",1,SWIGTYPE_p_ofImage_T_unsigned_short_t); }  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3); arg4 = (ofImageType)(int)lua_tonumber(L, 4); (arg1)->allocate(arg2,arg3,arg4);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortImage_isAllocated(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned short > *arg1 = (ofImage_< unsigned short > *) 0 ; bool result;
  SWIG_check_num_args("ofImage_< unsigned short >::isAllocated",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned short >::isAllocated",1,"ofImage_< unsigned short > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortImage_isAllocated",1,SWIGTYPE_p_ofImage_T_unsigned_short_t); } 
  result = (bool)((ofImage_< unsigned short > const *)arg1)->isAllocated(); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortImage_clear(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned short > *arg1 = (ofImage_< unsigned short > *) 0 ;
  SWIG_check_num_args("ofImage_< unsigned short >::clear",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned short >::clear",1,"ofImage_< unsigned short > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortImage_clear",1,SWIGTYPE_p_ofImage_T_unsigned_short_t); }  (arg1)->clear(); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortImage_load__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned short > *arg1 = (ofImage_< unsigned short > *) 0 ; std::filesystem::path *arg2 = 0 ;
  ofImageLoadSettings *arg3 = 0 ; std::filesystem::path temp2 ; bool result;
  SWIG_check_num_args("ofImage_< unsigned short >::load",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned short >::load",1,"ofImage_< unsigned short > *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofImage_< unsigned short >::load",2,"std::filesystem::path const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofImage_< unsigned short >::load",3,"ofImageLoadSettings const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortImage_load",1,SWIGTYPE_p_ofImage_T_unsigned_short_t); }  { size_t len = lua_rawlen(L, 2);
    temp2 = lua_tolstring(L, 2, &len); arg2 = &temp2; } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_ofImageLoadSettings,0))){
    SWIG_fail_ptr("ShortImage_load",3,SWIGTYPE_p_ofImageLoadSettings); } 
  result = (bool)(arg1)->load((std::filesystem::path const &)*arg2,(ofImageLoadSettings const &)*arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortImage_load__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned short > *arg1 = (ofImage_< unsigned short > *) 0 ; std::filesystem::path *arg2 = 0 ;
  std::filesystem::path temp2 ; bool result; SWIG_check_num_args("ofImage_< unsigned short >::load",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned short >::load",1,"ofImage_< unsigned short > *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofImage_< unsigned short >::load",2,"std::filesystem::path const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortImage_load",1,SWIGTYPE_p_ofImage_T_unsigned_short_t); }  { size_t len = lua_rawlen(L, 2);
    temp2 = lua_tolstring(L, 2, &len); arg2 = &temp2; }  result = (bool)(arg1)->load((std::filesystem::path const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortImage_load__SWIG_2(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned short > *arg1 = (ofImage_< unsigned short > *) 0 ; ofBuffer *arg2 = 0 ; ofImageLoadSettings *arg3 = 0 ;
  bool result; SWIG_check_num_args("ofImage_< unsigned short >::load",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned short >::load",1,"ofImage_< unsigned short > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofImage_< unsigned short >::load",2,"ofBuffer const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofImage_< unsigned short >::load",3,"ofImageLoadSettings const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortImage_load",1,SWIGTYPE_p_ofImage_T_unsigned_short_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofBuffer,0))){
    SWIG_fail_ptr("ShortImage_load",2,SWIGTYPE_p_ofBuffer); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_ofImageLoadSettings,0))){
    SWIG_fail_ptr("ShortImage_load",3,SWIGTYPE_p_ofImageLoadSettings); } 
  result = (bool)(arg1)->load((ofBuffer const &)*arg2,(ofImageLoadSettings const &)*arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortImage_load__SWIG_3(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned short > *arg1 = (ofImage_< unsigned short > *) 0 ; ofBuffer *arg2 = 0 ; bool result;
  SWIG_check_num_args("ofImage_< unsigned short >::load",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned short >::load",1,"ofImage_< unsigned short > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofImage_< unsigned short >::load",2,"ofBuffer const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortImage_load",1,SWIGTYPE_p_ofImage_T_unsigned_short_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofBuffer,0))){
    SWIG_fail_ptr("ShortImage_load",2,SWIGTYPE_p_ofBuffer); }  result = (bool)(arg1)->load((ofBuffer const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortImage_load(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_short_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofBuffer, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_ShortImage_load__SWIG_3(L);}  }  }  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_short_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L, argv[1]); }  if (_v) {
        return _wrap_ShortImage_load__SWIG_1(L);}  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_short_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofBuffer, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_ofImageLoadSettings, 0)) {
            _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_ShortImage_load__SWIG_2(L);}  }  }  }  if (argc == 3) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_short_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L, argv[1]); }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_ofImageLoadSettings, 0)) {
            _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_ShortImage_load__SWIG_0(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'ShortImage_load'\n" "  Possible C/C++ prototypes are:\n"
  "    ofImage_< unsigned short >::load(std::filesystem::path const &,ofImageLoadSettings const &)\n"
  "    ofImage_< unsigned short >::load(std::filesystem::path const &)\n"
  "    ofImage_< unsigned short >::load(ofBuffer const &,ofImageLoadSettings const &)\n"
  "    ofImage_< unsigned short >::load(ofBuffer const &)\n"); lua_error(L);return 0; }
static int _wrap_ShortImage_draw__SWIG_0_0(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned short > *arg1 = (ofImage_< unsigned short > *) 0 ; glm::vec2 *arg2 = 0 ; SWIG_check_num_args("draw",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("draw",1,"ofImage_< unsigned short > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("draw",2,"glm::vec2 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortImage_draw",1,SWIGTYPE_p_ofImage_T_unsigned_short_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec2,0))){
    SWIG_fail_ptr("ShortImage_draw",2,SWIGTYPE_p_glm__vec2); } 
  ((ofImage_< unsigned short > const *)arg1)->draw((glm::vec2 const &)*arg2); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortImage_draw__SWIG_0_1(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned short > *arg1 = (ofImage_< unsigned short > *) 0 ; ofRectangle *arg2 = 0 ; SWIG_check_num_args("draw",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("draw",1,"ofImage_< unsigned short > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("draw",2,"ofRectangle const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortImage_draw",1,SWIGTYPE_p_ofImage_T_unsigned_short_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("ShortImage_draw",2,SWIGTYPE_p_ofRectangle); } 
  ((ofImage_< unsigned short > const *)arg1)->draw((ofRectangle const &)*arg2); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortImage_draw__SWIG_0_2(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned short > *arg1 = (ofImage_< unsigned short > *) 0 ; glm::vec2 *arg2 = 0 ; float arg3 ; float arg4 ;
  SWIG_check_num_args("draw",4,4) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("draw",1,"ofImage_< unsigned short > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("draw",2,"glm::vec2 const &"); if(!lua_isnumber(L,3)) SWIG_fail_arg("draw",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("draw",4,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortImage_draw",1,SWIGTYPE_p_ofImage_T_unsigned_short_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec2,0))){
    SWIG_fail_ptr("ShortImage_draw",2,SWIGTYPE_p_glm__vec2); }  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4); ((ofImage_< unsigned short > const *)arg1)->draw((glm::vec2 const &)*arg2,arg3,arg4);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortImage_draw__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned short > *arg1 = (ofImage_< unsigned short > *) 0 ; float arg2 ; float arg3 ;
  SWIG_check_num_args("ofImage_< unsigned short >::draw",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned short >::draw",1,"ofImage_< unsigned short > const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofImage_< unsigned short >::draw",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofImage_< unsigned short >::draw",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortImage_draw",1,SWIGTYPE_p_ofImage_T_unsigned_short_t); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); ((ofImage_< unsigned short > const *)arg1)->draw(arg2,arg3); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortImage_draw__SWIG_2(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned short > *arg1 = (ofImage_< unsigned short > *) 0 ; float arg2 ; float arg3 ; float arg4 ;
  SWIG_check_num_args("ofImage_< unsigned short >::draw",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned short >::draw",1,"ofImage_< unsigned short > const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofImage_< unsigned short >::draw",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofImage_< unsigned short >::draw",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofImage_< unsigned short >::draw",4,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortImage_draw",1,SWIGTYPE_p_ofImage_T_unsigned_short_t); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  ((ofImage_< unsigned short > const *)arg1)->draw(arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_ShortImage_draw__SWIG_3(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned short > *arg1 = (ofImage_< unsigned short > *) 0 ; glm::vec3 *arg2 = 0 ;
  SWIG_check_num_args("ofImage_< unsigned short >::draw",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned short >::draw",1,"ofImage_< unsigned short > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofImage_< unsigned short >::draw",2,"glm::vec3 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortImage_draw",1,SWIGTYPE_p_ofImage_T_unsigned_short_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("ShortImage_draw",2,SWIGTYPE_p_glm__vec3); } 
  ((ofImage_< unsigned short > const *)arg1)->draw((glm::vec3 const &)*arg2); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortImage_draw__SWIG_4(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned short > *arg1 = (ofImage_< unsigned short > *) 0 ; float arg2 ; float arg3 ; float arg4 ; float arg5 ;
  SWIG_check_num_args("ofImage_< unsigned short >::draw",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned short >::draw",1,"ofImage_< unsigned short > const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofImage_< unsigned short >::draw",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofImage_< unsigned short >::draw",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofImage_< unsigned short >::draw",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofImage_< unsigned short >::draw",5,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortImage_draw",1,SWIGTYPE_p_ofImage_T_unsigned_short_t); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); arg5 = (float)lua_tonumber(L, 5);
  ((ofImage_< unsigned short > const *)arg1)->draw(arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_ShortImage_draw__SWIG_5(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned short > *arg1 = (ofImage_< unsigned short > *) 0 ; float arg2 ; float arg3 ; float arg4 ; float arg5 ;
  float arg6 ; SWIG_check_num_args("ofImage_< unsigned short >::draw",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned short >::draw",1,"ofImage_< unsigned short > const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofImage_< unsigned short >::draw",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofImage_< unsigned short >::draw",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofImage_< unsigned short >::draw",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofImage_< unsigned short >::draw",5,"float");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofImage_< unsigned short >::draw",6,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortImage_draw",1,SWIGTYPE_p_ofImage_T_unsigned_short_t); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); arg5 = (float)lua_tonumber(L, 5);
  arg6 = (float)lua_tonumber(L, 6); ((ofImage_< unsigned short > const *)arg1)->draw(arg2,arg3,arg4,arg5,arg6); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortImage_draw__SWIG_6(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned short > *arg1 = (ofImage_< unsigned short > *) 0 ; glm::vec3 *arg2 = 0 ; float arg3 ; float arg4 ;
  SWIG_check_num_args("ofImage_< unsigned short >::draw",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned short >::draw",1,"ofImage_< unsigned short > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofImage_< unsigned short >::draw",2,"glm::vec3 const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofImage_< unsigned short >::draw",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofImage_< unsigned short >::draw",4,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortImage_draw",1,SWIGTYPE_p_ofImage_T_unsigned_short_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("ShortImage_draw",2,SWIGTYPE_p_glm__vec3); }  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4); ((ofImage_< unsigned short > const *)arg1)->draw((glm::vec3 const &)*arg2,arg3,arg4);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortImage_draw(lua_State* L) { int argc; int argv[7]={ 1,2,3,4,5,6,7} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_short_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec2, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_ShortImage_draw__SWIG_0_0(L);}  }  }  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_short_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_ShortImage_draw__SWIG_0_1(L);}  }  }  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_short_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_ShortImage_draw__SWIG_3(L);}  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_short_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { return _wrap_ShortImage_draw__SWIG_1(L);}  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_short_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec2, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); } 
          if (_v) { return _wrap_ShortImage_draw__SWIG_0_2(L);}  }  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_short_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); } 
          if (_v) { return _wrap_ShortImage_draw__SWIG_6(L);}  }  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_short_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_ShortImage_draw__SWIG_2(L);}  }  }  }  } 
  if (argc == 5) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_short_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) {
              return _wrap_ShortImage_draw__SWIG_4(L);}  }  }  }  }  }  if (argc == 6) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_short_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) { {
                _v = lua_isnumber(L,argv[5]); }  if (_v) { return _wrap_ShortImage_draw__SWIG_5(L);}  }  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'ShortImage_draw'\n" "  Possible C/C++ prototypes are:\n"
  "    draw(glm::vec2 const &) const\n" "    draw(ofRectangle const &) const\n"
  "    draw(glm::vec2 const &,float,float) const\n" "    ofImage_< unsigned short >::draw(float,float) const\n"
  "    ofImage_< unsigned short >::draw(float,float,float) const\n"
  "    ofImage_< unsigned short >::draw(glm::vec3 const &) const\n"
  "    ofImage_< unsigned short >::draw(float,float,float,float) const\n"
  "    ofImage_< unsigned short >::draw(float,float,float,float,float) const\n"
  "    ofImage_< unsigned short >::draw(glm::vec3 const &,float,float) const\n"); lua_error(L);return 0; }
static int _wrap_ShortImage_drawSubsection__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned short > *arg1 = (ofImage_< unsigned short > *) 0 ; float arg2 ; float arg3 ; float arg4 ; float arg5 ;
  float arg6 ; float arg7 ; SWIG_check_num_args("ofImage_< unsigned short >::drawSubsection",7,7)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned short >::drawSubsection",1,"ofImage_< unsigned short > const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofImage_< unsigned short >::drawSubsection",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofImage_< unsigned short >::drawSubsection",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofImage_< unsigned short >::drawSubsection",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofImage_< unsigned short >::drawSubsection",5,"float");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofImage_< unsigned short >::drawSubsection",6,"float");
  if(!lua_isnumber(L,7)) SWIG_fail_arg("ofImage_< unsigned short >::drawSubsection",7,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortImage_drawSubsection",1,SWIGTYPE_p_ofImage_T_unsigned_short_t); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); arg5 = (float)lua_tonumber(L, 5);
  arg6 = (float)lua_tonumber(L, 6); arg7 = (float)lua_tonumber(L, 7);
  ((ofImage_< unsigned short > const *)arg1)->drawSubsection(arg2,arg3,arg4,arg5,arg6,arg7); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortImage_drawSubsection__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned short > *arg1 = (ofImage_< unsigned short > *) 0 ; float arg2 ; float arg3 ; float arg4 ; float arg5 ;
  float arg6 ; float arg7 ; float arg8 ; SWIG_check_num_args("ofImage_< unsigned short >::drawSubsection",8,8)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned short >::drawSubsection",1,"ofImage_< unsigned short > const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofImage_< unsigned short >::drawSubsection",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofImage_< unsigned short >::drawSubsection",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofImage_< unsigned short >::drawSubsection",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofImage_< unsigned short >::drawSubsection",5,"float");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofImage_< unsigned short >::drawSubsection",6,"float");
  if(!lua_isnumber(L,7)) SWIG_fail_arg("ofImage_< unsigned short >::drawSubsection",7,"float");
  if(!lua_isnumber(L,8)) SWIG_fail_arg("ofImage_< unsigned short >::drawSubsection",8,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortImage_drawSubsection",1,SWIGTYPE_p_ofImage_T_unsigned_short_t); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); arg5 = (float)lua_tonumber(L, 5);
  arg6 = (float)lua_tonumber(L, 6); arg7 = (float)lua_tonumber(L, 7); arg8 = (float)lua_tonumber(L, 8);
  ((ofImage_< unsigned short > const *)arg1)->drawSubsection(arg2,arg3,arg4,arg5,arg6,arg7,arg8); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortImage_drawSubsection__SWIG_2(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned short > *arg1 = (ofImage_< unsigned short > *) 0 ; float arg2 ; float arg3 ; float arg4 ; float arg5 ;
  float arg6 ; float arg7 ; float arg8 ; float arg9 ; SWIG_check_num_args("ofImage_< unsigned short >::drawSubsection",9,9)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned short >::drawSubsection",1,"ofImage_< unsigned short > const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofImage_< unsigned short >::drawSubsection",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofImage_< unsigned short >::drawSubsection",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofImage_< unsigned short >::drawSubsection",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofImage_< unsigned short >::drawSubsection",5,"float");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofImage_< unsigned short >::drawSubsection",6,"float");
  if(!lua_isnumber(L,7)) SWIG_fail_arg("ofImage_< unsigned short >::drawSubsection",7,"float");
  if(!lua_isnumber(L,8)) SWIG_fail_arg("ofImage_< unsigned short >::drawSubsection",8,"float");
  if(!lua_isnumber(L,9)) SWIG_fail_arg("ofImage_< unsigned short >::drawSubsection",9,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortImage_drawSubsection",1,SWIGTYPE_p_ofImage_T_unsigned_short_t); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); arg5 = (float)lua_tonumber(L, 5);
  arg6 = (float)lua_tonumber(L, 6); arg7 = (float)lua_tonumber(L, 7); arg8 = (float)lua_tonumber(L, 8);
  arg9 = (float)lua_tonumber(L, 9);
  ((ofImage_< unsigned short > const *)arg1)->drawSubsection(arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortImage_drawSubsection__SWIG_3(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned short > *arg1 = (ofImage_< unsigned short > *) 0 ; float arg2 ; float arg3 ; float arg4 ; float arg5 ;
  float arg6 ; float arg7 ; float arg8 ; float arg9 ; float arg10 ;
  SWIG_check_num_args("ofImage_< unsigned short >::drawSubsection",10,10)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned short >::drawSubsection",1,"ofImage_< unsigned short > const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofImage_< unsigned short >::drawSubsection",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofImage_< unsigned short >::drawSubsection",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofImage_< unsigned short >::drawSubsection",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofImage_< unsigned short >::drawSubsection",5,"float");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofImage_< unsigned short >::drawSubsection",6,"float");
  if(!lua_isnumber(L,7)) SWIG_fail_arg("ofImage_< unsigned short >::drawSubsection",7,"float");
  if(!lua_isnumber(L,8)) SWIG_fail_arg("ofImage_< unsigned short >::drawSubsection",8,"float");
  if(!lua_isnumber(L,9)) SWIG_fail_arg("ofImage_< unsigned short >::drawSubsection",9,"float");
  if(!lua_isnumber(L,10)) SWIG_fail_arg("ofImage_< unsigned short >::drawSubsection",10,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortImage_drawSubsection",1,SWIGTYPE_p_ofImage_T_unsigned_short_t); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); arg5 = (float)lua_tonumber(L, 5);
  arg6 = (float)lua_tonumber(L, 6); arg7 = (float)lua_tonumber(L, 7); arg8 = (float)lua_tonumber(L, 8);
  arg9 = (float)lua_tonumber(L, 9); arg10 = (float)lua_tonumber(L, 10);
  ((ofImage_< unsigned short > const *)arg1)->drawSubsection(arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortImage_drawSubsection(lua_State* L) { int argc; int argv[11]={ 1,2,3,4,5,6,7,8,9,10,11} ;
  argc = lua_gettop(L); if (argc == 7) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_short_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) { {
                _v = lua_isnumber(L,argv[5]); }  if (_v) { { _v = lua_isnumber(L,argv[6]); }  if (_v) {
                  return _wrap_ShortImage_drawSubsection__SWIG_0(L);}  }  }  }  }  }  }  }  if (argc == 8) { int _v; {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_short_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) { {
                _v = lua_isnumber(L,argv[5]); }  if (_v) { { _v = lua_isnumber(L,argv[6]); }  if (_v) { {
                    _v = lua_isnumber(L,argv[7]); }  if (_v) { return _wrap_ShortImage_drawSubsection__SWIG_1(L);}  }  }  }  }  }
         }  }  }  if (argc == 9) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_short_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) { {
                _v = lua_isnumber(L,argv[5]); }  if (_v) { { _v = lua_isnumber(L,argv[6]); }  if (_v) { {
                    _v = lua_isnumber(L,argv[7]); }  if (_v) { { _v = lua_isnumber(L,argv[8]); }  if (_v) {
                      return _wrap_ShortImage_drawSubsection__SWIG_2(L);}  }  }  }  }  }  }  }  }  }  if (argc == 10) { int _v;
    { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_short_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) { {
                _v = lua_isnumber(L,argv[5]); }  if (_v) { { _v = lua_isnumber(L,argv[6]); }  if (_v) { {
                    _v = lua_isnumber(L,argv[7]); }  if (_v) { { _v = lua_isnumber(L,argv[8]); }  if (_v) { {
                        _v = lua_isnumber(L,argv[9]); }  if (_v) { return _wrap_ShortImage_drawSubsection__SWIG_3(L);}  }  }  }
                 }  }  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'ShortImage_drawSubsection'\n"
  "  Possible C/C++ prototypes are:\n"
  "    ofImage_< unsigned short >::drawSubsection(float,float,float,float,float,float) const\n"
  "    ofImage_< unsigned short >::drawSubsection(float,float,float,float,float,float,float) const\n"
  "    ofImage_< unsigned short >::drawSubsection(float,float,float,float,float,float,float,float) const\n"
  "    ofImage_< unsigned short >::drawSubsection(float,float,float,float,float,float,float,float,float) const\n");
  lua_error(L);return 0; }
static int _wrap_ShortImage_update(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned short > *arg1 = (ofImage_< unsigned short > *) 0 ;
  SWIG_check_num_args("ofImage_< unsigned short >::update",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned short >::update",1,"ofImage_< unsigned short > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortImage_update",1,SWIGTYPE_p_ofImage_T_unsigned_short_t); }  (arg1)->update(); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortImage_setUseTexture(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned short > *arg1 = (ofImage_< unsigned short > *) 0 ; bool arg2 ;
  SWIG_check_num_args("ofImage_< unsigned short >::setUseTexture",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned short >::setUseTexture",1,"ofImage_< unsigned short > *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofImage_< unsigned short >::setUseTexture",2,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortImage_setUseTexture",1,SWIGTYPE_p_ofImage_T_unsigned_short_t); }  arg2 = (lua_toboolean(L, 2)!=0);
  (arg1)->setUseTexture(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortImage_isUsingTexture(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned short > *arg1 = (ofImage_< unsigned short > *) 0 ; bool result;
  SWIG_check_num_args("ofImage_< unsigned short >::isUsingTexture",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned short >::isUsingTexture",1,"ofImage_< unsigned short > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortImage_isUsingTexture",1,SWIGTYPE_p_ofImage_T_unsigned_short_t); } 
  result = (bool)((ofImage_< unsigned short > const *)arg1)->isUsingTexture(); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortImage_getTexture__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned short > *arg1 = (ofImage_< unsigned short > *) 0 ; ofTexture *result = 0 ;
  SWIG_check_num_args("ofImage_< unsigned short >::getTexture",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned short >::getTexture",1,"ofImage_< unsigned short > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortImage_getTexture",1,SWIGTYPE_p_ofImage_T_unsigned_short_t); } 
  result = (ofTexture *) &(arg1)->getTexture(); SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofTexture,0); SWIG_arg++; 
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortImage_getTexture__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned short > *arg1 = (ofImage_< unsigned short > *) 0 ; ofTexture *result = 0 ;
  SWIG_check_num_args("ofImage_< unsigned short >::getTexture",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned short >::getTexture",1,"ofImage_< unsigned short > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortImage_getTexture",1,SWIGTYPE_p_ofImage_T_unsigned_short_t); } 
  result = (ofTexture *) &((ofImage_< unsigned short > const *)arg1)->getTexture();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofTexture,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_ShortImage_getTexture(lua_State* L) { int argc; int argv[2]={ 1,2} ; argc = lua_gettop(L); if (argc == 1) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_short_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_ShortImage_getTexture__SWIG_0(L);}  }  if (argc == 1) { int _v; {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_short_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_ShortImage_getTexture__SWIG_1(L);}  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'ShortImage_getTexture'\n"
  "  Possible C/C++ prototypes are:\n" "    ofImage_< unsigned short >::getTexture()\n"
  "    ofImage_< unsigned short >::getTexture() const\n"); lua_error(L);return 0; }
static int _wrap_ShortImage_bind__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned short > *arg1 = (ofImage_< unsigned short > *) 0 ; int arg2 ;
  SWIG_check_num_args("ofImage_< unsigned short >::bind",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned short >::bind",1,"ofImage_< unsigned short > const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofImage_< unsigned short >::bind",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortImage_bind",1,SWIGTYPE_p_ofImage_T_unsigned_short_t); }  arg2 = (int)lua_tonumber(L, 2);
  ((ofImage_< unsigned short > const *)arg1)->bind(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_ShortImage_bind__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned short > *arg1 = (ofImage_< unsigned short > *) 0 ;
  SWIG_check_num_args("ofImage_< unsigned short >::bind",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned short >::bind",1,"ofImage_< unsigned short > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortImage_bind",1,SWIGTYPE_p_ofImage_T_unsigned_short_t); } 
  ((ofImage_< unsigned short > const *)arg1)->bind(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortImage_bind(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 1) { int _v;
    { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_short_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_ShortImage_bind__SWIG_1(L);}  }  if (argc == 2) { int _v; {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_short_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_ShortImage_bind__SWIG_0(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'ShortImage_bind'\n" "  Possible C/C++ prototypes are:\n"
  "    ofImage_< unsigned short >::bind(int) const\n" "    ofImage_< unsigned short >::bind() const\n"); lua_error(L);return 0; }
static int _wrap_ShortImage_unbind__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned short > *arg1 = (ofImage_< unsigned short > *) 0 ; int arg2 ;
  SWIG_check_num_args("ofImage_< unsigned short >::unbind",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned short >::unbind",1,"ofImage_< unsigned short > const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofImage_< unsigned short >::unbind",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortImage_unbind",1,SWIGTYPE_p_ofImage_T_unsigned_short_t); }  arg2 = (int)lua_tonumber(L, 2);
  ((ofImage_< unsigned short > const *)arg1)->unbind(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_ShortImage_unbind__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned short > *arg1 = (ofImage_< unsigned short > *) 0 ;
  SWIG_check_num_args("ofImage_< unsigned short >::unbind",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned short >::unbind",1,"ofImage_< unsigned short > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortImage_unbind",1,SWIGTYPE_p_ofImage_T_unsigned_short_t); } 
  ((ofImage_< unsigned short > const *)arg1)->unbind(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortImage_unbind(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 1) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_short_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_ShortImage_unbind__SWIG_1(L);}  }  if (argc == 2) { int _v; {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_short_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_ShortImage_unbind__SWIG_0(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'ShortImage_unbind'\n" "  Possible C/C++ prototypes are:\n"
  "    ofImage_< unsigned short >::unbind(int) const\n" "    ofImage_< unsigned short >::unbind() const\n");
  lua_error(L);return 0; }
static int _wrap_ShortImage_setCompression(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned short > *arg1 = (ofImage_< unsigned short > *) 0 ; ofTexCompression arg2 ;
  SWIG_check_num_args("ofImage_< unsigned short >::setCompression",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned short >::setCompression",1,"ofImage_< unsigned short > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofImage_< unsigned short >::setCompression",2,"ofTexCompression");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortImage_setCompression",1,SWIGTYPE_p_ofImage_T_unsigned_short_t); } 
  arg2 = (ofTexCompression)(int)lua_tonumber(L, 2); (arg1)->setCompression(arg2); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortImage_getPixels__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned short > *arg1 = (ofImage_< unsigned short > *) 0 ; ofPixels_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofImage_< unsigned short >::getPixels",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned short >::getPixels",1,"ofImage_< unsigned short > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortImage_getPixels",1,SWIGTYPE_p_ofImage_T_unsigned_short_t); } 
  result = (ofPixels_< unsigned short > *) &(arg1)->getPixels();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofPixels_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortImage_getPixels__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned short > *arg1 = (ofImage_< unsigned short > *) 0 ; ofPixels_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofImage_< unsigned short >::getPixels",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned short >::getPixels",1,"ofImage_< unsigned short > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortImage_getPixels",1,SWIGTYPE_p_ofImage_T_unsigned_short_t); } 
  result = (ofPixels_< unsigned short > *) &((ofImage_< unsigned short > const *)arg1)->getPixels();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofPixels_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortImage_getPixels(lua_State* L) { int argc; int argv[2]={ 1,2} ; argc = lua_gettop(L); if (argc == 1) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_short_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_ShortImage_getPixels__SWIG_0(L);}  }  if (argc == 1) { int _v; {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_short_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_ShortImage_getPixels__SWIG_1(L);}  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'ShortImage_getPixels'\n"
  "  Possible C/C++ prototypes are:\n" "    ofImage_< unsigned short >::getPixels()\n"
  "    ofImage_< unsigned short >::getPixels() const\n"); lua_error(L);return 0; }
static int _wrap_ShortImage_getColor__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned short > *arg1 = (ofImage_< unsigned short > *) 0 ; int arg2 ; int arg3 ; ofColor_< unsigned short > result;
  SWIG_check_num_args("ofImage_< unsigned short >::getColor",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned short >::getColor",1,"ofImage_< unsigned short > const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofImage_< unsigned short >::getColor",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofImage_< unsigned short >::getColor",3,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortImage_getColor",1,SWIGTYPE_p_ofImage_T_unsigned_short_t); }  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3); result = ((ofImage_< unsigned short > const *)arg1)->getColor(arg2,arg3); {
    ofColor_< unsigned short > * resultptr = new ofColor_< unsigned short >((const ofColor_< unsigned short > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofColor_T_unsigned_short_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortImage_getColor__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned short > *arg1 = (ofImage_< unsigned short > *) 0 ; int arg2 ; ofColor_< unsigned short > result;
  SWIG_check_num_args("ofImage_< unsigned short >::getColor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned short >::getColor",1,"ofImage_< unsigned short > const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofImage_< unsigned short >::getColor",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortImage_getColor",1,SWIGTYPE_p_ofImage_T_unsigned_short_t); }  arg2 = (int)lua_tonumber(L, 2);
  result = ((ofImage_< unsigned short > const *)arg1)->getColor(arg2); {
    ofColor_< unsigned short > * resultptr = new ofColor_< unsigned short >((const ofColor_< unsigned short > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofColor_T_unsigned_short_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortImage_getColor(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_short_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_ShortImage_getColor__SWIG_1(L);}  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_short_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { return _wrap_ShortImage_getColor__SWIG_0(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'ShortImage_getColor'\n"
  "  Possible C/C++ prototypes are:\n" "    ofImage_< unsigned short >::getColor(int,int) const\n"
  "    ofImage_< unsigned short >::getColor(int) const\n"); lua_error(L);return 0; }
static int _wrap_ShortImage_getHeight(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned short > *arg1 = (ofImage_< unsigned short > *) 0 ; float result;
  SWIG_check_num_args("ofImage_< unsigned short >::getHeight",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned short >::getHeight",1,"ofImage_< unsigned short > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortImage_getHeight",1,SWIGTYPE_p_ofImage_T_unsigned_short_t); } 
  result = (float)((ofImage_< unsigned short > const *)arg1)->getHeight(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortImage_getWidth(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned short > *arg1 = (ofImage_< unsigned short > *) 0 ; float result;
  SWIG_check_num_args("ofImage_< unsigned short >::getWidth",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned short >::getWidth",1,"ofImage_< unsigned short > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortImage_getWidth",1,SWIGTYPE_p_ofImage_T_unsigned_short_t); } 
  result = (float)((ofImage_< unsigned short > const *)arg1)->getWidth(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortImage_setColor__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned short > *arg1 = (ofImage_< unsigned short > *) 0 ; int arg2 ; int arg3 ;
  ofColor_< unsigned short > *arg4 = 0 ; SWIG_check_num_args("ofImage_< unsigned short >::setColor",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned short >::setColor",1,"ofImage_< unsigned short > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofImage_< unsigned short >::setColor",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofImage_< unsigned short >::setColor",3,"int");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("ofImage_< unsigned short >::setColor",4,"ofColor_< unsigned short > const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortImage_setColor",1,SWIGTYPE_p_ofImage_T_unsigned_short_t); }  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3); if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_ofColor_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortImage_setColor",4,SWIGTYPE_p_ofColor_T_unsigned_short_t); } 
  (arg1)->setColor(arg2,arg3,(ofColor_< unsigned short > const &)*arg4); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_ShortImage_setColor__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned short > *arg1 = (ofImage_< unsigned short > *) 0 ; int arg2 ; ofColor_< unsigned short > *arg3 = 0 ;
  SWIG_check_num_args("ofImage_< unsigned short >::setColor",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned short >::setColor",1,"ofImage_< unsigned short > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofImage_< unsigned short >::setColor",2,"int");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofImage_< unsigned short >::setColor",3,"ofColor_< unsigned short > const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortImage_setColor",1,SWIGTYPE_p_ofImage_T_unsigned_short_t); }  arg2 = (int)lua_tonumber(L, 2);
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_ofColor_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortImage_setColor",3,SWIGTYPE_p_ofColor_T_unsigned_short_t); } 
  (arg1)->setColor(arg2,(ofColor_< unsigned short > const &)*arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_ShortImage_setColor__SWIG_2(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned short > *arg1 = (ofImage_< unsigned short > *) 0 ; ofColor_< unsigned short > *arg2 = 0 ;
  SWIG_check_num_args("ofImage_< unsigned short >::setColor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned short >::setColor",1,"ofImage_< unsigned short > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofImage_< unsigned short >::setColor",2,"ofColor_< unsigned short > const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortImage_setColor",1,SWIGTYPE_p_ofImage_T_unsigned_short_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofColor_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortImage_setColor",2,SWIGTYPE_p_ofColor_T_unsigned_short_t); } 
  (arg1)->setColor((ofColor_< unsigned short > const &)*arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_ShortImage_setColor(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_short_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofColor_T_unsigned_short_t, 0)) {
          _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_ShortImage_setColor__SWIG_2(L);}  }  }  if (argc == 3) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_short_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_ofColor_T_unsigned_short_t, 0)) {
            _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_ShortImage_setColor__SWIG_1(L);}  }  }  }  if (argc == 4) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_short_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { { void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_ofColor_T_unsigned_short_t, 0)) {
              _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_ShortImage_setColor__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'ShortImage_setColor'\n"
  "  Possible C/C++ prototypes are:\n" "    ofImage_< unsigned short >::setColor(int,int,ofColor_< unsigned short > const &)\n"
  "    ofImage_< unsigned short >::setColor(int,ofColor_< unsigned short > const &)\n"
  "    ofImage_< unsigned short >::setColor(ofColor_< unsigned short > const &)\n"); lua_error(L);return 0; }
static int _wrap_ShortImage_setFromPixels__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned short > *arg1 = (ofImage_< unsigned short > *) 0 ; unsigned short *arg2 = (unsigned short *) 0 ; int arg3 ;
  int arg4 ; ofImageType arg5 ; bool arg6 ; SWIG_check_num_args("ofImage_< unsigned short >::setFromPixels",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned short >::setFromPixels",1,"ofImage_< unsigned short > *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofImage_< unsigned short >::setFromPixels",2,"unsigned short const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofImage_< unsigned short >::setFromPixels",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofImage_< unsigned short >::setFromPixels",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofImage_< unsigned short >::setFromPixels",5,"ofImageType");
  if(!lua_isboolean(L,6)) SWIG_fail_arg("ofImage_< unsigned short >::setFromPixels",6,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortImage_setFromPixels",1,SWIGTYPE_p_ofImage_T_unsigned_short_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_unsigned_short,0))){
    SWIG_fail_ptr("ShortImage_setFromPixels",2,SWIGTYPE_p_unsigned_short); }  arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4); arg5 = (ofImageType)(int)lua_tonumber(L, 5); arg6 = (lua_toboolean(L, 6)!=0);
  (arg1)->setFromPixels((unsigned short const *)arg2,arg3,arg4,arg5,arg6); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_ShortImage_setFromPixels__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned short > *arg1 = (ofImage_< unsigned short > *) 0 ; unsigned short *arg2 = (unsigned short *) 0 ; int arg3 ;
  int arg4 ; ofImageType arg5 ; SWIG_check_num_args("ofImage_< unsigned short >::setFromPixels",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned short >::setFromPixels",1,"ofImage_< unsigned short > *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofImage_< unsigned short >::setFromPixels",2,"unsigned short const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofImage_< unsigned short >::setFromPixels",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofImage_< unsigned short >::setFromPixels",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofImage_< unsigned short >::setFromPixels",5,"ofImageType");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortImage_setFromPixels",1,SWIGTYPE_p_ofImage_T_unsigned_short_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_unsigned_short,0))){
    SWIG_fail_ptr("ShortImage_setFromPixels",2,SWIGTYPE_p_unsigned_short); }  arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4); arg5 = (ofImageType)(int)lua_tonumber(L, 5);
  (arg1)->setFromPixels((unsigned short const *)arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_ShortImage_setFromPixels__SWIG_2(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned short > *arg1 = (ofImage_< unsigned short > *) 0 ; ofPixels_< unsigned short > *arg2 = 0 ;
  SWIG_check_num_args("ofImage_< unsigned short >::setFromPixels",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned short >::setFromPixels",1,"ofImage_< unsigned short > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofImage_< unsigned short >::setFromPixels",2,"ofPixels_< unsigned short > const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortImage_setFromPixels",1,SWIGTYPE_p_ofImage_T_unsigned_short_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofPixels_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortImage_setFromPixels",2,SWIGTYPE_p_ofPixels_T_unsigned_short_t); } 
  (arg1)->setFromPixels((ofPixels_< unsigned short > const &)*arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_ShortImage_setFromPixels(lua_State* L) { int argc; int argv[7]={ 1,2,3,4,5,6,7} ; argc = lua_gettop(L);
  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_short_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofPixels_T_unsigned_short_t, 0)) {
          _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_ShortImage_setFromPixels__SWIG_2(L);}  }  }  if (argc == 5) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_short_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_unsigned_short, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); } 
          if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) { return _wrap_ShortImage_setFromPixels__SWIG_1(L);}  }  }  }  }
     }  if (argc == 6) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_short_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_unsigned_short, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); } 
          if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) { { _v = lua_isboolean(L,argv[5]); }  if (_v) {
                return _wrap_ShortImage_setFromPixels__SWIG_0(L);}  }  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'ShortImage_setFromPixels'\n"
  "  Possible C/C++ prototypes are:\n"
  "    ofImage_< unsigned short >::setFromPixels(unsigned short const *,int,int,ofImageType,bool)\n"
  "    ofImage_< unsigned short >::setFromPixels(unsigned short const *,int,int,ofImageType)\n"
  "    ofImage_< unsigned short >::setFromPixels(ofPixels_< unsigned short > const &)\n"); lua_error(L);return 0; }
static int _wrap_ShortImage_grabScreen(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned short > *arg1 = (ofImage_< unsigned short > *) 0 ; int arg2 ; int arg3 ; int arg4 ; int arg5 ;
  SWIG_check_num_args("ofImage_< unsigned short >::grabScreen",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned short >::grabScreen",1,"ofImage_< unsigned short > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofImage_< unsigned short >::grabScreen",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofImage_< unsigned short >::grabScreen",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofImage_< unsigned short >::grabScreen",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofImage_< unsigned short >::grabScreen",5,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortImage_grabScreen",1,SWIGTYPE_p_ofImage_T_unsigned_short_t); }  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3); arg4 = (int)lua_tonumber(L, 4); arg5 = (int)lua_tonumber(L, 5);
  (arg1)->grabScreen(arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortImage_setImageType(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned short > *arg1 = (ofImage_< unsigned short > *) 0 ; ofImageType arg2 ;
  SWIG_check_num_args("ofImage_< unsigned short >::setImageType",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned short >::setImageType",1,"ofImage_< unsigned short > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofImage_< unsigned short >::setImageType",2,"ofImageType");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortImage_setImageType",1,SWIGTYPE_p_ofImage_T_unsigned_short_t); } 
  arg2 = (ofImageType)(int)lua_tonumber(L, 2); (arg1)->setImageType(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_ShortImage_getImageType(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned short > *arg1 = (ofImage_< unsigned short > *) 0 ; ofImageType result;
  SWIG_check_num_args("ofImage_< unsigned short >::getImageType",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned short >::getImageType",1,"ofImage_< unsigned short > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortImage_getImageType",1,SWIGTYPE_p_ofImage_T_unsigned_short_t); } 
  result = (ofImageType)((ofImage_< unsigned short > const *)arg1)->getImageType();
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_ShortImage_resize(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned short > *arg1 = (ofImage_< unsigned short > *) 0 ; int arg2 ; int arg3 ;
  SWIG_check_num_args("ofImage_< unsigned short >::resize",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned short >::resize",1,"ofImage_< unsigned short > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofImage_< unsigned short >::resize",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofImage_< unsigned short >::resize",3,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortImage_resize",1,SWIGTYPE_p_ofImage_T_unsigned_short_t); }  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3); (arg1)->resize(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_ShortImage_crop(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned short > *arg1 = (ofImage_< unsigned short > *) 0 ; int arg2 ; int arg3 ; int arg4 ; int arg5 ;
  SWIG_check_num_args("ofImage_< unsigned short >::crop",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned short >::crop",1,"ofImage_< unsigned short > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofImage_< unsigned short >::crop",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofImage_< unsigned short >::crop",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofImage_< unsigned short >::crop",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofImage_< unsigned short >::crop",5,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortImage_crop",1,SWIGTYPE_p_ofImage_T_unsigned_short_t); }  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3); arg4 = (int)lua_tonumber(L, 4); arg5 = (int)lua_tonumber(L, 5);
  (arg1)->crop(arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortImage_cropFrom(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned short > *arg1 = (ofImage_< unsigned short > *) 0 ; ofImage_< unsigned short > *arg2 = 0 ; int arg3 ;
  int arg4 ; int arg5 ; int arg6 ; SWIG_check_num_args("ofImage_< unsigned short >::cropFrom",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned short >::cropFrom",1,"ofImage_< unsigned short > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofImage_< unsigned short >::cropFrom",2,"ofImage_< unsigned short > const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofImage_< unsigned short >::cropFrom",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofImage_< unsigned short >::cropFrom",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofImage_< unsigned short >::cropFrom",5,"int");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofImage_< unsigned short >::cropFrom",6,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortImage_cropFrom",1,SWIGTYPE_p_ofImage_T_unsigned_short_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofImage_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortImage_cropFrom",2,SWIGTYPE_p_ofImage_T_unsigned_short_t); }  arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4); arg5 = (int)lua_tonumber(L, 5); arg6 = (int)lua_tonumber(L, 6);
  (arg1)->cropFrom((ofImage_< unsigned short > const &)*arg2,arg3,arg4,arg5,arg6); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortImage_rotate90(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned short > *arg1 = (ofImage_< unsigned short > *) 0 ; int arg2 ;
  SWIG_check_num_args("ofImage_< unsigned short >::rotate90",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned short >::rotate90",1,"ofImage_< unsigned short > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofImage_< unsigned short >::rotate90",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortImage_rotate90",1,SWIGTYPE_p_ofImage_T_unsigned_short_t); }  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->rotate90(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortImage_mirror(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned short > *arg1 = (ofImage_< unsigned short > *) 0 ; bool arg2 ; bool arg3 ;
  SWIG_check_num_args("ofImage_< unsigned short >::mirror",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned short >::mirror",1,"ofImage_< unsigned short > *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofImage_< unsigned short >::mirror",2,"bool");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("ofImage_< unsigned short >::mirror",3,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortImage_mirror",1,SWIGTYPE_p_ofImage_T_unsigned_short_t); }  arg2 = (lua_toboolean(L, 2)!=0);
  arg3 = (lua_toboolean(L, 3)!=0); (arg1)->mirror(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_ShortImage_setAnchorPercent(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned short > *arg1 = (ofImage_< unsigned short > *) 0 ; float arg2 ; float arg3 ;
  SWIG_check_num_args("ofImage_< unsigned short >::setAnchorPercent",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned short >::setAnchorPercent",1,"ofImage_< unsigned short > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofImage_< unsigned short >::setAnchorPercent",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofImage_< unsigned short >::setAnchorPercent",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortImage_setAnchorPercent",1,SWIGTYPE_p_ofImage_T_unsigned_short_t); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); (arg1)->setAnchorPercent(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_ShortImage_setAnchorPoint(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned short > *arg1 = (ofImage_< unsigned short > *) 0 ; float arg2 ; float arg3 ;
  SWIG_check_num_args("ofImage_< unsigned short >::setAnchorPoint",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned short >::setAnchorPoint",1,"ofImage_< unsigned short > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofImage_< unsigned short >::setAnchorPoint",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofImage_< unsigned short >::setAnchorPoint",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortImage_setAnchorPoint",1,SWIGTYPE_p_ofImage_T_unsigned_short_t); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); (arg1)->setAnchorPoint(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_ShortImage_resetAnchor(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned short > *arg1 = (ofImage_< unsigned short > *) 0 ;
  SWIG_check_num_args("ofImage_< unsigned short >::resetAnchor",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned short >::resetAnchor",1,"ofImage_< unsigned short > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortImage_resetAnchor",1,SWIGTYPE_p_ofImage_T_unsigned_short_t); }  (arg1)->resetAnchor(); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortImage_save__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned short > *arg1 = (ofImage_< unsigned short > *) 0 ; std::filesystem::path *arg2 = 0 ;
  ofImageQualityType arg3 ; std::filesystem::path temp2 ; bool result;
  SWIG_check_num_args("ofImage_< unsigned short >::save",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned short >::save",1,"ofImage_< unsigned short > const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofImage_< unsigned short >::save",2,"std::filesystem::path const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofImage_< unsigned short >::save",3,"ofImageQualityType");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortImage_save",1,SWIGTYPE_p_ofImage_T_unsigned_short_t); }  { size_t len = lua_rawlen(L, 2);
    temp2 = lua_tolstring(L, 2, &len); arg2 = &temp2; }  arg3 = (ofImageQualityType)(int)lua_tonumber(L, 3);
  result = (bool)((ofImage_< unsigned short > const *)arg1)->save((std::filesystem::path const &)*arg2,arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortImage_save__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned short > *arg1 = (ofImage_< unsigned short > *) 0 ; std::filesystem::path *arg2 = 0 ;
  std::filesystem::path temp2 ; bool result; SWIG_check_num_args("ofImage_< unsigned short >::save",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned short >::save",1,"ofImage_< unsigned short > const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofImage_< unsigned short >::save",2,"std::filesystem::path const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortImage_save",1,SWIGTYPE_p_ofImage_T_unsigned_short_t); }  { size_t len = lua_rawlen(L, 2);
    temp2 = lua_tolstring(L, 2, &len); arg2 = &temp2; } 
  result = (bool)((ofImage_< unsigned short > const *)arg1)->save((std::filesystem::path const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortImage_save__SWIG_2(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned short > *arg1 = (ofImage_< unsigned short > *) 0 ; ofBuffer *arg2 = 0 ; ofImageFormat arg3 ;
  ofImageQualityType arg4 ; bool result; SWIG_check_num_args("ofImage_< unsigned short >::save",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned short >::save",1,"ofImage_< unsigned short > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofImage_< unsigned short >::save",2,"ofBuffer &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofImage_< unsigned short >::save",3,"ofImageFormat");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofImage_< unsigned short >::save",4,"ofImageQualityType");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortImage_save",1,SWIGTYPE_p_ofImage_T_unsigned_short_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofBuffer,0))){
    SWIG_fail_ptr("ShortImage_save",2,SWIGTYPE_p_ofBuffer); }  arg3 = (ofImageFormat)(int)lua_tonumber(L, 3);
  arg4 = (ofImageQualityType)(int)lua_tonumber(L, 4);
  result = (bool)((ofImage_< unsigned short > const *)arg1)->save(*arg2,arg3,arg4);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortImage_save__SWIG_3(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned short > *arg1 = (ofImage_< unsigned short > *) 0 ; ofBuffer *arg2 = 0 ; ofImageFormat arg3 ; bool result;
  SWIG_check_num_args("ofImage_< unsigned short >::save",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned short >::save",1,"ofImage_< unsigned short > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofImage_< unsigned short >::save",2,"ofBuffer &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofImage_< unsigned short >::save",3,"ofImageFormat");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortImage_save",1,SWIGTYPE_p_ofImage_T_unsigned_short_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofBuffer,0))){
    SWIG_fail_ptr("ShortImage_save",2,SWIGTYPE_p_ofBuffer); }  arg3 = (ofImageFormat)(int)lua_tonumber(L, 3);
  result = (bool)((ofImage_< unsigned short > const *)arg1)->save(*arg2,arg3); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortImage_save__SWIG_4(lua_State* L) { int SWIG_arg = 0;
  ofImage_< unsigned short > *arg1 = (ofImage_< unsigned short > *) 0 ; ofBuffer *arg2 = 0 ; bool result;
  SWIG_check_num_args("ofImage_< unsigned short >::save",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofImage_< unsigned short >::save",1,"ofImage_< unsigned short > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofImage_< unsigned short >::save",2,"ofBuffer &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofImage_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortImage_save",1,SWIGTYPE_p_ofImage_T_unsigned_short_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofBuffer,0))){
    SWIG_fail_ptr("ShortImage_save",2,SWIGTYPE_p_ofBuffer); } 
  result = (bool)((ofImage_< unsigned short > const *)arg1)->save(*arg2); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortImage_save(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_short_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofBuffer, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_ShortImage_save__SWIG_4(L);}  }  }  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_short_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L, argv[1]); }  if (_v) {
        return _wrap_ShortImage_save__SWIG_1(L);}  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_short_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofBuffer, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { return _wrap_ShortImage_save__SWIG_3(L);}  }
       }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_short_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L, argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { return _wrap_ShortImage_save__SWIG_0(L);}  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofImage_T_unsigned_short_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofBuffer, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); } 
          if (_v) { return _wrap_ShortImage_save__SWIG_2(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'ShortImage_save'\n" "  Possible C/C++ prototypes are:\n"
  "    ofImage_< unsigned short >::save(std::filesystem::path const &,ofImageQualityType) const\n"
  "    ofImage_< unsigned short >::save(std::filesystem::path const &) const\n"
  "    ofImage_< unsigned short >::save(ofBuffer &,ofImageFormat,ofImageQualityType) const\n"
  "    ofImage_< unsigned short >::save(ofBuffer &,ofImageFormat) const\n"
  "    ofImage_< unsigned short >::save(ofBuffer &) const\n"); lua_error(L);return 0; }
static void swig_delete_ShortImage(void *obj) {
ofImage_< unsigned short > *arg1 = (ofImage_< unsigned short > *) obj;
delete arg1;
}
static int _proxy__wrap_new_ShortImage(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_ShortImage);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_ShortImage_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_ShortImage_methods[]= {
    { "allocate", _wrap_ShortImage_allocate},
    { "isAllocated", _wrap_ShortImage_isAllocated},
    { "clear", _wrap_ShortImage_clear},
    { "load", _wrap_ShortImage_load},
    { "draw", _wrap_ShortImage_draw},
    { "drawSubsection", _wrap_ShortImage_drawSubsection},
    { "update", _wrap_ShortImage_update},
    { "setUseTexture", _wrap_ShortImage_setUseTexture},
    { "isUsingTexture", _wrap_ShortImage_isUsingTexture},
    { "getTexture", _wrap_ShortImage_getTexture},
    { "bind", _wrap_ShortImage_bind},
    { "unbind", _wrap_ShortImage_unbind},
    { "setCompression", _wrap_ShortImage_setCompression},
    { "getPixels", _wrap_ShortImage_getPixels},
    { "getColor", _wrap_ShortImage_getColor},
    { "getHeight", _wrap_ShortImage_getHeight},
    { "getWidth", _wrap_ShortImage_getWidth},
    { "setColor", _wrap_ShortImage_setColor},
    { "setFromPixels", _wrap_ShortImage_setFromPixels},
    { "grabScreen", _wrap_ShortImage_grabScreen},
    { "setImageType", _wrap_ShortImage_setImageType},
    { "getImageType", _wrap_ShortImage_getImageType},
    { "resize", _wrap_ShortImage_resize},
    { "crop", _wrap_ShortImage_crop},
    { "cropFrom", _wrap_ShortImage_cropFrom},
    { "rotate90", _wrap_ShortImage_rotate90},
    { "mirror", _wrap_ShortImage_mirror},
    { "setAnchorPercent", _wrap_ShortImage_setAnchorPercent},
    { "setAnchorPoint", _wrap_ShortImage_setAnchorPoint},
    { "resetAnchor", _wrap_ShortImage_resetAnchor},
    { "save", _wrap_ShortImage_save},
    {0,0}
};
static swig_lua_method swig_ShortImage_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_ShortImage_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_ShortImage_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_ShortImage_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_ShortImage_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_ShortImage_Sf_SwigStatic = {
    "ShortImage",
    swig_ShortImage_Sf_SwigStatic_methods,
    swig_ShortImage_Sf_SwigStatic_attributes,
    swig_ShortImage_Sf_SwigStatic_constants,
    swig_ShortImage_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_ShortImage_bases[] = {0};
static const char *swig_ShortImage_base_names[] = {0};
static swig_lua_class _wrap_class_ShortImage = { "ShortImage", "ShortImage", &SWIGTYPE_p_ofImage_T_unsigned_short_t,_proxy__wrap_new_ShortImage, swig_delete_ShortImage, swig_ShortImage_methods, swig_ShortImage_attributes, &swig_ShortImage_Sf_SwigStatic, swig_ShortImage_meta, swig_ShortImage_bases, swig_ShortImage_base_names };

static int _wrap_new_Style(lua_State* L) { int SWIG_arg = 0; ofStyle *result = 0 ; SWIG_check_num_args("ofStyle::ofStyle",0,0)
  result = (ofStyle *)new ofStyle(); SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofStyle,1); SWIG_arg++;  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Style_color_set(lua_State* L) { int SWIG_arg = 0; ofStyle *arg1 = (ofStyle *) 0 ;
  ofColor *arg2 = (ofColor *) 0 ; SWIG_check_num_args("ofStyle::color",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofStyle::color",1,"ofStyle *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofStyle::color",2,"ofColor *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofStyle,0))){
    SWIG_fail_ptr("Style_color_set",1,SWIGTYPE_p_ofStyle); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Style_color_set",2,SWIGTYPE_p_ofColor_T_unsigned_char_t); }  if (arg1) (arg1)->color = *arg2;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Style_color_get(lua_State* L) { int SWIG_arg = 0; ofStyle *arg1 = (ofStyle *) 0 ; ofColor *result = 0 ;
  SWIG_check_num_args("ofStyle::color",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofStyle::color",1,"ofStyle *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofStyle,0))){
    SWIG_fail_ptr("Style_color_get",1,SWIGTYPE_p_ofStyle); }  result = (ofColor *)& ((arg1)->color);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Style_bgColor_set(lua_State* L) { int SWIG_arg = 0; ofStyle *arg1 = (ofStyle *) 0 ;
  ofColor *arg2 = (ofColor *) 0 ; SWIG_check_num_args("ofStyle::bgColor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofStyle::bgColor",1,"ofStyle *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofStyle::bgColor",2,"ofColor *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofStyle,0))){
    SWIG_fail_ptr("Style_bgColor_set",1,SWIGTYPE_p_ofStyle); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Style_bgColor_set",2,SWIGTYPE_p_ofColor_T_unsigned_char_t); }  if (arg1) (arg1)->bgColor = *arg2;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Style_bgColor_get(lua_State* L) { int SWIG_arg = 0; ofStyle *arg1 = (ofStyle *) 0 ; ofColor *result = 0 ;
  SWIG_check_num_args("ofStyle::bgColor",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofStyle::bgColor",1,"ofStyle *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofStyle,0))){
    SWIG_fail_ptr("Style_bgColor_get",1,SWIGTYPE_p_ofStyle); }  result = (ofColor *)& ((arg1)->bgColor);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Style_polyMode_set(lua_State* L) { int SWIG_arg = 0; ofStyle *arg1 = (ofStyle *) 0 ; ofPolyWindingMode arg2 ;
  SWIG_check_num_args("ofStyle::polyMode",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofStyle::polyMode",1,"ofStyle *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofStyle::polyMode",2,"ofPolyWindingMode");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofStyle,0))){
    SWIG_fail_ptr("Style_polyMode_set",1,SWIGTYPE_p_ofStyle); }  arg2 = (ofPolyWindingMode)(int)lua_tonumber(L, 2);
  if (arg1) (arg1)->polyMode = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Style_polyMode_get(lua_State* L) { int SWIG_arg = 0; ofStyle *arg1 = (ofStyle *) 0 ; ofPolyWindingMode result;
  SWIG_check_num_args("ofStyle::polyMode",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofStyle::polyMode",1,"ofStyle *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofStyle,0))){
    SWIG_fail_ptr("Style_polyMode_get",1,SWIGTYPE_p_ofStyle); }  result = (ofPolyWindingMode) ((arg1)->polyMode);
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Style_rectMode_set(lua_State* L) { int SWIG_arg = 0; ofStyle *arg1 = (ofStyle *) 0 ; ofRectMode arg2 ;
  SWIG_check_num_args("ofStyle::rectMode",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofStyle::rectMode",1,"ofStyle *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofStyle::rectMode",2,"ofRectMode");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofStyle,0))){
    SWIG_fail_ptr("Style_rectMode_set",1,SWIGTYPE_p_ofStyle); }  arg2 = (ofRectMode)(int)lua_tonumber(L, 2);
  if (arg1) (arg1)->rectMode = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Style_rectMode_get(lua_State* L) { int SWIG_arg = 0; ofStyle *arg1 = (ofStyle *) 0 ; ofRectMode result;
  SWIG_check_num_args("ofStyle::rectMode",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofStyle::rectMode",1,"ofStyle *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofStyle,0))){
    SWIG_fail_ptr("Style_rectMode_get",1,SWIGTYPE_p_ofStyle); }  result = (ofRectMode) ((arg1)->rectMode);
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Style_bFill_set(lua_State* L) { int SWIG_arg = 0; ofStyle *arg1 = (ofStyle *) 0 ; bool arg2 ;
  SWIG_check_num_args("ofStyle::bFill",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofStyle::bFill",1,"ofStyle *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofStyle::bFill",2,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofStyle,0))){
    SWIG_fail_ptr("Style_bFill_set",1,SWIGTYPE_p_ofStyle); }  arg2 = (lua_toboolean(L, 2)!=0); if (arg1) (arg1)->bFill = arg2;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Style_bFill_get(lua_State* L) { int SWIG_arg = 0; ofStyle *arg1 = (ofStyle *) 0 ; bool result;
  SWIG_check_num_args("ofStyle::bFill",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofStyle::bFill",1,"ofStyle *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofStyle,0))){
    SWIG_fail_ptr("Style_bFill_get",1,SWIGTYPE_p_ofStyle); }  result = (bool) ((arg1)->bFill);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Style_drawBitmapMode_set(lua_State* L) { int SWIG_arg = 0; ofStyle *arg1 = (ofStyle *) 0 ;
  ofDrawBitmapMode arg2 ; SWIG_check_num_args("ofStyle::drawBitmapMode",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofStyle::drawBitmapMode",1,"ofStyle *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofStyle::drawBitmapMode",2,"ofDrawBitmapMode");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofStyle,0))){
    SWIG_fail_ptr("Style_drawBitmapMode_set",1,SWIGTYPE_p_ofStyle); }  arg2 = (ofDrawBitmapMode)(int)lua_tonumber(L, 2);
  if (arg1) (arg1)->drawBitmapMode = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Style_drawBitmapMode_get(lua_State* L) { int SWIG_arg = 0; ofStyle *arg1 = (ofStyle *) 0 ;
  ofDrawBitmapMode result; SWIG_check_num_args("ofStyle::drawBitmapMode",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofStyle::drawBitmapMode",1,"ofStyle *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofStyle,0))){
    SWIG_fail_ptr("Style_drawBitmapMode_get",1,SWIGTYPE_p_ofStyle); }  result = (ofDrawBitmapMode) ((arg1)->drawBitmapMode);
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Style_blendingMode_set(lua_State* L) { int SWIG_arg = 0; ofStyle *arg1 = (ofStyle *) 0 ; ofBlendMode arg2 ;
  SWIG_check_num_args("ofStyle::blendingMode",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofStyle::blendingMode",1,"ofStyle *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofStyle::blendingMode",2,"ofBlendMode");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofStyle,0))){
    SWIG_fail_ptr("Style_blendingMode_set",1,SWIGTYPE_p_ofStyle); }  arg2 = (ofBlendMode)(int)lua_tonumber(L, 2);
  if (arg1) (arg1)->blendingMode = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Style_blendingMode_get(lua_State* L) { int SWIG_arg = 0; ofStyle *arg1 = (ofStyle *) 0 ; ofBlendMode result;
  SWIG_check_num_args("ofStyle::blendingMode",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofStyle::blendingMode",1,"ofStyle *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofStyle,0))){
    SWIG_fail_ptr("Style_blendingMode_get",1,SWIGTYPE_p_ofStyle); }  result = (ofBlendMode) ((arg1)->blendingMode);
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Style_smoothing_set(lua_State* L) { int SWIG_arg = 0; ofStyle *arg1 = (ofStyle *) 0 ; bool arg2 ;
  SWIG_check_num_args("ofStyle::smoothing",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofStyle::smoothing",1,"ofStyle *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofStyle::smoothing",2,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofStyle,0))){
    SWIG_fail_ptr("Style_smoothing_set",1,SWIGTYPE_p_ofStyle); }  arg2 = (lua_toboolean(L, 2)!=0);
  if (arg1) (arg1)->smoothing = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Style_smoothing_get(lua_State* L) { int SWIG_arg = 0; ofStyle *arg1 = (ofStyle *) 0 ; bool result;
  SWIG_check_num_args("ofStyle::smoothing",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofStyle::smoothing",1,"ofStyle *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofStyle,0))){
    SWIG_fail_ptr("Style_smoothing_get",1,SWIGTYPE_p_ofStyle); }  result = (bool) ((arg1)->smoothing);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Style_circleResolution_set(lua_State* L) { int SWIG_arg = 0; ofStyle *arg1 = (ofStyle *) 0 ; int arg2 ;
  SWIG_check_num_args("ofStyle::circleResolution",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofStyle::circleResolution",1,"ofStyle *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofStyle::circleResolution",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofStyle,0))){
    SWIG_fail_ptr("Style_circleResolution_set",1,SWIGTYPE_p_ofStyle); }  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->circleResolution = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Style_circleResolution_get(lua_State* L) { int SWIG_arg = 0; ofStyle *arg1 = (ofStyle *) 0 ; int result;
  SWIG_check_num_args("ofStyle::circleResolution",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofStyle::circleResolution",1,"ofStyle *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofStyle,0))){
    SWIG_fail_ptr("Style_circleResolution_get",1,SWIGTYPE_p_ofStyle); }  result = (int) ((arg1)->circleResolution);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Style_sphereResolution_set(lua_State* L) { int SWIG_arg = 0; ofStyle *arg1 = (ofStyle *) 0 ; int arg2 ;
  SWIG_check_num_args("ofStyle::sphereResolution",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofStyle::sphereResolution",1,"ofStyle *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofStyle::sphereResolution",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofStyle,0))){
    SWIG_fail_ptr("Style_sphereResolution_set",1,SWIGTYPE_p_ofStyle); }  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->sphereResolution = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Style_sphereResolution_get(lua_State* L) { int SWIG_arg = 0; ofStyle *arg1 = (ofStyle *) 0 ; int result;
  SWIG_check_num_args("ofStyle::sphereResolution",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofStyle::sphereResolution",1,"ofStyle *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofStyle,0))){
    SWIG_fail_ptr("Style_sphereResolution_get",1,SWIGTYPE_p_ofStyle); }  result = (int) ((arg1)->sphereResolution);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Style_curveResolution_set(lua_State* L) { int SWIG_arg = 0; ofStyle *arg1 = (ofStyle *) 0 ; int arg2 ;
  SWIG_check_num_args("ofStyle::curveResolution",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofStyle::curveResolution",1,"ofStyle *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofStyle::curveResolution",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofStyle,0))){
    SWIG_fail_ptr("Style_curveResolution_set",1,SWIGTYPE_p_ofStyle); }  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->curveResolution = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Style_curveResolution_get(lua_State* L) { int SWIG_arg = 0; ofStyle *arg1 = (ofStyle *) 0 ; int result;
  SWIG_check_num_args("ofStyle::curveResolution",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofStyle::curveResolution",1,"ofStyle *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofStyle,0))){
    SWIG_fail_ptr("Style_curveResolution_get",1,SWIGTYPE_p_ofStyle); }  result = (int) ((arg1)->curveResolution);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Style_lineWidth_set(lua_State* L) { int SWIG_arg = 0; ofStyle *arg1 = (ofStyle *) 0 ; float arg2 ;
  SWIG_check_num_args("ofStyle::lineWidth",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofStyle::lineWidth",1,"ofStyle *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofStyle::lineWidth",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofStyle,0))){
    SWIG_fail_ptr("Style_lineWidth_set",1,SWIGTYPE_p_ofStyle); }  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->lineWidth = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Style_lineWidth_get(lua_State* L) { int SWIG_arg = 0; ofStyle *arg1 = (ofStyle *) 0 ; float result;
  SWIG_check_num_args("ofStyle::lineWidth",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofStyle::lineWidth",1,"ofStyle *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofStyle,0))){
    SWIG_fail_ptr("Style_lineWidth_get",1,SWIGTYPE_p_ofStyle); }  result = (float) ((arg1)->lineWidth);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static void swig_delete_Style(void *obj) {
ofStyle *arg1 = (ofStyle *) obj;
delete arg1;
}
static int _proxy__wrap_new_Style(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_Style);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_Style_attributes[] = {
    { "color", _wrap_Style_color_get, _wrap_Style_color_set },
    { "bgColor", _wrap_Style_bgColor_get, _wrap_Style_bgColor_set },
    { "polyMode", _wrap_Style_polyMode_get, _wrap_Style_polyMode_set },
    { "rectMode", _wrap_Style_rectMode_get, _wrap_Style_rectMode_set },
    { "bFill", _wrap_Style_bFill_get, _wrap_Style_bFill_set },
    { "drawBitmapMode", _wrap_Style_drawBitmapMode_get, _wrap_Style_drawBitmapMode_set },
    { "blendingMode", _wrap_Style_blendingMode_get, _wrap_Style_blendingMode_set },
    { "smoothing", _wrap_Style_smoothing_get, _wrap_Style_smoothing_set },
    { "circleResolution", _wrap_Style_circleResolution_get, _wrap_Style_circleResolution_set },
    { "sphereResolution", _wrap_Style_sphereResolution_get, _wrap_Style_sphereResolution_set },
    { "curveResolution", _wrap_Style_curveResolution_get, _wrap_Style_curveResolution_set },
    { "lineWidth", _wrap_Style_lineWidth_get, _wrap_Style_lineWidth_set },
    {0,0,0}
};
static swig_lua_method swig_Style_methods[]= {
    {0,0}
};
static swig_lua_method swig_Style_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_Style_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_Style_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_Style_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_Style_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_Style_Sf_SwigStatic = {
    "Style",
    swig_Style_Sf_SwigStatic_methods,
    swig_Style_Sf_SwigStatic_attributes,
    swig_Style_Sf_SwigStatic_constants,
    swig_Style_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_Style_bases[] = {0};
static const char *swig_Style_base_names[] = {0};
static swig_lua_class _wrap_class_Style = { "Style", "Style", &SWIGTYPE_p_ofStyle,_proxy__wrap_new_Style, swig_delete_Style, swig_Style_methods, swig_Style_attributes, &swig_Style_Sf_SwigStatic, swig_Style_meta, swig_Style_bases, swig_Style_base_names };

static int _wrap_SoundDevice_api_set(lua_State* L) { int SWIG_arg = 0; ofSoundDevice *arg1 = (ofSoundDevice *) 0 ;
  enum ofSoundDevice::Api arg2 ; SWIG_check_num_args("ofSoundDevice::api",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSoundDevice::api",1,"ofSoundDevice *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofSoundDevice::api",2,"enum ofSoundDevice::Api");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSoundDevice,0))){
    SWIG_fail_ptr("SoundDevice_api_set",1,SWIGTYPE_p_ofSoundDevice); }  arg2 = (enum ofSoundDevice::Api)(int)lua_tonumber(L, 2);
  if (arg1) (arg1)->api = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_SoundDevice_api_get(lua_State* L) { int SWIG_arg = 0; ofSoundDevice *arg1 = (ofSoundDevice *) 0 ;
  enum ofSoundDevice::Api result; SWIG_check_num_args("ofSoundDevice::api",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSoundDevice::api",1,"ofSoundDevice *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSoundDevice,0))){
    SWIG_fail_ptr("SoundDevice_api_get",1,SWIGTYPE_p_ofSoundDevice); }  result = (enum ofSoundDevice::Api) ((arg1)->api);
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_SoundDevice_name_set(lua_State* L) { int SWIG_arg = 0; ofSoundDevice *arg1 = (ofSoundDevice *) 0 ;
  std::string *arg2 = 0 ; std::string temp2 ; SWIG_check_num_args("ofSoundDevice::name",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSoundDevice::name",1,"ofSoundDevice *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofSoundDevice::name",2,"std::string const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSoundDevice,0))){
    SWIG_fail_ptr("SoundDevice_name_set",1,SWIGTYPE_p_ofSoundDevice); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2; if (arg1) (arg1)->name = *arg2; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_SoundDevice_name_get(lua_State* L) { int SWIG_arg = 0; ofSoundDevice *arg1 = (ofSoundDevice *) 0 ;
  std::string *result = 0 ; SWIG_check_num_args("ofSoundDevice::name",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSoundDevice::name",1,"ofSoundDevice *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSoundDevice,0))){
    SWIG_fail_ptr("SoundDevice_name_get",1,SWIGTYPE_p_ofSoundDevice); }  result = (std::string *) & ((arg1)->name);
  lua_pushlstring(L,result->data(),result->size()); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_SoundDevice_deviceID_set(lua_State* L) { int SWIG_arg = 0; ofSoundDevice *arg1 = (ofSoundDevice *) 0 ;
  int arg2 ; SWIG_check_num_args("ofSoundDevice::deviceID",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSoundDevice::deviceID",1,"ofSoundDevice *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofSoundDevice::deviceID",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSoundDevice,0))){
    SWIG_fail_ptr("SoundDevice_deviceID_set",1,SWIGTYPE_p_ofSoundDevice); }  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->deviceID = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_SoundDevice_deviceID_get(lua_State* L) { int SWIG_arg = 0; ofSoundDevice *arg1 = (ofSoundDevice *) 0 ;
  int result; SWIG_check_num_args("ofSoundDevice::deviceID",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSoundDevice::deviceID",1,"ofSoundDevice *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSoundDevice,0))){
    SWIG_fail_ptr("SoundDevice_deviceID_get",1,SWIGTYPE_p_ofSoundDevice); }  result = (int) ((arg1)->deviceID);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_SoundDevice_inputChannels_set(lua_State* L) { int SWIG_arg = 0; ofSoundDevice *arg1 = (ofSoundDevice *) 0 ;
  unsigned int arg2 ; SWIG_check_num_args("ofSoundDevice::inputChannels",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSoundDevice::inputChannels",1,"ofSoundDevice *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofSoundDevice::inputChannels",2,"unsigned int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSoundDevice,0))){
    SWIG_fail_ptr("SoundDevice_inputChannels_set",1,SWIGTYPE_p_ofSoundDevice); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->inputChannels = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_SoundDevice_inputChannels_get(lua_State* L) { int SWIG_arg = 0; ofSoundDevice *arg1 = (ofSoundDevice *) 0 ;
  unsigned int result; SWIG_check_num_args("ofSoundDevice::inputChannels",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSoundDevice::inputChannels",1,"ofSoundDevice *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSoundDevice,0))){
    SWIG_fail_ptr("SoundDevice_inputChannels_get",1,SWIGTYPE_p_ofSoundDevice); } 
  result = (unsigned int) ((arg1)->inputChannels); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_SoundDevice_outputChannels_set(lua_State* L) { int SWIG_arg = 0; ofSoundDevice *arg1 = (ofSoundDevice *) 0 ;
  unsigned int arg2 ; SWIG_check_num_args("ofSoundDevice::outputChannels",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSoundDevice::outputChannels",1,"ofSoundDevice *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofSoundDevice::outputChannels",2,"unsigned int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSoundDevice,0))){
    SWIG_fail_ptr("SoundDevice_outputChannels_set",1,SWIGTYPE_p_ofSoundDevice); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->outputChannels = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_SoundDevice_outputChannels_get(lua_State* L) { int SWIG_arg = 0; ofSoundDevice *arg1 = (ofSoundDevice *) 0 ;
  unsigned int result; SWIG_check_num_args("ofSoundDevice::outputChannels",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSoundDevice::outputChannels",1,"ofSoundDevice *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSoundDevice,0))){
    SWIG_fail_ptr("SoundDevice_outputChannels_get",1,SWIGTYPE_p_ofSoundDevice); } 
  result = (unsigned int) ((arg1)->outputChannels); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_SoundDevice_isDefaultInput_set(lua_State* L) { int SWIG_arg = 0; ofSoundDevice *arg1 = (ofSoundDevice *) 0 ;
  bool arg2 ; SWIG_check_num_args("ofSoundDevice::isDefaultInput",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSoundDevice::isDefaultInput",1,"ofSoundDevice *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofSoundDevice::isDefaultInput",2,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSoundDevice,0))){
    SWIG_fail_ptr("SoundDevice_isDefaultInput_set",1,SWIGTYPE_p_ofSoundDevice); }  arg2 = (lua_toboolean(L, 2)!=0);
  if (arg1) (arg1)->isDefaultInput = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_SoundDevice_isDefaultInput_get(lua_State* L) { int SWIG_arg = 0; ofSoundDevice *arg1 = (ofSoundDevice *) 0 ;
  bool result; SWIG_check_num_args("ofSoundDevice::isDefaultInput",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSoundDevice::isDefaultInput",1,"ofSoundDevice *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSoundDevice,0))){
    SWIG_fail_ptr("SoundDevice_isDefaultInput_get",1,SWIGTYPE_p_ofSoundDevice); }  result = (bool) ((arg1)->isDefaultInput);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_SoundDevice_isDefaultOutput_set(lua_State* L) { int SWIG_arg = 0; ofSoundDevice *arg1 = (ofSoundDevice *) 0 ;
  bool arg2 ; SWIG_check_num_args("ofSoundDevice::isDefaultOutput",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSoundDevice::isDefaultOutput",1,"ofSoundDevice *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofSoundDevice::isDefaultOutput",2,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSoundDevice,0))){
    SWIG_fail_ptr("SoundDevice_isDefaultOutput_set",1,SWIGTYPE_p_ofSoundDevice); }  arg2 = (lua_toboolean(L, 2)!=0);
  if (arg1) (arg1)->isDefaultOutput = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_SoundDevice_isDefaultOutput_get(lua_State* L) { int SWIG_arg = 0; ofSoundDevice *arg1 = (ofSoundDevice *) 0 ;
  bool result; SWIG_check_num_args("ofSoundDevice::isDefaultOutput",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSoundDevice::isDefaultOutput",1,"ofSoundDevice *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSoundDevice,0))){
    SWIG_fail_ptr("SoundDevice_isDefaultOutput_get",1,SWIGTYPE_p_ofSoundDevice); }  result = (bool) ((arg1)->isDefaultOutput);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_SoundDevice_sampleRates_set(lua_State* L) { int SWIG_arg = 0; ofSoundDevice *arg1 = (ofSoundDevice *) 0 ;
  std::vector< unsigned int > *arg2 = (std::vector< unsigned int > *) 0 ; SWIG_check_num_args("ofSoundDevice::sampleRates",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSoundDevice::sampleRates",1,"ofSoundDevice *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofSoundDevice::sampleRates",2,"std::vector< unsigned int > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSoundDevice,0))){
    SWIG_fail_ptr("SoundDevice_sampleRates_set",1,SWIGTYPE_p_ofSoundDevice); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_std__vectorT_unsigned_int_t,0))){
    SWIG_fail_ptr("SoundDevice_sampleRates_set",2,SWIGTYPE_p_std__vectorT_unsigned_int_t); } 
  if (arg1) (arg1)->sampleRates = *arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_SoundDevice_sampleRates_get(lua_State* L) { int SWIG_arg = 0; ofSoundDevice *arg1 = (ofSoundDevice *) 0 ;
  std::vector< unsigned int > *result = 0 ; SWIG_check_num_args("ofSoundDevice::sampleRates",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSoundDevice::sampleRates",1,"ofSoundDevice *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSoundDevice,0))){
    SWIG_fail_ptr("SoundDevice_sampleRates_get",1,SWIGTYPE_p_ofSoundDevice); } 
  result = (std::vector< unsigned int > *)& ((arg1)->sampleRates);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorT_unsigned_int_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_SoundDevice(lua_State* L) { int SWIG_arg = 0; ofSoundDevice *result = 0 ;
  SWIG_check_num_args("ofSoundDevice::ofSoundDevice",0,0) result = (ofSoundDevice *)new ofSoundDevice();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofSoundDevice,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static void swig_delete_SoundDevice(void *obj) {
ofSoundDevice *arg1 = (ofSoundDevice *) obj;
delete arg1;
}
static int _proxy__wrap_new_SoundDevice(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_SoundDevice);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_SoundDevice_attributes[] = {
    { "api", _wrap_SoundDevice_api_get, _wrap_SoundDevice_api_set },
    { "name", _wrap_SoundDevice_name_get, _wrap_SoundDevice_name_set },
    { "deviceID", _wrap_SoundDevice_deviceID_get, _wrap_SoundDevice_deviceID_set },
    { "inputChannels", _wrap_SoundDevice_inputChannels_get, _wrap_SoundDevice_inputChannels_set },
    { "outputChannels", _wrap_SoundDevice_outputChannels_get, _wrap_SoundDevice_outputChannels_set },
    { "isDefaultInput", _wrap_SoundDevice_isDefaultInput_get, _wrap_SoundDevice_isDefaultInput_set },
    { "isDefaultOutput", _wrap_SoundDevice_isDefaultOutput_get, _wrap_SoundDevice_isDefaultOutput_set },
    { "sampleRates", _wrap_SoundDevice_sampleRates_get, _wrap_SoundDevice_sampleRates_set },
    {0,0,0}
};
static swig_lua_method swig_SoundDevice_methods[]= {
    {0,0}
};
static swig_lua_method swig_SoundDevice_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_SoundDevice_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_SoundDevice_Sf_SwigStatic_constants[]= {
    {SWIG_LUA_CONSTTAB_INT("UNSPECIFIED", ofSoundDevice::UNSPECIFIED)},
    {SWIG_LUA_CONSTTAB_INT("DEFAULT", ofSoundDevice::DEFAULT)},
    {SWIG_LUA_CONSTTAB_INT("ALSA", ofSoundDevice::ALSA)},
    {SWIG_LUA_CONSTTAB_INT("PULSE", ofSoundDevice::PULSE)},
    {SWIG_LUA_CONSTTAB_INT("OSS", ofSoundDevice::OSS)},
    {SWIG_LUA_CONSTTAB_INT("JACK", ofSoundDevice::JACK)},
    {SWIG_LUA_CONSTTAB_INT("OSX_CORE", ofSoundDevice::OSX_CORE)},
    {SWIG_LUA_CONSTTAB_INT("MS_WASAPI", ofSoundDevice::MS_WASAPI)},
    {SWIG_LUA_CONSTTAB_INT("MS_ASIO", ofSoundDevice::MS_ASIO)},
    {SWIG_LUA_CONSTTAB_INT("MS_DS", ofSoundDevice::MS_DS)},
    {SWIG_LUA_CONSTTAB_INT("NUM_APIS", ofSoundDevice::NUM_APIS)},
    {0,0,0,0,0,0}
};
static swig_lua_method swig_SoundDevice_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_SoundDevice_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_SoundDevice_Sf_SwigStatic = {
    "SoundDevice",
    swig_SoundDevice_Sf_SwigStatic_methods,
    swig_SoundDevice_Sf_SwigStatic_attributes,
    swig_SoundDevice_Sf_SwigStatic_constants,
    swig_SoundDevice_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_SoundDevice_bases[] = {0};
static const char *swig_SoundDevice_base_names[] = {0};
static swig_lua_class _wrap_class_SoundDevice = { "SoundDevice", "SoundDevice", &SWIGTYPE_p_ofSoundDevice,_proxy__wrap_new_SoundDevice, swig_delete_SoundDevice, swig_SoundDevice_methods, swig_SoundDevice_attributes, &swig_SoundDevice_Sf_SwigStatic, swig_SoundDevice_meta, swig_SoundDevice_bases, swig_SoundDevice_base_names };

static int _wrap_SoundStreamSettings_sampleRate_set(lua_State* L) { int SWIG_arg = 0;
  ofSoundStreamSettings *arg1 = (ofSoundStreamSettings *) 0 ; size_t arg2 ;
  SWIG_check_num_args("ofSoundStreamSettings::sampleRate",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSoundStreamSettings::sampleRate",1,"ofSoundStreamSettings *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofSoundStreamSettings::sampleRate",2,"size_t");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSoundStreamSettings,0))){
    SWIG_fail_ptr("SoundStreamSettings_sampleRate_set",1,SWIGTYPE_p_ofSoundStreamSettings); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (size_t)lua_tonumber(L, 2);
  if (arg1) (arg1)->sampleRate = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_SoundStreamSettings_sampleRate_get(lua_State* L) { int SWIG_arg = 0;
  ofSoundStreamSettings *arg1 = (ofSoundStreamSettings *) 0 ; size_t result;
  SWIG_check_num_args("ofSoundStreamSettings::sampleRate",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSoundStreamSettings::sampleRate",1,"ofSoundStreamSettings *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSoundStreamSettings,0))){
    SWIG_fail_ptr("SoundStreamSettings_sampleRate_get",1,SWIGTYPE_p_ofSoundStreamSettings); } 
  result = (size_t) ((arg1)->sampleRate); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_SoundStreamSettings_bufferSize_set(lua_State* L) { int SWIG_arg = 0;
  ofSoundStreamSettings *arg1 = (ofSoundStreamSettings *) 0 ; size_t arg2 ;
  SWIG_check_num_args("ofSoundStreamSettings::bufferSize",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSoundStreamSettings::bufferSize",1,"ofSoundStreamSettings *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofSoundStreamSettings::bufferSize",2,"size_t");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSoundStreamSettings,0))){
    SWIG_fail_ptr("SoundStreamSettings_bufferSize_set",1,SWIGTYPE_p_ofSoundStreamSettings); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (size_t)lua_tonumber(L, 2);
  if (arg1) (arg1)->bufferSize = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_SoundStreamSettings_bufferSize_get(lua_State* L) { int SWIG_arg = 0;
  ofSoundStreamSettings *arg1 = (ofSoundStreamSettings *) 0 ; size_t result;
  SWIG_check_num_args("ofSoundStreamSettings::bufferSize",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSoundStreamSettings::bufferSize",1,"ofSoundStreamSettings *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSoundStreamSettings,0))){
    SWIG_fail_ptr("SoundStreamSettings_bufferSize_get",1,SWIGTYPE_p_ofSoundStreamSettings); } 
  result = (size_t) ((arg1)->bufferSize); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_SoundStreamSettings_numBuffers_set(lua_State* L) { int SWIG_arg = 0;
  ofSoundStreamSettings *arg1 = (ofSoundStreamSettings *) 0 ; size_t arg2 ;
  SWIG_check_num_args("ofSoundStreamSettings::numBuffers",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSoundStreamSettings::numBuffers",1,"ofSoundStreamSettings *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofSoundStreamSettings::numBuffers",2,"size_t");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSoundStreamSettings,0))){
    SWIG_fail_ptr("SoundStreamSettings_numBuffers_set",1,SWIGTYPE_p_ofSoundStreamSettings); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (size_t)lua_tonumber(L, 2);
  if (arg1) (arg1)->numBuffers = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_SoundStreamSettings_numBuffers_get(lua_State* L) { int SWIG_arg = 0;
  ofSoundStreamSettings *arg1 = (ofSoundStreamSettings *) 0 ; size_t result;
  SWIG_check_num_args("ofSoundStreamSettings::numBuffers",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSoundStreamSettings::numBuffers",1,"ofSoundStreamSettings *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSoundStreamSettings,0))){
    SWIG_fail_ptr("SoundStreamSettings_numBuffers_get",1,SWIGTYPE_p_ofSoundStreamSettings); } 
  result = (size_t) ((arg1)->numBuffers); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_SoundStreamSettings_numInputChannels_set(lua_State* L) { int SWIG_arg = 0;
  ofSoundStreamSettings *arg1 = (ofSoundStreamSettings *) 0 ; size_t arg2 ;
  SWIG_check_num_args("ofSoundStreamSettings::numInputChannels",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSoundStreamSettings::numInputChannels",1,"ofSoundStreamSettings *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofSoundStreamSettings::numInputChannels",2,"size_t");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSoundStreamSettings,0))){
    SWIG_fail_ptr("SoundStreamSettings_numInputChannels_set",1,SWIGTYPE_p_ofSoundStreamSettings); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (size_t)lua_tonumber(L, 2);
  if (arg1) (arg1)->numInputChannels = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_SoundStreamSettings_numInputChannels_get(lua_State* L) { int SWIG_arg = 0;
  ofSoundStreamSettings *arg1 = (ofSoundStreamSettings *) 0 ; size_t result;
  SWIG_check_num_args("ofSoundStreamSettings::numInputChannels",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSoundStreamSettings::numInputChannels",1,"ofSoundStreamSettings *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSoundStreamSettings,0))){
    SWIG_fail_ptr("SoundStreamSettings_numInputChannels_get",1,SWIGTYPE_p_ofSoundStreamSettings); } 
  result = (size_t) ((arg1)->numInputChannels); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_SoundStreamSettings_numOutputChannels_set(lua_State* L) { int SWIG_arg = 0;
  ofSoundStreamSettings *arg1 = (ofSoundStreamSettings *) 0 ; size_t arg2 ;
  SWIG_check_num_args("ofSoundStreamSettings::numOutputChannels",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSoundStreamSettings::numOutputChannels",1,"ofSoundStreamSettings *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofSoundStreamSettings::numOutputChannels",2,"size_t");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSoundStreamSettings,0))){
    SWIG_fail_ptr("SoundStreamSettings_numOutputChannels_set",1,SWIGTYPE_p_ofSoundStreamSettings); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (size_t)lua_tonumber(L, 2);
  if (arg1) (arg1)->numOutputChannels = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_SoundStreamSettings_numOutputChannels_get(lua_State* L) { int SWIG_arg = 0;
  ofSoundStreamSettings *arg1 = (ofSoundStreamSettings *) 0 ; size_t result;
  SWIG_check_num_args("ofSoundStreamSettings::numOutputChannels",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSoundStreamSettings::numOutputChannels",1,"ofSoundStreamSettings *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSoundStreamSettings,0))){
    SWIG_fail_ptr("SoundStreamSettings_numOutputChannels_get",1,SWIGTYPE_p_ofSoundStreamSettings); } 
  result = (size_t) ((arg1)->numOutputChannels); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_SoundStreamSettings_setInDevice(lua_State* L) { int SWIG_arg = 0;
  ofSoundStreamSettings *arg1 = (ofSoundStreamSettings *) 0 ; ofSoundDevice *arg2 = 0 ; bool result;
  SWIG_check_num_args("ofSoundStreamSettings::setInDevice",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSoundStreamSettings::setInDevice",1,"ofSoundStreamSettings *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofSoundStreamSettings::setInDevice",2,"ofSoundDevice const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSoundStreamSettings,0))){
    SWIG_fail_ptr("SoundStreamSettings_setInDevice",1,SWIGTYPE_p_ofSoundStreamSettings); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofSoundDevice,0))){
    SWIG_fail_ptr("SoundStreamSettings_setInDevice",2,SWIGTYPE_p_ofSoundDevice); } 
  result = (bool)(arg1)->setInDevice((ofSoundDevice const &)*arg2); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_SoundStreamSettings_setOutDevice(lua_State* L) { int SWIG_arg = 0;
  ofSoundStreamSettings *arg1 = (ofSoundStreamSettings *) 0 ; ofSoundDevice *arg2 = 0 ; bool result;
  SWIG_check_num_args("ofSoundStreamSettings::setOutDevice",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSoundStreamSettings::setOutDevice",1,"ofSoundStreamSettings *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofSoundStreamSettings::setOutDevice",2,"ofSoundDevice const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSoundStreamSettings,0))){
    SWIG_fail_ptr("SoundStreamSettings_setOutDevice",1,SWIGTYPE_p_ofSoundStreamSettings); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofSoundDevice,0))){
    SWIG_fail_ptr("SoundStreamSettings_setOutDevice",2,SWIGTYPE_p_ofSoundDevice); } 
  result = (bool)(arg1)->setOutDevice((ofSoundDevice const &)*arg2); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_SoundStreamSettings_setApi(lua_State* L) { int SWIG_arg = 0;
  ofSoundStreamSettings *arg1 = (ofSoundStreamSettings *) 0 ; ofSoundDevice::Api arg2 ; bool result;
  SWIG_check_num_args("ofSoundStreamSettings::setApi",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSoundStreamSettings::setApi",1,"ofSoundStreamSettings *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofSoundStreamSettings::setApi",2,"ofSoundDevice::Api");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSoundStreamSettings,0))){
    SWIG_fail_ptr("SoundStreamSettings_setApi",1,SWIGTYPE_p_ofSoundStreamSettings); } 
  arg2 = (ofSoundDevice::Api)(int)lua_tonumber(L, 2); result = (bool)(arg1)->setApi(arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_SoundStreamSettings_getInDevice(lua_State* L) { int SWIG_arg = 0;
  ofSoundStreamSettings *arg1 = (ofSoundStreamSettings *) 0 ; ofSoundDevice *result = 0 ;
  SWIG_check_num_args("ofSoundStreamSettings::getInDevice",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSoundStreamSettings::getInDevice",1,"ofSoundStreamSettings const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSoundStreamSettings,0))){
    SWIG_fail_ptr("SoundStreamSettings_getInDevice",1,SWIGTYPE_p_ofSoundStreamSettings); } 
  result = (ofSoundDevice *)((ofSoundStreamSettings const *)arg1)->getInDevice();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofSoundDevice,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_SoundStreamSettings_getOutDevice(lua_State* L) { int SWIG_arg = 0;
  ofSoundStreamSettings *arg1 = (ofSoundStreamSettings *) 0 ; ofSoundDevice *result = 0 ;
  SWIG_check_num_args("ofSoundStreamSettings::getOutDevice",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSoundStreamSettings::getOutDevice",1,"ofSoundStreamSettings const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSoundStreamSettings,0))){
    SWIG_fail_ptr("SoundStreamSettings_getOutDevice",1,SWIGTYPE_p_ofSoundStreamSettings); } 
  result = (ofSoundDevice *)((ofSoundStreamSettings const *)arg1)->getOutDevice();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofSoundDevice,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_SoundStreamSettings_getApi(lua_State* L) { int SWIG_arg = 0;
  ofSoundStreamSettings *arg1 = (ofSoundStreamSettings *) 0 ; ofSoundDevice::Api result;
  SWIG_check_num_args("ofSoundStreamSettings::getApi",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSoundStreamSettings::getApi",1,"ofSoundStreamSettings const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSoundStreamSettings,0))){
    SWIG_fail_ptr("SoundStreamSettings_getApi",1,SWIGTYPE_p_ofSoundStreamSettings); } 
  result = (ofSoundDevice::Api)((ofSoundStreamSettings const *)arg1)->getApi();
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_SoundStreamSettings_inCallback_set(lua_State* L) { int SWIG_arg = 0;
  ofSoundStreamSettings *arg1 = (ofSoundStreamSettings *) 0 ;
  std::function< void (ofSoundBuffer &) > *arg2 = (std::function< void (ofSoundBuffer &) > *) 0 ;
  SWIG_check_num_args("ofSoundStreamSettings::inCallback",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSoundStreamSettings::inCallback",1,"ofSoundStreamSettings *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofSoundStreamSettings::inCallback",2,"std::function< void (ofSoundBuffer &) > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSoundStreamSettings,0))){
    SWIG_fail_ptr("SoundStreamSettings_inCallback_set",1,SWIGTYPE_p_ofSoundStreamSettings); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_std__functionT_void_fofSoundBuffer_RF_t,0))){
    SWIG_fail_ptr("SoundStreamSettings_inCallback_set",2,SWIGTYPE_p_std__functionT_void_fofSoundBuffer_RF_t); } 
  if (arg1) (arg1)->inCallback = *arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_SoundStreamSettings_inCallback_get(lua_State* L) { int SWIG_arg = 0;
  ofSoundStreamSettings *arg1 = (ofSoundStreamSettings *) 0 ; std::function< void (ofSoundBuffer &) > *result = 0 ;
  SWIG_check_num_args("ofSoundStreamSettings::inCallback",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSoundStreamSettings::inCallback",1,"ofSoundStreamSettings *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSoundStreamSettings,0))){
    SWIG_fail_ptr("SoundStreamSettings_inCallback_get",1,SWIGTYPE_p_ofSoundStreamSettings); } 
  result = (std::function< void (ofSoundBuffer &) > *)& ((arg1)->inCallback);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__functionT_void_fofSoundBuffer_RF_t,0); SWIG_arg++;  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_SoundStreamSettings_outCallback_set(lua_State* L) { int SWIG_arg = 0;
  ofSoundStreamSettings *arg1 = (ofSoundStreamSettings *) 0 ;
  std::function< void (ofSoundBuffer &) > *arg2 = (std::function< void (ofSoundBuffer &) > *) 0 ;
  SWIG_check_num_args("ofSoundStreamSettings::outCallback",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSoundStreamSettings::outCallback",1,"ofSoundStreamSettings *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofSoundStreamSettings::outCallback",2,"std::function< void (ofSoundBuffer &) > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSoundStreamSettings,0))){
    SWIG_fail_ptr("SoundStreamSettings_outCallback_set",1,SWIGTYPE_p_ofSoundStreamSettings); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_std__functionT_void_fofSoundBuffer_RF_t,0))){
    SWIG_fail_ptr("SoundStreamSettings_outCallback_set",2,SWIGTYPE_p_std__functionT_void_fofSoundBuffer_RF_t); } 
  if (arg1) (arg1)->outCallback = *arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_SoundStreamSettings_outCallback_get(lua_State* L) { int SWIG_arg = 0;
  ofSoundStreamSettings *arg1 = (ofSoundStreamSettings *) 0 ; std::function< void (ofSoundBuffer &) > *result = 0 ;
  SWIG_check_num_args("ofSoundStreamSettings::outCallback",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSoundStreamSettings::outCallback",1,"ofSoundStreamSettings *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSoundStreamSettings,0))){
    SWIG_fail_ptr("SoundStreamSettings_outCallback_get",1,SWIGTYPE_p_ofSoundStreamSettings); } 
  result = (std::function< void (ofSoundBuffer &) > *)& ((arg1)->outCallback);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__functionT_void_fofSoundBuffer_RF_t,0); SWIG_arg++;  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_new_SoundStreamSettings(lua_State* L) { int SWIG_arg = 0; ofSoundStreamSettings *result = 0 ;
  SWIG_check_num_args("ofSoundStreamSettings::ofSoundStreamSettings",0,0)
  result = (ofSoundStreamSettings *)new ofSoundStreamSettings();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofSoundStreamSettings,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static void swig_delete_SoundStreamSettings(void *obj) {
ofSoundStreamSettings *arg1 = (ofSoundStreamSettings *) obj;
delete arg1;
}
static int _proxy__wrap_new_SoundStreamSettings(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_SoundStreamSettings);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_SoundStreamSettings_attributes[] = {
    { "sampleRate", _wrap_SoundStreamSettings_sampleRate_get, _wrap_SoundStreamSettings_sampleRate_set },
    { "bufferSize", _wrap_SoundStreamSettings_bufferSize_get, _wrap_SoundStreamSettings_bufferSize_set },
    { "numBuffers", _wrap_SoundStreamSettings_numBuffers_get, _wrap_SoundStreamSettings_numBuffers_set },
    { "numInputChannels", _wrap_SoundStreamSettings_numInputChannels_get, _wrap_SoundStreamSettings_numInputChannels_set },
    { "numOutputChannels", _wrap_SoundStreamSettings_numOutputChannels_get, _wrap_SoundStreamSettings_numOutputChannels_set },
    { "inCallback", _wrap_SoundStreamSettings_inCallback_get, _wrap_SoundStreamSettings_inCallback_set },
    { "outCallback", _wrap_SoundStreamSettings_outCallback_get, _wrap_SoundStreamSettings_outCallback_set },
    {0,0,0}
};
static swig_lua_method swig_SoundStreamSettings_methods[]= {
    { "setInDevice", _wrap_SoundStreamSettings_setInDevice},
    { "setOutDevice", _wrap_SoundStreamSettings_setOutDevice},
    { "setApi", _wrap_SoundStreamSettings_setApi},
    { "getInDevice", _wrap_SoundStreamSettings_getInDevice},
    { "getOutDevice", _wrap_SoundStreamSettings_getOutDevice},
    { "getApi", _wrap_SoundStreamSettings_getApi},
    {0,0}
};
static swig_lua_method swig_SoundStreamSettings_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_SoundStreamSettings_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_SoundStreamSettings_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_SoundStreamSettings_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_SoundStreamSettings_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_SoundStreamSettings_Sf_SwigStatic = {
    "SoundStreamSettings",
    swig_SoundStreamSettings_Sf_SwigStatic_methods,
    swig_SoundStreamSettings_Sf_SwigStatic_attributes,
    swig_SoundStreamSettings_Sf_SwigStatic_constants,
    swig_SoundStreamSettings_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_SoundStreamSettings_bases[] = {0};
static const char *swig_SoundStreamSettings_base_names[] = {0};
static swig_lua_class _wrap_class_SoundStreamSettings = { "SoundStreamSettings", "SoundStreamSettings", &SWIGTYPE_p_ofSoundStreamSettings,_proxy__wrap_new_SoundStreamSettings, swig_delete_SoundStreamSettings, swig_SoundStreamSettings_methods, swig_SoundStreamSettings_attributes, &swig_SoundStreamSettings_Sf_SwigStatic, swig_SoundStreamSettings_meta, swig_SoundStreamSettings_bases, swig_SoundStreamSettings_base_names };

static int _wrap_BaseSoundStream_setup(lua_State* L) { int SWIG_arg = 0; ofBaseSoundStream *arg1 = (ofBaseSoundStream *) 0 ;
  ofSoundStreamSettings *arg2 = 0 ; bool result; SWIG_check_num_args("ofBaseSoundStream::setup",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBaseSoundStream::setup",1,"ofBaseSoundStream *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofBaseSoundStream::setup",2,"ofSoundStreamSettings const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBaseSoundStream,0))){
    SWIG_fail_ptr("BaseSoundStream_setup",1,SWIGTYPE_p_ofBaseSoundStream); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofSoundStreamSettings,0))){
    SWIG_fail_ptr("BaseSoundStream_setup",2,SWIGTYPE_p_ofSoundStreamSettings); } 
  result = (bool)(arg1)->setup((ofSoundStreamSettings const &)*arg2); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_BaseSoundStream_setInput(lua_State* L) { int SWIG_arg = 0; ofBaseSoundStream *arg1 = (ofBaseSoundStream *) 0 ;
  ofBaseSoundInput *arg2 = (ofBaseSoundInput *) 0 ; SWIG_check_num_args("ofBaseSoundStream::setInput",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBaseSoundStream::setInput",1,"ofBaseSoundStream *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofBaseSoundStream::setInput",2,"ofBaseSoundInput *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBaseSoundStream,0))){
    SWIG_fail_ptr("BaseSoundStream_setInput",1,SWIGTYPE_p_ofBaseSoundStream); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofBaseSoundInput,0))){
    SWIG_fail_ptr("BaseSoundStream_setInput",2,SWIGTYPE_p_ofBaseSoundInput); }  (arg1)->setInput(arg2); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_BaseSoundStream_setOutput(lua_State* L) { int SWIG_arg = 0; ofBaseSoundStream *arg1 = (ofBaseSoundStream *) 0 ;
  ofBaseSoundOutput *arg2 = (ofBaseSoundOutput *) 0 ; SWIG_check_num_args("ofBaseSoundStream::setOutput",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBaseSoundStream::setOutput",1,"ofBaseSoundStream *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofBaseSoundStream::setOutput",2,"ofBaseSoundOutput *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBaseSoundStream,0))){
    SWIG_fail_ptr("BaseSoundStream_setOutput",1,SWIGTYPE_p_ofBaseSoundStream); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofBaseSoundOutput,0))){
    SWIG_fail_ptr("BaseSoundStream_setOutput",2,SWIGTYPE_p_ofBaseSoundOutput); }  (arg1)->setOutput(arg2); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_BaseSoundStream_getDeviceList(lua_State* L) { int SWIG_arg = 0;
  ofBaseSoundStream *arg1 = (ofBaseSoundStream *) 0 ; ofSoundDevice::Api arg2 ;
  SwigValueWrapper< std::vector< ofSoundDevice > > result; SWIG_check_num_args("ofBaseSoundStream::getDeviceList",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBaseSoundStream::getDeviceList",1,"ofBaseSoundStream const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofBaseSoundStream::getDeviceList",2,"ofSoundDevice::Api");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBaseSoundStream,0))){
    SWIG_fail_ptr("BaseSoundStream_getDeviceList",1,SWIGTYPE_p_ofBaseSoundStream); } 
  arg2 = (ofSoundDevice::Api)(int)lua_tonumber(L, 2); result = ((ofBaseSoundStream const *)arg1)->getDeviceList(arg2); {
    std::vector< ofSoundDevice > * resultptr = new std::vector< ofSoundDevice >((const std::vector< ofSoundDevice > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_std__vectorT_ofSoundDevice_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_BaseSoundStream_printDeviceList(lua_State* L) { int SWIG_arg = 0;
  ofBaseSoundStream *arg1 = (ofBaseSoundStream *) 0 ; SWIG_check_num_args("ofBaseSoundStream::printDeviceList",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBaseSoundStream::printDeviceList",1,"ofBaseSoundStream const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBaseSoundStream,0))){
    SWIG_fail_ptr("BaseSoundStream_printDeviceList",1,SWIGTYPE_p_ofBaseSoundStream); } 
  ((ofBaseSoundStream const *)arg1)->printDeviceList(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_BaseSoundStream_start(lua_State* L) { int SWIG_arg = 0; ofBaseSoundStream *arg1 = (ofBaseSoundStream *) 0 ;
  SWIG_check_num_args("ofBaseSoundStream::start",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBaseSoundStream::start",1,"ofBaseSoundStream *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBaseSoundStream,0))){
    SWIG_fail_ptr("BaseSoundStream_start",1,SWIGTYPE_p_ofBaseSoundStream); }  (arg1)->start(); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_BaseSoundStream_stop(lua_State* L) { int SWIG_arg = 0; ofBaseSoundStream *arg1 = (ofBaseSoundStream *) 0 ;
  SWIG_check_num_args("ofBaseSoundStream::stop",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBaseSoundStream::stop",1,"ofBaseSoundStream *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBaseSoundStream,0))){
    SWIG_fail_ptr("BaseSoundStream_stop",1,SWIGTYPE_p_ofBaseSoundStream); }  (arg1)->stop(); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_BaseSoundStream_close(lua_State* L) { int SWIG_arg = 0; ofBaseSoundStream *arg1 = (ofBaseSoundStream *) 0 ;
  SWIG_check_num_args("ofBaseSoundStream::close",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBaseSoundStream::close",1,"ofBaseSoundStream *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBaseSoundStream,0))){
    SWIG_fail_ptr("BaseSoundStream_close",1,SWIGTYPE_p_ofBaseSoundStream); }  (arg1)->close(); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_BaseSoundStream_getTickCount(lua_State* L) { int SWIG_arg = 0;
  ofBaseSoundStream *arg1 = (ofBaseSoundStream *) 0 ; uint64_t result;
  SWIG_check_num_args("ofBaseSoundStream::getTickCount",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBaseSoundStream::getTickCount",1,"ofBaseSoundStream const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBaseSoundStream,0))){
    SWIG_fail_ptr("BaseSoundStream_getTickCount",1,SWIGTYPE_p_ofBaseSoundStream); } 
  result = (uint64_t)((ofBaseSoundStream const *)arg1)->getTickCount(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_BaseSoundStream_getNumInputChannels(lua_State* L) { int SWIG_arg = 0;
  ofBaseSoundStream *arg1 = (ofBaseSoundStream *) 0 ; int result;
  SWIG_check_num_args("ofBaseSoundStream::getNumInputChannels",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBaseSoundStream::getNumInputChannels",1,"ofBaseSoundStream const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBaseSoundStream,0))){
    SWIG_fail_ptr("BaseSoundStream_getNumInputChannels",1,SWIGTYPE_p_ofBaseSoundStream); } 
  result = (int)((ofBaseSoundStream const *)arg1)->getNumInputChannels(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_BaseSoundStream_getNumOutputChannels(lua_State* L) { int SWIG_arg = 0;
  ofBaseSoundStream *arg1 = (ofBaseSoundStream *) 0 ; int result;
  SWIG_check_num_args("ofBaseSoundStream::getNumOutputChannels",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBaseSoundStream::getNumOutputChannels",1,"ofBaseSoundStream const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBaseSoundStream,0))){
    SWIG_fail_ptr("BaseSoundStream_getNumOutputChannels",1,SWIGTYPE_p_ofBaseSoundStream); } 
  result = (int)((ofBaseSoundStream const *)arg1)->getNumOutputChannels(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_BaseSoundStream_getSampleRate(lua_State* L) { int SWIG_arg = 0;
  ofBaseSoundStream *arg1 = (ofBaseSoundStream *) 0 ; int result; SWIG_check_num_args("ofBaseSoundStream::getSampleRate",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBaseSoundStream::getSampleRate",1,"ofBaseSoundStream const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBaseSoundStream,0))){
    SWIG_fail_ptr("BaseSoundStream_getSampleRate",1,SWIGTYPE_p_ofBaseSoundStream); } 
  result = (int)((ofBaseSoundStream const *)arg1)->getSampleRate(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_BaseSoundStream_getBufferSize(lua_State* L) { int SWIG_arg = 0;
  ofBaseSoundStream *arg1 = (ofBaseSoundStream *) 0 ; int result; SWIG_check_num_args("ofBaseSoundStream::getBufferSize",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBaseSoundStream::getBufferSize",1,"ofBaseSoundStream const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBaseSoundStream,0))){
    SWIG_fail_ptr("BaseSoundStream_getBufferSize",1,SWIGTYPE_p_ofBaseSoundStream); } 
  result = (int)((ofBaseSoundStream const *)arg1)->getBufferSize(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_BaseSoundStream_getInDevice(lua_State* L) { int SWIG_arg = 0;
  ofBaseSoundStream *arg1 = (ofBaseSoundStream *) 0 ; ofSoundDevice result;
  SWIG_check_num_args("ofBaseSoundStream::getInDevice",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBaseSoundStream::getInDevice",1,"ofBaseSoundStream const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBaseSoundStream,0))){
    SWIG_fail_ptr("BaseSoundStream_getInDevice",1,SWIGTYPE_p_ofBaseSoundStream); } 
  result = ((ofBaseSoundStream const *)arg1)->getInDevice(); {
    ofSoundDevice * resultptr = new ofSoundDevice((const ofSoundDevice &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofSoundDevice,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_BaseSoundStream_getOutDevice(lua_State* L) { int SWIG_arg = 0;
  ofBaseSoundStream *arg1 = (ofBaseSoundStream *) 0 ; ofSoundDevice result;
  SWIG_check_num_args("ofBaseSoundStream::getOutDevice",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBaseSoundStream::getOutDevice",1,"ofBaseSoundStream const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBaseSoundStream,0))){
    SWIG_fail_ptr("BaseSoundStream_getOutDevice",1,SWIGTYPE_p_ofBaseSoundStream); } 
  result = ((ofBaseSoundStream const *)arg1)->getOutDevice(); {
    ofSoundDevice * resultptr = new ofSoundDevice((const ofSoundDevice &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofSoundDevice,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static void swig_delete_BaseSoundStream(void *obj) {
ofBaseSoundStream *arg1 = (ofBaseSoundStream *) obj;
delete arg1;
}
static swig_lua_attribute swig_BaseSoundStream_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_BaseSoundStream_methods[]= {
    { "setup", _wrap_BaseSoundStream_setup},
    { "setInput", _wrap_BaseSoundStream_setInput},
    { "setOutput", _wrap_BaseSoundStream_setOutput},
    { "getDeviceList", _wrap_BaseSoundStream_getDeviceList},
    { "printDeviceList", _wrap_BaseSoundStream_printDeviceList},
    { "start", _wrap_BaseSoundStream_start},
    { "stop", _wrap_BaseSoundStream_stop},
    { "close", _wrap_BaseSoundStream_close},
    { "getTickCount", _wrap_BaseSoundStream_getTickCount},
    { "getNumInputChannels", _wrap_BaseSoundStream_getNumInputChannels},
    { "getNumOutputChannels", _wrap_BaseSoundStream_getNumOutputChannels},
    { "getSampleRate", _wrap_BaseSoundStream_getSampleRate},
    { "getBufferSize", _wrap_BaseSoundStream_getBufferSize},
    { "getInDevice", _wrap_BaseSoundStream_getInDevice},
    { "getOutDevice", _wrap_BaseSoundStream_getOutDevice},
    {0,0}
};
static swig_lua_method swig_BaseSoundStream_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_BaseSoundStream_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_BaseSoundStream_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_BaseSoundStream_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_BaseSoundStream_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_BaseSoundStream_Sf_SwigStatic = {
    "BaseSoundStream",
    swig_BaseSoundStream_Sf_SwigStatic_methods,
    swig_BaseSoundStream_Sf_SwigStatic_attributes,
    swig_BaseSoundStream_Sf_SwigStatic_constants,
    swig_BaseSoundStream_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_BaseSoundStream_bases[] = {0};
static const char *swig_BaseSoundStream_base_names[] = {0};
static swig_lua_class _wrap_class_BaseSoundStream = { "BaseSoundStream", "BaseSoundStream", &SWIGTYPE_p_ofBaseSoundStream,0, swig_delete_BaseSoundStream, swig_BaseSoundStream_methods, swig_BaseSoundStream_attributes, &swig_BaseSoundStream_Sf_SwigStatic, swig_BaseSoundStream_meta, swig_BaseSoundStream_bases, swig_BaseSoundStream_base_names };

static int _wrap_toString(lua_State* L) { int SWIG_arg = 0; ofSoundDevice::Api arg1 ; std::string result;
  SWIG_check_num_args("toString",1,1) if(!lua_isnumber(L,1)) SWIG_fail_arg("toString",1,"ofSoundDevice::Api");
  arg1 = (ofSoundDevice::Api)(int)lua_tonumber(L, 1); result = toString(arg1);
  lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_BaseSoundPlayer_load__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofBaseSoundPlayer *arg1 = (ofBaseSoundPlayer *) 0 ; std::filesystem::path *arg2 = 0 ; bool arg3 ;
  std::filesystem::path temp2 ; bool result; SWIG_check_num_args("ofBaseSoundPlayer::load",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBaseSoundPlayer::load",1,"ofBaseSoundPlayer *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofBaseSoundPlayer::load",2,"std::filesystem::path const &");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("ofBaseSoundPlayer::load",3,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBaseSoundPlayer,0))){
    SWIG_fail_ptr("BaseSoundPlayer_load",1,SWIGTYPE_p_ofBaseSoundPlayer); }  { size_t len = lua_rawlen(L, 2);
    temp2 = lua_tolstring(L, 2, &len); arg2 = &temp2; }  arg3 = (lua_toboolean(L, 3)!=0);
  result = (bool)(arg1)->load((std::filesystem::path const &)*arg2,arg3); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_BaseSoundPlayer_load__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofBaseSoundPlayer *arg1 = (ofBaseSoundPlayer *) 0 ; std::filesystem::path *arg2 = 0 ; std::filesystem::path temp2 ;
  bool result; SWIG_check_num_args("ofBaseSoundPlayer::load",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBaseSoundPlayer::load",1,"ofBaseSoundPlayer *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofBaseSoundPlayer::load",2,"std::filesystem::path const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBaseSoundPlayer,0))){
    SWIG_fail_ptr("BaseSoundPlayer_load",1,SWIGTYPE_p_ofBaseSoundPlayer); }  { size_t len = lua_rawlen(L, 2);
    temp2 = lua_tolstring(L, 2, &len); arg2 = &temp2; }  result = (bool)(arg1)->load((std::filesystem::path const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_BaseSoundPlayer_load(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofBaseSoundPlayer, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L, argv[1]); }  if (_v) {
        return _wrap_BaseSoundPlayer_load__SWIG_1(L);}  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofBaseSoundPlayer, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L, argv[1]); }  if (_v) { {
          _v = lua_isboolean(L,argv[2]); }  if (_v) { return _wrap_BaseSoundPlayer_load__SWIG_0(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'BaseSoundPlayer_load'\n"
  "  Possible C/C++ prototypes are:\n" "    ofBaseSoundPlayer::load(std::filesystem::path const &,bool)\n"
  "    ofBaseSoundPlayer::load(std::filesystem::path const &)\n"); lua_error(L);return 0; }
static int _wrap_BaseSoundPlayer_unload(lua_State* L) { int SWIG_arg = 0; ofBaseSoundPlayer *arg1 = (ofBaseSoundPlayer *) 0 ;
  SWIG_check_num_args("ofBaseSoundPlayer::unload",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBaseSoundPlayer::unload",1,"ofBaseSoundPlayer *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBaseSoundPlayer,0))){
    SWIG_fail_ptr("BaseSoundPlayer_unload",1,SWIGTYPE_p_ofBaseSoundPlayer); }  (arg1)->unload(); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_BaseSoundPlayer_play(lua_State* L) { int SWIG_arg = 0; ofBaseSoundPlayer *arg1 = (ofBaseSoundPlayer *) 0 ;
  SWIG_check_num_args("ofBaseSoundPlayer::play",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBaseSoundPlayer::play",1,"ofBaseSoundPlayer *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBaseSoundPlayer,0))){
    SWIG_fail_ptr("BaseSoundPlayer_play",1,SWIGTYPE_p_ofBaseSoundPlayer); }  (arg1)->play(); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_BaseSoundPlayer_stop(lua_State* L) { int SWIG_arg = 0; ofBaseSoundPlayer *arg1 = (ofBaseSoundPlayer *) 0 ;
  SWIG_check_num_args("ofBaseSoundPlayer::stop",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBaseSoundPlayer::stop",1,"ofBaseSoundPlayer *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBaseSoundPlayer,0))){
    SWIG_fail_ptr("BaseSoundPlayer_stop",1,SWIGTYPE_p_ofBaseSoundPlayer); }  (arg1)->stop(); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_BaseSoundPlayer_setVolume(lua_State* L) { int SWIG_arg = 0; ofBaseSoundPlayer *arg1 = (ofBaseSoundPlayer *) 0 ;
  float arg2 ; SWIG_check_num_args("ofBaseSoundPlayer::setVolume",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBaseSoundPlayer::setVolume",1,"ofBaseSoundPlayer *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofBaseSoundPlayer::setVolume",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBaseSoundPlayer,0))){
    SWIG_fail_ptr("BaseSoundPlayer_setVolume",1,SWIGTYPE_p_ofBaseSoundPlayer); }  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setVolume(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_BaseSoundPlayer_setPan(lua_State* L) { int SWIG_arg = 0; ofBaseSoundPlayer *arg1 = (ofBaseSoundPlayer *) 0 ;
  float arg2 ; SWIG_check_num_args("ofBaseSoundPlayer::setPan",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBaseSoundPlayer::setPan",1,"ofBaseSoundPlayer *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofBaseSoundPlayer::setPan",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBaseSoundPlayer,0))){
    SWIG_fail_ptr("BaseSoundPlayer_setPan",1,SWIGTYPE_p_ofBaseSoundPlayer); }  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setPan(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_BaseSoundPlayer_setSpeed(lua_State* L) { int SWIG_arg = 0; ofBaseSoundPlayer *arg1 = (ofBaseSoundPlayer *) 0 ;
  float arg2 ; SWIG_check_num_args("ofBaseSoundPlayer::setSpeed",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBaseSoundPlayer::setSpeed",1,"ofBaseSoundPlayer *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofBaseSoundPlayer::setSpeed",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBaseSoundPlayer,0))){
    SWIG_fail_ptr("BaseSoundPlayer_setSpeed",1,SWIGTYPE_p_ofBaseSoundPlayer); }  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setSpeed(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_BaseSoundPlayer_setPaused(lua_State* L) { int SWIG_arg = 0; ofBaseSoundPlayer *arg1 = (ofBaseSoundPlayer *) 0 ;
  bool arg2 ; SWIG_check_num_args("ofBaseSoundPlayer::setPaused",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBaseSoundPlayer::setPaused",1,"ofBaseSoundPlayer *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofBaseSoundPlayer::setPaused",2,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBaseSoundPlayer,0))){
    SWIG_fail_ptr("BaseSoundPlayer_setPaused",1,SWIGTYPE_p_ofBaseSoundPlayer); }  arg2 = (lua_toboolean(L, 2)!=0);
  (arg1)->setPaused(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_BaseSoundPlayer_setLoop(lua_State* L) { int SWIG_arg = 0; ofBaseSoundPlayer *arg1 = (ofBaseSoundPlayer *) 0 ;
  bool arg2 ; SWIG_check_num_args("ofBaseSoundPlayer::setLoop",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBaseSoundPlayer::setLoop",1,"ofBaseSoundPlayer *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofBaseSoundPlayer::setLoop",2,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBaseSoundPlayer,0))){
    SWIG_fail_ptr("BaseSoundPlayer_setLoop",1,SWIGTYPE_p_ofBaseSoundPlayer); }  arg2 = (lua_toboolean(L, 2)!=0);
  (arg1)->setLoop(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_BaseSoundPlayer_setMultiPlay(lua_State* L) { int SWIG_arg = 0;
  ofBaseSoundPlayer *arg1 = (ofBaseSoundPlayer *) 0 ; bool arg2 ; SWIG_check_num_args("ofBaseSoundPlayer::setMultiPlay",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBaseSoundPlayer::setMultiPlay",1,"ofBaseSoundPlayer *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofBaseSoundPlayer::setMultiPlay",2,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBaseSoundPlayer,0))){
    SWIG_fail_ptr("BaseSoundPlayer_setMultiPlay",1,SWIGTYPE_p_ofBaseSoundPlayer); }  arg2 = (lua_toboolean(L, 2)!=0);
  (arg1)->setMultiPlay(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_BaseSoundPlayer_setPosition(lua_State* L) { int SWIG_arg = 0;
  ofBaseSoundPlayer *arg1 = (ofBaseSoundPlayer *) 0 ; float arg2 ; SWIG_check_num_args("ofBaseSoundPlayer::setPosition",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBaseSoundPlayer::setPosition",1,"ofBaseSoundPlayer *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofBaseSoundPlayer::setPosition",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBaseSoundPlayer,0))){
    SWIG_fail_ptr("BaseSoundPlayer_setPosition",1,SWIGTYPE_p_ofBaseSoundPlayer); }  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setPosition(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_BaseSoundPlayer_setPositionMS(lua_State* L) { int SWIG_arg = 0;
  ofBaseSoundPlayer *arg1 = (ofBaseSoundPlayer *) 0 ; int arg2 ; SWIG_check_num_args("ofBaseSoundPlayer::setPositionMS",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBaseSoundPlayer::setPositionMS",1,"ofBaseSoundPlayer *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofBaseSoundPlayer::setPositionMS",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBaseSoundPlayer,0))){
    SWIG_fail_ptr("BaseSoundPlayer_setPositionMS",1,SWIGTYPE_p_ofBaseSoundPlayer); }  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setPositionMS(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_BaseSoundPlayer_getPosition(lua_State* L) { int SWIG_arg = 0;
  ofBaseSoundPlayer *arg1 = (ofBaseSoundPlayer *) 0 ; float result; SWIG_check_num_args("ofBaseSoundPlayer::getPosition",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBaseSoundPlayer::getPosition",1,"ofBaseSoundPlayer const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBaseSoundPlayer,0))){
    SWIG_fail_ptr("BaseSoundPlayer_getPosition",1,SWIGTYPE_p_ofBaseSoundPlayer); } 
  result = (float)((ofBaseSoundPlayer const *)arg1)->getPosition(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_BaseSoundPlayer_getPositionMS(lua_State* L) { int SWIG_arg = 0;
  ofBaseSoundPlayer *arg1 = (ofBaseSoundPlayer *) 0 ; int result; SWIG_check_num_args("ofBaseSoundPlayer::getPositionMS",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBaseSoundPlayer::getPositionMS",1,"ofBaseSoundPlayer const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBaseSoundPlayer,0))){
    SWIG_fail_ptr("BaseSoundPlayer_getPositionMS",1,SWIGTYPE_p_ofBaseSoundPlayer); } 
  result = (int)((ofBaseSoundPlayer const *)arg1)->getPositionMS(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_BaseSoundPlayer_isPlaying(lua_State* L) { int SWIG_arg = 0; ofBaseSoundPlayer *arg1 = (ofBaseSoundPlayer *) 0 ;
  bool result; SWIG_check_num_args("ofBaseSoundPlayer::isPlaying",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBaseSoundPlayer::isPlaying",1,"ofBaseSoundPlayer const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBaseSoundPlayer,0))){
    SWIG_fail_ptr("BaseSoundPlayer_isPlaying",1,SWIGTYPE_p_ofBaseSoundPlayer); } 
  result = (bool)((ofBaseSoundPlayer const *)arg1)->isPlaying(); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_BaseSoundPlayer_getSpeed(lua_State* L) { int SWIG_arg = 0; ofBaseSoundPlayer *arg1 = (ofBaseSoundPlayer *) 0 ;
  float result; SWIG_check_num_args("ofBaseSoundPlayer::getSpeed",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBaseSoundPlayer::getSpeed",1,"ofBaseSoundPlayer const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBaseSoundPlayer,0))){
    SWIG_fail_ptr("BaseSoundPlayer_getSpeed",1,SWIGTYPE_p_ofBaseSoundPlayer); } 
  result = (float)((ofBaseSoundPlayer const *)arg1)->getSpeed(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_BaseSoundPlayer_getPan(lua_State* L) { int SWIG_arg = 0; ofBaseSoundPlayer *arg1 = (ofBaseSoundPlayer *) 0 ;
  float result; SWIG_check_num_args("ofBaseSoundPlayer::getPan",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBaseSoundPlayer::getPan",1,"ofBaseSoundPlayer const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBaseSoundPlayer,0))){
    SWIG_fail_ptr("BaseSoundPlayer_getPan",1,SWIGTYPE_p_ofBaseSoundPlayer); } 
  result = (float)((ofBaseSoundPlayer const *)arg1)->getPan(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_BaseSoundPlayer_isLoaded(lua_State* L) { int SWIG_arg = 0; ofBaseSoundPlayer *arg1 = (ofBaseSoundPlayer *) 0 ;
  bool result; SWIG_check_num_args("ofBaseSoundPlayer::isLoaded",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBaseSoundPlayer::isLoaded",1,"ofBaseSoundPlayer const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBaseSoundPlayer,0))){
    SWIG_fail_ptr("BaseSoundPlayer_isLoaded",1,SWIGTYPE_p_ofBaseSoundPlayer); } 
  result = (bool)((ofBaseSoundPlayer const *)arg1)->isLoaded(); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_BaseSoundPlayer_getVolume(lua_State* L) { int SWIG_arg = 0; ofBaseSoundPlayer *arg1 = (ofBaseSoundPlayer *) 0 ;
  float result; SWIG_check_num_args("ofBaseSoundPlayer::getVolume",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBaseSoundPlayer::getVolume",1,"ofBaseSoundPlayer const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBaseSoundPlayer,0))){
    SWIG_fail_ptr("BaseSoundPlayer_getVolume",1,SWIGTYPE_p_ofBaseSoundPlayer); } 
  result = (float)((ofBaseSoundPlayer const *)arg1)->getVolume(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static void swig_delete_BaseSoundPlayer(void *obj) {
ofBaseSoundPlayer *arg1 = (ofBaseSoundPlayer *) obj;
delete arg1;
}
static swig_lua_attribute swig_BaseSoundPlayer_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_BaseSoundPlayer_methods[]= {
    { "load", _wrap_BaseSoundPlayer_load},
    { "unload", _wrap_BaseSoundPlayer_unload},
    { "play", _wrap_BaseSoundPlayer_play},
    { "stop", _wrap_BaseSoundPlayer_stop},
    { "setVolume", _wrap_BaseSoundPlayer_setVolume},
    { "setPan", _wrap_BaseSoundPlayer_setPan},
    { "setSpeed", _wrap_BaseSoundPlayer_setSpeed},
    { "setPaused", _wrap_BaseSoundPlayer_setPaused},
    { "setLoop", _wrap_BaseSoundPlayer_setLoop},
    { "setMultiPlay", _wrap_BaseSoundPlayer_setMultiPlay},
    { "setPosition", _wrap_BaseSoundPlayer_setPosition},
    { "setPositionMS", _wrap_BaseSoundPlayer_setPositionMS},
    { "getPosition", _wrap_BaseSoundPlayer_getPosition},
    { "getPositionMS", _wrap_BaseSoundPlayer_getPositionMS},
    { "isPlaying", _wrap_BaseSoundPlayer_isPlaying},
    { "getSpeed", _wrap_BaseSoundPlayer_getSpeed},
    { "getPan", _wrap_BaseSoundPlayer_getPan},
    { "isLoaded", _wrap_BaseSoundPlayer_isLoaded},
    { "getVolume", _wrap_BaseSoundPlayer_getVolume},
    {0,0}
};
static swig_lua_method swig_BaseSoundPlayer_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_BaseSoundPlayer_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_BaseSoundPlayer_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_BaseSoundPlayer_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_BaseSoundPlayer_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_BaseSoundPlayer_Sf_SwigStatic = {
    "BaseSoundPlayer",
    swig_BaseSoundPlayer_Sf_SwigStatic_methods,
    swig_BaseSoundPlayer_Sf_SwigStatic_attributes,
    swig_BaseSoundPlayer_Sf_SwigStatic_constants,
    swig_BaseSoundPlayer_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_BaseSoundPlayer_bases[] = {0};
static const char *swig_BaseSoundPlayer_base_names[] = {0};
static swig_lua_class _wrap_class_BaseSoundPlayer = { "BaseSoundPlayer", "BaseSoundPlayer", &SWIGTYPE_p_ofBaseSoundPlayer,0, swig_delete_BaseSoundPlayer, swig_BaseSoundPlayer_methods, swig_BaseSoundPlayer_attributes, &swig_BaseSoundPlayer_Sf_SwigStatic, swig_BaseSoundPlayer_meta, swig_BaseSoundPlayer_bases, swig_BaseSoundPlayer_base_names };

static int _wrap_VideoFormat_pixelFormat_set(lua_State* L) { int SWIG_arg = 0; ofVideoFormat *arg1 = (ofVideoFormat *) 0 ;
  ofPixelFormat arg2 ; SWIG_check_num_args("ofVideoFormat::pixelFormat",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoFormat::pixelFormat",1,"ofVideoFormat *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVideoFormat::pixelFormat",2,"ofPixelFormat");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoFormat,0))){
    SWIG_fail_ptr("VideoFormat_pixelFormat_set",1,SWIGTYPE_p_ofVideoFormat); }  arg2 = (ofPixelFormat)(int)lua_tonumber(L, 2);
  if (arg1) (arg1)->pixelFormat = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_VideoFormat_pixelFormat_get(lua_State* L) { int SWIG_arg = 0; ofVideoFormat *arg1 = (ofVideoFormat *) 0 ;
  ofPixelFormat result; SWIG_check_num_args("ofVideoFormat::pixelFormat",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoFormat::pixelFormat",1,"ofVideoFormat *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoFormat,0))){
    SWIG_fail_ptr("VideoFormat_pixelFormat_get",1,SWIGTYPE_p_ofVideoFormat); }  result = (ofPixelFormat) ((arg1)->pixelFormat);
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_VideoFormat_width_set(lua_State* L) { int SWIG_arg = 0; ofVideoFormat *arg1 = (ofVideoFormat *) 0 ; int arg2 ;
  SWIG_check_num_args("ofVideoFormat::width",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoFormat::width",1,"ofVideoFormat *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVideoFormat::width",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoFormat,0))){
    SWIG_fail_ptr("VideoFormat_width_set",1,SWIGTYPE_p_ofVideoFormat); }  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->width = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_VideoFormat_width_get(lua_State* L) { int SWIG_arg = 0; ofVideoFormat *arg1 = (ofVideoFormat *) 0 ; int result;
  SWIG_check_num_args("ofVideoFormat::width",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoFormat::width",1,"ofVideoFormat *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoFormat,0))){
    SWIG_fail_ptr("VideoFormat_width_get",1,SWIGTYPE_p_ofVideoFormat); }  result = (int) ((arg1)->width);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_VideoFormat_height_set(lua_State* L) { int SWIG_arg = 0; ofVideoFormat *arg1 = (ofVideoFormat *) 0 ; int arg2 ;
  SWIG_check_num_args("ofVideoFormat::height",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoFormat::height",1,"ofVideoFormat *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVideoFormat::height",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoFormat,0))){
    SWIG_fail_ptr("VideoFormat_height_set",1,SWIGTYPE_p_ofVideoFormat); }  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->height = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_VideoFormat_height_get(lua_State* L) { int SWIG_arg = 0; ofVideoFormat *arg1 = (ofVideoFormat *) 0 ;
  int result; SWIG_check_num_args("ofVideoFormat::height",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoFormat::height",1,"ofVideoFormat *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoFormat,0))){
    SWIG_fail_ptr("VideoFormat_height_get",1,SWIGTYPE_p_ofVideoFormat); }  result = (int) ((arg1)->height);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_VideoFormat_framerates_set(lua_State* L) { int SWIG_arg = 0; ofVideoFormat *arg1 = (ofVideoFormat *) 0 ;
  std::vector< float > *arg2 = (std::vector< float > *) 0 ; SWIG_check_num_args("ofVideoFormat::framerates",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoFormat::framerates",1,"ofVideoFormat *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofVideoFormat::framerates",2,"std::vector< float > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoFormat,0))){
    SWIG_fail_ptr("VideoFormat_framerates_set",1,SWIGTYPE_p_ofVideoFormat); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_std__vectorT_float_t,0))){
    SWIG_fail_ptr("VideoFormat_framerates_set",2,SWIGTYPE_p_std__vectorT_float_t); }  if (arg1) (arg1)->framerates = *arg2;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_VideoFormat_framerates_get(lua_State* L) { int SWIG_arg = 0; ofVideoFormat *arg1 = (ofVideoFormat *) 0 ;
  std::vector< float > *result = 0 ; SWIG_check_num_args("ofVideoFormat::framerates",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoFormat::framerates",1,"ofVideoFormat *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoFormat,0))){
    SWIG_fail_ptr("VideoFormat_framerates_get",1,SWIGTYPE_p_ofVideoFormat); } 
  result = (std::vector< float > *)& ((arg1)->framerates);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorT_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static void swig_delete_VideoFormat(void *obj) {
ofVideoFormat *arg1 = (ofVideoFormat *) obj;
delete arg1;
}
static swig_lua_attribute swig_VideoFormat_attributes[] = {
    { "pixelFormat", _wrap_VideoFormat_pixelFormat_get, _wrap_VideoFormat_pixelFormat_set },
    { "width", _wrap_VideoFormat_width_get, _wrap_VideoFormat_width_set },
    { "height", _wrap_VideoFormat_height_get, _wrap_VideoFormat_height_set },
    { "framerates", _wrap_VideoFormat_framerates_get, _wrap_VideoFormat_framerates_set },
    {0,0,0}
};
static swig_lua_method swig_VideoFormat_methods[]= {
    {0,0}
};
static swig_lua_method swig_VideoFormat_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_VideoFormat_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_VideoFormat_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_VideoFormat_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_VideoFormat_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_VideoFormat_Sf_SwigStatic = {
    "VideoFormat",
    swig_VideoFormat_Sf_SwigStatic_methods,
    swig_VideoFormat_Sf_SwigStatic_attributes,
    swig_VideoFormat_Sf_SwigStatic_constants,
    swig_VideoFormat_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_VideoFormat_bases[] = {0};
static const char *swig_VideoFormat_base_names[] = {0};
static swig_lua_class _wrap_class_VideoFormat = { "VideoFormat", "VideoFormat", &SWIGTYPE_p_ofVideoFormat,0, swig_delete_VideoFormat, swig_VideoFormat_methods, swig_VideoFormat_attributes, &swig_VideoFormat_Sf_SwigStatic, swig_VideoFormat_meta, swig_VideoFormat_bases, swig_VideoFormat_base_names };

static int _wrap_VideoDevice_id_set(lua_State* L) { int SWIG_arg = 0; ofVideoDevice *arg1 = (ofVideoDevice *) 0 ; int arg2 ;
  SWIG_check_num_args("ofVideoDevice::id",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoDevice::id",1,"ofVideoDevice *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVideoDevice::id",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoDevice,0))){
    SWIG_fail_ptr("VideoDevice_id_set",1,SWIGTYPE_p_ofVideoDevice); }  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->id = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_VideoDevice_id_get(lua_State* L) { int SWIG_arg = 0; ofVideoDevice *arg1 = (ofVideoDevice *) 0 ; int result;
  SWIG_check_num_args("ofVideoDevice::id",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoDevice::id",1,"ofVideoDevice *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoDevice,0))){
    SWIG_fail_ptr("VideoDevice_id_get",1,SWIGTYPE_p_ofVideoDevice); }  result = (int) ((arg1)->id);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_VideoDevice_deviceName_set(lua_State* L) { int SWIG_arg = 0; ofVideoDevice *arg1 = (ofVideoDevice *) 0 ;
  std::string *arg2 = 0 ; std::string temp2 ; SWIG_check_num_args("ofVideoDevice::deviceName",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoDevice::deviceName",1,"ofVideoDevice *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofVideoDevice::deviceName",2,"std::string const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoDevice,0))){
    SWIG_fail_ptr("VideoDevice_deviceName_set",1,SWIGTYPE_p_ofVideoDevice); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2; if (arg1) (arg1)->deviceName = *arg2; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_VideoDevice_deviceName_get(lua_State* L) { int SWIG_arg = 0; ofVideoDevice *arg1 = (ofVideoDevice *) 0 ;
  std::string *result = 0 ; SWIG_check_num_args("ofVideoDevice::deviceName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoDevice::deviceName",1,"ofVideoDevice *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoDevice,0))){
    SWIG_fail_ptr("VideoDevice_deviceName_get",1,SWIGTYPE_p_ofVideoDevice); }  result = (std::string *) & ((arg1)->deviceName);
  lua_pushlstring(L,result->data(),result->size()); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_VideoDevice_hardwareName_set(lua_State* L) { int SWIG_arg = 0; ofVideoDevice *arg1 = (ofVideoDevice *) 0 ;
  std::string *arg2 = 0 ; std::string temp2 ; SWIG_check_num_args("ofVideoDevice::hardwareName",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoDevice::hardwareName",1,"ofVideoDevice *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofVideoDevice::hardwareName",2,"std::string const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoDevice,0))){
    SWIG_fail_ptr("VideoDevice_hardwareName_set",1,SWIGTYPE_p_ofVideoDevice); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2; if (arg1) (arg1)->hardwareName = *arg2; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_VideoDevice_hardwareName_get(lua_State* L) { int SWIG_arg = 0; ofVideoDevice *arg1 = (ofVideoDevice *) 0 ;
  std::string *result = 0 ; SWIG_check_num_args("ofVideoDevice::hardwareName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoDevice::hardwareName",1,"ofVideoDevice *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoDevice,0))){
    SWIG_fail_ptr("VideoDevice_hardwareName_get",1,SWIGTYPE_p_ofVideoDevice); } 
  result = (std::string *) & ((arg1)->hardwareName); lua_pushlstring(L,result->data(),result->size()); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_VideoDevice_serialID_set(lua_State* L) { int SWIG_arg = 0; ofVideoDevice *arg1 = (ofVideoDevice *) 0 ;
  std::string *arg2 = 0 ; std::string temp2 ; SWIG_check_num_args("ofVideoDevice::serialID",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoDevice::serialID",1,"ofVideoDevice *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofVideoDevice::serialID",2,"std::string const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoDevice,0))){
    SWIG_fail_ptr("VideoDevice_serialID_set",1,SWIGTYPE_p_ofVideoDevice); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2; if (arg1) (arg1)->serialID = *arg2; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_VideoDevice_serialID_get(lua_State* L) { int SWIG_arg = 0; ofVideoDevice *arg1 = (ofVideoDevice *) 0 ;
  std::string *result = 0 ; SWIG_check_num_args("ofVideoDevice::serialID",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoDevice::serialID",1,"ofVideoDevice *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoDevice,0))){
    SWIG_fail_ptr("VideoDevice_serialID_get",1,SWIGTYPE_p_ofVideoDevice); }  result = (std::string *) & ((arg1)->serialID);
  lua_pushlstring(L,result->data(),result->size()); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_VideoDevice_formats_set(lua_State* L) { int SWIG_arg = 0; ofVideoDevice *arg1 = (ofVideoDevice *) 0 ;
  std::vector< ofVideoFormat > *arg2 = (std::vector< ofVideoFormat > *) 0 ; SWIG_check_num_args("ofVideoDevice::formats",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoDevice::formats",1,"ofVideoDevice *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofVideoDevice::formats",2,"std::vector< ofVideoFormat > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoDevice,0))){
    SWIG_fail_ptr("VideoDevice_formats_set",1,SWIGTYPE_p_ofVideoDevice); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_std__vectorT_ofVideoFormat_t,0))){
    SWIG_fail_ptr("VideoDevice_formats_set",2,SWIGTYPE_p_std__vectorT_ofVideoFormat_t); }  if (arg1) (arg1)->formats = *arg2;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_VideoDevice_formats_get(lua_State* L) { int SWIG_arg = 0; ofVideoDevice *arg1 = (ofVideoDevice *) 0 ;
  std::vector< ofVideoFormat > *result = 0 ; SWIG_check_num_args("ofVideoDevice::formats",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoDevice::formats",1,"ofVideoDevice *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoDevice,0))){
    SWIG_fail_ptr("VideoDevice_formats_get",1,SWIGTYPE_p_ofVideoDevice); } 
  result = (std::vector< ofVideoFormat > *)& ((arg1)->formats);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorT_ofVideoFormat_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_VideoDevice_bAvailable_set(lua_State* L) { int SWIG_arg = 0; ofVideoDevice *arg1 = (ofVideoDevice *) 0 ;
  bool arg2 ; SWIG_check_num_args("ofVideoDevice::bAvailable",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoDevice::bAvailable",1,"ofVideoDevice *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofVideoDevice::bAvailable",2,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoDevice,0))){
    SWIG_fail_ptr("VideoDevice_bAvailable_set",1,SWIGTYPE_p_ofVideoDevice); }  arg2 = (lua_toboolean(L, 2)!=0);
  if (arg1) (arg1)->bAvailable = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_VideoDevice_bAvailable_get(lua_State* L) { int SWIG_arg = 0; ofVideoDevice *arg1 = (ofVideoDevice *) 0 ;
  bool result; SWIG_check_num_args("ofVideoDevice::bAvailable",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoDevice::bAvailable",1,"ofVideoDevice *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoDevice,0))){
    SWIG_fail_ptr("VideoDevice_bAvailable_get",1,SWIGTYPE_p_ofVideoDevice); }  result = (bool) ((arg1)->bAvailable);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static void swig_delete_VideoDevice(void *obj) {
ofVideoDevice *arg1 = (ofVideoDevice *) obj;
delete arg1;
}
static swig_lua_attribute swig_VideoDevice_attributes[] = {
    { "id", _wrap_VideoDevice_id_get, _wrap_VideoDevice_id_set },
    { "deviceName", _wrap_VideoDevice_deviceName_get, _wrap_VideoDevice_deviceName_set },
    { "hardwareName", _wrap_VideoDevice_hardwareName_get, _wrap_VideoDevice_hardwareName_set },
    { "serialID", _wrap_VideoDevice_serialID_get, _wrap_VideoDevice_serialID_set },
    { "formats", _wrap_VideoDevice_formats_get, _wrap_VideoDevice_formats_set },
    { "bAvailable", _wrap_VideoDevice_bAvailable_get, _wrap_VideoDevice_bAvailable_set },
    {0,0,0}
};
static swig_lua_method swig_VideoDevice_methods[]= {
    {0,0}
};
static swig_lua_method swig_VideoDevice_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_VideoDevice_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_VideoDevice_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_VideoDevice_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_VideoDevice_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_VideoDevice_Sf_SwigStatic = {
    "VideoDevice",
    swig_VideoDevice_Sf_SwigStatic_methods,
    swig_VideoDevice_Sf_SwigStatic_attributes,
    swig_VideoDevice_Sf_SwigStatic_constants,
    swig_VideoDevice_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_VideoDevice_bases[] = {0};
static const char *swig_VideoDevice_base_names[] = {0};
static swig_lua_class _wrap_class_VideoDevice = { "VideoDevice", "VideoDevice", &SWIGTYPE_p_ofVideoDevice,0, swig_delete_VideoDevice, swig_VideoDevice_methods, swig_VideoDevice_attributes, &swig_VideoDevice_Sf_SwigStatic, swig_VideoDevice_meta, swig_VideoDevice_bases, swig_VideoDevice_base_names };

static int _wrap_new_Node__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofNode *result = 0 ;
  SWIG_check_num_args("ofNode::ofNode",0,0) result = (ofNode *)new ofNode();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofNode,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_Node__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = 0 ; ofNode *result = 0 ;
  SWIG_check_num_args("ofNode::ofNode",1,1) if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofNode::ofNode",1,"ofNode &&");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){ SWIG_fail_ptr("new_Node",1,SWIGTYPE_p_ofNode); } 
  result = (ofNode *)new ofNode((ofNode &&)*arg1); SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofNode,1); SWIG_arg++; 
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_new_Node(lua_State* L) { int argc; int argv[2]={ 1,2} ; argc = lua_gettop(L); if (argc == 0) {
    return _wrap_new_Node__SWIG_0(L);}  if (argc == 1) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofNode, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { return _wrap_new_Node__SWIG_1(L);}  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_Node'\n" "  Possible C/C++ prototypes are:\n"
  "    ofNode::ofNode()\n" "    ofNode::ofNode(ofNode &&)\n"); lua_error(L);return 0; }
static int _wrap_Node_setParent__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = (ofNode *) 0 ; ofNode *arg2 = 0 ;
  bool arg3 ; SWIG_check_num_args("ofNode::setParent",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofNode::setParent",1,"ofNode *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofNode::setParent",2,"ofNode &");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("ofNode::setParent",3,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){ SWIG_fail_ptr("Node_setParent",1,SWIGTYPE_p_ofNode); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofNode,0))){
    SWIG_fail_ptr("Node_setParent",2,SWIGTYPE_p_ofNode); }  arg3 = (lua_toboolean(L, 3)!=0); (arg1)->setParent(*arg2,arg3);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Node_setParent__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = (ofNode *) 0 ; ofNode *arg2 = 0 ;
  SWIG_check_num_args("ofNode::setParent",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofNode::setParent",1,"ofNode *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofNode::setParent",2,"ofNode &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){ SWIG_fail_ptr("Node_setParent",1,SWIGTYPE_p_ofNode); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofNode,0))){
    SWIG_fail_ptr("Node_setParent",2,SWIGTYPE_p_ofNode); }  (arg1)->setParent(*arg2); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Node_setParent(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofNode, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofNode, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Node_setParent__SWIG_1(L);}  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofNode, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofNode, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isboolean(L,argv[2]); }  if (_v) { return _wrap_Node_setParent__SWIG_0(L);}  }
       }  }  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Node_setParent'\n"
  "  Possible C/C++ prototypes are:\n" "    ofNode::setParent(ofNode &,bool)\n" "    ofNode::setParent(ofNode &)\n");
  lua_error(L);return 0; }
static int _wrap_Node_clearParent__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = (ofNode *) 0 ; bool arg2 ;
  SWIG_check_num_args("ofNode::clearParent",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofNode::clearParent",1,"ofNode *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofNode::clearParent",2,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){
    SWIG_fail_ptr("Node_clearParent",1,SWIGTYPE_p_ofNode); }  arg2 = (lua_toboolean(L, 2)!=0); (arg1)->clearParent(arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Node_clearParent__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = (ofNode *) 0 ;
  SWIG_check_num_args("ofNode::clearParent",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofNode::clearParent",1,"ofNode *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){
    SWIG_fail_ptr("Node_clearParent",1,SWIGTYPE_p_ofNode); }  (arg1)->clearParent(); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Node_clearParent(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 1) {
    int _v; { void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofNode, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Node_clearParent__SWIG_1(L);}  }  if (argc == 2) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofNode, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isboolean(L,argv[1]); }  if (_v) {
        return _wrap_Node_clearParent__SWIG_0(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Node_clearParent'\n" "  Possible C/C++ prototypes are:\n"
  "    ofNode::clearParent(bool)\n" "    ofNode::clearParent()\n"); lua_error(L);return 0; }
static int _wrap_Node_getParent(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = (ofNode *) 0 ; ofNode *result = 0 ;
  SWIG_check_num_args("ofNode::getParent",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofNode::getParent",1,"ofNode const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){ SWIG_fail_ptr("Node_getParent",1,SWIGTYPE_p_ofNode); }
   result = (ofNode *)((ofNode const *)arg1)->getParent(); SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofNode,0); SWIG_arg++; 
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Node_getPosition(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = (ofNode *) 0 ; glm::vec3 result;
  SWIG_check_num_args("ofNode::getPosition",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofNode::getPosition",1,"ofNode const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){
    SWIG_fail_ptr("Node_getPosition",1,SWIGTYPE_p_ofNode); }  result = ((ofNode const *)arg1)->getPosition(); {
    glm::vec3 * resultptr = new glm::vec3((const glm::vec3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_glm__vec3,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Node_getX(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = (ofNode *) 0 ; float result;
  SWIG_check_num_args("ofNode::getX",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofNode::getX",1,"ofNode const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){ SWIG_fail_ptr("Node_getX",1,SWIGTYPE_p_ofNode); } 
  result = (float)((ofNode const *)arg1)->getX(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Node_getY(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = (ofNode *) 0 ; float result;
  SWIG_check_num_args("ofNode::getY",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofNode::getY",1,"ofNode const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){ SWIG_fail_ptr("Node_getY",1,SWIGTYPE_p_ofNode); } 
  result = (float)((ofNode const *)arg1)->getY(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Node_getZ(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = (ofNode *) 0 ; float result;
  SWIG_check_num_args("ofNode::getZ",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofNode::getZ",1,"ofNode const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){ SWIG_fail_ptr("Node_getZ",1,SWIGTYPE_p_ofNode); } 
  result = (float)((ofNode const *)arg1)->getZ(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Node_getXAxis(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = (ofNode *) 0 ; glm::vec3 result;
  SWIG_check_num_args("ofNode::getXAxis",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofNode::getXAxis",1,"ofNode const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){ SWIG_fail_ptr("Node_getXAxis",1,SWIGTYPE_p_ofNode); }
   result = ((ofNode const *)arg1)->getXAxis(); { glm::vec3 * resultptr = new glm::vec3((const glm::vec3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_glm__vec3,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Node_getYAxis(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = (ofNode *) 0 ; glm::vec3 result;
  SWIG_check_num_args("ofNode::getYAxis",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofNode::getYAxis",1,"ofNode const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){ SWIG_fail_ptr("Node_getYAxis",1,SWIGTYPE_p_ofNode); }
   result = ((ofNode const *)arg1)->getYAxis(); { glm::vec3 * resultptr = new glm::vec3((const glm::vec3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_glm__vec3,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Node_getZAxis(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = (ofNode *) 0 ; glm::vec3 result;
  SWIG_check_num_args("ofNode::getZAxis",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofNode::getZAxis",1,"ofNode const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){ SWIG_fail_ptr("Node_getZAxis",1,SWIGTYPE_p_ofNode); }
   result = ((ofNode const *)arg1)->getZAxis(); { glm::vec3 * resultptr = new glm::vec3((const glm::vec3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_glm__vec3,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Node_getSideDir(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = (ofNode *) 0 ; glm::vec3 result;
  SWIG_check_num_args("ofNode::getSideDir",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofNode::getSideDir",1,"ofNode const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){
    SWIG_fail_ptr("Node_getSideDir",1,SWIGTYPE_p_ofNode); }  result = ((ofNode const *)arg1)->getSideDir(); {
    glm::vec3 * resultptr = new glm::vec3((const glm::vec3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_glm__vec3,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Node_getLookAtDir(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = (ofNode *) 0 ; glm::vec3 result;
  SWIG_check_num_args("ofNode::getLookAtDir",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofNode::getLookAtDir",1,"ofNode const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){
    SWIG_fail_ptr("Node_getLookAtDir",1,SWIGTYPE_p_ofNode); }  result = ((ofNode const *)arg1)->getLookAtDir(); {
    glm::vec3 * resultptr = new glm::vec3((const glm::vec3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_glm__vec3,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Node_getUpDir(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = (ofNode *) 0 ; glm::vec3 result;
  SWIG_check_num_args("ofNode::getUpDir",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofNode::getUpDir",1,"ofNode const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){ SWIG_fail_ptr("Node_getUpDir",1,SWIGTYPE_p_ofNode); }
   result = ((ofNode const *)arg1)->getUpDir(); { glm::vec3 * resultptr = new glm::vec3((const glm::vec3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_glm__vec3,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Node_getPitchDeg(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = (ofNode *) 0 ; float result;
  SWIG_check_num_args("ofNode::getPitchDeg",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofNode::getPitchDeg",1,"ofNode const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){
    SWIG_fail_ptr("Node_getPitchDeg",1,SWIGTYPE_p_ofNode); }  result = (float)((ofNode const *)arg1)->getPitchDeg();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Node_getHeadingDeg(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = (ofNode *) 0 ; float result;
  SWIG_check_num_args("ofNode::getHeadingDeg",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofNode::getHeadingDeg",1,"ofNode const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){
    SWIG_fail_ptr("Node_getHeadingDeg",1,SWIGTYPE_p_ofNode); }  result = (float)((ofNode const *)arg1)->getHeadingDeg();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Node_getRollDeg(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = (ofNode *) 0 ; float result;
  SWIG_check_num_args("ofNode::getRollDeg",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofNode::getRollDeg",1,"ofNode const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){
    SWIG_fail_ptr("Node_getRollDeg",1,SWIGTYPE_p_ofNode); }  result = (float)((ofNode const *)arg1)->getRollDeg();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Node_getPitchRad(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = (ofNode *) 0 ; float result;
  SWIG_check_num_args("ofNode::getPitchRad",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofNode::getPitchRad",1,"ofNode const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){
    SWIG_fail_ptr("Node_getPitchRad",1,SWIGTYPE_p_ofNode); }  result = (float)((ofNode const *)arg1)->getPitchRad();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Node_getHeadingRad(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = (ofNode *) 0 ; float result;
  SWIG_check_num_args("ofNode::getHeadingRad",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofNode::getHeadingRad",1,"ofNode const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){
    SWIG_fail_ptr("Node_getHeadingRad",1,SWIGTYPE_p_ofNode); }  result = (float)((ofNode const *)arg1)->getHeadingRad();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Node_getRollRad(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = (ofNode *) 0 ; float result;
  SWIG_check_num_args("ofNode::getRollRad",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofNode::getRollRad",1,"ofNode const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){
    SWIG_fail_ptr("Node_getRollRad",1,SWIGTYPE_p_ofNode); }  result = (float)((ofNode const *)arg1)->getRollRad();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Node_getOrientationQuat(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = (ofNode *) 0 ; glm::quat result;
  SWIG_check_num_args("ofNode::getOrientationQuat",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofNode::getOrientationQuat",1,"ofNode const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){
    SWIG_fail_ptr("Node_getOrientationQuat",1,SWIGTYPE_p_ofNode); }  result = ((ofNode const *)arg1)->getOrientationQuat(); {
    glm::quat * resultptr = new glm::quat((const glm::quat &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_glm__quat,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Node_getOrientationEulerDeg(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = (ofNode *) 0 ; glm::vec3 result;
  SWIG_check_num_args("ofNode::getOrientationEulerDeg",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofNode::getOrientationEulerDeg",1,"ofNode const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){
    SWIG_fail_ptr("Node_getOrientationEulerDeg",1,SWIGTYPE_p_ofNode); } 
  result = ((ofNode const *)arg1)->getOrientationEulerDeg(); {
    glm::vec3 * resultptr = new glm::vec3((const glm::vec3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_glm__vec3,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Node_getOrientationEulerRad(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = (ofNode *) 0 ; glm::vec3 result;
  SWIG_check_num_args("ofNode::getOrientationEulerRad",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofNode::getOrientationEulerRad",1,"ofNode const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){
    SWIG_fail_ptr("Node_getOrientationEulerRad",1,SWIGTYPE_p_ofNode); } 
  result = ((ofNode const *)arg1)->getOrientationEulerRad(); {
    glm::vec3 * resultptr = new glm::vec3((const glm::vec3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_glm__vec3,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Node_getScale(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = (ofNode *) 0 ; glm::vec3 result;
  SWIG_check_num_args("ofNode::getScale",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofNode::getScale",1,"ofNode const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){ SWIG_fail_ptr("Node_getScale",1,SWIGTYPE_p_ofNode); }
   result = ((ofNode const *)arg1)->getScale(); { glm::vec3 * resultptr = new glm::vec3((const glm::vec3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_glm__vec3,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Node_getLocalTransformMatrix(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = (ofNode *) 0 ;
  glm::mat4 *result = 0 ; SWIG_check_num_args("ofNode::getLocalTransformMatrix",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofNode::getLocalTransformMatrix",1,"ofNode const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){
    SWIG_fail_ptr("Node_getLocalTransformMatrix",1,SWIGTYPE_p_ofNode); } 
  result = (glm::mat4 *) &((ofNode const *)arg1)->getLocalTransformMatrix();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_glm__mat4,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Node_getGlobalTransformMatrix(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = (ofNode *) 0 ; glm::mat4 result;
  SWIG_check_num_args("ofNode::getGlobalTransformMatrix",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofNode::getGlobalTransformMatrix",1,"ofNode const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){
    SWIG_fail_ptr("Node_getGlobalTransformMatrix",1,SWIGTYPE_p_ofNode); } 
  result = ((ofNode const *)arg1)->getGlobalTransformMatrix(); {
    glm::mat4 * resultptr = new glm::mat4((const glm::mat4 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_glm__mat4,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Node_getGlobalPosition(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = (ofNode *) 0 ; glm::vec3 result;
  SWIG_check_num_args("ofNode::getGlobalPosition",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofNode::getGlobalPosition",1,"ofNode const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){
    SWIG_fail_ptr("Node_getGlobalPosition",1,SWIGTYPE_p_ofNode); }  result = ((ofNode const *)arg1)->getGlobalPosition(); {
    glm::vec3 * resultptr = new glm::vec3((const glm::vec3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_glm__vec3,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Node_getGlobalOrientation(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = (ofNode *) 0 ; glm::quat result;
  SWIG_check_num_args("ofNode::getGlobalOrientation",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofNode::getGlobalOrientation",1,"ofNode const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){
    SWIG_fail_ptr("Node_getGlobalOrientation",1,SWIGTYPE_p_ofNode); }  result = ((ofNode const *)arg1)->getGlobalOrientation();
  { glm::quat * resultptr = new glm::quat((const glm::quat &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_glm__quat,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Node_getGlobalScale(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = (ofNode *) 0 ; glm::vec3 result;
  SWIG_check_num_args("ofNode::getGlobalScale",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofNode::getGlobalScale",1,"ofNode const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){
    SWIG_fail_ptr("Node_getGlobalScale",1,SWIGTYPE_p_ofNode); }  result = ((ofNode const *)arg1)->getGlobalScale(); {
    glm::vec3 * resultptr = new glm::vec3((const glm::vec3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_glm__vec3,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Node_setPosition__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = (ofNode *) 0 ; float arg2 ;
  float arg3 ; float arg4 ; SWIG_check_num_args("ofNode::setPosition",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofNode::setPosition",1,"ofNode *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofNode::setPosition",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofNode::setPosition",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofNode::setPosition",4,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){
    SWIG_fail_ptr("Node_setPosition",1,SWIGTYPE_p_ofNode); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); (arg1)->setPosition(arg2,arg3,arg4); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Node_setPosition__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = (ofNode *) 0 ; glm::vec3 *arg2 = 0 ;
  SWIG_check_num_args("ofNode::setPosition",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofNode::setPosition",1,"ofNode *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofNode::setPosition",2,"glm::vec3 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){
    SWIG_fail_ptr("Node_setPosition",1,SWIGTYPE_p_ofNode); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("Node_setPosition",2,SWIGTYPE_p_glm__vec3); }  (arg1)->setPosition((glm::vec3 const &)*arg2); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Node_setPosition(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofNode, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Node_setPosition__SWIG_1(L);}  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofNode, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { {
            _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_Node_setPosition__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Node_setPosition'\n" "  Possible C/C++ prototypes are:\n"
  "    ofNode::setPosition(float,float,float)\n" "    ofNode::setPosition(glm::vec3 const &)\n"); lua_error(L);return 0; }
static int _wrap_Node_setGlobalPosition__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = (ofNode *) 0 ; float arg2 ;
  float arg3 ; float arg4 ; SWIG_check_num_args("ofNode::setGlobalPosition",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofNode::setGlobalPosition",1,"ofNode *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofNode::setGlobalPosition",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofNode::setGlobalPosition",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofNode::setGlobalPosition",4,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){
    SWIG_fail_ptr("Node_setGlobalPosition",1,SWIGTYPE_p_ofNode); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); (arg1)->setGlobalPosition(arg2,arg3,arg4);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Node_setGlobalPosition__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = (ofNode *) 0 ;
  glm::vec3 *arg2 = 0 ; SWIG_check_num_args("ofNode::setGlobalPosition",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofNode::setGlobalPosition",1,"ofNode *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofNode::setGlobalPosition",2,"glm::vec3 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){
    SWIG_fail_ptr("Node_setGlobalPosition",1,SWIGTYPE_p_ofNode); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("Node_setGlobalPosition",2,SWIGTYPE_p_glm__vec3); }  (arg1)->setGlobalPosition((glm::vec3 const &)*arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Node_setGlobalPosition(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L);
  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofNode, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Node_setGlobalPosition__SWIG_1(L);}  }  }  if (argc == 4) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofNode, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_Node_setGlobalPosition__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Node_setGlobalPosition'\n"
  "  Possible C/C++ prototypes are:\n" "    ofNode::setGlobalPosition(float,float,float)\n"
  "    ofNode::setGlobalPosition(glm::vec3 const &)\n"); lua_error(L);return 0; }
static int _wrap_Node_setOrientation__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = (ofNode *) 0 ;
  glm::quat *arg2 = 0 ; SWIG_check_num_args("ofNode::setOrientation",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofNode::setOrientation",1,"ofNode *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofNode::setOrientation",2,"glm::quat const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){
    SWIG_fail_ptr("Node_setOrientation",1,SWIGTYPE_p_ofNode); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__quat,0))){
    SWIG_fail_ptr("Node_setOrientation",2,SWIGTYPE_p_glm__quat); }  (arg1)->setOrientation((glm::quat const &)*arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Node_setOrientation__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = (ofNode *) 0 ;
  glm::vec3 *arg2 = 0 ; SWIG_check_num_args("ofNode::setOrientation",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofNode::setOrientation",1,"ofNode *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofNode::setOrientation",2,"glm::vec3 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){
    SWIG_fail_ptr("Node_setOrientation",1,SWIGTYPE_p_ofNode); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("Node_setOrientation",2,SWIGTYPE_p_glm__vec3); }  (arg1)->setOrientation((glm::vec3 const &)*arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Node_setOrientation(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofNode, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__quat, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Node_setOrientation__SWIG_0(L);}  }  }  if (argc == 2) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofNode, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Node_setOrientation__SWIG_1(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Node_setOrientation'\n"
  "  Possible C/C++ prototypes are:\n" "    ofNode::setOrientation(glm::quat const &)\n"
  "    ofNode::setOrientation(glm::vec3 const &)\n"); lua_error(L);return 0; }
static int _wrap_Node_setGlobalOrientation(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = (ofNode *) 0 ; glm::quat *arg2 = 0 ;
  SWIG_check_num_args("ofNode::setGlobalOrientation",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofNode::setGlobalOrientation",1,"ofNode *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofNode::setGlobalOrientation",2,"glm::quat const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){
    SWIG_fail_ptr("Node_setGlobalOrientation",1,SWIGTYPE_p_ofNode); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__quat,0))){
    SWIG_fail_ptr("Node_setGlobalOrientation",2,SWIGTYPE_p_glm__quat); } 
  (arg1)->setGlobalOrientation((glm::quat const &)*arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Node_setScale__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = (ofNode *) 0 ; float arg2 ;
  SWIG_check_num_args("ofNode::setScale",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofNode::setScale",1,"ofNode *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofNode::setScale",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){ SWIG_fail_ptr("Node_setScale",1,SWIGTYPE_p_ofNode); }
   arg2 = (float)lua_tonumber(L, 2); (arg1)->setScale(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Node_setScale__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = (ofNode *) 0 ; float arg2 ; float arg3 ;
  float arg4 ; SWIG_check_num_args("ofNode::setScale",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofNode::setScale",1,"ofNode *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofNode::setScale",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofNode::setScale",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofNode::setScale",4,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){ SWIG_fail_ptr("Node_setScale",1,SWIGTYPE_p_ofNode); }
   arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  (arg1)->setScale(arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Node_setScale__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = (ofNode *) 0 ; glm::vec3 *arg2 = 0 ;
  SWIG_check_num_args("ofNode::setScale",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofNode::setScale",1,"ofNode *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofNode::setScale",2,"glm::vec3 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){ SWIG_fail_ptr("Node_setScale",1,SWIGTYPE_p_ofNode); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("Node_setScale",2,SWIGTYPE_p_glm__vec3); }  (arg1)->setScale((glm::vec3 const &)*arg2); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Node_setScale(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofNode, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Node_setScale__SWIG_2(L);}  }  }  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofNode, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { return _wrap_Node_setScale__SWIG_0(L);}  }  } 
  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofNode, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { {
            _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_Node_setScale__SWIG_1(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Node_setScale'\n" "  Possible C/C++ prototypes are:\n"
  "    ofNode::setScale(float)\n" "    ofNode::setScale(float,float,float)\n" "    ofNode::setScale(glm::vec3 const &)\n");
  lua_error(L);return 0; }
static int _wrap_Node_move__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = (ofNode *) 0 ; float arg2 ; float arg3 ;
  float arg4 ; SWIG_check_num_args("ofNode::move",4,4) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofNode::move",1,"ofNode *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofNode::move",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofNode::move",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofNode::move",4,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){ SWIG_fail_ptr("Node_move",1,SWIGTYPE_p_ofNode); } 
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  (arg1)->move(arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Node_move__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = (ofNode *) 0 ; glm::vec3 *arg2 = 0 ;
  SWIG_check_num_args("ofNode::move",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofNode::move",1,"ofNode *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofNode::move",2,"glm::vec3 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){ SWIG_fail_ptr("Node_move",1,SWIGTYPE_p_ofNode); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("Node_move",2,SWIGTYPE_p_glm__vec3); }  (arg1)->move((glm::vec3 const &)*arg2); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Node_move(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L); if (argc == 2) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofNode, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Node_move__SWIG_1(L);}  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofNode, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { {
            _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_Node_move__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Node_move'\n" "  Possible C/C++ prototypes are:\n"
  "    ofNode::move(float,float,float)\n" "    ofNode::move(glm::vec3 const &)\n"); lua_error(L);return 0; }
static int _wrap_Node_truck(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = (ofNode *) 0 ; float arg2 ;
  SWIG_check_num_args("ofNode::truck",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofNode::truck",1,"ofNode *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofNode::truck",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){ SWIG_fail_ptr("Node_truck",1,SWIGTYPE_p_ofNode); } 
  arg2 = (float)lua_tonumber(L, 2); (arg1)->truck(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Node_boom(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = (ofNode *) 0 ; float arg2 ;
  SWIG_check_num_args("ofNode::boom",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofNode::boom",1,"ofNode *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofNode::boom",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){ SWIG_fail_ptr("Node_boom",1,SWIGTYPE_p_ofNode); } 
  arg2 = (float)lua_tonumber(L, 2); (arg1)->boom(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Node_dolly(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = (ofNode *) 0 ; float arg2 ;
  SWIG_check_num_args("ofNode::dolly",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofNode::dolly",1,"ofNode *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofNode::dolly",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){ SWIG_fail_ptr("Node_dolly",1,SWIGTYPE_p_ofNode); } 
  arg2 = (float)lua_tonumber(L, 2); (arg1)->dolly(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Node_tiltDeg(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = (ofNode *) 0 ; float arg2 ;
  SWIG_check_num_args("ofNode::tiltDeg",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofNode::tiltDeg",1,"ofNode *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofNode::tiltDeg",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){ SWIG_fail_ptr("Node_tiltDeg",1,SWIGTYPE_p_ofNode); } 
  arg2 = (float)lua_tonumber(L, 2); (arg1)->tiltDeg(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Node_tiltRad(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = (ofNode *) 0 ; float arg2 ;
  SWIG_check_num_args("ofNode::tiltRad",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofNode::tiltRad",1,"ofNode *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofNode::tiltRad",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){ SWIG_fail_ptr("Node_tiltRad",1,SWIGTYPE_p_ofNode); } 
  arg2 = (float)lua_tonumber(L, 2); (arg1)->tiltRad(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Node_panDeg(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = (ofNode *) 0 ; float arg2 ;
  SWIG_check_num_args("ofNode::panDeg",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofNode::panDeg",1,"ofNode *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofNode::panDeg",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){ SWIG_fail_ptr("Node_panDeg",1,SWIGTYPE_p_ofNode); } 
  arg2 = (float)lua_tonumber(L, 2); (arg1)->panDeg(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Node_panRad(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = (ofNode *) 0 ; float arg2 ;
  SWIG_check_num_args("ofNode::panRad",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofNode::panRad",1,"ofNode *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofNode::panRad",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){ SWIG_fail_ptr("Node_panRad",1,SWIGTYPE_p_ofNode); } 
  arg2 = (float)lua_tonumber(L, 2); (arg1)->panRad(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Node_rollDeg(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = (ofNode *) 0 ; float arg2 ;
  SWIG_check_num_args("ofNode::rollDeg",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofNode::rollDeg",1,"ofNode *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofNode::rollDeg",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){ SWIG_fail_ptr("Node_rollDeg",1,SWIGTYPE_p_ofNode); } 
  arg2 = (float)lua_tonumber(L, 2); (arg1)->rollDeg(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Node_rollRad(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = (ofNode *) 0 ; float arg2 ;
  SWIG_check_num_args("ofNode::rollRad",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofNode::rollRad",1,"ofNode *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofNode::rollRad",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){ SWIG_fail_ptr("Node_rollRad",1,SWIGTYPE_p_ofNode); } 
  arg2 = (float)lua_tonumber(L, 2); (arg1)->rollRad(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Node_rotateDeg__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = (ofNode *) 0 ; float arg2 ;
  glm::vec3 *arg3 = 0 ; SWIG_check_num_args("ofNode::rotateDeg",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofNode::rotateDeg",1,"ofNode *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofNode::rotateDeg",2,"float");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofNode::rotateDeg",3,"glm::vec3 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){ SWIG_fail_ptr("Node_rotateDeg",1,SWIGTYPE_p_ofNode); }
   arg2 = (float)lua_tonumber(L, 2); if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("Node_rotateDeg",3,SWIGTYPE_p_glm__vec3); }  (arg1)->rotateDeg(arg2,(glm::vec3 const &)*arg3);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Node_rotateRad__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = (ofNode *) 0 ; float arg2 ;
  glm::vec3 *arg3 = 0 ; SWIG_check_num_args("ofNode::rotateRad",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofNode::rotateRad",1,"ofNode *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofNode::rotateRad",2,"float");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofNode::rotateRad",3,"glm::vec3 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){ SWIG_fail_ptr("Node_rotateRad",1,SWIGTYPE_p_ofNode); }
   arg2 = (float)lua_tonumber(L, 2); if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("Node_rotateRad",3,SWIGTYPE_p_glm__vec3); }  (arg1)->rotateRad(arg2,(glm::vec3 const &)*arg3);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Node_rotateDeg__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = (ofNode *) 0 ; float arg2 ;
  float arg3 ; float arg4 ; float arg5 ; SWIG_check_num_args("ofNode::rotateDeg",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofNode::rotateDeg",1,"ofNode *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofNode::rotateDeg",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofNode::rotateDeg",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofNode::rotateDeg",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofNode::rotateDeg",5,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){ SWIG_fail_ptr("Node_rotateDeg",1,SWIGTYPE_p_ofNode); }
   arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  arg5 = (float)lua_tonumber(L, 5); (arg1)->rotateDeg(arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Node_rotateDeg(lua_State* L) { int argc; int argv[6]={ 1,2,3,4,5,6} ; argc = lua_gettop(L); if (argc == 3) {
    int _v; { void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofNode, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
           else { _v = 1; }  }  if (_v) { return _wrap_Node_rotateDeg__SWIG_0(L);}  }  }  }  if (argc == 5) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofNode, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) {
              return _wrap_Node_rotateDeg__SWIG_1(L);}  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Node_rotateDeg'\n" "  Possible C/C++ prototypes are:\n"
  "    ofNode::rotateDeg(float,glm::vec3 const &)\n" "    ofNode::rotateDeg(float,float,float,float)\n");
  lua_error(L);return 0; }
static int _wrap_Node_rotateRad__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = (ofNode *) 0 ; float arg2 ;
  float arg3 ; float arg4 ; float arg5 ; SWIG_check_num_args("ofNode::rotateRad",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofNode::rotateRad",1,"ofNode *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofNode::rotateRad",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofNode::rotateRad",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofNode::rotateRad",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofNode::rotateRad",5,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){ SWIG_fail_ptr("Node_rotateRad",1,SWIGTYPE_p_ofNode); }
   arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  arg5 = (float)lua_tonumber(L, 5); (arg1)->rotateRad(arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Node_rotateRad(lua_State* L) { int argc; int argv[6]={ 1,2,3,4,5,6} ; argc = lua_gettop(L); if (argc == 3) {
    int _v; { void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofNode, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
           else { _v = 1; }  }  if (_v) { return _wrap_Node_rotateRad__SWIG_0(L);}  }  }  }  if (argc == 5) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofNode, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) {
              return _wrap_Node_rotateRad__SWIG_1(L);}  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Node_rotateRad'\n" "  Possible C/C++ prototypes are:\n"
  "    ofNode::rotateRad(float,glm::vec3 const &)\n" "    ofNode::rotateRad(float,float,float,float)\n");
  lua_error(L);return 0; }
static int _wrap_Node_rotateAround(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = (ofNode *) 0 ; glm::quat *arg2 = 0 ;
  glm::vec3 *arg3 = 0 ; SWIG_check_num_args("ofNode::rotateAround",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofNode::rotateAround",1,"ofNode *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofNode::rotateAround",2,"glm::quat const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofNode::rotateAround",3,"glm::vec3 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){
    SWIG_fail_ptr("Node_rotateAround",1,SWIGTYPE_p_ofNode); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__quat,0))){
    SWIG_fail_ptr("Node_rotateAround",2,SWIGTYPE_p_glm__quat); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("Node_rotateAround",3,SWIGTYPE_p_glm__vec3); } 
  (arg1)->rotateAround((glm::quat const &)*arg2,(glm::vec3 const &)*arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Node_rotateAroundDeg(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = (ofNode *) 0 ; float arg2 ;
  glm::vec3 *arg3 = 0 ; glm::vec3 *arg4 = 0 ; SWIG_check_num_args("ofNode::rotateAroundDeg",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofNode::rotateAroundDeg",1,"ofNode *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofNode::rotateAroundDeg",2,"float");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofNode::rotateAroundDeg",3,"glm::vec3 const &");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("ofNode::rotateAroundDeg",4,"glm::vec3 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){
    SWIG_fail_ptr("Node_rotateAroundDeg",1,SWIGTYPE_p_ofNode); }  arg2 = (float)lua_tonumber(L, 2);
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("Node_rotateAroundDeg",3,SWIGTYPE_p_glm__vec3); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("Node_rotateAroundDeg",4,SWIGTYPE_p_glm__vec3); } 
  (arg1)->rotateAroundDeg(arg2,(glm::vec3 const &)*arg3,(glm::vec3 const &)*arg4); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Node_rotateAroundRad(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = (ofNode *) 0 ; float arg2 ;
  glm::vec3 *arg3 = 0 ; glm::vec3 *arg4 = 0 ; SWIG_check_num_args("ofNode::rotateAroundRad",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofNode::rotateAroundRad",1,"ofNode *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofNode::rotateAroundRad",2,"float");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofNode::rotateAroundRad",3,"glm::vec3 const &");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("ofNode::rotateAroundRad",4,"glm::vec3 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){
    SWIG_fail_ptr("Node_rotateAroundRad",1,SWIGTYPE_p_ofNode); }  arg2 = (float)lua_tonumber(L, 2);
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("Node_rotateAroundRad",3,SWIGTYPE_p_glm__vec3); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("Node_rotateAroundRad",4,SWIGTYPE_p_glm__vec3); } 
  (arg1)->rotateAroundRad(arg2,(glm::vec3 const &)*arg3,(glm::vec3 const &)*arg4); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Node_lookAt__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = (ofNode *) 0 ; glm::vec3 *arg2 = 0 ;
  SWIG_check_num_args("ofNode::lookAt",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofNode::lookAt",1,"ofNode *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofNode::lookAt",2,"glm::vec3 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){ SWIG_fail_ptr("Node_lookAt",1,SWIGTYPE_p_ofNode); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("Node_lookAt",2,SWIGTYPE_p_glm__vec3); }  (arg1)->lookAt((glm::vec3 const &)*arg2); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Node_lookAt__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = (ofNode *) 0 ; glm::vec3 *arg2 = 0 ;
  glm::vec3 arg3 ; glm::vec3 *argp3 ; SWIG_check_num_args("ofNode::lookAt",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofNode::lookAt",1,"ofNode *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofNode::lookAt",2,"glm::vec3 const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofNode::lookAt",3,"glm::vec3");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){ SWIG_fail_ptr("Node_lookAt",1,SWIGTYPE_p_ofNode); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("Node_lookAt",2,SWIGTYPE_p_glm__vec3); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("Node_lookAt",3,SWIGTYPE_p_glm__vec3); }  arg3 = *argp3; (arg1)->lookAt((glm::vec3 const &)*arg2,arg3);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Node_lookAt__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = (ofNode *) 0 ; ofNode *arg2 = 0 ;
  SWIG_check_num_args("ofNode::lookAt",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofNode::lookAt",1,"ofNode *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofNode::lookAt",2,"ofNode const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){ SWIG_fail_ptr("Node_lookAt",1,SWIGTYPE_p_ofNode); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofNode,0))){ SWIG_fail_ptr("Node_lookAt",2,SWIGTYPE_p_ofNode); } 
  (arg1)->lookAt((ofNode const &)*arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Node_lookAt__SWIG_3(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = (ofNode *) 0 ; ofNode *arg2 = 0 ;
  glm::vec3 *arg3 = 0 ; SWIG_check_num_args("ofNode::lookAt",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofNode::lookAt",1,"ofNode *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofNode::lookAt",2,"ofNode const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofNode::lookAt",3,"glm::vec3 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){ SWIG_fail_ptr("Node_lookAt",1,SWIGTYPE_p_ofNode); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofNode,0))){ SWIG_fail_ptr("Node_lookAt",2,SWIGTYPE_p_ofNode); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("Node_lookAt",3,SWIGTYPE_p_glm__vec3); }  (arg1)->lookAt((ofNode const &)*arg2,(glm::vec3 const &)*arg3);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Node_lookAt(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 2) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofNode, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Node_lookAt__SWIG_0(L);}  }  }  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofNode, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofNode, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Node_lookAt__SWIG_2(L);}  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofNode, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
           else { _v = 1; }  }  if (_v) { return _wrap_Node_lookAt__SWIG_1(L);}  }  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofNode, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofNode, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
           else { _v = 1; }  }  if (_v) { return _wrap_Node_lookAt__SWIG_3(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Node_lookAt'\n" "  Possible C/C++ prototypes are:\n"
  "    ofNode::lookAt(glm::vec3 const &)\n" "    ofNode::lookAt(glm::vec3 const &,glm::vec3)\n"
  "    ofNode::lookAt(ofNode const &)\n" "    ofNode::lookAt(ofNode const &,glm::vec3 const &)\n"); lua_error(L);return 0; }
static int _wrap_Node_orbitDeg__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = (ofNode *) 0 ; float arg2 ; float arg3 ;
  float arg4 ; glm::vec3 *arg5 = 0 ; SWIG_check_num_args("ofNode::orbitDeg",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofNode::orbitDeg",1,"ofNode *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofNode::orbitDeg",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofNode::orbitDeg",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofNode::orbitDeg",4,"float");
  if(!lua_isuserdata(L,5)) SWIG_fail_arg("ofNode::orbitDeg",5,"glm::vec3 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){ SWIG_fail_ptr("Node_orbitDeg",1,SWIGTYPE_p_ofNode); }
   arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&arg5,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("Node_orbitDeg",5,SWIGTYPE_p_glm__vec3); }  (arg1)->orbitDeg(arg2,arg3,arg4,(glm::vec3 const &)*arg5);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Node_orbitDeg__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = (ofNode *) 0 ; float arg2 ; float arg3 ;
  float arg4 ; SWIG_check_num_args("ofNode::orbitDeg",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofNode::orbitDeg",1,"ofNode *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofNode::orbitDeg",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofNode::orbitDeg",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofNode::orbitDeg",4,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){ SWIG_fail_ptr("Node_orbitDeg",1,SWIGTYPE_p_ofNode); }
   arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  (arg1)->orbitDeg(arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Node_orbitDeg__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = (ofNode *) 0 ; float arg2 ; float arg3 ;
  float arg4 ; ofNode *arg5 = 0 ; SWIG_check_num_args("ofNode::orbitDeg",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofNode::orbitDeg",1,"ofNode *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofNode::orbitDeg",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofNode::orbitDeg",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofNode::orbitDeg",4,"float");
  if(!lua_isuserdata(L,5)) SWIG_fail_arg("ofNode::orbitDeg",5,"ofNode &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){ SWIG_fail_ptr("Node_orbitDeg",1,SWIGTYPE_p_ofNode); }
   arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&arg5,SWIGTYPE_p_ofNode,0))){ SWIG_fail_ptr("Node_orbitDeg",5,SWIGTYPE_p_ofNode); }
   (arg1)->orbitDeg(arg2,arg3,arg4,*arg5); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Node_orbitDeg(lua_State* L) { int argc; int argv[6]={ 1,2,3,4,5,6} ; argc = lua_gettop(L); if (argc == 4) {
    int _v; { void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofNode, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_Node_orbitDeg__SWIG_1(L);}  }  }  }  } 
  if (argc == 5) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofNode, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { {
            _v = lua_isnumber(L,argv[3]); }  if (_v) { { void *ptr;
              if (lua_isuserdata(L,argv[4])==0 || SWIG_ConvertPtr(L,argv[4], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) {
                _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Node_orbitDeg__SWIG_0(L);}  }  }  }  }  } 
  if (argc == 5) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofNode, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { {
            _v = lua_isnumber(L,argv[3]); }  if (_v) { { void *ptr;
              if (lua_isuserdata(L,argv[4])==0 || SWIG_ConvertPtr(L,argv[4], (void **) &ptr, SWIGTYPE_p_ofNode, 0)) { _v = 0; }
               else { _v = 1; }  }  if (_v) { return _wrap_Node_orbitDeg__SWIG_2(L);}  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Node_orbitDeg'\n" "  Possible C/C++ prototypes are:\n"
  "    ofNode::orbitDeg(float,float,float,glm::vec3 const &)\n" "    ofNode::orbitDeg(float,float,float)\n"
  "    ofNode::orbitDeg(float,float,float,ofNode &)\n"); lua_error(L);return 0; }
static int _wrap_Node_orbitRad__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = (ofNode *) 0 ; float arg2 ; float arg3 ;
  float arg4 ; glm::vec3 *arg5 = 0 ; SWIG_check_num_args("ofNode::orbitRad",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofNode::orbitRad",1,"ofNode *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofNode::orbitRad",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofNode::orbitRad",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofNode::orbitRad",4,"float");
  if(!lua_isuserdata(L,5)) SWIG_fail_arg("ofNode::orbitRad",5,"glm::vec3 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){ SWIG_fail_ptr("Node_orbitRad",1,SWIGTYPE_p_ofNode); }
   arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&arg5,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("Node_orbitRad",5,SWIGTYPE_p_glm__vec3); }  (arg1)->orbitRad(arg2,arg3,arg4,(glm::vec3 const &)*arg5);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Node_orbitRad__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = (ofNode *) 0 ; float arg2 ; float arg3 ;
  float arg4 ; SWIG_check_num_args("ofNode::orbitRad",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofNode::orbitRad",1,"ofNode *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofNode::orbitRad",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofNode::orbitRad",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofNode::orbitRad",4,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){ SWIG_fail_ptr("Node_orbitRad",1,SWIGTYPE_p_ofNode); }
   arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  (arg1)->orbitRad(arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Node_orbitRad__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = (ofNode *) 0 ; float arg2 ; float arg3 ;
  float arg4 ; ofNode *arg5 = 0 ; SWIG_check_num_args("ofNode::orbitRad",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofNode::orbitRad",1,"ofNode *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofNode::orbitRad",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofNode::orbitRad",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofNode::orbitRad",4,"float");
  if(!lua_isuserdata(L,5)) SWIG_fail_arg("ofNode::orbitRad",5,"ofNode &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){ SWIG_fail_ptr("Node_orbitRad",1,SWIGTYPE_p_ofNode); }
   arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&arg5,SWIGTYPE_p_ofNode,0))){ SWIG_fail_ptr("Node_orbitRad",5,SWIGTYPE_p_ofNode); }
   (arg1)->orbitRad(arg2,arg3,arg4,*arg5); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Node_orbitRad(lua_State* L) { int argc; int argv[6]={ 1,2,3,4,5,6} ; argc = lua_gettop(L); if (argc == 4) {
    int _v; { void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofNode, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_Node_orbitRad__SWIG_1(L);}  }  }  }  } 
  if (argc == 5) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofNode, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { {
            _v = lua_isnumber(L,argv[3]); }  if (_v) { { void *ptr;
              if (lua_isuserdata(L,argv[4])==0 || SWIG_ConvertPtr(L,argv[4], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) {
                _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Node_orbitRad__SWIG_0(L);}  }  }  }  }  } 
  if (argc == 5) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofNode, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { {
            _v = lua_isnumber(L,argv[3]); }  if (_v) { { void *ptr;
              if (lua_isuserdata(L,argv[4])==0 || SWIG_ConvertPtr(L,argv[4], (void **) &ptr, SWIGTYPE_p_ofNode, 0)) { _v = 0; }
               else { _v = 1; }  }  if (_v) { return _wrap_Node_orbitRad__SWIG_2(L);}  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Node_orbitRad'\n" "  Possible C/C++ prototypes are:\n"
  "    ofNode::orbitRad(float,float,float,glm::vec3 const &)\n" "    ofNode::orbitRad(float,float,float)\n"
  "    ofNode::orbitRad(float,float,float,ofNode &)\n"); lua_error(L);return 0; }
static int _wrap_Node_transformGL__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = (ofNode *) 0 ;
  ofBaseRenderer *arg2 = (ofBaseRenderer *) 0 ; SWIG_check_num_args("ofNode::transformGL",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofNode::transformGL",1,"ofNode const *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofNode::transformGL",2,"ofBaseRenderer *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){
    SWIG_fail_ptr("Node_transformGL",1,SWIGTYPE_p_ofNode); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofBaseRenderer,0))){
    SWIG_fail_ptr("Node_transformGL",2,SWIGTYPE_p_ofBaseRenderer); }  ((ofNode const *)arg1)->transformGL(arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Node_transformGL__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = (ofNode *) 0 ;
  SWIG_check_num_args("ofNode::transformGL",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofNode::transformGL",1,"ofNode const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){
    SWIG_fail_ptr("Node_transformGL",1,SWIGTYPE_p_ofNode); }  ((ofNode const *)arg1)->transformGL(); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Node_transformGL(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 1) {
    int _v; { void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofNode, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Node_transformGL__SWIG_1(L);}  }  if (argc == 2) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofNode, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofBaseRenderer, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Node_transformGL__SWIG_0(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Node_transformGL'\n" "  Possible C/C++ prototypes are:\n"
  "    ofNode::transformGL(ofBaseRenderer *) const\n" "    ofNode::transformGL() const\n"); lua_error(L);return 0; }
static int _wrap_Node_restoreTransformGL__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = (ofNode *) 0 ;
  ofBaseRenderer *arg2 = (ofBaseRenderer *) 0 ; SWIG_check_num_args("ofNode::restoreTransformGL",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofNode::restoreTransformGL",1,"ofNode const *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofNode::restoreTransformGL",2,"ofBaseRenderer *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){
    SWIG_fail_ptr("Node_restoreTransformGL",1,SWIGTYPE_p_ofNode); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofBaseRenderer,0))){
    SWIG_fail_ptr("Node_restoreTransformGL",2,SWIGTYPE_p_ofBaseRenderer); }  ((ofNode const *)arg1)->restoreTransformGL(arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Node_restoreTransformGL__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = (ofNode *) 0 ;
  SWIG_check_num_args("ofNode::restoreTransformGL",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofNode::restoreTransformGL",1,"ofNode const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){
    SWIG_fail_ptr("Node_restoreTransformGL",1,SWIGTYPE_p_ofNode); }  ((ofNode const *)arg1)->restoreTransformGL();
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Node_restoreTransformGL(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 1) {
    int _v; { void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofNode, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Node_restoreTransformGL__SWIG_1(L);}  }  if (argc == 2) { int _v;
    { void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofNode, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofBaseRenderer, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Node_restoreTransformGL__SWIG_0(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Node_restoreTransformGL'\n"
  "  Possible C/C++ prototypes are:\n" "    ofNode::restoreTransformGL(ofBaseRenderer *) const\n"
  "    ofNode::restoreTransformGL() const\n"); lua_error(L);return 0; }
static int _wrap_Node_resetTransform(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = (ofNode *) 0 ;
  SWIG_check_num_args("ofNode::resetTransform",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofNode::resetTransform",1,"ofNode *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){
    SWIG_fail_ptr("Node_resetTransform",1,SWIGTYPE_p_ofNode); }  (arg1)->resetTransform(); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Node_customDraw__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = (ofNode *) 0 ;
  ofBaseRenderer *arg2 = (ofBaseRenderer *) 0 ; SWIG_check_num_args("ofNode::customDraw",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofNode::customDraw",1,"ofNode const *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofNode::customDraw",2,"ofBaseRenderer const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){
    SWIG_fail_ptr("Node_customDraw",1,SWIGTYPE_p_ofNode); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofBaseRenderer,0))){
    SWIG_fail_ptr("Node_customDraw",2,SWIGTYPE_p_ofBaseRenderer); } 
  ((ofNode const *)arg1)->customDraw((ofBaseRenderer const *)arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Node_customDraw__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = (ofNode *) 0 ;
  SWIG_check_num_args("ofNode::customDraw",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofNode::customDraw",1,"ofNode *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){
    SWIG_fail_ptr("Node_customDraw",1,SWIGTYPE_p_ofNode); }  (arg1)->customDraw(); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Node_customDraw(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 1) { int _v;
    { void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofNode, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Node_customDraw__SWIG_1(L);}  }  if (argc == 2) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofNode, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofBaseRenderer, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Node_customDraw__SWIG_0(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Node_customDraw'\n" "  Possible C/C++ prototypes are:\n"
  "    ofNode::customDraw(ofBaseRenderer const *) const\n" "    ofNode::customDraw()\n"); lua_error(L);return 0; }
static int _wrap_Node_draw(lua_State* L) { int SWIG_arg = 0; ofNode *arg1 = (ofNode *) 0 ;
  SWIG_check_num_args("ofNode::draw",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofNode::draw",1,"ofNode const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofNode,0))){ SWIG_fail_ptr("Node_draw",1,SWIGTYPE_p_ofNode); } 
  ((ofNode const *)arg1)->draw(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static void swig_delete_Node(void *obj) {
ofNode *arg1 = (ofNode *) obj;
delete arg1;
}
static int _proxy__wrap_new_Node(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_Node);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_Node_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_Node_methods[]= {
    { "setParent", _wrap_Node_setParent},
    { "clearParent", _wrap_Node_clearParent},
    { "getParent", _wrap_Node_getParent},
    { "getPosition", _wrap_Node_getPosition},
    { "getX", _wrap_Node_getX},
    { "getY", _wrap_Node_getY},
    { "getZ", _wrap_Node_getZ},
    { "getXAxis", _wrap_Node_getXAxis},
    { "getYAxis", _wrap_Node_getYAxis},
    { "getZAxis", _wrap_Node_getZAxis},
    { "getSideDir", _wrap_Node_getSideDir},
    { "getLookAtDir", _wrap_Node_getLookAtDir},
    { "getUpDir", _wrap_Node_getUpDir},
    { "getPitchDeg", _wrap_Node_getPitchDeg},
    { "getHeadingDeg", _wrap_Node_getHeadingDeg},
    { "getRollDeg", _wrap_Node_getRollDeg},
    { "getPitchRad", _wrap_Node_getPitchRad},
    { "getHeadingRad", _wrap_Node_getHeadingRad},
    { "getRollRad", _wrap_Node_getRollRad},
    { "getOrientationQuat", _wrap_Node_getOrientationQuat},
    { "getOrientationEulerDeg", _wrap_Node_getOrientationEulerDeg},
    { "getOrientationEulerRad", _wrap_Node_getOrientationEulerRad},
    { "getScale", _wrap_Node_getScale},
    { "getLocalTransformMatrix", _wrap_Node_getLocalTransformMatrix},
    { "getGlobalTransformMatrix", _wrap_Node_getGlobalTransformMatrix},
    { "getGlobalPosition", _wrap_Node_getGlobalPosition},
    { "getGlobalOrientation", _wrap_Node_getGlobalOrientation},
    { "getGlobalScale", _wrap_Node_getGlobalScale},
    { "setPosition", _wrap_Node_setPosition},
    { "setGlobalPosition", _wrap_Node_setGlobalPosition},
    { "setOrientation", _wrap_Node_setOrientation},
    { "setGlobalOrientation", _wrap_Node_setGlobalOrientation},
    { "setScale", _wrap_Node_setScale},
    { "move", _wrap_Node_move},
    { "truck", _wrap_Node_truck},
    { "boom", _wrap_Node_boom},
    { "dolly", _wrap_Node_dolly},
    { "tiltDeg", _wrap_Node_tiltDeg},
    { "tiltRad", _wrap_Node_tiltRad},
    { "panDeg", _wrap_Node_panDeg},
    { "panRad", _wrap_Node_panRad},
    { "rollDeg", _wrap_Node_rollDeg},
    { "rollRad", _wrap_Node_rollRad},
    { "rotateDeg", _wrap_Node_rotateDeg},
    { "rotateRad", _wrap_Node_rotateRad},
    { "rotateAround", _wrap_Node_rotateAround},
    { "rotateAroundDeg", _wrap_Node_rotateAroundDeg},
    { "rotateAroundRad", _wrap_Node_rotateAroundRad},
    { "lookAt", _wrap_Node_lookAt},
    { "orbitDeg", _wrap_Node_orbitDeg},
    { "orbitRad", _wrap_Node_orbitRad},
    { "transformGL", _wrap_Node_transformGL},
    { "restoreTransformGL", _wrap_Node_restoreTransformGL},
    { "resetTransform", _wrap_Node_resetTransform},
    { "customDraw", _wrap_Node_customDraw},
    { "draw", _wrap_Node_draw},
    {0,0}
};
static swig_lua_method swig_Node_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_Node_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_Node_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_Node_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_Node_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_Node_Sf_SwigStatic = {
    "Node",
    swig_Node_Sf_SwigStatic_methods,
    swig_Node_Sf_SwigStatic_attributes,
    swig_Node_Sf_SwigStatic_constants,
    swig_Node_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_Node_bases[] = {0};
static const char *swig_Node_base_names[] = {0};
static swig_lua_class _wrap_class_Node = { "Node", "Node", &SWIGTYPE_p_ofNode,_proxy__wrap_new_Node, swig_delete_Node, swig_Node_methods, swig_Node_attributes, &swig_Node_Sf_SwigStatic, swig_Node_meta, swig_Node_bases, swig_Node_base_names };

static int _wrap_drawAxis(lua_State* L) { int SWIG_arg = 0; float arg1 ; SWIG_check_num_args("ofDrawAxis",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofDrawAxis",1,"float"); arg1 = (float)lua_tonumber(L, 1); ofDrawAxis(arg1);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_drawGrid__SWIG_0(lua_State* L) { int SWIG_arg = 0; float arg1 ; size_t arg2 ; bool arg3 ; bool arg4 ;
  bool arg5 ; bool arg6 ; SWIG_check_num_args("ofDrawGrid",6,6) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofDrawGrid",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofDrawGrid",2,"size_t"); if(!lua_isboolean(L,3)) SWIG_fail_arg("ofDrawGrid",3,"bool");
  if(!lua_isboolean(L,4)) SWIG_fail_arg("ofDrawGrid",4,"bool"); if(!lua_isboolean(L,5)) SWIG_fail_arg("ofDrawGrid",5,"bool");
  if(!lua_isboolean(L,6)) SWIG_fail_arg("ofDrawGrid",6,"bool"); arg1 = (float)lua_tonumber(L, 1);
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (size_t)lua_tonumber(L, 2);
  arg3 = (lua_toboolean(L, 3)!=0); arg4 = (lua_toboolean(L, 4)!=0); arg5 = (lua_toboolean(L, 5)!=0);
  arg6 = (lua_toboolean(L, 6)!=0); ofDrawGrid(arg1,arg2,arg3,arg4,arg5,arg6); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_drawGrid__SWIG_1(lua_State* L) { int SWIG_arg = 0; float arg1 ; size_t arg2 ; bool arg3 ; bool arg4 ;
  bool arg5 ; SWIG_check_num_args("ofDrawGrid",5,5) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofDrawGrid",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofDrawGrid",2,"size_t"); if(!lua_isboolean(L,3)) SWIG_fail_arg("ofDrawGrid",3,"bool");
  if(!lua_isboolean(L,4)) SWIG_fail_arg("ofDrawGrid",4,"bool"); if(!lua_isboolean(L,5)) SWIG_fail_arg("ofDrawGrid",5,"bool");
  arg1 = (float)lua_tonumber(L, 1); SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2); arg3 = (lua_toboolean(L, 3)!=0); arg4 = (lua_toboolean(L, 4)!=0);
  arg5 = (lua_toboolean(L, 5)!=0); ofDrawGrid(arg1,arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_drawGrid__SWIG_2(lua_State* L) { int SWIG_arg = 0; float arg1 ; size_t arg2 ; bool arg3 ; bool arg4 ;
  SWIG_check_num_args("ofDrawGrid",4,4) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofDrawGrid",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofDrawGrid",2,"size_t"); if(!lua_isboolean(L,3)) SWIG_fail_arg("ofDrawGrid",3,"bool");
  if(!lua_isboolean(L,4)) SWIG_fail_arg("ofDrawGrid",4,"bool"); arg1 = (float)lua_tonumber(L, 1);
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (size_t)lua_tonumber(L, 2);
  arg3 = (lua_toboolean(L, 3)!=0); arg4 = (lua_toboolean(L, 4)!=0); ofDrawGrid(arg1,arg2,arg3,arg4); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_drawGrid__SWIG_3(lua_State* L) { int SWIG_arg = 0; float arg1 ; size_t arg2 ; bool arg3 ;
  SWIG_check_num_args("ofDrawGrid",3,3) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofDrawGrid",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofDrawGrid",2,"size_t"); if(!lua_isboolean(L,3)) SWIG_fail_arg("ofDrawGrid",3,"bool");
  arg1 = (float)lua_tonumber(L, 1); SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (size_t)lua_tonumber(L, 2); arg3 = (lua_toboolean(L, 3)!=0); ofDrawGrid(arg1,arg2,arg3); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_drawGrid__SWIG_4(lua_State* L) { int SWIG_arg = 0; float arg1 ; size_t arg2 ;
  SWIG_check_num_args("ofDrawGrid",2,2) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofDrawGrid",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofDrawGrid",2,"size_t"); arg1 = (float)lua_tonumber(L, 1);
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (size_t)lua_tonumber(L, 2);
  ofDrawGrid(arg1,arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_drawGrid__SWIG_5(lua_State* L) { int SWIG_arg = 0; float arg1 ; SWIG_check_num_args("ofDrawGrid",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofDrawGrid",1,"float"); arg1 = (float)lua_tonumber(L, 1); ofDrawGrid(arg1);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_drawGrid__SWIG_6(lua_State* L) { int SWIG_arg = 0; SWIG_check_num_args("ofDrawGrid",0,0) ofDrawGrid();
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_drawGrid(lua_State* L) { int argc; int argv[7]={ 1,2,3,4,5,6,7} ; argc = lua_gettop(L); if (argc == 0) {
    return _wrap_drawGrid__SWIG_6(L);}  if (argc == 1) { int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) {
      return _wrap_drawGrid__SWIG_5(L);}  }  if (argc == 2) { int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { {
        _v = lua_isnumber(L,argv[1]); }  if (_v) { return _wrap_drawGrid__SWIG_4(L);}  }  }  if (argc == 3) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isboolean(L,argv[2]); }
         if (_v) { return _wrap_drawGrid__SWIG_3(L);}  }  }  }  if (argc == 4) { int _v; { _v = lua_isnumber(L,argv[0]); } 
    if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isboolean(L,argv[2]); }  if (_v) { {
            _v = lua_isboolean(L,argv[3]); }  if (_v) { return _wrap_drawGrid__SWIG_2(L);}  }  }  }  }  if (argc == 5) { int _v;
    { _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isboolean(L,argv[2]); }
         if (_v) { { _v = lua_isboolean(L,argv[3]); }  if (_v) { { _v = lua_isboolean(L,argv[4]); }  if (_v) {
              return _wrap_drawGrid__SWIG_1(L);}  }  }  }  }  }  if (argc == 6) { int _v; { _v = lua_isnumber(L,argv[0]); } 
    if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isboolean(L,argv[2]); }  if (_v) { {
            _v = lua_isboolean(L,argv[3]); }  if (_v) { { _v = lua_isboolean(L,argv[4]); }  if (_v) { {
                _v = lua_isboolean(L,argv[5]); }  if (_v) { return _wrap_drawGrid__SWIG_0(L);}  }  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'drawGrid'\n" "  Possible C/C++ prototypes are:\n"
  "    ofDrawGrid(float,size_t,bool,bool,bool,bool)\n" "    ofDrawGrid(float,size_t,bool,bool,bool)\n"
  "    ofDrawGrid(float,size_t,bool,bool)\n" "    ofDrawGrid(float,size_t,bool)\n" "    ofDrawGrid(float,size_t)\n"
  "    ofDrawGrid(float)\n" "    ofDrawGrid()\n"); lua_error(L);return 0; }
static int _wrap_drawGridPlane__SWIG_0(lua_State* L) { int SWIG_arg = 0; float arg1 ; size_t arg2 ; bool arg3 ;
  SWIG_check_num_args("ofDrawGridPlane",3,3) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofDrawGridPlane",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofDrawGridPlane",2,"size_t");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("ofDrawGridPlane",3,"bool"); arg1 = (float)lua_tonumber(L, 1);
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (size_t)lua_tonumber(L, 2);
  arg3 = (lua_toboolean(L, 3)!=0); ofDrawGridPlane(arg1,arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_drawGridPlane__SWIG_1(lua_State* L) { int SWIG_arg = 0; float arg1 ; size_t arg2 ;
  SWIG_check_num_args("ofDrawGridPlane",2,2) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofDrawGridPlane",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofDrawGridPlane",2,"size_t"); arg1 = (float)lua_tonumber(L, 1);
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (size_t)lua_tonumber(L, 2);
  ofDrawGridPlane(arg1,arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_drawGridPlane__SWIG_2(lua_State* L) { int SWIG_arg = 0; float arg1 ; SWIG_check_num_args("ofDrawGridPlane",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofDrawGridPlane",1,"float"); arg1 = (float)lua_tonumber(L, 1); ofDrawGridPlane(arg1);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_drawGridPlane__SWIG_3(lua_State* L) { int SWIG_arg = 0; SWIG_check_num_args("ofDrawGridPlane",0,0)
  ofDrawGridPlane(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_drawGridPlane(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 0) {
    return _wrap_drawGridPlane__SWIG_3(L);}  if (argc == 1) { int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) {
      return _wrap_drawGridPlane__SWIG_2(L);}  }  if (argc == 2) { int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { {
        _v = lua_isnumber(L,argv[1]); }  if (_v) { return _wrap_drawGridPlane__SWIG_1(L);}  }  }  if (argc == 3) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isboolean(L,argv[2]); }
         if (_v) { return _wrap_drawGridPlane__SWIG_0(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'drawGridPlane'\n" "  Possible C/C++ prototypes are:\n"
  "    ofDrawGridPlane(float,size_t,bool)\n" "    ofDrawGridPlane(float,size_t)\n" "    ofDrawGridPlane(float)\n"
  "    ofDrawGridPlane()\n"); lua_error(L);return 0; }
static int _wrap_drawArrow__SWIG_0(lua_State* L) { int SWIG_arg = 0; glm::vec3 *arg1 = 0 ; glm::vec3 *arg2 = 0 ; float arg3 ;
  SWIG_check_num_args("ofDrawArrow",3,3) if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofDrawArrow",1,"glm::vec3 const &");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofDrawArrow",2,"glm::vec3 const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofDrawArrow",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("drawArrow",1,SWIGTYPE_p_glm__vec3); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("drawArrow",2,SWIGTYPE_p_glm__vec3); }  arg3 = (float)lua_tonumber(L, 3);
  ofDrawArrow((glm::vec3 const &)*arg1,(glm::vec3 const &)*arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_drawArrow__SWIG_1(lua_State* L) { int SWIG_arg = 0; glm::vec3 *arg1 = 0 ; glm::vec3 *arg2 = 0 ;
  SWIG_check_num_args("ofDrawArrow",2,2) if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofDrawArrow",1,"glm::vec3 const &");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofDrawArrow",2,"glm::vec3 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("drawArrow",1,SWIGTYPE_p_glm__vec3); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("drawArrow",2,SWIGTYPE_p_glm__vec3); }  ofDrawArrow((glm::vec3 const &)*arg1,(glm::vec3 const &)*arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_drawArrow(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 2) { int _v; {
      void *ptr; if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_drawArrow__SWIG_1(L);}  }  }  if (argc == 3) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { return _wrap_drawArrow__SWIG_0(L);}  }  }  }
   SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'drawArrow'\n" "  Possible C/C++ prototypes are:\n"
  "    ofDrawArrow(glm::vec3 const &,glm::vec3 const &,float)\n" "    ofDrawArrow(glm::vec3 const &,glm::vec3 const &)\n");
  lua_error(L);return 0; }
static int _wrap_drawRotationAxes__SWIG_0(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; int arg3 ;
  SWIG_check_num_args("ofDrawRotationAxes",3,3) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofDrawRotationAxes",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofDrawRotationAxes",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofDrawRotationAxes",3,"int"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (int)lua_tonumber(L, 3); ofDrawRotationAxes(arg1,arg2,arg3); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_drawRotationAxes__SWIG_1(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ;
  SWIG_check_num_args("ofDrawRotationAxes",2,2) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofDrawRotationAxes",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofDrawRotationAxes",2,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); ofDrawRotationAxes(arg1,arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_drawRotationAxes__SWIG_2(lua_State* L) { int SWIG_arg = 0; float arg1 ;
  SWIG_check_num_args("ofDrawRotationAxes",1,1) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofDrawRotationAxes",1,"float");
  arg1 = (float)lua_tonumber(L, 1); ofDrawRotationAxes(arg1); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_drawRotationAxes(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 1) {
    int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { return _wrap_drawRotationAxes__SWIG_2(L);}  }  if (argc == 2) { int _v;
    { _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_drawRotationAxes__SWIG_1(L);}  }  }  if (argc == 3) { int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) {
      { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_drawRotationAxes__SWIG_0(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'drawRotationAxes'\n" "  Possible C/C++ prototypes are:\n"
  "    ofDrawRotationAxes(float,float,int)\n" "    ofDrawRotationAxes(float,float)\n" "    ofDrawRotationAxes(float)\n");
  lua_error(L);return 0; }
static int _wrap_new_Camera(lua_State* L) { int SWIG_arg = 0; ofCamera *result = 0 ;
  SWIG_check_num_args("ofCamera::ofCamera",0,0) result = (ofCamera *)new ofCamera();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofCamera,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Camera_setFov(lua_State* L) { int SWIG_arg = 0; ofCamera *arg1 = (ofCamera *) 0 ; float arg2 ;
  SWIG_check_num_args("ofCamera::setFov",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofCamera::setFov",1,"ofCamera *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofCamera::setFov",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofCamera,0))){
    SWIG_fail_ptr("Camera_setFov",1,SWIGTYPE_p_ofCamera); }  arg2 = (float)lua_tonumber(L, 2); (arg1)->setFov(arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Camera_setNearClip(lua_State* L) { int SWIG_arg = 0; ofCamera *arg1 = (ofCamera *) 0 ; float arg2 ;
  SWIG_check_num_args("ofCamera::setNearClip",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofCamera::setNearClip",1,"ofCamera *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofCamera::setNearClip",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofCamera,0))){
    SWIG_fail_ptr("Camera_setNearClip",1,SWIGTYPE_p_ofCamera); }  arg2 = (float)lua_tonumber(L, 2); (arg1)->setNearClip(arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Camera_setFarClip(lua_State* L) { int SWIG_arg = 0; ofCamera *arg1 = (ofCamera *) 0 ; float arg2 ;
  SWIG_check_num_args("ofCamera::setFarClip",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofCamera::setFarClip",1,"ofCamera *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofCamera::setFarClip",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofCamera,0))){
    SWIG_fail_ptr("Camera_setFarClip",1,SWIGTYPE_p_ofCamera); }  arg2 = (float)lua_tonumber(L, 2); (arg1)->setFarClip(arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Camera_setLensOffset(lua_State* L) { int SWIG_arg = 0; ofCamera *arg1 = (ofCamera *) 0 ; glm::vec2 *arg2 = 0 ;
  SWIG_check_num_args("ofCamera::setLensOffset",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofCamera::setLensOffset",1,"ofCamera *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofCamera::setLensOffset",2,"glm::vec2 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofCamera,0))){
    SWIG_fail_ptr("Camera_setLensOffset",1,SWIGTYPE_p_ofCamera); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec2,0))){
    SWIG_fail_ptr("Camera_setLensOffset",2,SWIGTYPE_p_glm__vec2); }  (arg1)->setLensOffset((glm::vec2 const &)*arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Camera_setAspectRatio(lua_State* L) { int SWIG_arg = 0; ofCamera *arg1 = (ofCamera *) 0 ; float arg2 ;
  SWIG_check_num_args("ofCamera::setAspectRatio",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofCamera::setAspectRatio",1,"ofCamera *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofCamera::setAspectRatio",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofCamera,0))){
    SWIG_fail_ptr("Camera_setAspectRatio",1,SWIGTYPE_p_ofCamera); }  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setAspectRatio(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Camera_setForceAspectRatio(lua_State* L) { int SWIG_arg = 0; ofCamera *arg1 = (ofCamera *) 0 ; bool arg2 ;
  SWIG_check_num_args("ofCamera::setForceAspectRatio",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofCamera::setForceAspectRatio",1,"ofCamera *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofCamera::setForceAspectRatio",2,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofCamera,0))){
    SWIG_fail_ptr("Camera_setForceAspectRatio",1,SWIGTYPE_p_ofCamera); }  arg2 = (lua_toboolean(L, 2)!=0);
  (arg1)->setForceAspectRatio(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Camera_getFov(lua_State* L) { int SWIG_arg = 0; ofCamera *arg1 = (ofCamera *) 0 ; float result;
  SWIG_check_num_args("ofCamera::getFov",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofCamera::getFov",1,"ofCamera const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofCamera,0))){
    SWIG_fail_ptr("Camera_getFov",1,SWIGTYPE_p_ofCamera); }  result = (float)((ofCamera const *)arg1)->getFov();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Camera_getNearClip(lua_State* L) { int SWIG_arg = 0; ofCamera *arg1 = (ofCamera *) 0 ; float result;
  SWIG_check_num_args("ofCamera::getNearClip",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofCamera::getNearClip",1,"ofCamera const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofCamera,0))){
    SWIG_fail_ptr("Camera_getNearClip",1,SWIGTYPE_p_ofCamera); }  result = (float)((ofCamera const *)arg1)->getNearClip();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Camera_getFarClip(lua_State* L) { int SWIG_arg = 0; ofCamera *arg1 = (ofCamera *) 0 ; float result;
  SWIG_check_num_args("ofCamera::getFarClip",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofCamera::getFarClip",1,"ofCamera const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofCamera,0))){
    SWIG_fail_ptr("Camera_getFarClip",1,SWIGTYPE_p_ofCamera); }  result = (float)((ofCamera const *)arg1)->getFarClip();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Camera_getLensOffset(lua_State* L) { int SWIG_arg = 0; ofCamera *arg1 = (ofCamera *) 0 ; glm::vec2 result;
  SWIG_check_num_args("ofCamera::getLensOffset",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofCamera::getLensOffset",1,"ofCamera const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofCamera,0))){
    SWIG_fail_ptr("Camera_getLensOffset",1,SWIGTYPE_p_ofCamera); }  result = ((ofCamera const *)arg1)->getLensOffset(); {
    glm::vec2 * resultptr = new glm::vec2((const glm::vec2 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_glm__vec2,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Camera_getForceAspectRatio(lua_State* L) { int SWIG_arg = 0; ofCamera *arg1 = (ofCamera *) 0 ; bool result;
  SWIG_check_num_args("ofCamera::getForceAspectRatio",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofCamera::getForceAspectRatio",1,"ofCamera const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofCamera,0))){
    SWIG_fail_ptr("Camera_getForceAspectRatio",1,SWIGTYPE_p_ofCamera); } 
  result = (bool)((ofCamera const *)arg1)->getForceAspectRatio(); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Camera_getAspectRatio(lua_State* L) { int SWIG_arg = 0; ofCamera *arg1 = (ofCamera *) 0 ; float result;
  SWIG_check_num_args("ofCamera::getAspectRatio",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofCamera::getAspectRatio",1,"ofCamera const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofCamera,0))){
    SWIG_fail_ptr("Camera_getAspectRatio",1,SWIGTYPE_p_ofCamera); }  result = (float)((ofCamera const *)arg1)->getAspectRatio();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Camera_setupPerspective__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofCamera *arg1 = (ofCamera *) 0 ; bool arg2 ;
  float arg3 ; float arg4 ; float arg5 ; glm::vec2 *arg6 = 0 ; SWIG_check_num_args("ofCamera::setupPerspective",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofCamera::setupPerspective",1,"ofCamera *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofCamera::setupPerspective",2,"bool");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofCamera::setupPerspective",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofCamera::setupPerspective",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofCamera::setupPerspective",5,"float");
  if(!lua_isuserdata(L,6)) SWIG_fail_arg("ofCamera::setupPerspective",6,"glm::vec2 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofCamera,0))){
    SWIG_fail_ptr("Camera_setupPerspective",1,SWIGTYPE_p_ofCamera); }  arg2 = (lua_toboolean(L, 2)!=0);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); arg5 = (float)lua_tonumber(L, 5);
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,6,(void**)&arg6,SWIGTYPE_p_glm__vec2,0))){
    SWIG_fail_ptr("Camera_setupPerspective",6,SWIGTYPE_p_glm__vec2); } 
  (arg1)->setupPerspective(arg2,arg3,arg4,arg5,(glm::vec2 const &)*arg6); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Camera_setupPerspective__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofCamera *arg1 = (ofCamera *) 0 ; bool arg2 ;
  float arg3 ; float arg4 ; float arg5 ; SWIG_check_num_args("ofCamera::setupPerspective",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofCamera::setupPerspective",1,"ofCamera *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofCamera::setupPerspective",2,"bool");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofCamera::setupPerspective",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofCamera::setupPerspective",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofCamera::setupPerspective",5,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofCamera,0))){
    SWIG_fail_ptr("Camera_setupPerspective",1,SWIGTYPE_p_ofCamera); }  arg2 = (lua_toboolean(L, 2)!=0);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); arg5 = (float)lua_tonumber(L, 5);
  (arg1)->setupPerspective(arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Camera_setupPerspective__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofCamera *arg1 = (ofCamera *) 0 ; bool arg2 ;
  float arg3 ; float arg4 ; SWIG_check_num_args("ofCamera::setupPerspective",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofCamera::setupPerspective",1,"ofCamera *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofCamera::setupPerspective",2,"bool");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofCamera::setupPerspective",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofCamera::setupPerspective",4,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofCamera,0))){
    SWIG_fail_ptr("Camera_setupPerspective",1,SWIGTYPE_p_ofCamera); }  arg2 = (lua_toboolean(L, 2)!=0);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); (arg1)->setupPerspective(arg2,arg3,arg4); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Camera_setupPerspective__SWIG_3(lua_State* L) { int SWIG_arg = 0; ofCamera *arg1 = (ofCamera *) 0 ; bool arg2 ;
  float arg3 ; SWIG_check_num_args("ofCamera::setupPerspective",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofCamera::setupPerspective",1,"ofCamera *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofCamera::setupPerspective",2,"bool");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofCamera::setupPerspective",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofCamera,0))){
    SWIG_fail_ptr("Camera_setupPerspective",1,SWIGTYPE_p_ofCamera); }  arg2 = (lua_toboolean(L, 2)!=0);
  arg3 = (float)lua_tonumber(L, 3); (arg1)->setupPerspective(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Camera_setupPerspective__SWIG_4(lua_State* L) { int SWIG_arg = 0; ofCamera *arg1 = (ofCamera *) 0 ; bool arg2 ;
  SWIG_check_num_args("ofCamera::setupPerspective",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofCamera::setupPerspective",1,"ofCamera *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofCamera::setupPerspective",2,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofCamera,0))){
    SWIG_fail_ptr("Camera_setupPerspective",1,SWIGTYPE_p_ofCamera); }  arg2 = (lua_toboolean(L, 2)!=0);
  (arg1)->setupPerspective(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Camera_setupPerspective__SWIG_5(lua_State* L) { int SWIG_arg = 0; ofCamera *arg1 = (ofCamera *) 0 ;
  SWIG_check_num_args("ofCamera::setupPerspective",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofCamera::setupPerspective",1,"ofCamera *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofCamera,0))){
    SWIG_fail_ptr("Camera_setupPerspective",1,SWIGTYPE_p_ofCamera); }  (arg1)->setupPerspective(); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Camera_setupPerspective(lua_State* L) { int argc; int argv[7]={ 1,2,3,4,5,6,7} ; argc = lua_gettop(L);
  if (argc == 1) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofCamera, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { return _wrap_Camera_setupPerspective__SWIG_5(L);}  }  if (argc == 2) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofCamera, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isboolean(L,argv[1]); }  if (_v) {
        return _wrap_Camera_setupPerspective__SWIG_4(L);}  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofCamera, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isboolean(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_Camera_setupPerspective__SWIG_3(L);}  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofCamera, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isboolean(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          { _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_Camera_setupPerspective__SWIG_2(L);}  }  }  }  } 
  if (argc == 5) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofCamera, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isboolean(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) {
              return _wrap_Camera_setupPerspective__SWIG_1(L);}  }  }  }  }  }  if (argc == 6) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofCamera, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isboolean(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) { { void *ptr;
                if (lua_isuserdata(L,argv[5])==0 || SWIG_ConvertPtr(L,argv[5], (void **) &ptr, SWIGTYPE_p_glm__vec2, 0)) {
                  _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Camera_setupPerspective__SWIG_0(L);}  }  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Camera_setupPerspective'\n"
  "  Possible C/C++ prototypes are:\n" "    ofCamera::setupPerspective(bool,float,float,float,glm::vec2 const &)\n"
  "    ofCamera::setupPerspective(bool,float,float,float)\n" "    ofCamera::setupPerspective(bool,float,float)\n"
  "    ofCamera::setupPerspective(bool,float)\n" "    ofCamera::setupPerspective(bool)\n" "    ofCamera::setupPerspective()\n");
  lua_error(L);return 0; }
static int _wrap_Camera_setupOffAxisViewPortal(lua_State* L) { int SWIG_arg = 0; ofCamera *arg1 = (ofCamera *) 0 ;
  glm::vec3 *arg2 = 0 ; glm::vec3 *arg3 = 0 ; glm::vec3 *arg4 = 0 ; SWIG_check_num_args("ofCamera::setupOffAxisViewPortal",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofCamera::setupOffAxisViewPortal",1,"ofCamera *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofCamera::setupOffAxisViewPortal",2,"glm::vec3 const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofCamera::setupOffAxisViewPortal",3,"glm::vec3 const &");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("ofCamera::setupOffAxisViewPortal",4,"glm::vec3 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofCamera,0))){
    SWIG_fail_ptr("Camera_setupOffAxisViewPortal",1,SWIGTYPE_p_ofCamera); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("Camera_setupOffAxisViewPortal",2,SWIGTYPE_p_glm__vec3); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("Camera_setupOffAxisViewPortal",3,SWIGTYPE_p_glm__vec3); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("Camera_setupOffAxisViewPortal",4,SWIGTYPE_p_glm__vec3); } 
  (arg1)->setupOffAxisViewPortal((glm::vec3 const &)*arg2,(glm::vec3 const &)*arg3,(glm::vec3 const &)*arg4); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Camera_setVFlip(lua_State* L) { int SWIG_arg = 0; ofCamera *arg1 = (ofCamera *) 0 ; bool arg2 ;
  SWIG_check_num_args("ofCamera::setVFlip",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofCamera::setVFlip",1,"ofCamera *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofCamera::setVFlip",2,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofCamera,0))){
    SWIG_fail_ptr("Camera_setVFlip",1,SWIGTYPE_p_ofCamera); }  arg2 = (lua_toboolean(L, 2)!=0); (arg1)->setVFlip(arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Camera_isVFlipped(lua_State* L) { int SWIG_arg = 0; ofCamera *arg1 = (ofCamera *) 0 ; bool result;
  SWIG_check_num_args("ofCamera::isVFlipped",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofCamera::isVFlipped",1,"ofCamera const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofCamera,0))){
    SWIG_fail_ptr("Camera_isVFlipped",1,SWIGTYPE_p_ofCamera); }  result = (bool)((ofCamera const *)arg1)->isVFlipped();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Camera_enableOrtho(lua_State* L) { int SWIG_arg = 0; ofCamera *arg1 = (ofCamera *) 0 ;
  SWIG_check_num_args("ofCamera::enableOrtho",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofCamera::enableOrtho",1,"ofCamera *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofCamera,0))){
    SWIG_fail_ptr("Camera_enableOrtho",1,SWIGTYPE_p_ofCamera); }  (arg1)->enableOrtho(); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Camera_disableOrtho(lua_State* L) { int SWIG_arg = 0; ofCamera *arg1 = (ofCamera *) 0 ;
  SWIG_check_num_args("ofCamera::disableOrtho",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofCamera::disableOrtho",1,"ofCamera *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofCamera,0))){
    SWIG_fail_ptr("Camera_disableOrtho",1,SWIGTYPE_p_ofCamera); }  (arg1)->disableOrtho(); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Camera_getOrtho(lua_State* L) { int SWIG_arg = 0; ofCamera *arg1 = (ofCamera *) 0 ; bool result;
  SWIG_check_num_args("ofCamera::getOrtho",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofCamera::getOrtho",1,"ofCamera const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofCamera,0))){
    SWIG_fail_ptr("Camera_getOrtho",1,SWIGTYPE_p_ofCamera); }  result = (bool)((ofCamera const *)arg1)->getOrtho();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Camera_getImagePlaneDistance__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofCamera *arg1 = (ofCamera *) 0 ;
  ofRectangle *arg2 = 0 ; float result; SWIG_check_num_args("ofCamera::getImagePlaneDistance",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofCamera::getImagePlaneDistance",1,"ofCamera const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofCamera::getImagePlaneDistance",2,"ofRectangle const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofCamera,0))){
    SWIG_fail_ptr("Camera_getImagePlaneDistance",1,SWIGTYPE_p_ofCamera); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Camera_getImagePlaneDistance",2,SWIGTYPE_p_ofRectangle); } 
  result = (float)((ofCamera const *)arg1)->getImagePlaneDistance((ofRectangle const &)*arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Camera_getImagePlaneDistance__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofCamera *arg1 = (ofCamera *) 0 ;
  float result; SWIG_check_num_args("ofCamera::getImagePlaneDistance",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofCamera::getImagePlaneDistance",1,"ofCamera const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofCamera,0))){
    SWIG_fail_ptr("Camera_getImagePlaneDistance",1,SWIGTYPE_p_ofCamera); } 
  result = (float)((ofCamera const *)arg1)->getImagePlaneDistance(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Camera_getImagePlaneDistance(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L);
  if (argc == 1) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofCamera, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { return _wrap_Camera_getImagePlaneDistance__SWIG_1(L);}  }  if (argc == 2) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofCamera, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Camera_getImagePlaneDistance__SWIG_0(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Camera_getImagePlaneDistance'\n"
  "  Possible C/C++ prototypes are:\n" "    ofCamera::getImagePlaneDistance(ofRectangle const &) const\n"
  "    ofCamera::getImagePlaneDistance() const\n"); lua_error(L);return 0; }
static int _wrap_Camera_beginCamera__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofCamera *arg1 = (ofCamera *) 0 ;
  SWIG_check_num_args("ofCamera::begin",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofCamera::begin",1,"ofCamera *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofCamera,0))){
    SWIG_fail_ptr("Camera_beginCamera",1,SWIGTYPE_p_ofCamera); }  (arg1)->begin(); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Camera_beginCamera__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofCamera *arg1 = (ofCamera *) 0 ;
  ofRectangle *arg2 = 0 ; SWIG_check_num_args("ofCamera::begin",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofCamera::begin",1,"ofCamera *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofCamera::begin",2,"ofRectangle const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofCamera,0))){
    SWIG_fail_ptr("Camera_beginCamera",1,SWIGTYPE_p_ofCamera); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Camera_beginCamera",2,SWIGTYPE_p_ofRectangle); }  (arg1)->begin((ofRectangle const &)*arg2); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Camera_beginCamera(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 1) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofCamera, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { return _wrap_Camera_beginCamera__SWIG_0(L);}  }  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofCamera, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Camera_beginCamera__SWIG_1(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Camera_beginCamera'\n" "  Possible C/C++ prototypes are:\n"
  "    ofCamera::begin()\n" "    ofCamera::begin(ofRectangle const &)\n"); lua_error(L);return 0; }
static int _wrap_Camera_endCamera(lua_State* L) { int SWIG_arg = 0; ofCamera *arg1 = (ofCamera *) 0 ;
  SWIG_check_num_args("ofCamera::end",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofCamera::end",1,"ofCamera *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofCamera,0))){
    SWIG_fail_ptr("Camera_endCamera",1,SWIGTYPE_p_ofCamera); }  (arg1)->end(); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Camera_getProjectionMatrix__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofCamera *arg1 = (ofCamera *) 0 ;
  glm::mat4 result; SWIG_check_num_args("ofCamera::getProjectionMatrix",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofCamera::getProjectionMatrix",1,"ofCamera const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofCamera,0))){
    SWIG_fail_ptr("Camera_getProjectionMatrix",1,SWIGTYPE_p_ofCamera); } 
  result = ((ofCamera const *)arg1)->getProjectionMatrix(); { glm::mat4 * resultptr = new glm::mat4((const glm::mat4 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_glm__mat4,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Camera_getProjectionMatrix__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofCamera *arg1 = (ofCamera *) 0 ;
  ofRectangle *arg2 = 0 ; glm::mat4 result; SWIG_check_num_args("ofCamera::getProjectionMatrix",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofCamera::getProjectionMatrix",1,"ofCamera const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofCamera::getProjectionMatrix",2,"ofRectangle const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofCamera,0))){
    SWIG_fail_ptr("Camera_getProjectionMatrix",1,SWIGTYPE_p_ofCamera); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Camera_getProjectionMatrix",2,SWIGTYPE_p_ofRectangle); } 
  result = ((ofCamera const *)arg1)->getProjectionMatrix((ofRectangle const &)*arg2); {
    glm::mat4 * resultptr = new glm::mat4((const glm::mat4 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_glm__mat4,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Camera_getProjectionMatrix(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L);
  if (argc == 1) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofCamera, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { return _wrap_Camera_getProjectionMatrix__SWIG_0(L);}  }  if (argc == 2) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofCamera, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Camera_getProjectionMatrix__SWIG_1(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Camera_getProjectionMatrix'\n"
  "  Possible C/C++ prototypes are:\n" "    ofCamera::getProjectionMatrix() const\n"
  "    ofCamera::getProjectionMatrix(ofRectangle const &) const\n"); lua_error(L);return 0; }
static int _wrap_Camera_getModelViewMatrix(lua_State* L) { int SWIG_arg = 0; ofCamera *arg1 = (ofCamera *) 0 ; glm::mat4 result;
  SWIG_check_num_args("ofCamera::getModelViewMatrix",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofCamera::getModelViewMatrix",1,"ofCamera const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofCamera,0))){
    SWIG_fail_ptr("Camera_getModelViewMatrix",1,SWIGTYPE_p_ofCamera); } 
  result = ((ofCamera const *)arg1)->getModelViewMatrix(); { glm::mat4 * resultptr = new glm::mat4((const glm::mat4 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_glm__mat4,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Camera_getModelViewProjectionMatrix__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofCamera *arg1 = (ofCamera *) 0 ;
  ofRectangle *arg2 = 0 ; glm::mat4 result; SWIG_check_num_args("ofCamera::getModelViewProjectionMatrix",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofCamera::getModelViewProjectionMatrix",1,"ofCamera const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofCamera::getModelViewProjectionMatrix",2,"ofRectangle const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofCamera,0))){
    SWIG_fail_ptr("Camera_getModelViewProjectionMatrix",1,SWIGTYPE_p_ofCamera); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Camera_getModelViewProjectionMatrix",2,SWIGTYPE_p_ofRectangle); } 
  result = ((ofCamera const *)arg1)->getModelViewProjectionMatrix((ofRectangle const &)*arg2); {
    glm::mat4 * resultptr = new glm::mat4((const glm::mat4 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_glm__mat4,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Camera_getModelViewProjectionMatrix__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofCamera *arg1 = (ofCamera *) 0 ;
  glm::mat4 result; SWIG_check_num_args("ofCamera::getModelViewProjectionMatrix",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofCamera::getModelViewProjectionMatrix",1,"ofCamera const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofCamera,0))){
    SWIG_fail_ptr("Camera_getModelViewProjectionMatrix",1,SWIGTYPE_p_ofCamera); } 
  result = ((ofCamera const *)arg1)->getModelViewProjectionMatrix(); {
    glm::mat4 * resultptr = new glm::mat4((const glm::mat4 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_glm__mat4,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Camera_getModelViewProjectionMatrix(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L);
  if (argc == 1) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofCamera, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { return _wrap_Camera_getModelViewProjectionMatrix__SWIG_1(L);}  }  if (argc == 2) { int _v;
    { void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofCamera, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Camera_getModelViewProjectionMatrix__SWIG_0(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Camera_getModelViewProjectionMatrix'\n"
  "  Possible C/C++ prototypes are:\n" "    ofCamera::getModelViewProjectionMatrix(ofRectangle const &) const\n"
  "    ofCamera::getModelViewProjectionMatrix() const\n"); lua_error(L);return 0; }
static int _wrap_Camera_worldToScreen__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofCamera *arg1 = (ofCamera *) 0 ;
  glm::vec3 arg2 ; ofRectangle *arg3 = 0 ; glm::vec3 *argp2 ; glm::vec3 result;
  SWIG_check_num_args("ofCamera::worldToScreen",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofCamera::worldToScreen",1,"ofCamera const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofCamera::worldToScreen",2,"glm::vec3");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofCamera::worldToScreen",3,"ofRectangle const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofCamera,0))){
    SWIG_fail_ptr("Camera_worldToScreen",1,SWIGTYPE_p_ofCamera); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("Camera_worldToScreen",2,SWIGTYPE_p_glm__vec3); }  arg2 = *argp2;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Camera_worldToScreen",3,SWIGTYPE_p_ofRectangle); } 
  result = ((ofCamera const *)arg1)->worldToScreen(arg2,(ofRectangle const &)*arg3); {
    glm::vec3 * resultptr = new glm::vec3((const glm::vec3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_glm__vec3,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Camera_worldToScreen__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofCamera *arg1 = (ofCamera *) 0 ;
  glm::vec3 arg2 ; glm::vec3 *argp2 ; glm::vec3 result; SWIG_check_num_args("ofCamera::worldToScreen",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofCamera::worldToScreen",1,"ofCamera const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofCamera::worldToScreen",2,"glm::vec3");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofCamera,0))){
    SWIG_fail_ptr("Camera_worldToScreen",1,SWIGTYPE_p_ofCamera); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("Camera_worldToScreen",2,SWIGTYPE_p_glm__vec3); }  arg2 = *argp2;
  result = ((ofCamera const *)arg1)->worldToScreen(arg2); { glm::vec3 * resultptr = new glm::vec3((const glm::vec3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_glm__vec3,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Camera_worldToScreen(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofCamera, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Camera_worldToScreen__SWIG_1(L);}  }  }  if (argc == 3) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofCamera, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
           else { _v = 1; }  }  if (_v) { return _wrap_Camera_worldToScreen__SWIG_0(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Camera_worldToScreen'\n"
  "  Possible C/C++ prototypes are:\n" "    ofCamera::worldToScreen(glm::vec3,ofRectangle const &) const\n"
  "    ofCamera::worldToScreen(glm::vec3) const\n"); lua_error(L);return 0; }
static int _wrap_Camera_screenToWorld__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofCamera *arg1 = (ofCamera *) 0 ;
  glm::vec3 arg2 ; ofRectangle *arg3 = 0 ; glm::vec3 *argp2 ; glm::vec3 result;
  SWIG_check_num_args("ofCamera::screenToWorld",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofCamera::screenToWorld",1,"ofCamera const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofCamera::screenToWorld",2,"glm::vec3");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofCamera::screenToWorld",3,"ofRectangle const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofCamera,0))){
    SWIG_fail_ptr("Camera_screenToWorld",1,SWIGTYPE_p_ofCamera); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("Camera_screenToWorld",2,SWIGTYPE_p_glm__vec3); }  arg2 = *argp2;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Camera_screenToWorld",3,SWIGTYPE_p_ofRectangle); } 
  result = ((ofCamera const *)arg1)->screenToWorld(arg2,(ofRectangle const &)*arg3); {
    glm::vec3 * resultptr = new glm::vec3((const glm::vec3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_glm__vec3,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Camera_screenToWorld__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofCamera *arg1 = (ofCamera *) 0 ;
  glm::vec3 arg2 ; glm::vec3 *argp2 ; glm::vec3 result; SWIG_check_num_args("ofCamera::screenToWorld",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofCamera::screenToWorld",1,"ofCamera const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofCamera::screenToWorld",2,"glm::vec3");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofCamera,0))){
    SWIG_fail_ptr("Camera_screenToWorld",1,SWIGTYPE_p_ofCamera); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("Camera_screenToWorld",2,SWIGTYPE_p_glm__vec3); }  arg2 = *argp2;
  result = ((ofCamera const *)arg1)->screenToWorld(arg2); { glm::vec3 * resultptr = new glm::vec3((const glm::vec3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_glm__vec3,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Camera_screenToWorld(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofCamera, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Camera_screenToWorld__SWIG_1(L);}  }  }  if (argc == 3) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofCamera, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
           else { _v = 1; }  }  if (_v) { return _wrap_Camera_screenToWorld__SWIG_0(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Camera_screenToWorld'\n"
  "  Possible C/C++ prototypes are:\n" "    ofCamera::screenToWorld(glm::vec3,ofRectangle const &) const\n"
  "    ofCamera::screenToWorld(glm::vec3) const\n"); lua_error(L);return 0; }
static int _wrap_Camera_worldToCamera__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofCamera *arg1 = (ofCamera *) 0 ;
  glm::vec3 arg2 ; ofRectangle *arg3 = 0 ; glm::vec3 *argp2 ; glm::vec3 result;
  SWIG_check_num_args("ofCamera::worldToCamera",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofCamera::worldToCamera",1,"ofCamera const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofCamera::worldToCamera",2,"glm::vec3");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofCamera::worldToCamera",3,"ofRectangle const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofCamera,0))){
    SWIG_fail_ptr("Camera_worldToCamera",1,SWIGTYPE_p_ofCamera); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("Camera_worldToCamera",2,SWIGTYPE_p_glm__vec3); }  arg2 = *argp2;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Camera_worldToCamera",3,SWIGTYPE_p_ofRectangle); } 
  result = ((ofCamera const *)arg1)->worldToCamera(arg2,(ofRectangle const &)*arg3); {
    glm::vec3 * resultptr = new glm::vec3((const glm::vec3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_glm__vec3,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Camera_worldToCamera__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofCamera *arg1 = (ofCamera *) 0 ;
  glm::vec3 arg2 ; glm::vec3 *argp2 ; glm::vec3 result; SWIG_check_num_args("ofCamera::worldToCamera",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofCamera::worldToCamera",1,"ofCamera const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofCamera::worldToCamera",2,"glm::vec3");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofCamera,0))){
    SWIG_fail_ptr("Camera_worldToCamera",1,SWIGTYPE_p_ofCamera); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("Camera_worldToCamera",2,SWIGTYPE_p_glm__vec3); }  arg2 = *argp2;
  result = ((ofCamera const *)arg1)->worldToCamera(arg2); { glm::vec3 * resultptr = new glm::vec3((const glm::vec3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_glm__vec3,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Camera_worldToCamera(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofCamera, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Camera_worldToCamera__SWIG_1(L);}  }  }  if (argc == 3) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofCamera, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
           else { _v = 1; }  }  if (_v) { return _wrap_Camera_worldToCamera__SWIG_0(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Camera_worldToCamera'\n"
  "  Possible C/C++ prototypes are:\n" "    ofCamera::worldToCamera(glm::vec3,ofRectangle const &) const\n"
  "    ofCamera::worldToCamera(glm::vec3) const\n"); lua_error(L);return 0; }
static int _wrap_Camera_cameraToWorld__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofCamera *arg1 = (ofCamera *) 0 ;
  glm::vec3 arg2 ; ofRectangle *arg3 = 0 ; glm::vec3 *argp2 ; glm::vec3 result;
  SWIG_check_num_args("ofCamera::cameraToWorld",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofCamera::cameraToWorld",1,"ofCamera const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofCamera::cameraToWorld",2,"glm::vec3");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofCamera::cameraToWorld",3,"ofRectangle const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofCamera,0))){
    SWIG_fail_ptr("Camera_cameraToWorld",1,SWIGTYPE_p_ofCamera); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("Camera_cameraToWorld",2,SWIGTYPE_p_glm__vec3); }  arg2 = *argp2;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Camera_cameraToWorld",3,SWIGTYPE_p_ofRectangle); } 
  result = ((ofCamera const *)arg1)->cameraToWorld(arg2,(ofRectangle const &)*arg3); {
    glm::vec3 * resultptr = new glm::vec3((const glm::vec3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_glm__vec3,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Camera_cameraToWorld__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofCamera *arg1 = (ofCamera *) 0 ;
  glm::vec3 arg2 ; glm::vec3 *argp2 ; glm::vec3 result; SWIG_check_num_args("ofCamera::cameraToWorld",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofCamera::cameraToWorld",1,"ofCamera const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofCamera::cameraToWorld",2,"glm::vec3");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofCamera,0))){
    SWIG_fail_ptr("Camera_cameraToWorld",1,SWIGTYPE_p_ofCamera); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("Camera_cameraToWorld",2,SWIGTYPE_p_glm__vec3); }  arg2 = *argp2;
  result = ((ofCamera const *)arg1)->cameraToWorld(arg2); { glm::vec3 * resultptr = new glm::vec3((const glm::vec3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_glm__vec3,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Camera_cameraToWorld(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofCamera, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Camera_cameraToWorld__SWIG_1(L);}  }  }  if (argc == 3) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofCamera, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
           else { _v = 1; }  }  if (_v) { return _wrap_Camera_cameraToWorld__SWIG_0(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Camera_cameraToWorld'\n"
  "  Possible C/C++ prototypes are:\n" "    ofCamera::cameraToWorld(glm::vec3,ofRectangle const &) const\n"
  "    ofCamera::cameraToWorld(glm::vec3) const\n"); lua_error(L);return 0; }
static int _wrap_Camera_setRenderer(lua_State* L) { int SWIG_arg = 0; ofCamera *arg1 = (ofCamera *) 0 ;
  SwigValueWrapper< std::shared_ptr< ofBaseRenderer > > arg2 ; std::shared_ptr< ofBaseRenderer > *argp2 ;
  SWIG_check_num_args("ofCamera::setRenderer",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofCamera::setRenderer",1,"ofCamera *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofCamera::setRenderer",2,"std::shared_ptr< ofBaseRenderer >");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofCamera,0))){
    SWIG_fail_ptr("Camera_setRenderer",1,SWIGTYPE_p_ofCamera); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_std__shared_ptrT_ofBaseRenderer_t,0))){
    SWIG_fail_ptr("Camera_setRenderer",2,SWIGTYPE_p_std__shared_ptrT_ofBaseRenderer_t); }  arg2 = *argp2;
  (arg1)->setRenderer(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Camera_drawFrustum__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofCamera *arg1 = (ofCamera *) 0 ;
  ofRectangle *arg2 = 0 ; SWIG_check_num_args("ofCamera::drawFrustum",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofCamera::drawFrustum",1,"ofCamera const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofCamera::drawFrustum",2,"ofRectangle const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofCamera,0))){
    SWIG_fail_ptr("Camera_drawFrustum",1,SWIGTYPE_p_ofCamera); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Camera_drawFrustum",2,SWIGTYPE_p_ofRectangle); } 
  ((ofCamera const *)arg1)->drawFrustum((ofRectangle const &)*arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Camera_drawFrustum__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofCamera *arg1 = (ofCamera *) 0 ;
  SWIG_check_num_args("ofCamera::drawFrustum",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofCamera::drawFrustum",1,"ofCamera const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofCamera,0))){
    SWIG_fail_ptr("Camera_drawFrustum",1,SWIGTYPE_p_ofCamera); }  ((ofCamera const *)arg1)->drawFrustum(); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Camera_drawFrustum(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 1) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofCamera, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { return _wrap_Camera_drawFrustum__SWIG_1(L);}  }  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofCamera, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Camera_drawFrustum__SWIG_0(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Camera_drawFrustum'\n" "  Possible C/C++ prototypes are:\n"
  "    ofCamera::drawFrustum(ofRectangle const &) const\n" "    ofCamera::drawFrustum() const\n"); lua_error(L);return 0; }
static void swig_delete_Camera(void *obj) {
ofCamera *arg1 = (ofCamera *) obj;
delete arg1;
}
static int _proxy__wrap_new_Camera(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_Camera);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_Camera_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_Camera_methods[]= {
    { "setFov", _wrap_Camera_setFov},
    { "setNearClip", _wrap_Camera_setNearClip},
    { "setFarClip", _wrap_Camera_setFarClip},
    { "setLensOffset", _wrap_Camera_setLensOffset},
    { "setAspectRatio", _wrap_Camera_setAspectRatio},
    { "setForceAspectRatio", _wrap_Camera_setForceAspectRatio},
    { "getFov", _wrap_Camera_getFov},
    { "getNearClip", _wrap_Camera_getNearClip},
    { "getFarClip", _wrap_Camera_getFarClip},
    { "getLensOffset", _wrap_Camera_getLensOffset},
    { "getForceAspectRatio", _wrap_Camera_getForceAspectRatio},
    { "getAspectRatio", _wrap_Camera_getAspectRatio},
    { "setupPerspective", _wrap_Camera_setupPerspective},
    { "setupOffAxisViewPortal", _wrap_Camera_setupOffAxisViewPortal},
    { "setVFlip", _wrap_Camera_setVFlip},
    { "isVFlipped", _wrap_Camera_isVFlipped},
    { "enableOrtho", _wrap_Camera_enableOrtho},
    { "disableOrtho", _wrap_Camera_disableOrtho},
    { "getOrtho", _wrap_Camera_getOrtho},
    { "getImagePlaneDistance", _wrap_Camera_getImagePlaneDistance},
    { "beginCamera", _wrap_Camera_beginCamera},
    { "endCamera", _wrap_Camera_endCamera},
    { "getProjectionMatrix", _wrap_Camera_getProjectionMatrix},
    { "getModelViewMatrix", _wrap_Camera_getModelViewMatrix},
    { "getModelViewProjectionMatrix", _wrap_Camera_getModelViewProjectionMatrix},
    { "worldToScreen", _wrap_Camera_worldToScreen},
    { "screenToWorld", _wrap_Camera_screenToWorld},
    { "worldToCamera", _wrap_Camera_worldToCamera},
    { "cameraToWorld", _wrap_Camera_cameraToWorld},
    { "setRenderer", _wrap_Camera_setRenderer},
    { "drawFrustum", _wrap_Camera_drawFrustum},
    {0,0}
};
static swig_lua_method swig_Camera_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_Camera_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_Camera_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_Camera_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_Camera_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_Camera_Sf_SwigStatic = {
    "Camera",
    swig_Camera_Sf_SwigStatic_methods,
    swig_Camera_Sf_SwigStatic_attributes,
    swig_Camera_Sf_SwigStatic_constants,
    swig_Camera_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_Camera_bases[] = {0,0};
static const char *swig_Camera_base_names[] = {"ofNode *",0};
static swig_lua_class _wrap_class_Camera = { "Camera", "Camera", &SWIGTYPE_p_ofCamera,_proxy__wrap_new_Camera, swig_delete_Camera, swig_Camera_methods, swig_Camera_attributes, &swig_Camera_Sf_SwigStatic, swig_Camera_meta, swig_Camera_bases, swig_Camera_base_names };

static int _wrap_new_EasyCam(lua_State* L) { int SWIG_arg = 0; ofEasyCam *result = 0 ;
  SWIG_check_num_args("ofEasyCam::ofEasyCam",0,0) result = (ofEasyCam *)new ofEasyCam();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofEasyCam,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_EasyCam_beginCamera__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofEasyCam *arg1 = (ofEasyCam *) 0 ;
  ofRectangle *arg2 = 0 ; SWIG_check_num_args("ofEasyCam::begin",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofEasyCam::begin",1,"ofEasyCam *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofEasyCam::begin",2,"ofRectangle const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofEasyCam,0))){
    SWIG_fail_ptr("EasyCam_beginCamera",1,SWIGTYPE_p_ofEasyCam); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("EasyCam_beginCamera",2,SWIGTYPE_p_ofRectangle); }  (arg1)->begin((ofRectangle const &)*arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_EasyCam_beginCamera__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofEasyCam *arg1 = (ofEasyCam *) 0 ;
  SWIG_check_num_args("ofEasyCam::begin",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofEasyCam::begin",1,"ofEasyCam *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofEasyCam,0))){
    SWIG_fail_ptr("EasyCam_beginCamera",1,SWIGTYPE_p_ofEasyCam); }  (arg1)->begin(); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_EasyCam_beginCamera(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 1) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofEasyCam, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { return _wrap_EasyCam_beginCamera__SWIG_1(L);}  }  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofEasyCam, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_EasyCam_beginCamera__SWIG_0(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'EasyCam_beginCamera'\n"
  "  Possible C/C++ prototypes are:\n" "    ofEasyCam::begin(ofRectangle const &)\n" "    ofEasyCam::begin()\n");
  lua_error(L);return 0; }
static int _wrap_EasyCam_reset(lua_State* L) { int SWIG_arg = 0; ofEasyCam *arg1 = (ofEasyCam *) 0 ;
  SWIG_check_num_args("ofEasyCam::reset",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofEasyCam::reset",1,"ofEasyCam *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofEasyCam,0))){
    SWIG_fail_ptr("EasyCam_reset",1,SWIGTYPE_p_ofEasyCam); }  (arg1)->reset(); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_EasyCam_setTarget__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofEasyCam *arg1 = (ofEasyCam *) 0 ;
  glm::vec3 *arg2 = 0 ; SWIG_check_num_args("ofEasyCam::setTarget",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofEasyCam::setTarget",1,"ofEasyCam *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofEasyCam::setTarget",2,"glm::vec3 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofEasyCam,0))){
    SWIG_fail_ptr("EasyCam_setTarget",1,SWIGTYPE_p_ofEasyCam); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("EasyCam_setTarget",2,SWIGTYPE_p_glm__vec3); }  (arg1)->setTarget((glm::vec3 const &)*arg2); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_EasyCam_setTarget__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofEasyCam *arg1 = (ofEasyCam *) 0 ;
  ofNode *arg2 = 0 ; SWIG_check_num_args("ofEasyCam::setTarget",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofEasyCam::setTarget",1,"ofEasyCam *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofEasyCam::setTarget",2,"ofNode &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofEasyCam,0))){
    SWIG_fail_ptr("EasyCam_setTarget",1,SWIGTYPE_p_ofEasyCam); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofNode,0))){
    SWIG_fail_ptr("EasyCam_setTarget",2,SWIGTYPE_p_ofNode); }  (arg1)->setTarget(*arg2); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_EasyCam_setTarget(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofEasyCam, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_EasyCam_setTarget__SWIG_0(L);}  }  }  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofEasyCam, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofNode, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_EasyCam_setTarget__SWIG_1(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'EasyCam_setTarget'\n" "  Possible C/C++ prototypes are:\n"
  "    ofEasyCam::setTarget(glm::vec3 const &)\n" "    ofEasyCam::setTarget(ofNode &)\n"); lua_error(L);return 0; }
static int _wrap_EasyCam_getTarget(lua_State* L) { int SWIG_arg = 0; ofEasyCam *arg1 = (ofEasyCam *) 0 ; ofNode *result = 0 ;
  SWIG_check_num_args("ofEasyCam::getTarget",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofEasyCam::getTarget",1,"ofEasyCam const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofEasyCam,0))){
    SWIG_fail_ptr("EasyCam_getTarget",1,SWIGTYPE_p_ofEasyCam); }  result = (ofNode *) &((ofEasyCam const *)arg1)->getTarget();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofNode,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_EasyCam_setDistance(lua_State* L) { int SWIG_arg = 0; ofEasyCam *arg1 = (ofEasyCam *) 0 ; float arg2 ;
  SWIG_check_num_args("ofEasyCam::setDistance",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofEasyCam::setDistance",1,"ofEasyCam *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofEasyCam::setDistance",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofEasyCam,0))){
    SWIG_fail_ptr("EasyCam_setDistance",1,SWIGTYPE_p_ofEasyCam); }  arg2 = (float)lua_tonumber(L, 2); (arg1)->setDistance(arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_EasyCam_getDistance(lua_State* L) { int SWIG_arg = 0; ofEasyCam *arg1 = (ofEasyCam *) 0 ; float result;
  SWIG_check_num_args("ofEasyCam::getDistance",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofEasyCam::getDistance",1,"ofEasyCam const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofEasyCam,0))){
    SWIG_fail_ptr("EasyCam_getDistance",1,SWIGTYPE_p_ofEasyCam); }  result = (float)((ofEasyCam const *)arg1)->getDistance();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_EasyCam_setDrag(lua_State* L) { int SWIG_arg = 0; ofEasyCam *arg1 = (ofEasyCam *) 0 ; float arg2 ;
  SWIG_check_num_args("ofEasyCam::setDrag",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofEasyCam::setDrag",1,"ofEasyCam *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofEasyCam::setDrag",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofEasyCam,0))){
    SWIG_fail_ptr("EasyCam_setDrag",1,SWIGTYPE_p_ofEasyCam); }  arg2 = (float)lua_tonumber(L, 2); (arg1)->setDrag(arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_EasyCam_getDrag(lua_State* L) { int SWIG_arg = 0; ofEasyCam *arg1 = (ofEasyCam *) 0 ; float result;
  SWIG_check_num_args("ofEasyCam::getDrag",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofEasyCam::getDrag",1,"ofEasyCam const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofEasyCam,0))){
    SWIG_fail_ptr("EasyCam_getDrag",1,SWIGTYPE_p_ofEasyCam); }  result = (float)((ofEasyCam const *)arg1)->getDrag();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_EasyCam_setAutoDistance(lua_State* L) { int SWIG_arg = 0; ofEasyCam *arg1 = (ofEasyCam *) 0 ; bool arg2 ;
  SWIG_check_num_args("ofEasyCam::setAutoDistance",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofEasyCam::setAutoDistance",1,"ofEasyCam *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofEasyCam::setAutoDistance",2,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofEasyCam,0))){
    SWIG_fail_ptr("EasyCam_setAutoDistance",1,SWIGTYPE_p_ofEasyCam); }  arg2 = (lua_toboolean(L, 2)!=0);
  (arg1)->setAutoDistance(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_EasyCam_setEvents(lua_State* L) { int SWIG_arg = 0; ofEasyCam *arg1 = (ofEasyCam *) 0 ;
  ofCoreEvents *arg2 = 0 ; SWIG_check_num_args("ofEasyCam::setEvents",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofEasyCam::setEvents",1,"ofEasyCam *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofEasyCam::setEvents",2,"ofCoreEvents &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofEasyCam,0))){
    SWIG_fail_ptr("EasyCam_setEvents",1,SWIGTYPE_p_ofEasyCam); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofCoreEvents,0))){
    SWIG_fail_ptr("EasyCam_setEvents",2,SWIGTYPE_p_ofCoreEvents); }  (arg1)->setEvents(*arg2); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_EasyCam_setRotationSensitivity__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofEasyCam *arg1 = (ofEasyCam *) 0 ;
  float arg2 ; float arg3 ; float arg4 ; SWIG_check_num_args("ofEasyCam::setRotationSensitivity",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofEasyCam::setRotationSensitivity",1,"ofEasyCam *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofEasyCam::setRotationSensitivity",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofEasyCam::setRotationSensitivity",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofEasyCam::setRotationSensitivity",4,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofEasyCam,0))){
    SWIG_fail_ptr("EasyCam_setRotationSensitivity",1,SWIGTYPE_p_ofEasyCam); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); (arg1)->setRotationSensitivity(arg2,arg3,arg4);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_EasyCam_setRotationSensitivity__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofEasyCam *arg1 = (ofEasyCam *) 0 ;
  glm::vec3 *arg2 = 0 ; SWIG_check_num_args("ofEasyCam::setRotationSensitivity",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofEasyCam::setRotationSensitivity",1,"ofEasyCam *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofEasyCam::setRotationSensitivity",2,"glm::vec3 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofEasyCam,0))){
    SWIG_fail_ptr("EasyCam_setRotationSensitivity",1,SWIGTYPE_p_ofEasyCam); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("EasyCam_setRotationSensitivity",2,SWIGTYPE_p_glm__vec3); } 
  (arg1)->setRotationSensitivity((glm::vec3 const &)*arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_EasyCam_setRotationSensitivity(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L);
  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofEasyCam, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_EasyCam_setRotationSensitivity__SWIG_1(L);}  }  }  if (argc == 4) { int _v;
    { void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofEasyCam, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_EasyCam_setRotationSensitivity__SWIG_0(L);}  }  }  }
     }  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'EasyCam_setRotationSensitivity'\n"
  "  Possible C/C++ prototypes are:\n" "    ofEasyCam::setRotationSensitivity(float,float,float)\n"
  "    ofEasyCam::setRotationSensitivity(glm::vec3 const &)\n"); lua_error(L);return 0; }
static int _wrap_EasyCam_setTranslationSensitivity__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofEasyCam *arg1 = (ofEasyCam *) 0 ;
  float arg2 ; float arg3 ; float arg4 ; SWIG_check_num_args("ofEasyCam::setTranslationSensitivity",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofEasyCam::setTranslationSensitivity",1,"ofEasyCam *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofEasyCam::setTranslationSensitivity",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofEasyCam::setTranslationSensitivity",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofEasyCam::setTranslationSensitivity",4,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofEasyCam,0))){
    SWIG_fail_ptr("EasyCam_setTranslationSensitivity",1,SWIGTYPE_p_ofEasyCam); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); (arg1)->setTranslationSensitivity(arg2,arg3,arg4);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_EasyCam_setTranslationSensitivity__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofEasyCam *arg1 = (ofEasyCam *) 0 ;
  glm::vec3 *arg2 = 0 ; SWIG_check_num_args("ofEasyCam::setTranslationSensitivity",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofEasyCam::setTranslationSensitivity",1,"ofEasyCam *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofEasyCam::setTranslationSensitivity",2,"glm::vec3 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofEasyCam,0))){
    SWIG_fail_ptr("EasyCam_setTranslationSensitivity",1,SWIGTYPE_p_ofEasyCam); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("EasyCam_setTranslationSensitivity",2,SWIGTYPE_p_glm__vec3); } 
  (arg1)->setTranslationSensitivity((glm::vec3 const &)*arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_EasyCam_setTranslationSensitivity(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L);
  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofEasyCam, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_EasyCam_setTranslationSensitivity__SWIG_1(L);}  }  }  if (argc == 4) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofEasyCam, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          { _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_EasyCam_setTranslationSensitivity__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'EasyCam_setTranslationSensitivity'\n"
  "  Possible C/C++ prototypes are:\n" "    ofEasyCam::setTranslationSensitivity(float,float,float)\n"
  "    ofEasyCam::setTranslationSensitivity(glm::vec3 const &)\n"); lua_error(L);return 0; }
static int _wrap_EasyCam_setTranslationKey(lua_State* L) { int SWIG_arg = 0; ofEasyCam *arg1 = (ofEasyCam *) 0 ; char arg2 ;
  SWIG_check_num_args("ofEasyCam::setTranslationKey",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofEasyCam::setTranslationKey",1,"ofEasyCam *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("ofEasyCam::setTranslationKey",2,"char");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofEasyCam,0))){
    SWIG_fail_ptr("EasyCam_setTranslationKey",1,SWIGTYPE_p_ofEasyCam); }  arg2 = (lua_tostring(L, 2))[0];
  (arg1)->setTranslationKey(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_EasyCam_getTranslationKey(lua_State* L) { int SWIG_arg = 0; ofEasyCam *arg1 = (ofEasyCam *) 0 ; char result;
  SWIG_check_num_args("ofEasyCam::getTranslationKey",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofEasyCam::getTranslationKey",1,"ofEasyCam const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofEasyCam,0))){
    SWIG_fail_ptr("EasyCam_getTranslationKey",1,SWIGTYPE_p_ofEasyCam); } 
  result = (char)((ofEasyCam const *)arg1)->getTranslationKey(); lua_pushlstring(L, &result, 1); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_EasyCam_enableMouseInput(lua_State* L) { int SWIG_arg = 0; ofEasyCam *arg1 = (ofEasyCam *) 0 ;
  SWIG_check_num_args("ofEasyCam::enableMouseInput",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofEasyCam::enableMouseInput",1,"ofEasyCam *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofEasyCam,0))){
    SWIG_fail_ptr("EasyCam_enableMouseInput",1,SWIGTYPE_p_ofEasyCam); }  (arg1)->enableMouseInput(); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_EasyCam_disableMouseInput(lua_State* L) { int SWIG_arg = 0; ofEasyCam *arg1 = (ofEasyCam *) 0 ;
  SWIG_check_num_args("ofEasyCam::disableMouseInput",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofEasyCam::disableMouseInput",1,"ofEasyCam *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofEasyCam,0))){
    SWIG_fail_ptr("EasyCam_disableMouseInput",1,SWIGTYPE_p_ofEasyCam); }  (arg1)->disableMouseInput(); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_EasyCam_getMouseInputEnabled(lua_State* L) { int SWIG_arg = 0; ofEasyCam *arg1 = (ofEasyCam *) 0 ; bool result;
  SWIG_check_num_args("ofEasyCam::getMouseInputEnabled",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofEasyCam::getMouseInputEnabled",1,"ofEasyCam const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofEasyCam,0))){
    SWIG_fail_ptr("EasyCam_getMouseInputEnabled",1,SWIGTYPE_p_ofEasyCam); } 
  result = (bool)((ofEasyCam const *)arg1)->getMouseInputEnabled(); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_EasyCam_enableMouseMiddleButton(lua_State* L) { int SWIG_arg = 0; ofEasyCam *arg1 = (ofEasyCam *) 0 ;
  SWIG_check_num_args("ofEasyCam::enableMouseMiddleButton",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofEasyCam::enableMouseMiddleButton",1,"ofEasyCam *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofEasyCam,0))){
    SWIG_fail_ptr("EasyCam_enableMouseMiddleButton",1,SWIGTYPE_p_ofEasyCam); }  (arg1)->enableMouseMiddleButton();
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_EasyCam_disableMouseMiddleButton(lua_State* L) { int SWIG_arg = 0; ofEasyCam *arg1 = (ofEasyCam *) 0 ;
  SWIG_check_num_args("ofEasyCam::disableMouseMiddleButton",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofEasyCam::disableMouseMiddleButton",1,"ofEasyCam *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofEasyCam,0))){
    SWIG_fail_ptr("EasyCam_disableMouseMiddleButton",1,SWIGTYPE_p_ofEasyCam); }  (arg1)->disableMouseMiddleButton();
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_EasyCam_getMouseMiddleButtonEnabled(lua_State* L) { int SWIG_arg = 0; ofEasyCam *arg1 = (ofEasyCam *) 0 ;
  bool result; SWIG_check_num_args("ofEasyCam::getMouseMiddleButtonEnabled",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofEasyCam::getMouseMiddleButtonEnabled",1,"ofEasyCam const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofEasyCam,0))){
    SWIG_fail_ptr("EasyCam_getMouseMiddleButtonEnabled",1,SWIGTYPE_p_ofEasyCam); } 
  result = (bool)((ofEasyCam const *)arg1)->getMouseMiddleButtonEnabled(); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_EasyCam_setRelativeYAxis__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofEasyCam *arg1 = (ofEasyCam *) 0 ;
  bool arg2 ; SWIG_check_num_args("ofEasyCam::setRelativeYAxis",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofEasyCam::setRelativeYAxis",1,"ofEasyCam *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofEasyCam::setRelativeYAxis",2,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofEasyCam,0))){
    SWIG_fail_ptr("EasyCam_setRelativeYAxis",1,SWIGTYPE_p_ofEasyCam); }  arg2 = (lua_toboolean(L, 2)!=0);
  (arg1)->setRelativeYAxis(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_EasyCam_setRelativeYAxis__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofEasyCam *arg1 = (ofEasyCam *) 0 ;
  SWIG_check_num_args("ofEasyCam::setRelativeYAxis",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofEasyCam::setRelativeYAxis",1,"ofEasyCam *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofEasyCam,0))){
    SWIG_fail_ptr("EasyCam_setRelativeYAxis",1,SWIGTYPE_p_ofEasyCam); }  (arg1)->setRelativeYAxis(); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_EasyCam_setRelativeYAxis(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L);
  if (argc == 1) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofEasyCam, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { return _wrap_EasyCam_setRelativeYAxis__SWIG_1(L);}  }  if (argc == 2) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofEasyCam, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isboolean(L,argv[1]); }  if (_v) {
        return _wrap_EasyCam_setRelativeYAxis__SWIG_0(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'EasyCam_setRelativeYAxis'\n"
  "  Possible C/C++ prototypes are:\n" "    ofEasyCam::setRelativeYAxis(bool)\n" "    ofEasyCam::setRelativeYAxis()\n");
  lua_error(L);return 0; }
static int _wrap_EasyCam_getRelativeYAxis(lua_State* L) { int SWIG_arg = 0; ofEasyCam *arg1 = (ofEasyCam *) 0 ; bool result;
  SWIG_check_num_args("ofEasyCam::getRelativeYAxis",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofEasyCam::getRelativeYAxis",1,"ofEasyCam const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofEasyCam,0))){
    SWIG_fail_ptr("EasyCam_getRelativeYAxis",1,SWIGTYPE_p_ofEasyCam); } 
  result = (bool)((ofEasyCam const *)arg1)->getRelativeYAxis(); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_EasyCam_setUpAxis(lua_State* L) { int SWIG_arg = 0; ofEasyCam *arg1 = (ofEasyCam *) 0 ; glm::vec3 *arg2 = 0 ;
  SWIG_check_num_args("ofEasyCam::setUpAxis",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofEasyCam::setUpAxis",1,"ofEasyCam *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofEasyCam::setUpAxis",2,"glm::vec3 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofEasyCam,0))){
    SWIG_fail_ptr("EasyCam_setUpAxis",1,SWIGTYPE_p_ofEasyCam); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("EasyCam_setUpAxis",2,SWIGTYPE_p_glm__vec3); }  (arg1)->setUpAxis((glm::vec3 const &)*arg2); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_EasyCam_getUpAxis(lua_State* L) { int SWIG_arg = 0; ofEasyCam *arg1 = (ofEasyCam *) 0 ; glm::vec3 *result = 0 ;
  SWIG_check_num_args("ofEasyCam::getUpAxis",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofEasyCam::getUpAxis",1,"ofEasyCam const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofEasyCam,0))){
    SWIG_fail_ptr("EasyCam_getUpAxis",1,SWIGTYPE_p_ofEasyCam); } 
  result = (glm::vec3 *) &((ofEasyCam const *)arg1)->getUpAxis();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_glm__vec3,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_EasyCam_enableInertia(lua_State* L) { int SWIG_arg = 0; ofEasyCam *arg1 = (ofEasyCam *) 0 ;
  SWIG_check_num_args("ofEasyCam::enableInertia",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofEasyCam::enableInertia",1,"ofEasyCam *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofEasyCam,0))){
    SWIG_fail_ptr("EasyCam_enableInertia",1,SWIGTYPE_p_ofEasyCam); }  (arg1)->enableInertia(); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_EasyCam_disableInertia(lua_State* L) { int SWIG_arg = 0; ofEasyCam *arg1 = (ofEasyCam *) 0 ;
  SWIG_check_num_args("ofEasyCam::disableInertia",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofEasyCam::disableInertia",1,"ofEasyCam *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofEasyCam,0))){
    SWIG_fail_ptr("EasyCam_disableInertia",1,SWIGTYPE_p_ofEasyCam); }  (arg1)->disableInertia(); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_EasyCam_getInertiaEnabled(lua_State* L) { int SWIG_arg = 0; ofEasyCam *arg1 = (ofEasyCam *) 0 ; bool result;
  SWIG_check_num_args("ofEasyCam::getInertiaEnabled",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofEasyCam::getInertiaEnabled",1,"ofEasyCam const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofEasyCam,0))){
    SWIG_fail_ptr("EasyCam_getInertiaEnabled",1,SWIGTYPE_p_ofEasyCam); } 
  result = (bool)((ofEasyCam const *)arg1)->getInertiaEnabled(); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_EasyCam_setControlArea(lua_State* L) { int SWIG_arg = 0; ofEasyCam *arg1 = (ofEasyCam *) 0 ;
  ofRectangle *arg2 = 0 ; SWIG_check_num_args("ofEasyCam::setControlArea",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofEasyCam::setControlArea",1,"ofEasyCam *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofEasyCam::setControlArea",2,"ofRectangle const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofEasyCam,0))){
    SWIG_fail_ptr("EasyCam_setControlArea",1,SWIGTYPE_p_ofEasyCam); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("EasyCam_setControlArea",2,SWIGTYPE_p_ofRectangle); }  (arg1)->setControlArea((ofRectangle const &)*arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_EasyCam_clearControlArea(lua_State* L) { int SWIG_arg = 0; ofEasyCam *arg1 = (ofEasyCam *) 0 ;
  SWIG_check_num_args("ofEasyCam::clearControlArea",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofEasyCam::clearControlArea",1,"ofEasyCam *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofEasyCam,0))){
    SWIG_fail_ptr("EasyCam_clearControlArea",1,SWIGTYPE_p_ofEasyCam); }  (arg1)->clearControlArea(); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_EasyCam_getControlArea(lua_State* L) { int SWIG_arg = 0; ofEasyCam *arg1 = (ofEasyCam *) 0 ;
  ofRectangle result; SWIG_check_num_args("ofEasyCam::getControlArea",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofEasyCam::getControlArea",1,"ofEasyCam const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofEasyCam,0))){
    SWIG_fail_ptr("EasyCam_getControlArea",1,SWIGTYPE_p_ofEasyCam); }  result = ((ofEasyCam const *)arg1)->getControlArea(); {
    ofRectangle * resultptr = new ofRectangle((const ofRectangle &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofRectangle,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_EasyCam_addInteraction__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofEasyCam *arg1 = (ofEasyCam *) 0 ;
  ofEasyCam::TransformType arg2 ; int arg3 ; int arg4 ; SWIG_check_num_args("ofEasyCam::addInteraction",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofEasyCam::addInteraction",1,"ofEasyCam *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofEasyCam::addInteraction",2,"ofEasyCam::TransformType");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofEasyCam::addInteraction",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofEasyCam::addInteraction",4,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofEasyCam,0))){
    SWIG_fail_ptr("EasyCam_addInteraction",1,SWIGTYPE_p_ofEasyCam); }  arg2 = (ofEasyCam::TransformType)(int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3); arg4 = (int)lua_tonumber(L, 4); (arg1)->addInteraction(arg2,arg3,arg4); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_EasyCam_addInteraction__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofEasyCam *arg1 = (ofEasyCam *) 0 ;
  ofEasyCam::TransformType arg2 ; int arg3 ; SWIG_check_num_args("ofEasyCam::addInteraction",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofEasyCam::addInteraction",1,"ofEasyCam *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofEasyCam::addInteraction",2,"ofEasyCam::TransformType");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofEasyCam::addInteraction",3,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofEasyCam,0))){
    SWIG_fail_ptr("EasyCam_addInteraction",1,SWIGTYPE_p_ofEasyCam); }  arg2 = (ofEasyCam::TransformType)(int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3); (arg1)->addInteraction(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_EasyCam_addInteraction(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L);
  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofEasyCam, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_EasyCam_addInteraction__SWIG_1(L);}  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofEasyCam, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          { _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_EasyCam_addInteraction__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'EasyCam_addInteraction'\n"
  "  Possible C/C++ prototypes are:\n" "    ofEasyCam::addInteraction(ofEasyCam::TransformType,int,int)\n"
  "    ofEasyCam::addInteraction(ofEasyCam::TransformType,int)\n"); lua_error(L);return 0; }
static int _wrap_EasyCam_removeInteraction__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofEasyCam *arg1 = (ofEasyCam *) 0 ;
  ofEasyCam::TransformType arg2 ; int arg3 ; int arg4 ; SWIG_check_num_args("ofEasyCam::removeInteraction",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofEasyCam::removeInteraction",1,"ofEasyCam *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofEasyCam::removeInteraction",2,"ofEasyCam::TransformType");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofEasyCam::removeInteraction",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofEasyCam::removeInteraction",4,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofEasyCam,0))){
    SWIG_fail_ptr("EasyCam_removeInteraction",1,SWIGTYPE_p_ofEasyCam); } 
  arg2 = (ofEasyCam::TransformType)(int)lua_tonumber(L, 2); arg3 = (int)lua_tonumber(L, 3); arg4 = (int)lua_tonumber(L, 4);
  (arg1)->removeInteraction(arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_EasyCam_removeInteraction__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofEasyCam *arg1 = (ofEasyCam *) 0 ;
  ofEasyCam::TransformType arg2 ; int arg3 ; SWIG_check_num_args("ofEasyCam::removeInteraction",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofEasyCam::removeInteraction",1,"ofEasyCam *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofEasyCam::removeInteraction",2,"ofEasyCam::TransformType");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofEasyCam::removeInteraction",3,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofEasyCam,0))){
    SWIG_fail_ptr("EasyCam_removeInteraction",1,SWIGTYPE_p_ofEasyCam); } 
  arg2 = (ofEasyCam::TransformType)(int)lua_tonumber(L, 2); arg3 = (int)lua_tonumber(L, 3);
  (arg1)->removeInteraction(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_EasyCam_removeInteraction(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L);
  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofEasyCam, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_EasyCam_removeInteraction__SWIG_1(L);}  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofEasyCam, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          { _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_EasyCam_removeInteraction__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'EasyCam_removeInteraction'\n"
  "  Possible C/C++ prototypes are:\n" "    ofEasyCam::removeInteraction(ofEasyCam::TransformType,int,int)\n"
  "    ofEasyCam::removeInteraction(ofEasyCam::TransformType,int)\n"); lua_error(L);return 0; }
static int _wrap_EasyCam_hasInteraction__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofEasyCam *arg1 = (ofEasyCam *) 0 ;
  ofEasyCam::TransformType arg2 ; int arg3 ; int arg4 ; bool result; SWIG_check_num_args("ofEasyCam::hasInteraction",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofEasyCam::hasInteraction",1,"ofEasyCam *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofEasyCam::hasInteraction",2,"ofEasyCam::TransformType");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofEasyCam::hasInteraction",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofEasyCam::hasInteraction",4,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofEasyCam,0))){
    SWIG_fail_ptr("EasyCam_hasInteraction",1,SWIGTYPE_p_ofEasyCam); }  arg2 = (ofEasyCam::TransformType)(int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3); arg4 = (int)lua_tonumber(L, 4); result = (bool)(arg1)->hasInteraction(arg2,arg3,arg4);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_EasyCam_hasInteraction__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofEasyCam *arg1 = (ofEasyCam *) 0 ;
  ofEasyCam::TransformType arg2 ; int arg3 ; bool result; SWIG_check_num_args("ofEasyCam::hasInteraction",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofEasyCam::hasInteraction",1,"ofEasyCam *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofEasyCam::hasInteraction",2,"ofEasyCam::TransformType");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofEasyCam::hasInteraction",3,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofEasyCam,0))){
    SWIG_fail_ptr("EasyCam_hasInteraction",1,SWIGTYPE_p_ofEasyCam); }  arg2 = (ofEasyCam::TransformType)(int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3); result = (bool)(arg1)->hasInteraction(arg2,arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_EasyCam_hasInteraction(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L);
  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofEasyCam, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_EasyCam_hasInteraction__SWIG_1(L);}  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofEasyCam, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          { _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_EasyCam_hasInteraction__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'EasyCam_hasInteraction'\n"
  "  Possible C/C++ prototypes are:\n" "    ofEasyCam::hasInteraction(ofEasyCam::TransformType,int,int)\n"
  "    ofEasyCam::hasInteraction(ofEasyCam::TransformType,int)\n"); lua_error(L);return 0; }
static int _wrap_EasyCam_removeAllInteractions(lua_State* L) { int SWIG_arg = 0; ofEasyCam *arg1 = (ofEasyCam *) 0 ;
  SWIG_check_num_args("ofEasyCam::removeAllInteractions",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofEasyCam::removeAllInteractions",1,"ofEasyCam *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofEasyCam,0))){
    SWIG_fail_ptr("EasyCam_removeAllInteractions",1,SWIGTYPE_p_ofEasyCam); }  (arg1)->removeAllInteractions(); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static void swig_delete_EasyCam(void *obj) {
ofEasyCam *arg1 = (ofEasyCam *) obj;
delete arg1;
}
static int _proxy__wrap_new_EasyCam(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_EasyCam);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_EasyCam_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_EasyCam_methods[]= {
    { "beginCamera", _wrap_EasyCam_beginCamera},
    { "reset", _wrap_EasyCam_reset},
    { "setTarget", _wrap_EasyCam_setTarget},
    { "getTarget", _wrap_EasyCam_getTarget},
    { "setDistance", _wrap_EasyCam_setDistance},
    { "getDistance", _wrap_EasyCam_getDistance},
    { "setDrag", _wrap_EasyCam_setDrag},
    { "getDrag", _wrap_EasyCam_getDrag},
    { "setAutoDistance", _wrap_EasyCam_setAutoDistance},
    { "setEvents", _wrap_EasyCam_setEvents},
    { "setRotationSensitivity", _wrap_EasyCam_setRotationSensitivity},
    { "setTranslationSensitivity", _wrap_EasyCam_setTranslationSensitivity},
    { "setTranslationKey", _wrap_EasyCam_setTranslationKey},
    { "getTranslationKey", _wrap_EasyCam_getTranslationKey},
    { "enableMouseInput", _wrap_EasyCam_enableMouseInput},
    { "disableMouseInput", _wrap_EasyCam_disableMouseInput},
    { "getMouseInputEnabled", _wrap_EasyCam_getMouseInputEnabled},
    { "enableMouseMiddleButton", _wrap_EasyCam_enableMouseMiddleButton},
    { "disableMouseMiddleButton", _wrap_EasyCam_disableMouseMiddleButton},
    { "getMouseMiddleButtonEnabled", _wrap_EasyCam_getMouseMiddleButtonEnabled},
    { "setRelativeYAxis", _wrap_EasyCam_setRelativeYAxis},
    { "getRelativeYAxis", _wrap_EasyCam_getRelativeYAxis},
    { "setUpAxis", _wrap_EasyCam_setUpAxis},
    { "getUpAxis", _wrap_EasyCam_getUpAxis},
    { "enableInertia", _wrap_EasyCam_enableInertia},
    { "disableInertia", _wrap_EasyCam_disableInertia},
    { "getInertiaEnabled", _wrap_EasyCam_getInertiaEnabled},
    { "setControlArea", _wrap_EasyCam_setControlArea},
    { "clearControlArea", _wrap_EasyCam_clearControlArea},
    { "getControlArea", _wrap_EasyCam_getControlArea},
    { "addInteraction", _wrap_EasyCam_addInteraction},
    { "removeInteraction", _wrap_EasyCam_removeInteraction},
    { "hasInteraction", _wrap_EasyCam_hasInteraction},
    { "removeAllInteractions", _wrap_EasyCam_removeAllInteractions},
    {0,0}
};
static swig_lua_method swig_EasyCam_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_EasyCam_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_EasyCam_Sf_SwigStatic_constants[]= {
    {SWIG_LUA_CONSTTAB_INT("TRANSFORM_NONE", ofEasyCam::TRANSFORM_NONE)},
    {SWIG_LUA_CONSTTAB_INT("TRANSFORM_ROTATE", ofEasyCam::TRANSFORM_ROTATE)},
    {SWIG_LUA_CONSTTAB_INT("TRANSFORM_TRANSLATE_XY", ofEasyCam::TRANSFORM_TRANSLATE_XY)},
    {SWIG_LUA_CONSTTAB_INT("TRANSFORM_TRANSLATE_Z", ofEasyCam::TRANSFORM_TRANSLATE_Z)},
    {SWIG_LUA_CONSTTAB_INT("TRANSFORM_SCALE", ofEasyCam::TRANSFORM_SCALE)},
    {0,0,0,0,0,0}
};
static swig_lua_method swig_EasyCam_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_EasyCam_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_EasyCam_Sf_SwigStatic = {
    "EasyCam",
    swig_EasyCam_Sf_SwigStatic_methods,
    swig_EasyCam_Sf_SwigStatic_attributes,
    swig_EasyCam_Sf_SwigStatic_constants,
    swig_EasyCam_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_EasyCam_bases[] = {0,0};
static const char *swig_EasyCam_base_names[] = {"ofCamera *",0};
static swig_lua_class _wrap_class_EasyCam = { "EasyCam", "EasyCam", &SWIGTYPE_p_ofEasyCam,_proxy__wrap_new_EasyCam, swig_delete_EasyCam, swig_EasyCam_methods, swig_EasyCam_attributes, &swig_EasyCam_Sf_SwigStatic, swig_EasyCam_meta, swig_EasyCam_bases, swig_EasyCam_base_names };

static int _wrap_new_Mesh__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *result = 0 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::ofMesh_",0,0)
  result = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *)new ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,1); SWIG_arg++; 
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_new_Mesh__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofPrimitiveMode arg1 ;
  std::vector< ofDefaultVertexType > *arg2 = 0 ;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *result = 0 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::ofMesh_",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::ofMesh_",1,"ofPrimitiveMode");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::ofMesh_",2,"std::vector< ofDefaultVertexType > const &");
  arg1 = (ofPrimitiveMode)(int)lua_tonumber(L, 1);
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_std__vectorT_glm__vec3_t,0))){
    SWIG_fail_ptr("new_Mesh",2,SWIGTYPE_p_std__vectorT_glm__vec3_t); } 
  result = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *)new ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >(arg1,(std::vector< ofDefaultVertexType > const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,1); SWIG_arg++; 
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_new_Mesh(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 0) {
    return _wrap_new_Mesh__SWIG_0(L);}  if (argc == 2) { int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_std__vectorT_glm__vec3_t, 0)) {
          _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_new_Mesh__SWIG_1(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_Mesh'\n" "  Possible C/C++ prototypes are:\n"
  "    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::ofMesh_()\n"
  "    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::ofMesh_(ofPrimitiveMode,std::vector< ofDefaultVertexType > const &)\n");
  lua_error(L);return 0; }
static int _wrap_Mesh_setFromTriangles__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  std::vector< ofMeshFace_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > > *arg2 = 0 ;
  bool arg3 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::setFromTriangles",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::setFromTriangles",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::setFromTriangles",2,"std::vector< ofMeshFace_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > > const &");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::setFromTriangles",3,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_setFromTriangles",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_std__vectorT_ofMeshFace_T_glm__vec3_glm__vec3_ofColor_T_float_t_glm__vec2_t_t,0))){
    SWIG_fail_ptr("Mesh_setFromTriangles",2,SWIGTYPE_p_std__vectorT_ofMeshFace_T_glm__vec3_glm__vec3_ofColor_T_float_t_glm__vec2_t_t); }
   arg3 = (lua_toboolean(L, 3)!=0);
  (arg1)->setFromTriangles((std::vector< ofMeshFace_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > > const &)*arg2,arg3);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_setFromTriangles__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  std::vector< ofMeshFace_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > > *arg2 = 0 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::setFromTriangles",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::setFromTriangles",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::setFromTriangles",2,"std::vector< ofMeshFace_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > > const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_setFromTriangles",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_std__vectorT_ofMeshFace_T_glm__vec3_glm__vec3_ofColor_T_float_t_glm__vec2_t_t,0))){
    SWIG_fail_ptr("Mesh_setFromTriangles",2,SWIGTYPE_p_std__vectorT_ofMeshFace_T_glm__vec3_glm__vec3_ofColor_T_float_t_glm__vec2_t_t); }
  
  (arg1)->setFromTriangles((std::vector< ofMeshFace_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > > const &)*arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_setFromTriangles(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_std__vectorT_ofMeshFace_T_glm__vec3_glm__vec3_ofColor_T_float_t_glm__vec2_t_t, 0)) {
          _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Mesh_setFromTriangles__SWIG_1(L);}  }  }  if (argc == 3) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_std__vectorT_ofMeshFace_T_glm__vec3_glm__vec3_ofColor_T_float_t_glm__vec2_t_t, 0)) {
          _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isboolean(L,argv[2]); }  if (_v) {
          return _wrap_Mesh_setFromTriangles__SWIG_0(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Mesh_setFromTriangles'\n"
  "  Possible C/C++ prototypes are:\n"
  "    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::setFromTriangles(std::vector< ofMeshFace_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > > const &,bool)\n"
  "    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::setFromTriangles(std::vector< ofMeshFace_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > > const &)\n");
  lua_error(L);return 0; }
static int _wrap_Mesh_setMode(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  ofPrimitiveMode arg2 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::setMode",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::setMode",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::setMode",2,"ofPrimitiveMode");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_setMode",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   arg2 = (ofPrimitiveMode)(int)lua_tonumber(L, 2); (arg1)->setMode(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Mesh_getMode(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  ofPrimitiveMode result;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getMode",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getMode",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_getMode",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
  
  result = (ofPrimitiveMode)((ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *)arg1)->getMode();
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Mesh_plane__SWIG_0(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; int arg3 ; int arg4 ;
  ofPrimitiveMode arg5 ; ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > result;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::plane",5,5)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::plane",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::plane",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::plane",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::plane",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::plane",5,"ofPrimitiveMode");
  arg1 = (float)lua_tonumber(L, 1); arg2 = (float)lua_tonumber(L, 2); arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4); arg5 = (ofPrimitiveMode)(int)lua_tonumber(L, 5);
  result = ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::SWIGTEMPLATEDISAMBIGUATOR plane(arg1,arg2,arg3,arg4,arg5);
  {
    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > * resultptr = new ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >((const ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,1); SWIG_arg++; }
   return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_plane__SWIG_1(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; int arg3 ; int arg4 ;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > result;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::plane",4,4)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::plane",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::plane",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::plane",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::plane",4,"int");
  arg1 = (float)lua_tonumber(L, 1); arg2 = (float)lua_tonumber(L, 2); arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  result = ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::SWIGTEMPLATEDISAMBIGUATOR plane(arg1,arg2,arg3,arg4);
  {
    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > * resultptr = new ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >((const ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,1); SWIG_arg++; }
   return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_plane__SWIG_2(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; int arg3 ;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > result;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::plane",3,3)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::plane",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::plane",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::plane",3,"int");
  arg1 = (float)lua_tonumber(L, 1); arg2 = (float)lua_tonumber(L, 2); arg3 = (int)lua_tonumber(L, 3);
  result = ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::SWIGTEMPLATEDISAMBIGUATOR plane(arg1,arg2,arg3);
  {
    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > * resultptr = new ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >((const ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,1); SWIG_arg++; }
   return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_plane__SWIG_3(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > result;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::plane",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::plane",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::plane",2,"float");
  arg1 = (float)lua_tonumber(L, 1); arg2 = (float)lua_tonumber(L, 2);
  result = ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::SWIGTEMPLATEDISAMBIGUATOR plane(arg1,arg2);
  {
    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > * resultptr = new ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >((const ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,1); SWIG_arg++; }
   return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_plane(lua_State* L) { int argc; int argv[6]={ 1,2,3,4,5,6} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_Mesh_plane__SWIG_3(L);}  }  }  if (argc == 3) { int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { {
        _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_Mesh_plane__SWIG_2(L);}  }  }  }  if (argc == 4) { int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { {
        _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); }
           if (_v) { return _wrap_Mesh_plane__SWIG_1(L);}  }  }  }  }  if (argc == 5) { int _v; { _v = lua_isnumber(L,argv[0]); }
     if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { {
            _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) {
              return _wrap_Mesh_plane__SWIG_0(L);}  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Mesh_plane'\n" "  Possible C/C++ prototypes are:\n"
  "    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::plane(float,float,int,int,ofPrimitiveMode)\n"
  "    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::plane(float,float,int,int)\n"
  "    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::plane(float,float,int)\n"
  "    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::plane(float,float)\n");
  lua_error(L);return 0; }
static int _wrap_Mesh_sphere__SWIG_0(lua_State* L) { int SWIG_arg = 0; float arg1 ; int arg2 ; ofPrimitiveMode arg3 ;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > result;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::sphere",3,3)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::sphere",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::sphere",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::sphere",3,"ofPrimitiveMode");
  arg1 = (float)lua_tonumber(L, 1); arg2 = (int)lua_tonumber(L, 2); arg3 = (ofPrimitiveMode)(int)lua_tonumber(L, 3);
  result = ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::SWIGTEMPLATEDISAMBIGUATOR sphere(arg1,arg2,arg3);
  {
    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > * resultptr = new ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >((const ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,1); SWIG_arg++; }
   return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_sphere__SWIG_1(lua_State* L) { int SWIG_arg = 0; float arg1 ; int arg2 ;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > result;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::sphere",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::sphere",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::sphere",2,"int");
  arg1 = (float)lua_tonumber(L, 1); arg2 = (int)lua_tonumber(L, 2);
  result = ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::SWIGTEMPLATEDISAMBIGUATOR sphere(arg1,arg2);
  {
    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > * resultptr = new ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >((const ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,1); SWIG_arg++; }
   return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_sphere__SWIG_2(lua_State* L) { int SWIG_arg = 0; float arg1 ;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > result;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::sphere",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::sphere",1,"float");
  arg1 = (float)lua_tonumber(L, 1);
  result = ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::SWIGTEMPLATEDISAMBIGUATOR sphere(arg1);
  {
    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > * resultptr = new ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >((const ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,1); SWIG_arg++; }
   return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_sphere(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 1) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { return _wrap_Mesh_sphere__SWIG_2(L);}  }  if (argc == 2) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_Mesh_sphere__SWIG_1(L);}  }  }  if (argc == 3) { int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { {
        _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_Mesh_sphere__SWIG_0(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Mesh_sphere'\n" "  Possible C/C++ prototypes are:\n"
  "    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::sphere(float,int,ofPrimitiveMode)\n"
  "    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::sphere(float,int)\n"
  "    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::sphere(float)\n");
  lua_error(L);return 0; }
static int _wrap_Mesh_icosahedron(lua_State* L) { int SWIG_arg = 0; float arg1 ;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > result;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::icosahedron",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::icosahedron",1,"float");
  arg1 = (float)lua_tonumber(L, 1);
  result = ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::SWIGTEMPLATEDISAMBIGUATOR icosahedron(arg1);
  {
    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > * resultptr = new ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >((const ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,1); SWIG_arg++; }
   return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_icosphere__SWIG_0(lua_State* L) { int SWIG_arg = 0; float arg1 ; std::size_t arg2 ;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > result;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::icosphere",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::icosphere",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::icosphere",2,"std::size_t");
  arg1 = (float)lua_tonumber(L, 1); SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (std::size_t)lua_tonumber(L, 2);
  result = ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::SWIGTEMPLATEDISAMBIGUATOR icosphere(arg1,arg2);
  {
    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > * resultptr = new ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >((const ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,1); SWIG_arg++; }
   return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_icosphere__SWIG_1(lua_State* L) { int SWIG_arg = 0; float arg1 ;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > result;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::icosphere",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::icosphere",1,"float");
  arg1 = (float)lua_tonumber(L, 1);
  result = ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::SWIGTEMPLATEDISAMBIGUATOR icosphere(arg1);
  {
    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > * resultptr = new ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >((const ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,1); SWIG_arg++; }
   return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_icosphere(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 1) { int _v;
    { _v = lua_isnumber(L,argv[0]); }  if (_v) { return _wrap_Mesh_icosphere__SWIG_1(L);}  }  if (argc == 2) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_Mesh_icosphere__SWIG_0(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Mesh_icosphere'\n" "  Possible C/C++ prototypes are:\n"
  "    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::icosphere(float,std::size_t)\n"
  "    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::icosphere(float)\n");
  lua_error(L);return 0; }
static int _wrap_Mesh_cylinder__SWIG_0(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; int arg3 ; int arg4 ;
  int arg5 ; bool arg6 ; ofPrimitiveMode arg7 ;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > result;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::cylinder",7,7)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::cylinder",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::cylinder",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::cylinder",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::cylinder",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::cylinder",5,"int");
  if(!lua_isboolean(L,6)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::cylinder",6,"bool");
  if(!lua_isnumber(L,7)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::cylinder",7,"ofPrimitiveMode");
  arg1 = (float)lua_tonumber(L, 1); arg2 = (float)lua_tonumber(L, 2); arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4); arg5 = (int)lua_tonumber(L, 5); arg6 = (lua_toboolean(L, 6)!=0);
  arg7 = (ofPrimitiveMode)(int)lua_tonumber(L, 7);
  result = ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::SWIGTEMPLATEDISAMBIGUATOR cylinder(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
  {
    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > * resultptr = new ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >((const ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,1); SWIG_arg++; }
   return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_cylinder__SWIG_1(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; int arg3 ; int arg4 ;
  int arg5 ; bool arg6 ; ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > result;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::cylinder",6,6)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::cylinder",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::cylinder",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::cylinder",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::cylinder",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::cylinder",5,"int");
  if(!lua_isboolean(L,6)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::cylinder",6,"bool");
  arg1 = (float)lua_tonumber(L, 1); arg2 = (float)lua_tonumber(L, 2); arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4); arg5 = (int)lua_tonumber(L, 5); arg6 = (lua_toboolean(L, 6)!=0);
  result = ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::SWIGTEMPLATEDISAMBIGUATOR cylinder(arg1,arg2,arg3,arg4,arg5,arg6);
  {
    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > * resultptr = new ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >((const ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,1); SWIG_arg++; }
   return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_cylinder__SWIG_2(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; int arg3 ; int arg4 ;
  int arg5 ; ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > result;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::cylinder",5,5)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::cylinder",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::cylinder",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::cylinder",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::cylinder",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::cylinder",5,"int");
  arg1 = (float)lua_tonumber(L, 1); arg2 = (float)lua_tonumber(L, 2); arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4); arg5 = (int)lua_tonumber(L, 5);
  result = ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::SWIGTEMPLATEDISAMBIGUATOR cylinder(arg1,arg2,arg3,arg4,arg5);
  {
    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > * resultptr = new ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >((const ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,1); SWIG_arg++; }
   return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_cylinder__SWIG_3(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; int arg3 ; int arg4 ;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > result;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::cylinder",4,4)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::cylinder",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::cylinder",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::cylinder",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::cylinder",4,"int");
  arg1 = (float)lua_tonumber(L, 1); arg2 = (float)lua_tonumber(L, 2); arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  result = ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::SWIGTEMPLATEDISAMBIGUATOR cylinder(arg1,arg2,arg3,arg4);
  {
    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > * resultptr = new ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >((const ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,1); SWIG_arg++; }
   return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_cylinder__SWIG_4(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; int arg3 ;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > result;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::cylinder",3,3)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::cylinder",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::cylinder",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::cylinder",3,"int");
  arg1 = (float)lua_tonumber(L, 1); arg2 = (float)lua_tonumber(L, 2); arg3 = (int)lua_tonumber(L, 3);
  result = ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::SWIGTEMPLATEDISAMBIGUATOR cylinder(arg1,arg2,arg3);
  {
    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > * resultptr = new ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >((const ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,1); SWIG_arg++; }
   return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_cylinder__SWIG_5(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > result;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::cylinder",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::cylinder",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::cylinder",2,"float");
  arg1 = (float)lua_tonumber(L, 1); arg2 = (float)lua_tonumber(L, 2);
  result = ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::SWIGTEMPLATEDISAMBIGUATOR cylinder(arg1,arg2);
  {
    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > * resultptr = new ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >((const ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,1); SWIG_arg++; }
   return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_cylinder(lua_State* L) { int argc; int argv[8]={ 1,2,3,4,5,6,7,8} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_Mesh_cylinder__SWIG_5(L);}  }  }  if (argc == 3) { int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { {
        _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_Mesh_cylinder__SWIG_4(L);}  }  }  }  if (argc == 4) { int _v; { _v = lua_isnumber(L,argv[0]); } 
    if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { {
            _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_Mesh_cylinder__SWIG_3(L);}  }  }  }  }  if (argc == 5) {
    int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { {
          _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { {
              _v = lua_isnumber(L,argv[4]); }  if (_v) { return _wrap_Mesh_cylinder__SWIG_2(L);}  }  }  }  }  } 
  if (argc == 6) { int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { {
          _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { {
              _v = lua_isnumber(L,argv[4]); }  if (_v) { { _v = lua_isboolean(L,argv[5]); }  if (_v) {
                return _wrap_Mesh_cylinder__SWIG_1(L);}  }  }  }  }  }  }  if (argc == 7) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); } 
        if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) { {
                _v = lua_isboolean(L,argv[5]); }  if (_v) { { _v = lua_isnumber(L,argv[6]); }  if (_v) {
                  return _wrap_Mesh_cylinder__SWIG_0(L);}  }  }  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Mesh_cylinder'\n" "  Possible C/C++ prototypes are:\n"
  "    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::cylinder(float,float,int,int,int,bool,ofPrimitiveMode)\n"
  "    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::cylinder(float,float,int,int,int,bool)\n"
  "    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::cylinder(float,float,int,int,int)\n"
  "    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::cylinder(float,float,int,int)\n"
  "    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::cylinder(float,float,int)\n"
  "    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::cylinder(float,float)\n");
  lua_error(L);return 0; }
static int _wrap_Mesh_cone__SWIG_0(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; int arg3 ; int arg4 ; int arg5 ;
  ofPrimitiveMode arg6 ; ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > result;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::cone",6,6)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::cone",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::cone",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::cone",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::cone",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::cone",5,"int");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::cone",6,"ofPrimitiveMode");
  arg1 = (float)lua_tonumber(L, 1); arg2 = (float)lua_tonumber(L, 2); arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4); arg5 = (int)lua_tonumber(L, 5); arg6 = (ofPrimitiveMode)(int)lua_tonumber(L, 6);
  result = ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::SWIGTEMPLATEDISAMBIGUATOR cone(arg1,arg2,arg3,arg4,arg5,arg6);
  {
    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > * resultptr = new ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >((const ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,1); SWIG_arg++; }
   return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_cone__SWIG_1(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; int arg3 ; int arg4 ; int arg5 ;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > result;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::cone",5,5)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::cone",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::cone",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::cone",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::cone",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::cone",5,"int");
  arg1 = (float)lua_tonumber(L, 1); arg2 = (float)lua_tonumber(L, 2); arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4); arg5 = (int)lua_tonumber(L, 5);
  result = ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::SWIGTEMPLATEDISAMBIGUATOR cone(arg1,arg2,arg3,arg4,arg5);
  {
    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > * resultptr = new ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >((const ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,1); SWIG_arg++; }
   return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_cone__SWIG_2(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; int arg3 ; int arg4 ;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > result;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::cone",4,4)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::cone",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::cone",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::cone",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::cone",4,"int");
  arg1 = (float)lua_tonumber(L, 1); arg2 = (float)lua_tonumber(L, 2); arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  result = ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::SWIGTEMPLATEDISAMBIGUATOR cone(arg1,arg2,arg3,arg4);
  {
    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > * resultptr = new ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >((const ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,1); SWIG_arg++; }
   return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_cone__SWIG_3(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; int arg3 ;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > result;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::cone",3,3)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::cone",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::cone",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::cone",3,"int");
  arg1 = (float)lua_tonumber(L, 1); arg2 = (float)lua_tonumber(L, 2); arg3 = (int)lua_tonumber(L, 3);
  result = ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::SWIGTEMPLATEDISAMBIGUATOR cone(arg1,arg2,arg3);
  {
    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > * resultptr = new ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >((const ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,1); SWIG_arg++; }
   return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_cone__SWIG_4(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > result;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::cone",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::cone",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::cone",2,"float");
  arg1 = (float)lua_tonumber(L, 1); arg2 = (float)lua_tonumber(L, 2);
  result = ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::SWIGTEMPLATEDISAMBIGUATOR cone(arg1,arg2);
  {
    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > * resultptr = new ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >((const ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,1); SWIG_arg++; }
   return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_cone(lua_State* L) { int argc; int argv[7]={ 1,2,3,4,5,6,7} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_Mesh_cone__SWIG_4(L);}  }  }  if (argc == 3) { int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { {
        _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_Mesh_cone__SWIG_3(L);}  }  }  }  if (argc == 4) { int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { {
        _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); }
           if (_v) { return _wrap_Mesh_cone__SWIG_2(L);}  }  }  }  }  if (argc == 5) { int _v; { _v = lua_isnumber(L,argv[0]); }
     if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { {
            _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) {
              return _wrap_Mesh_cone__SWIG_1(L);}  }  }  }  }  }  if (argc == 6) { int _v; { _v = lua_isnumber(L,argv[0]); } 
    if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { {
            _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) { {
                _v = lua_isnumber(L,argv[5]); }  if (_v) { return _wrap_Mesh_cone__SWIG_0(L);}  }  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Mesh_cone'\n" "  Possible C/C++ prototypes are:\n"
  "    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::cone(float,float,int,int,int,ofPrimitiveMode)\n"
  "    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::cone(float,float,int,int,int)\n"
  "    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::cone(float,float,int,int)\n"
  "    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::cone(float,float,int)\n"
  "    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::cone(float,float)\n");
  lua_error(L);return 0; }
static int _wrap_Mesh_box__SWIG_0(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ; int arg4 ; int arg5 ;
  int arg6 ; ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > result;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::box",6,6)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::box",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::box",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::box",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::box",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::box",5,"int");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::box",6,"int");
  arg1 = (float)lua_tonumber(L, 1); arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4); arg5 = (int)lua_tonumber(L, 5); arg6 = (int)lua_tonumber(L, 6);
  result = ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::SWIGTEMPLATEDISAMBIGUATOR box(arg1,arg2,arg3,arg4,arg5,arg6);
  {
    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > * resultptr = new ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >((const ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,1); SWIG_arg++; }
   return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_box__SWIG_1(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ; int arg4 ; int arg5 ;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > result;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::box",5,5)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::box",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::box",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::box",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::box",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::box",5,"int");
  arg1 = (float)lua_tonumber(L, 1); arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4); arg5 = (int)lua_tonumber(L, 5);
  result = ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::SWIGTEMPLATEDISAMBIGUATOR box(arg1,arg2,arg3,arg4,arg5);
  {
    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > * resultptr = new ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >((const ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,1); SWIG_arg++; }
   return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_box__SWIG_2(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ; int arg4 ;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > result;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::box",4,4)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::box",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::box",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::box",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::box",4,"int");
  arg1 = (float)lua_tonumber(L, 1); arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  result = ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::SWIGTEMPLATEDISAMBIGUATOR box(arg1,arg2,arg3,arg4);
  {
    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > * resultptr = new ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >((const ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,1); SWIG_arg++; }
   return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_box__SWIG_3(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > result;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::box",3,3)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::box",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::box",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::box",3,"float");
  arg1 = (float)lua_tonumber(L, 1); arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3);
  result = ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::SWIGTEMPLATEDISAMBIGUATOR box(arg1,arg2,arg3);
  {
    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > * resultptr = new ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >((const ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,1); SWIG_arg++; }
   return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_box(lua_State* L) { int argc; int argv[7]={ 1,2,3,4,5,6,7} ; argc = lua_gettop(L); if (argc == 3) {
    int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { {
          _v = lua_isnumber(L,argv[2]); }  if (_v) { return _wrap_Mesh_box__SWIG_3(L);}  }  }  }  if (argc == 4) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); } 
        if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_Mesh_box__SWIG_2(L);}  }  }  }  }  if (argc == 5) {
    int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { {
          _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { {
              _v = lua_isnumber(L,argv[4]); }  if (_v) { return _wrap_Mesh_box__SWIG_1(L);}  }  }  }  }  }  if (argc == 6) {
    int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { {
          _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { {
              _v = lua_isnumber(L,argv[4]); }  if (_v) { { _v = lua_isnumber(L,argv[5]); }  if (_v) {
                return _wrap_Mesh_box__SWIG_0(L);}  }  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Mesh_box'\n" "  Possible C/C++ prototypes are:\n"
  "    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::box(float,float,float,int,int,int)\n"
  "    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::box(float,float,float,int,int)\n"
  "    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::box(float,float,float,int)\n"
  "    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::box(float,float,float)\n");
  lua_error(L);return 0; }
static int _wrap_Mesh_axis__SWIG_0(lua_State* L) { int SWIG_arg = 0; float arg1 ;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > result;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::axis",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::axis",1,"float");
  arg1 = (float)lua_tonumber(L, 1);
  result = ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::SWIGTEMPLATEDISAMBIGUATOR axis(arg1);
  {
    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > * resultptr = new ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >((const ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,1); SWIG_arg++; }
   return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_axis__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > result;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::axis",0,0)
  result = ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::SWIGTEMPLATEDISAMBIGUATOR axis();
  {
    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > * resultptr = new ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >((const ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,1); SWIG_arg++; }
   return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_axis(lua_State* L) { int argc; int argv[2]={ 1,2} ; argc = lua_gettop(L); if (argc == 0) {
    return _wrap_Mesh_axis__SWIG_1(L);}  if (argc == 1) { int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) {
      return _wrap_Mesh_axis__SWIG_0(L);}  }  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Mesh_axis'\n"
  "  Possible C/C++ prototypes are:\n"
  "    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::axis(float)\n"
  "    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::axis()\n");
  lua_error(L);return 0; }
static int _wrap_Mesh_addVertex(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  ofDefaultVertexType *arg2 = 0 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::addVertex",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::addVertex",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::addVertex",2,"ofDefaultVertexType const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_addVertex",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("Mesh_addVertex",2,SWIGTYPE_p_glm__vec3); }  (arg1)->addVertex((ofDefaultVertexType const &)*arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_addVertices__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  std::vector< ofDefaultVertexType > *arg2 = 0 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::addVertices",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::addVertices",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::addVertices",2,"std::vector< ofDefaultVertexType > const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_addVertices",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_std__vectorT_glm__vec3_t,0))){
    SWIG_fail_ptr("Mesh_addVertices",2,SWIGTYPE_p_std__vectorT_glm__vec3_t); } 
  (arg1)->addVertices((std::vector< ofDefaultVertexType > const &)*arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Mesh_addVertices__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  ofDefaultVertexType *arg2 = (ofDefaultVertexType *) 0 ; std::size_t arg3 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::addVertices",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::addVertices",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::addVertices",2,"ofDefaultVertexType const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::addVertices",3,"std::size_t");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_addVertices",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("Mesh_addVertices",2,SWIGTYPE_p_glm__vec3); } 
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (std::size_t)lua_tonumber(L, 3);
  (arg1)->addVertices((ofDefaultVertexType const *)arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Mesh_addVertices(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_std__vectorT_glm__vec3_t, 0)) {
          _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Mesh_addVertices__SWIG_0(L);}  }  }  if (argc == 3) { int _v; {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { return _wrap_Mesh_addVertices__SWIG_1(L);}
         }  }  }  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Mesh_addVertices'\n"
  "  Possible C/C++ prototypes are:\n"
  "    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::addVertices(std::vector< ofDefaultVertexType > const &)\n"
  "    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::addVertices(ofDefaultVertexType const *,std::size_t)\n");
  lua_error(L);return 0; }
static int _wrap_Mesh_removeVertex(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  ofIndexType arg2 ; ofIndexType *argp2 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::removeVertex",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::removeVertex",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::removeVertex",2,"ofIndexType");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_removeVertex",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_TESSindex,0))){
    SWIG_fail_ptr("Mesh_removeVertex",2,SWIGTYPE_p_TESSindex); }  arg2 = *argp2; (arg1)->removeVertex(arg2); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_setVertex(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  ofIndexType arg2 ; ofDefaultVertexType *arg3 = 0 ; ofIndexType *argp2 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::setVertex",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::setVertex",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::setVertex",2,"ofIndexType");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::setVertex",3,"ofDefaultVertexType const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_setVertex",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_TESSindex,0))){
    SWIG_fail_ptr("Mesh_setVertex",2,SWIGTYPE_p_TESSindex); }  arg2 = *argp2;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("Mesh_setVertex",3,SWIGTYPE_p_glm__vec3); }  (arg1)->setVertex(arg2,(ofDefaultVertexType const &)*arg3);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_clearVertices(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::clearVertices",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::clearVertices",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_clearVertices",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   (arg1)->clearVertices(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_clear(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::clear",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::clear",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_clear",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   (arg1)->clear(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_getNumVertices(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  std::size_t result;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getNumVertices",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getNumVertices",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_getNumVertices",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
  
  result = (std::size_t)((ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *)arg1)->getNumVertices();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_getVerticesPointer__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  ofDefaultVertexType *result = 0 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getVerticesPointer",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getVerticesPointer",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_getVerticesPointer",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   result = (ofDefaultVertexType *)(arg1)->getVerticesPointer();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_glm__vec3,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Mesh_getVerticesPointer__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  ofDefaultVertexType *result = 0 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getVerticesPointer",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getVerticesPointer",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_getVerticesPointer",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
  
  result = (ofDefaultVertexType *)((ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *)arg1)->getVerticesPointer();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_glm__vec3,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Mesh_getVerticesPointer(lua_State* L) { int argc; int argv[2]={ 1,2} ; argc = lua_gettop(L); if (argc == 1) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Mesh_getVerticesPointer__SWIG_0(L);}  }  if (argc == 1) { int _v;
    { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Mesh_getVerticesPointer__SWIG_1(L);}  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Mesh_getVerticesPointer'\n"
  "  Possible C/C++ prototypes are:\n"
  "    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getVerticesPointer()\n"
  "    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getVerticesPointer() const\n");
  lua_error(L);return 0; }
static int _wrap_Mesh_getVertex(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  ofIndexType arg2 ; ofIndexType *argp2 ; ofDefaultVertexType result;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getVertex",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getVertex",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getVertex",2,"ofIndexType");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_getVertex",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_TESSindex,0))){
    SWIG_fail_ptr("Mesh_getVertex",2,SWIGTYPE_p_TESSindex); }  arg2 = *argp2;
  result = ((ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *)arg1)->getVertex(arg2);
  { ofDefaultVertexType * resultptr = new ofDefaultVertexType((const ofDefaultVertexType &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_glm__vec3,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_getVertices__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  std::vector< ofDefaultVertexType > *result = 0 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getVertices",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getVertices",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_getVertices",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   result = (std::vector< ofDefaultVertexType > *) &(arg1)->getVertices();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorT_glm__vec3_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_getVertices__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  std::vector< ofDefaultVertexType > *result = 0 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getVertices",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getVertices",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_getVertices",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
  
  result = (std::vector< ofDefaultVertexType > *) &((ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *)arg1)->getVertices();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorT_glm__vec3_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_getVertices(lua_State* L) { int argc; int argv[2]={ 1,2} ; argc = lua_gettop(L); if (argc == 1) { int _v;
    { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Mesh_getVertices__SWIG_0(L);}  }  if (argc == 1) { int _v; {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Mesh_getVertices__SWIG_1(L);}  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Mesh_getVertices'\n" "  Possible C/C++ prototypes are:\n"
  "    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getVertices()\n"
  "    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getVertices() const\n");
  lua_error(L);return 0; }
static int _wrap_Mesh_hasVertices(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  bool result;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::hasVertices",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::hasVertices",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_hasVertices",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
  
  result = (bool)((ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *)arg1)->hasVertices();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_append(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg2 = 0 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::append",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::append",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::append",2,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_append",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_append",2,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   (arg1)->append((ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const &)*arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_mergeDuplicateVertices(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::mergeDuplicateVertices",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::mergeDuplicateVertices",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_mergeDuplicateVertices",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   (arg1)->mergeDuplicateVertices(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_getCentroid(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  ofDefaultVertexType result;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getCentroid",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getCentroid",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_getCentroid",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
  
  result = ((ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *)arg1)->getCentroid();
  { ofDefaultVertexType * resultptr = new ofDefaultVertexType((const ofDefaultVertexType &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_glm__vec3,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_getNormal(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  ofIndexType arg2 ; ofIndexType *argp2 ; ofDefaultNormalType result;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getNormal",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getNormal",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getNormal",2,"ofIndexType");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_getNormal",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_TESSindex,0))){
    SWIG_fail_ptr("Mesh_getNormal",2,SWIGTYPE_p_TESSindex); }  arg2 = *argp2;
  result = ((ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *)arg1)->getNormal(arg2);
  { ofDefaultNormalType * resultptr = new ofDefaultNormalType((const ofDefaultNormalType &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_glm__vec3,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_addNormal(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  ofDefaultNormalType *arg2 = 0 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::addNormal",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::addNormal",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::addNormal",2,"ofDefaultNormalType const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_addNormal",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("Mesh_addNormal",2,SWIGTYPE_p_glm__vec3); }  (arg1)->addNormal((ofDefaultNormalType const &)*arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_addNormals__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  std::vector< ofDefaultNormalType > *arg2 = 0 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::addNormals",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::addNormals",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::addNormals",2,"std::vector< ofDefaultNormalType > const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_addNormals",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_std__vectorT_glm__vec3_t,0))){
    SWIG_fail_ptr("Mesh_addNormals",2,SWIGTYPE_p_std__vectorT_glm__vec3_t); } 
  (arg1)->addNormals((std::vector< ofDefaultNormalType > const &)*arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Mesh_addNormals__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  ofDefaultNormalType *arg2 = (ofDefaultNormalType *) 0 ; std::size_t arg3 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::addNormals",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::addNormals",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::addNormals",2,"ofDefaultNormalType const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::addNormals",3,"std::size_t");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_addNormals",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("Mesh_addNormals",2,SWIGTYPE_p_glm__vec3); } 
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (std::size_t)lua_tonumber(L, 3);
  (arg1)->addNormals((ofDefaultNormalType const *)arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Mesh_addNormals(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_std__vectorT_glm__vec3_t, 0)) {
          _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Mesh_addNormals__SWIG_0(L);}  }  }  if (argc == 3) { int _v; {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { return _wrap_Mesh_addNormals__SWIG_1(L);}  }
       }  }  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Mesh_addNormals'\n"
  "  Possible C/C++ prototypes are:\n"
  "    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::addNormals(std::vector< ofDefaultNormalType > const &)\n"
  "    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::addNormals(ofDefaultNormalType const *,std::size_t)\n");
  lua_error(L);return 0; }
static int _wrap_Mesh_removeNormal(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  ofIndexType arg2 ; ofIndexType *argp2 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::removeNormal",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::removeNormal",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::removeNormal",2,"ofIndexType");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_removeNormal",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_TESSindex,0))){
    SWIG_fail_ptr("Mesh_removeNormal",2,SWIGTYPE_p_TESSindex); }  arg2 = *argp2; (arg1)->removeNormal(arg2); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_setNormal(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  ofIndexType arg2 ; ofDefaultNormalType *arg3 = 0 ; ofIndexType *argp2 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::setNormal",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::setNormal",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::setNormal",2,"ofIndexType");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::setNormal",3,"ofDefaultNormalType const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_setNormal",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_TESSindex,0))){
    SWIG_fail_ptr("Mesh_setNormal",2,SWIGTYPE_p_TESSindex); }  arg2 = *argp2;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("Mesh_setNormal",3,SWIGTYPE_p_glm__vec3); }  (arg1)->setNormal(arg2,(ofDefaultNormalType const &)*arg3);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_clearNormals(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::clearNormals",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::clearNormals",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_clearNormals",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   (arg1)->clearNormals(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_getNumNormals(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  std::size_t result;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getNumNormals",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getNumNormals",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_getNumNormals",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
  
  result = (std::size_t)((ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *)arg1)->getNumNormals();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_getNormalsPointer__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  ofDefaultNormalType *result = 0 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getNormalsPointer",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getNormalsPointer",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_getNormalsPointer",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   result = (ofDefaultNormalType *)(arg1)->getNormalsPointer();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_glm__vec3,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Mesh_getNormalsPointer__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  ofDefaultNormalType *result = 0 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getNormalsPointer",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getNormalsPointer",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_getNormalsPointer",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
  
  result = (ofDefaultNormalType *)((ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *)arg1)->getNormalsPointer();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_glm__vec3,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Mesh_getNormalsPointer(lua_State* L) { int argc; int argv[2]={ 1,2} ; argc = lua_gettop(L); if (argc == 1) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Mesh_getNormalsPointer__SWIG_0(L);}  }  if (argc == 1) { int _v;
    { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Mesh_getNormalsPointer__SWIG_1(L);}  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Mesh_getNormalsPointer'\n"
  "  Possible C/C++ prototypes are:\n"
  "    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getNormalsPointer()\n"
  "    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getNormalsPointer() const\n");
  lua_error(L);return 0; }
static int _wrap_Mesh_getNormals__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  std::vector< ofDefaultNormalType > *result = 0 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getNormals",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getNormals",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_getNormals",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   result = (std::vector< ofDefaultNormalType > *) &(arg1)->getNormals();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorT_glm__vec3_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_getNormals__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  std::vector< ofDefaultNormalType > *result = 0 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getNormals",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getNormals",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_getNormals",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
  
  result = (std::vector< ofDefaultNormalType > *) &((ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *)arg1)->getNormals();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorT_glm__vec3_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_getNormals(lua_State* L) { int argc; int argv[2]={ 1,2} ; argc = lua_gettop(L); if (argc == 1) { int _v; {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Mesh_getNormals__SWIG_0(L);}  }  if (argc == 1) { int _v; {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Mesh_getNormals__SWIG_1(L);}  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Mesh_getNormals'\n" "  Possible C/C++ prototypes are:\n"
  "    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getNormals()\n"
  "    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getNormals() const\n");
  lua_error(L);return 0; }
static int _wrap_Mesh_hasNormals(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  bool result;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::hasNormals",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::hasNormals",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_hasNormals",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
  
  result = (bool)((ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *)arg1)->hasNormals();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_enableNormals(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::enableNormals",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::enableNormals",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_enableNormals",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   (arg1)->enableNormals(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_disableNormals(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::disableNormals",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::disableNormals",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_disableNormals",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   (arg1)->disableNormals(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_usingNormals(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  bool result;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::usingNormals",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::usingNormals",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_usingNormals",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
  
  result = (bool)((ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *)arg1)->usingNormals();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_smoothNormals(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  float arg2 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::smoothNormals",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::smoothNormals",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::smoothNormals",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_smoothNormals",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   arg2 = (float)lua_tonumber(L, 2); (arg1)->smoothNormals(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Mesh_flatNormals(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::flatNormals",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::flatNormals",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_flatNormals",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   (arg1)->flatNormals(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_getFace(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  ofIndexType arg2 ; ofIndexType *argp2 ;
  SwigValueWrapper< ofMeshFace_< glm::vec3,glm::vec3,ofColor_< float >,glm::vec2 > > result;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getFace",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getFace",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getFace",2,"ofIndexType");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_getFace",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_TESSindex,0))){
    SWIG_fail_ptr("Mesh_getFace",2,SWIGTYPE_p_TESSindex); }  arg2 = *argp2;
  result = ((ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *)arg1)->getFace(arg2);
  {
    ofMeshFace_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > * resultptr = new ofMeshFace_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >((const ofMeshFace_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofMeshFace_T_glm__vec3_glm__vec3_ofColor_T_float_t_glm__vec2_t,1); SWIG_arg++; }
   return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_getFaceNormals__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  bool arg2 ; SwigValueWrapper< std::vector< glm::vec3 > > result;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getFaceNormals",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getFaceNormals",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getFaceNormals",2,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_getFaceNormals",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   arg2 = (lua_toboolean(L, 2)!=0);
  result = ((ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *)arg1)->getFaceNormals(arg2);
  {
    std::vector< ofDefaultNormalType > * resultptr = new std::vector< ofDefaultNormalType >((const std::vector< ofDefaultNormalType > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_std__vectorT_glm__vec3_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_getFaceNormals__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  SwigValueWrapper< std::vector< glm::vec3 > > result;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getFaceNormals",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getFaceNormals",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_getFaceNormals",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
  
  result = ((ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *)arg1)->getFaceNormals();
  {
    std::vector< ofDefaultNormalType > * resultptr = new std::vector< ofDefaultNormalType >((const std::vector< ofDefaultNormalType > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_std__vectorT_glm__vec3_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_getFaceNormals(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 1) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Mesh_getFaceNormals__SWIG_1(L);}  }  if (argc == 2) { int _v; {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isboolean(L,argv[1]); }  if (_v) {
        return _wrap_Mesh_getFaceNormals__SWIG_0(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Mesh_getFaceNormals'\n"
  "  Possible C/C++ prototypes are:\n"
  "    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getFaceNormals(bool) const\n"
  "    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getFaceNormals() const\n");
  lua_error(L);return 0; }
static int _wrap_Mesh_getUniqueFaces(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  std::vector< ofMeshFace_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > > *result = 0 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getUniqueFaces",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getUniqueFaces",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_getUniqueFaces",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
  
  result = (std::vector< ofMeshFace_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > > *) &((ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *)arg1)->getUniqueFaces();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorT_ofMeshFace_T_glm__vec3_glm__vec3_ofColor_T_float_t_glm__vec2_t_t,0); SWIG_arg++; 
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_getColor(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  ofIndexType arg2 ; ofIndexType *argp2 ; ofDefaultColorType result;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getColor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getColor",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getColor",2,"ofIndexType");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_getColor",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_TESSindex,0))){
    SWIG_fail_ptr("Mesh_getColor",2,SWIGTYPE_p_TESSindex); }  arg2 = *argp2;
  result = ((ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *)arg1)->getColor(arg2);
  { ofDefaultColorType * resultptr = new ofDefaultColorType((const ofDefaultColorType &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofColor_T_float_t,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_addColor(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  ofDefaultColorType *arg2 = 0 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::addColor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::addColor",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::addColor",2,"ofDefaultColorType const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_addColor",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("Mesh_addColor",2,SWIGTYPE_p_ofColor_T_float_t); }  (arg1)->addColor((ofDefaultColorType const &)*arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_addColors__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  std::vector< ofDefaultColorType > *arg2 = 0 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::addColors",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::addColors",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::addColors",2,"std::vector< ofDefaultColorType > const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_addColors",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_std__vectorT_ofColor_T_float_t_t,0))){
    SWIG_fail_ptr("Mesh_addColors",2,SWIGTYPE_p_std__vectorT_ofColor_T_float_t_t); } 
  (arg1)->addColors((std::vector< ofDefaultColorType > const &)*arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Mesh_addColors__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  ofDefaultColorType *arg2 = (ofDefaultColorType *) 0 ; std::size_t arg3 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::addColors",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::addColors",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::addColors",2,"ofDefaultColorType const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::addColors",3,"std::size_t");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_addColors",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("Mesh_addColors",2,SWIGTYPE_p_ofColor_T_float_t); } 
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (std::size_t)lua_tonumber(L, 3);
  (arg1)->addColors((ofDefaultColorType const *)arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Mesh_addColors(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_std__vectorT_ofColor_T_float_t_t, 0)) {
          _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Mesh_addColors__SWIG_0(L);}  }  }  if (argc == 3) { int _v; {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofColor_T_float_t, 0)) {
          _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_Mesh_addColors__SWIG_1(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Mesh_addColors'\n" "  Possible C/C++ prototypes are:\n"
  "    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::addColors(std::vector< ofDefaultColorType > const &)\n"
  "    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::addColors(ofDefaultColorType const *,std::size_t)\n");
  lua_error(L);return 0; }
static int _wrap_Mesh_removeColor(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  ofIndexType arg2 ; ofIndexType *argp2 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::removeColor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::removeColor",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::removeColor",2,"ofIndexType");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_removeColor",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_TESSindex,0))){
    SWIG_fail_ptr("Mesh_removeColor",2,SWIGTYPE_p_TESSindex); }  arg2 = *argp2; (arg1)->removeColor(arg2); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_setColor(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  ofIndexType arg2 ; ofDefaultColorType *arg3 = 0 ; ofIndexType *argp2 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::setColor",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::setColor",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::setColor",2,"ofIndexType");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::setColor",3,"ofDefaultColorType const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_setColor",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_TESSindex,0))){
    SWIG_fail_ptr("Mesh_setColor",2,SWIGTYPE_p_TESSindex); }  arg2 = *argp2;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("Mesh_setColor",3,SWIGTYPE_p_ofColor_T_float_t); }  (arg1)->setColor(arg2,(ofDefaultColorType const &)*arg3);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_clearColors(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::clearColors",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::clearColors",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_clearColors",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   (arg1)->clearColors(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_getNumColors(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  std::size_t result;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getNumColors",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getNumColors",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_getNumColors",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
  
  result = (std::size_t)((ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *)arg1)->getNumColors();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_getColorsPointer__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  ofDefaultColorType *result = 0 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getColorsPointer",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getColorsPointer",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_getColorsPointer",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   result = (ofDefaultColorType *)(arg1)->getColorsPointer();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_getColorsPointer__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  ofDefaultColorType *result = 0 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getColorsPointer",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getColorsPointer",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_getColorsPointer",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
  
  result = (ofDefaultColorType *)((ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *)arg1)->getColorsPointer();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_getColorsPointer(lua_State* L) { int argc; int argv[2]={ 1,2} ; argc = lua_gettop(L); if (argc == 1) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Mesh_getColorsPointer__SWIG_0(L);}  }  if (argc == 1) { int _v; {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Mesh_getColorsPointer__SWIG_1(L);}  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Mesh_getColorsPointer'\n"
  "  Possible C/C++ prototypes are:\n"
  "    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getColorsPointer()\n"
  "    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getColorsPointer() const\n");
  lua_error(L);return 0; }
static int _wrap_Mesh_getColors__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  std::vector< ofDefaultColorType > *result = 0 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getColors",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getColors",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_getColors",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   result = (std::vector< ofDefaultColorType > *) &(arg1)->getColors();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorT_ofColor_T_float_t_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_getColors__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  std::vector< ofDefaultColorType > *result = 0 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getColors",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getColors",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_getColors",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
  
  result = (std::vector< ofDefaultColorType > *) &((ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *)arg1)->getColors();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorT_ofColor_T_float_t_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_getColors(lua_State* L) { int argc; int argv[2]={ 1,2} ; argc = lua_gettop(L); if (argc == 1) { int _v; {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Mesh_getColors__SWIG_0(L);}  }  if (argc == 1) { int _v; {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Mesh_getColors__SWIG_1(L);}  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Mesh_getColors'\n" "  Possible C/C++ prototypes are:\n"
  "    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getColors()\n"
  "    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getColors() const\n");
  lua_error(L);return 0; }
static int _wrap_Mesh_hasColors(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  bool result;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::hasColors",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::hasColors",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_hasColors",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
  
  result = (bool)((ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *)arg1)->hasColors();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_enableColors(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::enableColors",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::enableColors",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_enableColors",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   (arg1)->enableColors(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_disableColors(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::disableColors",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::disableColors",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_disableColors",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   (arg1)->disableColors(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_usingColors(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  bool result;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::usingColors",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::usingColors",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_usingColors",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
  
  result = (bool)((ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *)arg1)->usingColors();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_getTexCoord(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  ofIndexType arg2 ; ofIndexType *argp2 ; ofDefaultTexCoordType result;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getTexCoord",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getTexCoord",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getTexCoord",2,"ofIndexType");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_getTexCoord",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_TESSindex,0))){
    SWIG_fail_ptr("Mesh_getTexCoord",2,SWIGTYPE_p_TESSindex); }  arg2 = *argp2;
  result = ((ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *)arg1)->getTexCoord(arg2);
  { ofDefaultTexCoordType * resultptr = new ofDefaultTexCoordType((const ofDefaultTexCoordType &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_glm__vec2,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_addTexCoord(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  ofDefaultTexCoordType *arg2 = 0 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::addTexCoord",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::addTexCoord",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::addTexCoord",2,"ofDefaultTexCoordType const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_addTexCoord",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec2,0))){
    SWIG_fail_ptr("Mesh_addTexCoord",2,SWIGTYPE_p_glm__vec2); }  (arg1)->addTexCoord((ofDefaultTexCoordType const &)*arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_addTexCoords__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  std::vector< ofDefaultTexCoordType > *arg2 = 0 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::addTexCoords",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::addTexCoords",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::addTexCoords",2,"std::vector< ofDefaultTexCoordType > const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_addTexCoords",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_std__vectorT_glm__vec2_t,0))){
    SWIG_fail_ptr("Mesh_addTexCoords",2,SWIGTYPE_p_std__vectorT_glm__vec2_t); } 
  (arg1)->addTexCoords((std::vector< ofDefaultTexCoordType > const &)*arg2); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_addTexCoords__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  ofDefaultTexCoordType *arg2 = (ofDefaultTexCoordType *) 0 ; std::size_t arg3 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::addTexCoords",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::addTexCoords",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::addTexCoords",2,"ofDefaultTexCoordType const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::addTexCoords",3,"std::size_t");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_addTexCoords",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec2,0))){
    SWIG_fail_ptr("Mesh_addTexCoords",2,SWIGTYPE_p_glm__vec2); } 
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (std::size_t)lua_tonumber(L, 3);
  (arg1)->addTexCoords((ofDefaultTexCoordType const *)arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Mesh_addTexCoords(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_std__vectorT_glm__vec2_t, 0)) {
          _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Mesh_addTexCoords__SWIG_0(L);}  }  }  if (argc == 3) { int _v;
    { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec2, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { return _wrap_Mesh_addTexCoords__SWIG_1(L);}
         }  }  }  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Mesh_addTexCoords'\n"
  "  Possible C/C++ prototypes are:\n"
  "    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::addTexCoords(std::vector< ofDefaultTexCoordType > const &)\n"
  "    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::addTexCoords(ofDefaultTexCoordType const *,std::size_t)\n");
  lua_error(L);return 0; }
static int _wrap_Mesh_removeTexCoord(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  ofIndexType arg2 ; ofIndexType *argp2 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::removeTexCoord",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::removeTexCoord",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::removeTexCoord",2,"ofIndexType");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_removeTexCoord",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_TESSindex,0))){
    SWIG_fail_ptr("Mesh_removeTexCoord",2,SWIGTYPE_p_TESSindex); }  arg2 = *argp2; (arg1)->removeTexCoord(arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_setTexCoord(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  ofIndexType arg2 ; ofDefaultTexCoordType *arg3 = 0 ; ofIndexType *argp2 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::setTexCoord",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::setTexCoord",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::setTexCoord",2,"ofIndexType");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::setTexCoord",3,"ofDefaultTexCoordType const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_setTexCoord",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_TESSindex,0))){
    SWIG_fail_ptr("Mesh_setTexCoord",2,SWIGTYPE_p_TESSindex); }  arg2 = *argp2;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_glm__vec2,0))){
    SWIG_fail_ptr("Mesh_setTexCoord",3,SWIGTYPE_p_glm__vec2); }  (arg1)->setTexCoord(arg2,(ofDefaultTexCoordType const &)*arg3);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_clearTexCoords(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::clearTexCoords",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::clearTexCoords",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_clearTexCoords",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   (arg1)->clearTexCoords(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_getNumTexCoords(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  std::size_t result;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getNumTexCoords",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getNumTexCoords",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_getNumTexCoords",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
  
  result = (std::size_t)((ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *)arg1)->getNumTexCoords();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_getTexCoordsPointer__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  ofDefaultTexCoordType *result = 0 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getTexCoordsPointer",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getTexCoordsPointer",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_getTexCoordsPointer",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   result = (ofDefaultTexCoordType *)(arg1)->getTexCoordsPointer();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_glm__vec2,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Mesh_getTexCoordsPointer__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  ofDefaultTexCoordType *result = 0 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getTexCoordsPointer",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getTexCoordsPointer",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_getTexCoordsPointer",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
  
  result = (ofDefaultTexCoordType *)((ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *)arg1)->getTexCoordsPointer();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_glm__vec2,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Mesh_getTexCoordsPointer(lua_State* L) { int argc; int argv[2]={ 1,2} ; argc = lua_gettop(L); if (argc == 1) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Mesh_getTexCoordsPointer__SWIG_0(L);}  }  if (argc == 1) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Mesh_getTexCoordsPointer__SWIG_1(L);}  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Mesh_getTexCoordsPointer'\n"
  "  Possible C/C++ prototypes are:\n"
  "    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getTexCoordsPointer()\n"
  "    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getTexCoordsPointer() const\n");
  lua_error(L);return 0; }
static int _wrap_Mesh_getTexCoords__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  std::vector< ofDefaultTexCoordType > *result = 0 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getTexCoords",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getTexCoords",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_getTexCoords",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   result = (std::vector< ofDefaultTexCoordType > *) &(arg1)->getTexCoords();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorT_glm__vec2_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_getTexCoords__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  std::vector< ofDefaultTexCoordType > *result = 0 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getTexCoords",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getTexCoords",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_getTexCoords",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
  
  result = (std::vector< ofDefaultTexCoordType > *) &((ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *)arg1)->getTexCoords();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorT_glm__vec2_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_getTexCoords(lua_State* L) { int argc; int argv[2]={ 1,2} ; argc = lua_gettop(L); if (argc == 1) { int _v;
    { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Mesh_getTexCoords__SWIG_0(L);}  }  if (argc == 1) { int _v; {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Mesh_getTexCoords__SWIG_1(L);}  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Mesh_getTexCoords'\n" "  Possible C/C++ prototypes are:\n"
  "    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getTexCoords()\n"
  "    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getTexCoords() const\n");
  lua_error(L);return 0; }
static int _wrap_Mesh_hasTexCoords(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  bool result;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::hasTexCoords",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::hasTexCoords",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_hasTexCoords",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
  
  result = (bool)((ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *)arg1)->hasTexCoords();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_enableTextures(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::enableTextures",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::enableTextures",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_enableTextures",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   (arg1)->enableTextures(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_disableTextures(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::disableTextures",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::disableTextures",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_disableTextures",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   (arg1)->disableTextures(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_usingTextures(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  bool result;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::usingTextures",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::usingTextures",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_usingTextures",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
  
  result = (bool)((ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *)arg1)->usingTextures();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_setupIndicesAuto(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::setupIndicesAuto",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::setupIndicesAuto",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_setupIndicesAuto",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   (arg1)->setupIndicesAuto(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_getIndices__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  std::vector< ofIndexType > *result = 0 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getIndices",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getIndices",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_getIndices",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   result = (std::vector< ofIndexType > *) &(arg1)->getIndices();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorT_TESSindex_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_getIndex(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  ofIndexType arg2 ; ofIndexType *argp2 ; ofIndexType result;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getIndex",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getIndex",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getIndex",2,"ofIndexType");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_getIndex",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_TESSindex,0))){
    SWIG_fail_ptr("Mesh_getIndex",2,SWIGTYPE_p_TESSindex); }  arg2 = *argp2;
  result = ((ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *)arg1)->getIndex(arg2);
  { ofIndexType * resultptr = new ofIndexType((const ofIndexType &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_TESSindex,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_addIndex(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  ofIndexType arg2 ; ofIndexType *argp2 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::addIndex",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::addIndex",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::addIndex",2,"ofIndexType");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_addIndex",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_TESSindex,0))){
    SWIG_fail_ptr("Mesh_addIndex",2,SWIGTYPE_p_TESSindex); }  arg2 = *argp2; (arg1)->addIndex(arg2); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_addIndices__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  std::vector< ofIndexType > *arg2 = 0 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::addIndices",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::addIndices",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::addIndices",2,"std::vector< ofIndexType > const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_addIndices",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_std__vectorT_TESSindex_t,0))){
    SWIG_fail_ptr("Mesh_addIndices",2,SWIGTYPE_p_std__vectorT_TESSindex_t); } 
  (arg1)->addIndices((std::vector< ofIndexType > const &)*arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Mesh_addIndices__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  ofIndexType *arg2 = (ofIndexType *) 0 ; std::size_t arg3 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::addIndices",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::addIndices",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::addIndices",2,"ofIndexType const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::addIndices",3,"std::size_t");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_addIndices",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_TESSindex,0))){
    SWIG_fail_ptr("Mesh_addIndices",2,SWIGTYPE_p_TESSindex); } 
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (std::size_t)lua_tonumber(L, 3);
  (arg1)->addIndices((ofIndexType const *)arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_addIndices(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_std__vectorT_TESSindex_t, 0)) {
          _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Mesh_addIndices__SWIG_0(L);}  }  }  if (argc == 3) { int _v; {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_TESSindex, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { return _wrap_Mesh_addIndices__SWIG_1(L);}  }
       }  }  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Mesh_addIndices'\n"
  "  Possible C/C++ prototypes are:\n"
  "    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::addIndices(std::vector< ofIndexType > const &)\n"
  "    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::addIndices(ofIndexType const *,std::size_t)\n");
  lua_error(L);return 0; }
static int _wrap_Mesh_removeIndex(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  ofIndexType arg2 ; ofIndexType *argp2 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::removeIndex",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::removeIndex",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::removeIndex",2,"ofIndexType");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_removeIndex",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_TESSindex,0))){
    SWIG_fail_ptr("Mesh_removeIndex",2,SWIGTYPE_p_TESSindex); }  arg2 = *argp2; (arg1)->removeIndex(arg2); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_setIndex(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  ofIndexType arg2 ; ofIndexType arg3 ; ofIndexType *argp2 ; ofIndexType *argp3 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::setIndex",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::setIndex",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::setIndex",2,"ofIndexType");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::setIndex",3,"ofIndexType");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_setIndex",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_TESSindex,0))){
    SWIG_fail_ptr("Mesh_setIndex",2,SWIGTYPE_p_TESSindex); }  arg2 = *argp2;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_TESSindex,0))){
    SWIG_fail_ptr("Mesh_setIndex",3,SWIGTYPE_p_TESSindex); }  arg3 = *argp3; (arg1)->setIndex(arg2,arg3); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_clearIndices(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::clearIndices",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::clearIndices",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_clearIndices",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   (arg1)->clearIndices(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_getNumIndices(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  std::size_t result;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getNumIndices",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getNumIndices",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_getNumIndices",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
  
  result = (std::size_t)((ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *)arg1)->getNumIndices();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_getIndexPointer__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  ofIndexType *result = 0 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getIndexPointer",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getIndexPointer",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_getIndexPointer",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   result = (ofIndexType *)(arg1)->getIndexPointer(); SWIG_NewPointerObj(L,result,SWIGTYPE_p_TESSindex,0); SWIG_arg++; 
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_getIndexPointer__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  ofIndexType *result = 0 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getIndexPointer",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getIndexPointer",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_getIndexPointer",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
  
  result = (ofIndexType *)((ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *)arg1)->getIndexPointer();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_TESSindex,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Mesh_getIndexPointer(lua_State* L) { int argc; int argv[2]={ 1,2} ; argc = lua_gettop(L); if (argc == 1) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Mesh_getIndexPointer__SWIG_0(L);}  }  if (argc == 1) { int _v; {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Mesh_getIndexPointer__SWIG_1(L);}  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Mesh_getIndexPointer'\n"
  "  Possible C/C++ prototypes are:\n"
  "    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getIndexPointer()\n"
  "    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getIndexPointer() const\n");
  lua_error(L);return 0; }
static int _wrap_Mesh_getIndices__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  std::vector< ofIndexType > *result = 0 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getIndices",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getIndices",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_getIndices",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
  
  result = (std::vector< ofIndexType > *) &((ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *)arg1)->getIndices();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorT_TESSindex_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_getIndices(lua_State* L) { int argc; int argv[2]={ 1,2} ; argc = lua_gettop(L); if (argc == 1) { int _v; {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Mesh_getIndices__SWIG_0(L);}  }  if (argc == 1) { int _v; {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Mesh_getIndices__SWIG_1(L);}  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Mesh_getIndices'\n" "  Possible C/C++ prototypes are:\n"
  "    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getIndices()\n"
  "    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getIndices() const\n");
  lua_error(L);return 0; }
static int _wrap_Mesh_hasIndices(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  bool result;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::hasIndices",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::hasIndices",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_hasIndices",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
  
  result = (bool)((ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *)arg1)->hasIndices();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_addTriangle(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  ofIndexType arg2 ; ofIndexType arg3 ; ofIndexType arg4 ; ofIndexType *argp2 ; ofIndexType *argp3 ; ofIndexType *argp4 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::addTriangle",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::addTriangle",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::addTriangle",2,"ofIndexType");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::addTriangle",3,"ofIndexType");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::addTriangle",4,"ofIndexType");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_addTriangle",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_TESSindex,0))){
    SWIG_fail_ptr("Mesh_addTriangle",2,SWIGTYPE_p_TESSindex); }  arg2 = *argp2;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_TESSindex,0))){
    SWIG_fail_ptr("Mesh_addTriangle",3,SWIGTYPE_p_TESSindex); }  arg3 = *argp3;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&argp4,SWIGTYPE_p_TESSindex,0))){
    SWIG_fail_ptr("Mesh_addTriangle",4,SWIGTYPE_p_TESSindex); }  arg4 = *argp4; (arg1)->addTriangle(arg2,arg3,arg4);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_enableIndices(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::enableIndices",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::enableIndices",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_enableIndices",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   (arg1)->enableIndices(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_disableIndices(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::disableIndices",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::disableIndices",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_disableIndices",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   (arg1)->disableIndices(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_usingIndices(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  bool result;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::usingIndices",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::usingIndices",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_usingIndices",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
  
  result = (bool)((ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *)arg1)->usingIndices();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_setColorForIndices(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  ofIndexType arg2 ; ofIndexType arg3 ; ofDefaultColorType arg4 ; ofIndexType *argp2 ; ofIndexType *argp3 ;
  ofDefaultColorType *argp4 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::setColorForIndices",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::setColorForIndices",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::setColorForIndices",2,"ofIndexType");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::setColorForIndices",3,"ofIndexType");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::setColorForIndices",4,"ofDefaultColorType");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_setColorForIndices",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_TESSindex,0))){
    SWIG_fail_ptr("Mesh_setColorForIndices",2,SWIGTYPE_p_TESSindex); }  arg2 = *argp2;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_TESSindex,0))){
    SWIG_fail_ptr("Mesh_setColorForIndices",3,SWIGTYPE_p_TESSindex); }  arg3 = *argp3;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&argp4,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("Mesh_setColorForIndices",4,SWIGTYPE_p_ofColor_T_float_t); }  arg4 = *argp4;
  (arg1)->setColorForIndices(arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_getMeshForIndices__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  ofIndexType arg2 ; ofIndexType arg3 ; ofIndexType *argp2 ; ofIndexType *argp3 ;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > result;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getMeshForIndices",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getMeshForIndices",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getMeshForIndices",2,"ofIndexType");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getMeshForIndices",3,"ofIndexType");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_getMeshForIndices",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_TESSindex,0))){
    SWIG_fail_ptr("Mesh_getMeshForIndices",2,SWIGTYPE_p_TESSindex); }  arg2 = *argp2;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_TESSindex,0))){
    SWIG_fail_ptr("Mesh_getMeshForIndices",3,SWIGTYPE_p_TESSindex); }  arg3 = *argp3;
  result = ((ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *)arg1)->getMeshForIndices(arg2,arg3);
  {
    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > * resultptr = new ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >((const ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,1); SWIG_arg++; }
   return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_getMeshForIndices__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  ofIndexType arg2 ; ofIndexType arg3 ; ofIndexType arg4 ; ofIndexType arg5 ; ofIndexType *argp2 ; ofIndexType *argp3 ;
  ofIndexType *argp4 ; ofIndexType *argp5 ;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > result;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getMeshForIndices",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getMeshForIndices",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getMeshForIndices",2,"ofIndexType");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getMeshForIndices",3,"ofIndexType");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getMeshForIndices",4,"ofIndexType");
  if(!lua_isuserdata(L,5)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getMeshForIndices",5,"ofIndexType");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_getMeshForIndices",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_TESSindex,0))){
    SWIG_fail_ptr("Mesh_getMeshForIndices",2,SWIGTYPE_p_TESSindex); }  arg2 = *argp2;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_TESSindex,0))){
    SWIG_fail_ptr("Mesh_getMeshForIndices",3,SWIGTYPE_p_TESSindex); }  arg3 = *argp3;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&argp4,SWIGTYPE_p_TESSindex,0))){
    SWIG_fail_ptr("Mesh_getMeshForIndices",4,SWIGTYPE_p_TESSindex); }  arg4 = *argp4;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&argp5,SWIGTYPE_p_TESSindex,0))){
    SWIG_fail_ptr("Mesh_getMeshForIndices",5,SWIGTYPE_p_TESSindex); }  arg5 = *argp5;
  result = ((ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *)arg1)->getMeshForIndices(arg2,arg3,arg4,arg5);
  {
    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > * resultptr = new ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >((const ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,1); SWIG_arg++; }
   return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_getMeshForIndices(lua_State* L) { int argc; int argv[6]={ 1,2,3,4,5,6} ; argc = lua_gettop(L);
  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_TESSindex, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_TESSindex, 0)) { _v = 0; }
           else { _v = 1; }  }  if (_v) { return _wrap_Mesh_getMeshForIndices__SWIG_0(L);}  }  }  }  if (argc == 5) { int _v; {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_TESSindex, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_TESSindex, 0)) { _v = 0; }
           else { _v = 1; }  }  if (_v) { { void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_TESSindex, 0)) { _v = 0; }
             else { _v = 1; }  }  if (_v) { { void *ptr;
              if (lua_isuserdata(L,argv[4])==0 || SWIG_ConvertPtr(L,argv[4], (void **) &ptr, SWIGTYPE_p_TESSindex, 0)) {
                _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Mesh_getMeshForIndices__SWIG_1(L);}  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Mesh_getMeshForIndices'\n"
  "  Possible C/C++ prototypes are:\n"
  "    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getMeshForIndices(ofIndexType,ofIndexType) const\n"
  "    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::getMeshForIndices(ofIndexType,ofIndexType,ofIndexType,ofIndexType) const\n");
  lua_error(L);return 0; }
static int _wrap_Mesh_drawVertices(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::drawVertices",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::drawVertices",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_drawVertices",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   ((ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *)arg1)->drawVertices();
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_drawWireframe(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::drawWireframe",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::drawWireframe",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_drawWireframe",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   ((ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *)arg1)->drawWireframe();
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_drawFaces(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::drawFaces",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::drawFaces",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_drawFaces",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   ((ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *)arg1)->drawFaces();
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_draw__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::draw",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::draw",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_draw",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   ((ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *)arg1)->draw();
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_draw__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  ofPolyRenderMode arg2 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::draw",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::draw",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::draw",2,"ofPolyRenderMode");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_draw",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   arg2 = (ofPolyRenderMode)(int)lua_tonumber(L, 2);
  ((ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *)arg1)->draw(arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_draw(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 1) { int _v; {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Mesh_draw__SWIG_0(L);}  }  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_Mesh_draw__SWIG_1(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Mesh_draw'\n" "  Possible C/C++ prototypes are:\n"
  "    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::draw() const\n"
  "    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::draw(ofPolyRenderMode) const\n");
  lua_error(L);return 0; }
static int _wrap_Mesh_load(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  std::filesystem::path *arg2 = 0 ; std::filesystem::path temp2 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::load",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::load",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::load",2,"std::filesystem::path const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_load",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   { size_t len = lua_rawlen(L, 2); temp2 = lua_tolstring(L, 2, &len); arg2 = &temp2; } 
  (arg1)->load((std::filesystem::path const &)*arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_save__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  std::filesystem::path *arg2 = 0 ; bool arg3 ; std::filesystem::path temp2 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::save",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::save",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::save",2,"std::filesystem::path const &");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::save",3,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_save",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   { size_t len = lua_rawlen(L, 2); temp2 = lua_tolstring(L, 2, &len); arg2 = &temp2; }  arg3 = (lua_toboolean(L, 3)!=0);
  ((ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *)arg1)->save((std::filesystem::path const &)*arg2,arg3);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_save__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) 0 ;
  std::filesystem::path *arg2 = 0 ; std::filesystem::path temp2 ;
  SWIG_check_num_args("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::save",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::save",1,"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::save",2,"std::filesystem::path const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Mesh_save",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   { size_t len = lua_rawlen(L, 2); temp2 = lua_tolstring(L, 2, &len); arg2 = &temp2; } 
  ((ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > const *)arg1)->save((std::filesystem::path const &)*arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Mesh_save(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 2) { int _v; {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L, argv[1]); }  if (_v) {
        return _wrap_Mesh_save__SWIG_1(L);}  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L, argv[1]); }  if (_v) { {
          _v = lua_isboolean(L,argv[2]); }  if (_v) { return _wrap_Mesh_save__SWIG_0(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Mesh_save'\n" "  Possible C/C++ prototypes are:\n"
  "    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::save(std::filesystem::path const &,bool) const\n"
  "    ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType >::save(std::filesystem::path const &) const\n");
  lua_error(L);return 0; }
static void swig_delete_Mesh(void *obj) {
ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *arg1 = (ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *) obj;
delete arg1;
}
static int _proxy__wrap_new_Mesh(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_Mesh);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_Mesh_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_Mesh_methods[]= {
    { "setFromTriangles", _wrap_Mesh_setFromTriangles},
    { "setMode", _wrap_Mesh_setMode},
    { "getMode", _wrap_Mesh_getMode},
    { "addVertex", _wrap_Mesh_addVertex},
    { "addVertices", _wrap_Mesh_addVertices},
    { "removeVertex", _wrap_Mesh_removeVertex},
    { "setVertex", _wrap_Mesh_setVertex},
    { "clearVertices", _wrap_Mesh_clearVertices},
    { "clear", _wrap_Mesh_clear},
    { "getNumVertices", _wrap_Mesh_getNumVertices},
    { "getVerticesPointer", _wrap_Mesh_getVerticesPointer},
    { "getVertex", _wrap_Mesh_getVertex},
    { "getVertices", _wrap_Mesh_getVertices},
    { "hasVertices", _wrap_Mesh_hasVertices},
    { "append", _wrap_Mesh_append},
    { "mergeDuplicateVertices", _wrap_Mesh_mergeDuplicateVertices},
    { "getCentroid", _wrap_Mesh_getCentroid},
    { "getNormal", _wrap_Mesh_getNormal},
    { "addNormal", _wrap_Mesh_addNormal},
    { "addNormals", _wrap_Mesh_addNormals},
    { "removeNormal", _wrap_Mesh_removeNormal},
    { "setNormal", _wrap_Mesh_setNormal},
    { "clearNormals", _wrap_Mesh_clearNormals},
    { "getNumNormals", _wrap_Mesh_getNumNormals},
    { "getNormalsPointer", _wrap_Mesh_getNormalsPointer},
    { "getNormals", _wrap_Mesh_getNormals},
    { "hasNormals", _wrap_Mesh_hasNormals},
    { "enableNormals", _wrap_Mesh_enableNormals},
    { "disableNormals", _wrap_Mesh_disableNormals},
    { "usingNormals", _wrap_Mesh_usingNormals},
    { "smoothNormals", _wrap_Mesh_smoothNormals},
    { "flatNormals", _wrap_Mesh_flatNormals},
    { "getFace", _wrap_Mesh_getFace},
    { "getFaceNormals", _wrap_Mesh_getFaceNormals},
    { "getUniqueFaces", _wrap_Mesh_getUniqueFaces},
    { "getColor", _wrap_Mesh_getColor},
    { "addColor", _wrap_Mesh_addColor},
    { "addColors", _wrap_Mesh_addColors},
    { "removeColor", _wrap_Mesh_removeColor},
    { "setColor", _wrap_Mesh_setColor},
    { "clearColors", _wrap_Mesh_clearColors},
    { "getNumColors", _wrap_Mesh_getNumColors},
    { "getColorsPointer", _wrap_Mesh_getColorsPointer},
    { "getColors", _wrap_Mesh_getColors},
    { "hasColors", _wrap_Mesh_hasColors},
    { "enableColors", _wrap_Mesh_enableColors},
    { "disableColors", _wrap_Mesh_disableColors},
    { "usingColors", _wrap_Mesh_usingColors},
    { "getTexCoord", _wrap_Mesh_getTexCoord},
    { "addTexCoord", _wrap_Mesh_addTexCoord},
    { "addTexCoords", _wrap_Mesh_addTexCoords},
    { "removeTexCoord", _wrap_Mesh_removeTexCoord},
    { "setTexCoord", _wrap_Mesh_setTexCoord},
    { "clearTexCoords", _wrap_Mesh_clearTexCoords},
    { "getNumTexCoords", _wrap_Mesh_getNumTexCoords},
    { "getTexCoordsPointer", _wrap_Mesh_getTexCoordsPointer},
    { "getTexCoords", _wrap_Mesh_getTexCoords},
    { "hasTexCoords", _wrap_Mesh_hasTexCoords},
    { "enableTextures", _wrap_Mesh_enableTextures},
    { "disableTextures", _wrap_Mesh_disableTextures},
    { "usingTextures", _wrap_Mesh_usingTextures},
    { "setupIndicesAuto", _wrap_Mesh_setupIndicesAuto},
    { "getIndex", _wrap_Mesh_getIndex},
    { "addIndex", _wrap_Mesh_addIndex},
    { "addIndices", _wrap_Mesh_addIndices},
    { "removeIndex", _wrap_Mesh_removeIndex},
    { "setIndex", _wrap_Mesh_setIndex},
    { "clearIndices", _wrap_Mesh_clearIndices},
    { "getNumIndices", _wrap_Mesh_getNumIndices},
    { "getIndexPointer", _wrap_Mesh_getIndexPointer},
    { "getIndices", _wrap_Mesh_getIndices},
    { "hasIndices", _wrap_Mesh_hasIndices},
    { "addTriangle", _wrap_Mesh_addTriangle},
    { "enableIndices", _wrap_Mesh_enableIndices},
    { "disableIndices", _wrap_Mesh_disableIndices},
    { "usingIndices", _wrap_Mesh_usingIndices},
    { "setColorForIndices", _wrap_Mesh_setColorForIndices},
    { "getMeshForIndices", _wrap_Mesh_getMeshForIndices},
    { "drawVertices", _wrap_Mesh_drawVertices},
    { "drawWireframe", _wrap_Mesh_drawWireframe},
    { "drawFaces", _wrap_Mesh_drawFaces},
    { "draw", _wrap_Mesh_draw},
    { "load", _wrap_Mesh_load},
    { "save", _wrap_Mesh_save},
    {0,0}
};
static swig_lua_method swig_Mesh_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_Mesh_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_Mesh_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_Mesh_Sf_SwigStatic_methods[]= {
    { "plane", _wrap_Mesh_plane},
    { "sphere", _wrap_Mesh_sphere},
    { "icosahedron", _wrap_Mesh_icosahedron},
    { "icosphere", _wrap_Mesh_icosphere},
    { "cylinder", _wrap_Mesh_cylinder},
    { "cone", _wrap_Mesh_cone},
    { "box", _wrap_Mesh_box},
    { "axis", _wrap_Mesh_axis},
    {0,0}
};
static swig_lua_class* swig_Mesh_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_Mesh_Sf_SwigStatic = {
    "Mesh",
    swig_Mesh_Sf_SwigStatic_methods,
    swig_Mesh_Sf_SwigStatic_attributes,
    swig_Mesh_Sf_SwigStatic_constants,
    swig_Mesh_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_Mesh_bases[] = {0};
static const char *swig_Mesh_base_names[] = {0};
static swig_lua_class _wrap_class_Mesh = { "Mesh", "Mesh", &SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,_proxy__wrap_new_Mesh, swig_delete_Mesh, swig_Mesh_methods, swig_Mesh_attributes, &swig_Mesh_Sf_SwigStatic, swig_Mesh_meta, swig_Mesh_bases, swig_Mesh_base_names };

static int _wrap_new_3dPrimitive__SWIG_0(lua_State* L) { int SWIG_arg = 0; of3dPrimitive *result = 0 ;
  SWIG_check_num_args("of3dPrimitive::of3dPrimitive",0,0) result = (of3dPrimitive *)new of3dPrimitive();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_of3dPrimitive,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_3dPrimitive__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofMesh *arg1 = 0 ; of3dPrimitive *result = 0 ;
  SWIG_check_num_args("of3dPrimitive::of3dPrimitive",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("of3dPrimitive::of3dPrimitive",1,"ofMesh const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("new_3dPrimitive",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   result = (of3dPrimitive *)new of3dPrimitive((ofMesh const &)*arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_of3dPrimitive,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_3dPrimitive__SWIG_2(lua_State* L) { int SWIG_arg = 0; of3dPrimitive *arg1 = 0 ; of3dPrimitive *result = 0 ;
  SWIG_check_num_args("of3dPrimitive::of3dPrimitive",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("of3dPrimitive::of3dPrimitive",1,"of3dPrimitive const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_of3dPrimitive,0))){
    SWIG_fail_ptr("new_3dPrimitive",1,SWIGTYPE_p_of3dPrimitive); } 
  result = (of3dPrimitive *)new of3dPrimitive((of3dPrimitive const &)*arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_of3dPrimitive,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_3dPrimitive(lua_State* L) { int argc; int argv[2]={ 1,2} ; argc = lua_gettop(L); if (argc == 0) {
    return _wrap_new_3dPrimitive__SWIG_0(L);}  if (argc == 1) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_new_3dPrimitive__SWIG_1(L);}  }  if (argc == 1) { int _v; {
      void *ptr; if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_of3dPrimitive, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_new_3dPrimitive__SWIG_2(L);}  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_3dPrimitive'\n" "  Possible C/C++ prototypes are:\n"
  "    of3dPrimitive::of3dPrimitive()\n" "    of3dPrimitive::of3dPrimitive(ofMesh const &)\n"
  "    of3dPrimitive::of3dPrimitive(of3dPrimitive const &)\n"); lua_error(L);return 0; }
static int _wrap_3dPrimitive_mapTexCoords(lua_State* L) { int SWIG_arg = 0; of3dPrimitive *arg1 = (of3dPrimitive *) 0 ;
  float arg2 ; float arg3 ; float arg4 ; float arg5 ; SWIG_check_num_args("of3dPrimitive::mapTexCoords",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("of3dPrimitive::mapTexCoords",1,"of3dPrimitive *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("of3dPrimitive::mapTexCoords",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("of3dPrimitive::mapTexCoords",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("of3dPrimitive::mapTexCoords",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("of3dPrimitive::mapTexCoords",5,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_of3dPrimitive,0))){
    SWIG_fail_ptr("3dPrimitive_mapTexCoords",1,SWIGTYPE_p_of3dPrimitive); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); arg5 = (float)lua_tonumber(L, 5);
  (arg1)->mapTexCoords(arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_3dPrimitive_mapTexCoordsFromTexture(lua_State* L) { int SWIG_arg = 0;
  of3dPrimitive *arg1 = (of3dPrimitive *) 0 ; ofTexture *arg2 = 0 ;
  SWIG_check_num_args("of3dPrimitive::mapTexCoordsFromTexture",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("of3dPrimitive::mapTexCoordsFromTexture",1,"of3dPrimitive *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("of3dPrimitive::mapTexCoordsFromTexture",2,"ofTexture const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_of3dPrimitive,0))){
    SWIG_fail_ptr("3dPrimitive_mapTexCoordsFromTexture",1,SWIGTYPE_p_of3dPrimitive); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("3dPrimitive_mapTexCoordsFromTexture",2,SWIGTYPE_p_ofTexture); } 
  (arg1)->mapTexCoordsFromTexture((ofTexture const &)*arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_3dPrimitive_getMeshPtr__SWIG_0(lua_State* L) { int SWIG_arg = 0; of3dPrimitive *arg1 = (of3dPrimitive *) 0 ;
  ofMesh *result = 0 ; SWIG_check_num_args("of3dPrimitive::getMeshPtr",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("of3dPrimitive::getMeshPtr",1,"of3dPrimitive *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_of3dPrimitive,0))){
    SWIG_fail_ptr("3dPrimitive_getMeshPtr",1,SWIGTYPE_p_of3dPrimitive); }  result = (ofMesh *)(arg1)->getMeshPtr();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0); SWIG_arg++; 
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_3dPrimitive_getMesh__SWIG_0(lua_State* L) { int SWIG_arg = 0; of3dPrimitive *arg1 = (of3dPrimitive *) 0 ;
  ofMesh *result = 0 ; SWIG_check_num_args("of3dPrimitive::getMesh",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("of3dPrimitive::getMesh",1,"of3dPrimitive *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_of3dPrimitive,0))){
    SWIG_fail_ptr("3dPrimitive_getMesh",1,SWIGTYPE_p_of3dPrimitive); }  result = (ofMesh *) &(arg1)->getMesh();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0); SWIG_arg++; 
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_3dPrimitive_getMeshPtr__SWIG_1(lua_State* L) { int SWIG_arg = 0; of3dPrimitive *arg1 = (of3dPrimitive *) 0 ;
  ofMesh *result = 0 ; SWIG_check_num_args("of3dPrimitive::getMeshPtr",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("of3dPrimitive::getMeshPtr",1,"of3dPrimitive const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_of3dPrimitive,0))){
    SWIG_fail_ptr("3dPrimitive_getMeshPtr",1,SWIGTYPE_p_of3dPrimitive); } 
  result = (ofMesh *)((of3dPrimitive const *)arg1)->getMeshPtr();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0); SWIG_arg++; 
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_3dPrimitive_getMeshPtr(lua_State* L) { int argc; int argv[2]={ 1,2} ; argc = lua_gettop(L); if (argc == 1) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_of3dPrimitive, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { return _wrap_3dPrimitive_getMeshPtr__SWIG_0(L);}  }  if (argc == 1) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_of3dPrimitive, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { return _wrap_3dPrimitive_getMeshPtr__SWIG_1(L);}  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function '3dPrimitive_getMeshPtr'\n"
  "  Possible C/C++ prototypes are:\n" "    of3dPrimitive::getMeshPtr()\n" "    of3dPrimitive::getMeshPtr() const\n");
  lua_error(L);return 0; }
static int _wrap_3dPrimitive_getMesh__SWIG_1(lua_State* L) { int SWIG_arg = 0; of3dPrimitive *arg1 = (of3dPrimitive *) 0 ;
  ofMesh *result = 0 ; SWIG_check_num_args("of3dPrimitive::getMesh",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("of3dPrimitive::getMesh",1,"of3dPrimitive const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_of3dPrimitive,0))){
    SWIG_fail_ptr("3dPrimitive_getMesh",1,SWIGTYPE_p_of3dPrimitive); } 
  result = (ofMesh *) &((of3dPrimitive const *)arg1)->getMesh();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0); SWIG_arg++; 
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_3dPrimitive_getMesh(lua_State* L) { int argc; int argv[2]={ 1,2} ; argc = lua_gettop(L); if (argc == 1) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_of3dPrimitive, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { return _wrap_3dPrimitive_getMesh__SWIG_0(L);}  }  if (argc == 1) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_of3dPrimitive, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { return _wrap_3dPrimitive_getMesh__SWIG_1(L);}  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function '3dPrimitive_getMesh'\n"
  "  Possible C/C++ prototypes are:\n" "    of3dPrimitive::getMesh()\n" "    of3dPrimitive::getMesh() const\n");
  lua_error(L);return 0; }
static int _wrap_3dPrimitive_getTexCoordsPtr__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  of3dPrimitive *arg1 = (of3dPrimitive *) 0 ; glm::vec4 *result = 0 ; SWIG_check_num_args("of3dPrimitive::getTexCoordsPtr",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("of3dPrimitive::getTexCoordsPtr",1,"of3dPrimitive *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_of3dPrimitive,0))){
    SWIG_fail_ptr("3dPrimitive_getTexCoordsPtr",1,SWIGTYPE_p_of3dPrimitive); }  result = (glm::vec4 *)(arg1)->getTexCoordsPtr();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_glm__vec4,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_3dPrimitive_getTexCoords__SWIG_0(lua_State* L) { int SWIG_arg = 0; of3dPrimitive *arg1 = (of3dPrimitive *) 0 ;
  glm::vec4 *result = 0 ; SWIG_check_num_args("of3dPrimitive::getTexCoords",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("of3dPrimitive::getTexCoords",1,"of3dPrimitive *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_of3dPrimitive,0))){
    SWIG_fail_ptr("3dPrimitive_getTexCoords",1,SWIGTYPE_p_of3dPrimitive); }  result = (glm::vec4 *) &(arg1)->getTexCoords();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_glm__vec4,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_3dPrimitive_getTexCoordsPtr__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  of3dPrimitive *arg1 = (of3dPrimitive *) 0 ; glm::vec4 *result = 0 ; SWIG_check_num_args("of3dPrimitive::getTexCoordsPtr",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("of3dPrimitive::getTexCoordsPtr",1,"of3dPrimitive const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_of3dPrimitive,0))){
    SWIG_fail_ptr("3dPrimitive_getTexCoordsPtr",1,SWIGTYPE_p_of3dPrimitive); } 
  result = (glm::vec4 *)((of3dPrimitive const *)arg1)->getTexCoordsPtr();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_glm__vec4,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_3dPrimitive_getTexCoordsPtr(lua_State* L) { int argc; int argv[2]={ 1,2} ; argc = lua_gettop(L);
  if (argc == 1) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_of3dPrimitive, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { return _wrap_3dPrimitive_getTexCoordsPtr__SWIG_0(L);}  }  if (argc == 1) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_of3dPrimitive, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_3dPrimitive_getTexCoordsPtr__SWIG_1(L);}  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function '3dPrimitive_getTexCoordsPtr'\n"
  "  Possible C/C++ prototypes are:\n" "    of3dPrimitive::getTexCoordsPtr()\n" "    of3dPrimitive::getTexCoordsPtr() const\n");
  lua_error(L);return 0; }
static int _wrap_3dPrimitive_getTexCoords__SWIG_1(lua_State* L) { int SWIG_arg = 0; of3dPrimitive *arg1 = (of3dPrimitive *) 0 ;
  glm::vec4 *result = 0 ; SWIG_check_num_args("of3dPrimitive::getTexCoords",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("of3dPrimitive::getTexCoords",1,"of3dPrimitive const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_of3dPrimitive,0))){
    SWIG_fail_ptr("3dPrimitive_getTexCoords",1,SWIGTYPE_p_of3dPrimitive); } 
  result = (glm::vec4 *) &((of3dPrimitive const *)arg1)->getTexCoords();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_glm__vec4,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_3dPrimitive_getTexCoords(lua_State* L) { int argc; int argv[2]={ 1,2} ; argc = lua_gettop(L); if (argc == 1) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_of3dPrimitive, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { return _wrap_3dPrimitive_getTexCoords__SWIG_0(L);}  }  if (argc == 1) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_of3dPrimitive, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_3dPrimitive_getTexCoords__SWIG_1(L);}  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function '3dPrimitive_getTexCoords'\n"
  "  Possible C/C++ prototypes are:\n" "    of3dPrimitive::getTexCoords()\n" "    of3dPrimitive::getTexCoords() const\n");
  lua_error(L);return 0; }
static int _wrap_3dPrimitive_hasScaling(lua_State* L) { int SWIG_arg = 0; of3dPrimitive *arg1 = (of3dPrimitive *) 0 ;
  bool result; SWIG_check_num_args("of3dPrimitive::hasScaling",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("of3dPrimitive::hasScaling",1,"of3dPrimitive const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_of3dPrimitive,0))){
    SWIG_fail_ptr("3dPrimitive_hasScaling",1,SWIGTYPE_p_of3dPrimitive); } 
  result = (bool)((of3dPrimitive const *)arg1)->hasScaling(); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_3dPrimitive_hasNormalsEnabled(lua_State* L) { int SWIG_arg = 0; of3dPrimitive *arg1 = (of3dPrimitive *) 0 ;
  bool result; SWIG_check_num_args("of3dPrimitive::hasNormalsEnabled",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("of3dPrimitive::hasNormalsEnabled",1,"of3dPrimitive const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_of3dPrimitive,0))){
    SWIG_fail_ptr("3dPrimitive_hasNormalsEnabled",1,SWIGTYPE_p_of3dPrimitive); } 
  result = (bool)((of3dPrimitive const *)arg1)->hasNormalsEnabled(); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_3dPrimitive_enableNormals(lua_State* L) { int SWIG_arg = 0; of3dPrimitive *arg1 = (of3dPrimitive *) 0 ;
  SWIG_check_num_args("of3dPrimitive::enableNormals",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("of3dPrimitive::enableNormals",1,"of3dPrimitive *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_of3dPrimitive,0))){
    SWIG_fail_ptr("3dPrimitive_enableNormals",1,SWIGTYPE_p_of3dPrimitive); }  (arg1)->enableNormals(); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_3dPrimitive_enableTextures(lua_State* L) { int SWIG_arg = 0; of3dPrimitive *arg1 = (of3dPrimitive *) 0 ;
  SWIG_check_num_args("of3dPrimitive::enableTextures",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("of3dPrimitive::enableTextures",1,"of3dPrimitive *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_of3dPrimitive,0))){
    SWIG_fail_ptr("3dPrimitive_enableTextures",1,SWIGTYPE_p_of3dPrimitive); }  (arg1)->enableTextures(); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_3dPrimitive_enableColors(lua_State* L) { int SWIG_arg = 0; of3dPrimitive *arg1 = (of3dPrimitive *) 0 ;
  SWIG_check_num_args("of3dPrimitive::enableColors",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("of3dPrimitive::enableColors",1,"of3dPrimitive *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_of3dPrimitive,0))){
    SWIG_fail_ptr("3dPrimitive_enableColors",1,SWIGTYPE_p_of3dPrimitive); }  (arg1)->enableColors(); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_3dPrimitive_disableNormals(lua_State* L) { int SWIG_arg = 0; of3dPrimitive *arg1 = (of3dPrimitive *) 0 ;
  SWIG_check_num_args("of3dPrimitive::disableNormals",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("of3dPrimitive::disableNormals",1,"of3dPrimitive *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_of3dPrimitive,0))){
    SWIG_fail_ptr("3dPrimitive_disableNormals",1,SWIGTYPE_p_of3dPrimitive); }  (arg1)->disableNormals(); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_3dPrimitive_disableTextures(lua_State* L) { int SWIG_arg = 0; of3dPrimitive *arg1 = (of3dPrimitive *) 0 ;
  SWIG_check_num_args("of3dPrimitive::disableTextures",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("of3dPrimitive::disableTextures",1,"of3dPrimitive *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_of3dPrimitive,0))){
    SWIG_fail_ptr("3dPrimitive_disableTextures",1,SWIGTYPE_p_of3dPrimitive); }  (arg1)->disableTextures(); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_3dPrimitive_disableColors(lua_State* L) { int SWIG_arg = 0; of3dPrimitive *arg1 = (of3dPrimitive *) 0 ;
  SWIG_check_num_args("of3dPrimitive::disableColors",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("of3dPrimitive::disableColors",1,"of3dPrimitive *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_of3dPrimitive,0))){
    SWIG_fail_ptr("3dPrimitive_disableColors",1,SWIGTYPE_p_of3dPrimitive); }  (arg1)->disableColors(); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_3dPrimitive_drawVertices(lua_State* L) { int SWIG_arg = 0; of3dPrimitive *arg1 = (of3dPrimitive *) 0 ;
  SWIG_check_num_args("of3dPrimitive::drawVertices",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("of3dPrimitive::drawVertices",1,"of3dPrimitive const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_of3dPrimitive,0))){
    SWIG_fail_ptr("3dPrimitive_drawVertices",1,SWIGTYPE_p_of3dPrimitive); }  ((of3dPrimitive const *)arg1)->drawVertices();
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_3dPrimitive_drawWireframe(lua_State* L) { int SWIG_arg = 0; of3dPrimitive *arg1 = (of3dPrimitive *) 0 ;
  SWIG_check_num_args("of3dPrimitive::drawWireframe",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("of3dPrimitive::drawWireframe",1,"of3dPrimitive const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_of3dPrimitive,0))){
    SWIG_fail_ptr("3dPrimitive_drawWireframe",1,SWIGTYPE_p_of3dPrimitive); }  ((of3dPrimitive const *)arg1)->drawWireframe();
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_3dPrimitive_drawFaces(lua_State* L) { int SWIG_arg = 0; of3dPrimitive *arg1 = (of3dPrimitive *) 0 ;
  SWIG_check_num_args("of3dPrimitive::drawFaces",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("of3dPrimitive::drawFaces",1,"of3dPrimitive const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_of3dPrimitive,0))){
    SWIG_fail_ptr("3dPrimitive_drawFaces",1,SWIGTYPE_p_of3dPrimitive); }  ((of3dPrimitive const *)arg1)->drawFaces();
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_3dPrimitive_draw(lua_State* L) { int SWIG_arg = 0; of3dPrimitive *arg1 = (of3dPrimitive *) 0 ;
  ofPolyRenderMode arg2 ; SWIG_check_num_args("of3dPrimitive::draw",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("of3dPrimitive::draw",1,"of3dPrimitive const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("of3dPrimitive::draw",2,"ofPolyRenderMode");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_of3dPrimitive,0))){
    SWIG_fail_ptr("3dPrimitive_draw",1,SWIGTYPE_p_of3dPrimitive); }  arg2 = (ofPolyRenderMode)(int)lua_tonumber(L, 2);
  ((of3dPrimitive const *)arg1)->draw(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_3dPrimitive_drawNormals__SWIG_0(lua_State* L) { int SWIG_arg = 0; of3dPrimitive *arg1 = (of3dPrimitive *) 0 ;
  float arg2 ; bool arg3 ; SWIG_check_num_args("of3dPrimitive::drawNormals",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("of3dPrimitive::drawNormals",1,"of3dPrimitive const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("of3dPrimitive::drawNormals",2,"float");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("of3dPrimitive::drawNormals",3,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_of3dPrimitive,0))){
    SWIG_fail_ptr("3dPrimitive_drawNormals",1,SWIGTYPE_p_of3dPrimitive); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (lua_toboolean(L, 3)!=0); ((of3dPrimitive const *)arg1)->drawNormals(arg2,arg3); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_3dPrimitive_drawNormals__SWIG_1(lua_State* L) { int SWIG_arg = 0; of3dPrimitive *arg1 = (of3dPrimitive *) 0 ;
  float arg2 ; SWIG_check_num_args("of3dPrimitive::drawNormals",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("of3dPrimitive::drawNormals",1,"of3dPrimitive const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("of3dPrimitive::drawNormals",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_of3dPrimitive,0))){
    SWIG_fail_ptr("3dPrimitive_drawNormals",1,SWIGTYPE_p_of3dPrimitive); }  arg2 = (float)lua_tonumber(L, 2);
  ((of3dPrimitive const *)arg1)->drawNormals(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_3dPrimitive_drawNormals(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L);
  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_of3dPrimitive, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_3dPrimitive_drawNormals__SWIG_1(L);}  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_of3dPrimitive, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isboolean(L,argv[2]); }  if (_v) {
          return _wrap_3dPrimitive_drawNormals__SWIG_0(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function '3dPrimitive_drawNormals'\n"
  "  Possible C/C++ prototypes are:\n" "    of3dPrimitive::drawNormals(float,bool) const\n"
  "    of3dPrimitive::drawNormals(float) const\n"); lua_error(L);return 0; }
static int _wrap_3dPrimitive_drawAxes(lua_State* L) { int SWIG_arg = 0; of3dPrimitive *arg1 = (of3dPrimitive *) 0 ; float arg2 ;
  SWIG_check_num_args("of3dPrimitive::drawAxes",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("of3dPrimitive::drawAxes",1,"of3dPrimitive const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("of3dPrimitive::drawAxes",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_of3dPrimitive,0))){
    SWIG_fail_ptr("3dPrimitive_drawAxes",1,SWIGTYPE_p_of3dPrimitive); }  arg2 = (float)lua_tonumber(L, 2);
  ((of3dPrimitive const *)arg1)->drawAxes(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_3dPrimitive_setUseVbo(lua_State* L) { int SWIG_arg = 0; of3dPrimitive *arg1 = (of3dPrimitive *) 0 ; bool arg2 ;
  SWIG_check_num_args("of3dPrimitive::setUseVbo",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("of3dPrimitive::setUseVbo",1,"of3dPrimitive *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("of3dPrimitive::setUseVbo",2,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_of3dPrimitive,0))){
    SWIG_fail_ptr("3dPrimitive_setUseVbo",1,SWIGTYPE_p_of3dPrimitive); }  arg2 = (lua_toboolean(L, 2)!=0);
  (arg1)->setUseVbo(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_3dPrimitive_isUsingVbo(lua_State* L) { int SWIG_arg = 0; of3dPrimitive *arg1 = (of3dPrimitive *) 0 ;
  bool result; SWIG_check_num_args("of3dPrimitive::isUsingVbo",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("of3dPrimitive::isUsingVbo",1,"of3dPrimitive const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_of3dPrimitive,0))){
    SWIG_fail_ptr("3dPrimitive_isUsingVbo",1,SWIGTYPE_p_of3dPrimitive); } 
  result = (bool)((of3dPrimitive const *)arg1)->isUsingVbo(); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static void swig_delete_3dPrimitive(void *obj) {
of3dPrimitive *arg1 = (of3dPrimitive *) obj;
delete arg1;
}
static int _proxy__wrap_new_3dPrimitive(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_3dPrimitive);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_3dPrimitive_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_3dPrimitive_methods[]= {
    { "mapTexCoords", _wrap_3dPrimitive_mapTexCoords},
    { "mapTexCoordsFromTexture", _wrap_3dPrimitive_mapTexCoordsFromTexture},
    { "getMeshPtr", _wrap_3dPrimitive_getMeshPtr},
    { "getMesh", _wrap_3dPrimitive_getMesh},
    { "getTexCoordsPtr", _wrap_3dPrimitive_getTexCoordsPtr},
    { "getTexCoords", _wrap_3dPrimitive_getTexCoords},
    { "hasScaling", _wrap_3dPrimitive_hasScaling},
    { "hasNormalsEnabled", _wrap_3dPrimitive_hasNormalsEnabled},
    { "enableNormals", _wrap_3dPrimitive_enableNormals},
    { "enableTextures", _wrap_3dPrimitive_enableTextures},
    { "enableColors", _wrap_3dPrimitive_enableColors},
    { "disableNormals", _wrap_3dPrimitive_disableNormals},
    { "disableTextures", _wrap_3dPrimitive_disableTextures},
    { "disableColors", _wrap_3dPrimitive_disableColors},
    { "drawVertices", _wrap_3dPrimitive_drawVertices},
    { "drawWireframe", _wrap_3dPrimitive_drawWireframe},
    { "drawFaces", _wrap_3dPrimitive_drawFaces},
    { "drawNormals", _wrap_3dPrimitive_drawNormals},
    { "drawAxes", _wrap_3dPrimitive_drawAxes},
    { "setUseVbo", _wrap_3dPrimitive_setUseVbo},
    { "isUsingVbo", _wrap_3dPrimitive_isUsingVbo},
    {0,0}
};
static swig_lua_method swig_3dPrimitive_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_3dPrimitive_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_3dPrimitive_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_3dPrimitive_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_3dPrimitive_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_3dPrimitive_Sf_SwigStatic = {
    "3dPrimitive",
    swig_3dPrimitive_Sf_SwigStatic_methods,
    swig_3dPrimitive_Sf_SwigStatic_attributes,
    swig_3dPrimitive_Sf_SwigStatic_constants,
    swig_3dPrimitive_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_3dPrimitive_bases[] = {0,0};
static const char *swig_3dPrimitive_base_names[] = {"ofNode *",0};
static swig_lua_class _wrap_class_3dPrimitive = { "3dPrimitive", "3dPrimitive", &SWIGTYPE_p_of3dPrimitive,_proxy__wrap_new_3dPrimitive, swig_delete_3dPrimitive, swig_3dPrimitive_methods, swig_3dPrimitive_attributes, &swig_3dPrimitive_Sf_SwigStatic, swig_3dPrimitive_meta, swig_3dPrimitive_bases, swig_3dPrimitive_base_names };

static int _wrap_new_PlanePrimitive__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofPlanePrimitive *result = 0 ;
  SWIG_check_num_args("ofPlanePrimitive::ofPlanePrimitive",0,0) result = (ofPlanePrimitive *)new ofPlanePrimitive();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofPlanePrimitive,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_PlanePrimitive__SWIG_1(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; int arg3 ; int arg4 ;
  ofPrimitiveMode arg5 ; ofPlanePrimitive *result = 0 ; SWIG_check_num_args("ofPlanePrimitive::ofPlanePrimitive",5,5)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofPlanePrimitive::ofPlanePrimitive",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofPlanePrimitive::ofPlanePrimitive",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofPlanePrimitive::ofPlanePrimitive",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofPlanePrimitive::ofPlanePrimitive",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofPlanePrimitive::ofPlanePrimitive",5,"ofPrimitiveMode");
  arg1 = (float)lua_tonumber(L, 1); arg2 = (float)lua_tonumber(L, 2); arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4); arg5 = (ofPrimitiveMode)(int)lua_tonumber(L, 5);
  result = (ofPlanePrimitive *)new ofPlanePrimitive(arg1,arg2,arg3,arg4,arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofPlanePrimitive,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_PlanePrimitive__SWIG_2(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; int arg3 ; int arg4 ;
  ofPlanePrimitive *result = 0 ; SWIG_check_num_args("ofPlanePrimitive::ofPlanePrimitive",4,4)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofPlanePrimitive::ofPlanePrimitive",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofPlanePrimitive::ofPlanePrimitive",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofPlanePrimitive::ofPlanePrimitive",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofPlanePrimitive::ofPlanePrimitive",4,"int"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (int)lua_tonumber(L, 3); arg4 = (int)lua_tonumber(L, 4);
  result = (ofPlanePrimitive *)new ofPlanePrimitive(arg1,arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofPlanePrimitive,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_PlanePrimitive(lua_State* L) { int argc; int argv[6]={ 1,2,3,4,5,6} ; argc = lua_gettop(L);
  if (argc == 0) { return _wrap_new_PlanePrimitive__SWIG_0(L);}  if (argc == 4) { int _v; { _v = lua_isnumber(L,argv[0]); } 
    if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { {
            _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_new_PlanePrimitive__SWIG_2(L);}  }  }  }  } 
  if (argc == 5) { int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { {
          _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { {
              _v = lua_isnumber(L,argv[4]); }  if (_v) { return _wrap_new_PlanePrimitive__SWIG_1(L);}  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_PlanePrimitive'\n" "  Possible C/C++ prototypes are:\n"
  "    ofPlanePrimitive::ofPlanePrimitive()\n" "    ofPlanePrimitive::ofPlanePrimitive(float,float,int,int,ofPrimitiveMode)\n"
  "    ofPlanePrimitive::ofPlanePrimitive(float,float,int,int)\n"); lua_error(L);return 0; }
static int _wrap_PlanePrimitive_set__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofPlanePrimitive *arg1 = (ofPlanePrimitive *) 0 ;
  float arg2 ; float arg3 ; int arg4 ; int arg5 ; ofPrimitiveMode arg6 ; SWIG_check_num_args("ofPlanePrimitive::set",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPlanePrimitive::set",1,"ofPlanePrimitive *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofPlanePrimitive::set",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofPlanePrimitive::set",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofPlanePrimitive::set",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofPlanePrimitive::set",5,"int");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofPlanePrimitive::set",6,"ofPrimitiveMode");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPlanePrimitive,0))){
    SWIG_fail_ptr("PlanePrimitive_set",1,SWIGTYPE_p_ofPlanePrimitive); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (int)lua_tonumber(L, 4); arg5 = (int)lua_tonumber(L, 5);
  arg6 = (ofPrimitiveMode)(int)lua_tonumber(L, 6); (arg1)->set(arg2,arg3,arg4,arg5,arg6); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_PlanePrimitive_set__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofPlanePrimitive *arg1 = (ofPlanePrimitive *) 0 ;
  float arg2 ; float arg3 ; int arg4 ; int arg5 ; SWIG_check_num_args("ofPlanePrimitive::set",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPlanePrimitive::set",1,"ofPlanePrimitive *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofPlanePrimitive::set",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofPlanePrimitive::set",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofPlanePrimitive::set",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofPlanePrimitive::set",5,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPlanePrimitive,0))){
    SWIG_fail_ptr("PlanePrimitive_set",1,SWIGTYPE_p_ofPlanePrimitive); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (int)lua_tonumber(L, 4); arg5 = (int)lua_tonumber(L, 5);
  (arg1)->set(arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_PlanePrimitive_set__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofPlanePrimitive *arg1 = (ofPlanePrimitive *) 0 ;
  float arg2 ; float arg3 ; SWIG_check_num_args("ofPlanePrimitive::set",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPlanePrimitive::set",1,"ofPlanePrimitive *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofPlanePrimitive::set",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofPlanePrimitive::set",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPlanePrimitive,0))){
    SWIG_fail_ptr("PlanePrimitive_set",1,SWIGTYPE_p_ofPlanePrimitive); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); (arg1)->set(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_PlanePrimitive_set(lua_State* L) { int argc; int argv[7]={ 1,2,3,4,5,6,7} ; argc = lua_gettop(L);
  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofPlanePrimitive, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_PlanePrimitive_set__SWIG_2(L);}  }  }  }  if (argc == 5) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofPlanePrimitive, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) {
              return _wrap_PlanePrimitive_set__SWIG_1(L);}  }  }  }  }  }  if (argc == 6) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofPlanePrimitive, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) { {
                _v = lua_isnumber(L,argv[5]); }  if (_v) { return _wrap_PlanePrimitive_set__SWIG_0(L);}  }  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'PlanePrimitive_set'\n" "  Possible C/C++ prototypes are:\n"
  "    ofPlanePrimitive::set(float,float,int,int,ofPrimitiveMode)\n" "    ofPlanePrimitive::set(float,float,int,int)\n"
  "    ofPlanePrimitive::set(float,float)\n"); lua_error(L);return 0; }
static int _wrap_PlanePrimitive_resizeToTexture__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofPlanePrimitive *arg1 = (ofPlanePrimitive *) 0 ; ofTexture *arg2 = 0 ; float arg3 ;
  SWIG_check_num_args("ofPlanePrimitive::resizeToTexture",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPlanePrimitive::resizeToTexture",1,"ofPlanePrimitive *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofPlanePrimitive::resizeToTexture",2,"ofTexture &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofPlanePrimitive::resizeToTexture",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPlanePrimitive,0))){
    SWIG_fail_ptr("PlanePrimitive_resizeToTexture",1,SWIGTYPE_p_ofPlanePrimitive); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("PlanePrimitive_resizeToTexture",2,SWIGTYPE_p_ofTexture); }  arg3 = (float)lua_tonumber(L, 3);
  (arg1)->resizeToTexture(*arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_PlanePrimitive_resizeToTexture__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofPlanePrimitive *arg1 = (ofPlanePrimitive *) 0 ; ofTexture *arg2 = 0 ;
  SWIG_check_num_args("ofPlanePrimitive::resizeToTexture",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPlanePrimitive::resizeToTexture",1,"ofPlanePrimitive *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofPlanePrimitive::resizeToTexture",2,"ofTexture &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPlanePrimitive,0))){
    SWIG_fail_ptr("PlanePrimitive_resizeToTexture",1,SWIGTYPE_p_ofPlanePrimitive); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("PlanePrimitive_resizeToTexture",2,SWIGTYPE_p_ofTexture); }  (arg1)->resizeToTexture(*arg2); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_PlanePrimitive_resizeToTexture(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L);
  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofPlanePrimitive, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofTexture, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_PlanePrimitive_resizeToTexture__SWIG_1(L);}  }  }  if (argc == 3) { int _v;
    { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofPlanePrimitive, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofTexture, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_PlanePrimitive_resizeToTexture__SWIG_0(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'PlanePrimitive_resizeToTexture'\n"
  "  Possible C/C++ prototypes are:\n" "    ofPlanePrimitive::resizeToTexture(ofTexture &,float)\n"
  "    ofPlanePrimitive::resizeToTexture(ofTexture &)\n"); lua_error(L);return 0; }
static int _wrap_PlanePrimitive_setWidth(lua_State* L) { int SWIG_arg = 0; ofPlanePrimitive *arg1 = (ofPlanePrimitive *) 0 ;
  float arg2 ; SWIG_check_num_args("ofPlanePrimitive::setWidth",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPlanePrimitive::setWidth",1,"ofPlanePrimitive *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofPlanePrimitive::setWidth",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPlanePrimitive,0))){
    SWIG_fail_ptr("PlanePrimitive_setWidth",1,SWIGTYPE_p_ofPlanePrimitive); }  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setWidth(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_PlanePrimitive_setHeight(lua_State* L) { int SWIG_arg = 0; ofPlanePrimitive *arg1 = (ofPlanePrimitive *) 0 ;
  float arg2 ; SWIG_check_num_args("ofPlanePrimitive::setHeight",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPlanePrimitive::setHeight",1,"ofPlanePrimitive *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofPlanePrimitive::setHeight",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPlanePrimitive,0))){
    SWIG_fail_ptr("PlanePrimitive_setHeight",1,SWIGTYPE_p_ofPlanePrimitive); }  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setHeight(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_PlanePrimitive_setColumns(lua_State* L) { int SWIG_arg = 0; ofPlanePrimitive *arg1 = (ofPlanePrimitive *) 0 ;
  int arg2 ; SWIG_check_num_args("ofPlanePrimitive::setColumns",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPlanePrimitive::setColumns",1,"ofPlanePrimitive *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofPlanePrimitive::setColumns",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPlanePrimitive,0))){
    SWIG_fail_ptr("PlanePrimitive_setColumns",1,SWIGTYPE_p_ofPlanePrimitive); }  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setColumns(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_PlanePrimitive_setRows(lua_State* L) { int SWIG_arg = 0; ofPlanePrimitive *arg1 = (ofPlanePrimitive *) 0 ;
  int arg2 ; SWIG_check_num_args("ofPlanePrimitive::setRows",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPlanePrimitive::setRows",1,"ofPlanePrimitive *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofPlanePrimitive::setRows",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPlanePrimitive,0))){
    SWIG_fail_ptr("PlanePrimitive_setRows",1,SWIGTYPE_p_ofPlanePrimitive); }  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setRows(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_PlanePrimitive_setResolution(lua_State* L) { int SWIG_arg = 0;
  ofPlanePrimitive *arg1 = (ofPlanePrimitive *) 0 ; int arg2 ; int arg3 ;
  SWIG_check_num_args("ofPlanePrimitive::setResolution",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPlanePrimitive::setResolution",1,"ofPlanePrimitive *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofPlanePrimitive::setResolution",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofPlanePrimitive::setResolution",3,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPlanePrimitive,0))){
    SWIG_fail_ptr("PlanePrimitive_setResolution",1,SWIGTYPE_p_ofPlanePrimitive); }  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3); (arg1)->setResolution(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_PlanePrimitive_setMode(lua_State* L) { int SWIG_arg = 0; ofPlanePrimitive *arg1 = (ofPlanePrimitive *) 0 ;
  ofPrimitiveMode arg2 ; SWIG_check_num_args("ofPlanePrimitive::setMode",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPlanePrimitive::setMode",1,"ofPlanePrimitive *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofPlanePrimitive::setMode",2,"ofPrimitiveMode");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPlanePrimitive,0))){
    SWIG_fail_ptr("PlanePrimitive_setMode",1,SWIGTYPE_p_ofPlanePrimitive); }  arg2 = (ofPrimitiveMode)(int)lua_tonumber(L, 2);
  (arg1)->setMode(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_PlanePrimitive_getNumColumns(lua_State* L) { int SWIG_arg = 0;
  ofPlanePrimitive *arg1 = (ofPlanePrimitive *) 0 ; int result; SWIG_check_num_args("ofPlanePrimitive::getNumColumns",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPlanePrimitive::getNumColumns",1,"ofPlanePrimitive const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPlanePrimitive,0))){
    SWIG_fail_ptr("PlanePrimitive_getNumColumns",1,SWIGTYPE_p_ofPlanePrimitive); } 
  result = (int)((ofPlanePrimitive const *)arg1)->getNumColumns(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_PlanePrimitive_getNumRows(lua_State* L) { int SWIG_arg = 0; ofPlanePrimitive *arg1 = (ofPlanePrimitive *) 0 ;
  int result; SWIG_check_num_args("ofPlanePrimitive::getNumRows",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPlanePrimitive::getNumRows",1,"ofPlanePrimitive const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPlanePrimitive,0))){
    SWIG_fail_ptr("PlanePrimitive_getNumRows",1,SWIGTYPE_p_ofPlanePrimitive); } 
  result = (int)((ofPlanePrimitive const *)arg1)->getNumRows(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_PlanePrimitive_getResolution(lua_State* L) { int SWIG_arg = 0;
  ofPlanePrimitive *arg1 = (ofPlanePrimitive *) 0 ; glm::vec2 result; SWIG_check_num_args("ofPlanePrimitive::getResolution",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPlanePrimitive::getResolution",1,"ofPlanePrimitive const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPlanePrimitive,0))){
    SWIG_fail_ptr("PlanePrimitive_getResolution",1,SWIGTYPE_p_ofPlanePrimitive); } 
  result = ((ofPlanePrimitive const *)arg1)->getResolution(); {
    glm::vec2 * resultptr = new glm::vec2((const glm::vec2 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_glm__vec2,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_PlanePrimitive_getWidth(lua_State* L) { int SWIG_arg = 0; ofPlanePrimitive *arg1 = (ofPlanePrimitive *) 0 ;
  float result; SWIG_check_num_args("ofPlanePrimitive::getWidth",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPlanePrimitive::getWidth",1,"ofPlanePrimitive const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPlanePrimitive,0))){
    SWIG_fail_ptr("PlanePrimitive_getWidth",1,SWIGTYPE_p_ofPlanePrimitive); } 
  result = (float)((ofPlanePrimitive const *)arg1)->getWidth(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_PlanePrimitive_getHeight(lua_State* L) { int SWIG_arg = 0; ofPlanePrimitive *arg1 = (ofPlanePrimitive *) 0 ;
  float result; SWIG_check_num_args("ofPlanePrimitive::getHeight",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPlanePrimitive::getHeight",1,"ofPlanePrimitive const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPlanePrimitive,0))){
    SWIG_fail_ptr("PlanePrimitive_getHeight",1,SWIGTYPE_p_ofPlanePrimitive); } 
  result = (float)((ofPlanePrimitive const *)arg1)->getHeight(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static void swig_delete_PlanePrimitive(void *obj) {
ofPlanePrimitive *arg1 = (ofPlanePrimitive *) obj;
delete arg1;
}
static int _proxy__wrap_new_PlanePrimitive(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_PlanePrimitive);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_PlanePrimitive_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_PlanePrimitive_methods[]= {
    { "set", _wrap_PlanePrimitive_set},
    { "resizeToTexture", _wrap_PlanePrimitive_resizeToTexture},
    { "setWidth", _wrap_PlanePrimitive_setWidth},
    { "setHeight", _wrap_PlanePrimitive_setHeight},
    { "setColumns", _wrap_PlanePrimitive_setColumns},
    { "setRows", _wrap_PlanePrimitive_setRows},
    { "setResolution", _wrap_PlanePrimitive_setResolution},
    { "setMode", _wrap_PlanePrimitive_setMode},
    { "getNumColumns", _wrap_PlanePrimitive_getNumColumns},
    { "getNumRows", _wrap_PlanePrimitive_getNumRows},
    { "getResolution", _wrap_PlanePrimitive_getResolution},
    { "getWidth", _wrap_PlanePrimitive_getWidth},
    { "getHeight", _wrap_PlanePrimitive_getHeight},
    {0,0}
};
static swig_lua_method swig_PlanePrimitive_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_PlanePrimitive_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_PlanePrimitive_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_PlanePrimitive_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_PlanePrimitive_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_PlanePrimitive_Sf_SwigStatic = {
    "PlanePrimitive",
    swig_PlanePrimitive_Sf_SwigStatic_methods,
    swig_PlanePrimitive_Sf_SwigStatic_attributes,
    swig_PlanePrimitive_Sf_SwigStatic_constants,
    swig_PlanePrimitive_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_PlanePrimitive_bases[] = {0,0};
static const char *swig_PlanePrimitive_base_names[] = {"of3dPrimitive *",0};
static swig_lua_class _wrap_class_PlanePrimitive = { "PlanePrimitive", "PlanePrimitive", &SWIGTYPE_p_ofPlanePrimitive,_proxy__wrap_new_PlanePrimitive, swig_delete_PlanePrimitive, swig_PlanePrimitive_methods, swig_PlanePrimitive_attributes, &swig_PlanePrimitive_Sf_SwigStatic, swig_PlanePrimitive_meta, swig_PlanePrimitive_bases, swig_PlanePrimitive_base_names };

static int _wrap_new_SpherePrimitive__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofSpherePrimitive *result = 0 ;
  SWIG_check_num_args("ofSpherePrimitive::ofSpherePrimitive",0,0) result = (ofSpherePrimitive *)new ofSpherePrimitive();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofSpherePrimitive,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_SpherePrimitive__SWIG_1(lua_State* L) { int SWIG_arg = 0; float arg1 ; int arg2 ; ofPrimitiveMode arg3 ;
  ofSpherePrimitive *result = 0 ; SWIG_check_num_args("ofSpherePrimitive::ofSpherePrimitive",3,3)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofSpherePrimitive::ofSpherePrimitive",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofSpherePrimitive::ofSpherePrimitive",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofSpherePrimitive::ofSpherePrimitive",3,"ofPrimitiveMode");
  arg1 = (float)lua_tonumber(L, 1); arg2 = (int)lua_tonumber(L, 2); arg3 = (ofPrimitiveMode)(int)lua_tonumber(L, 3);
  result = (ofSpherePrimitive *)new ofSpherePrimitive(arg1,arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofSpherePrimitive,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_SpherePrimitive__SWIG_2(lua_State* L) { int SWIG_arg = 0; float arg1 ; int arg2 ;
  ofSpherePrimitive *result = 0 ; SWIG_check_num_args("ofSpherePrimitive::ofSpherePrimitive",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofSpherePrimitive::ofSpherePrimitive",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofSpherePrimitive::ofSpherePrimitive",2,"int"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (int)lua_tonumber(L, 2); result = (ofSpherePrimitive *)new ofSpherePrimitive(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofSpherePrimitive,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_SpherePrimitive(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 0) {
    return _wrap_new_SpherePrimitive__SWIG_0(L);}  if (argc == 2) { int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { {
        _v = lua_isnumber(L,argv[1]); }  if (_v) { return _wrap_new_SpherePrimitive__SWIG_2(L);}  }  }  if (argc == 3) { int _v;
    { _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); } 
        if (_v) { return _wrap_new_SpherePrimitive__SWIG_1(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_SpherePrimitive'\n"
  "  Possible C/C++ prototypes are:\n" "    ofSpherePrimitive::ofSpherePrimitive()\n"
  "    ofSpherePrimitive::ofSpherePrimitive(float,int,ofPrimitiveMode)\n"
  "    ofSpherePrimitive::ofSpherePrimitive(float,int)\n"); lua_error(L);return 0; }
static int _wrap_SpherePrimitive_set__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofSpherePrimitive *arg1 = (ofSpherePrimitive *) 0 ; float arg2 ; int arg3 ; ofPrimitiveMode arg4 ;
  SWIG_check_num_args("ofSpherePrimitive::set",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSpherePrimitive::set",1,"ofSpherePrimitive *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofSpherePrimitive::set",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofSpherePrimitive::set",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofSpherePrimitive::set",4,"ofPrimitiveMode");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSpherePrimitive,0))){
    SWIG_fail_ptr("SpherePrimitive_set",1,SWIGTYPE_p_ofSpherePrimitive); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3); arg4 = (ofPrimitiveMode)(int)lua_tonumber(L, 4); (arg1)->set(arg2,arg3,arg4); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_SpherePrimitive_set__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofSpherePrimitive *arg1 = (ofSpherePrimitive *) 0 ; float arg2 ; int arg3 ; SWIG_check_num_args("ofSpherePrimitive::set",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSpherePrimitive::set",1,"ofSpherePrimitive *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofSpherePrimitive::set",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofSpherePrimitive::set",3,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSpherePrimitive,0))){
    SWIG_fail_ptr("SpherePrimitive_set",1,SWIGTYPE_p_ofSpherePrimitive); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3); (arg1)->set(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_SpherePrimitive_set(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L); if (argc == 3) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofSpherePrimitive, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { return _wrap_SpherePrimitive_set__SWIG_1(L);}  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofSpherePrimitive, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_SpherePrimitive_set__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'SpherePrimitive_set'\n"
  "  Possible C/C++ prototypes are:\n" "    ofSpherePrimitive::set(float,int,ofPrimitiveMode)\n"
  "    ofSpherePrimitive::set(float,int)\n"); lua_error(L);return 0; }
static int _wrap_SpherePrimitive_setResolution(lua_State* L) { int SWIG_arg = 0;
  ofSpherePrimitive *arg1 = (ofSpherePrimitive *) 0 ; int arg2 ; SWIG_check_num_args("ofSpherePrimitive::setResolution",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSpherePrimitive::setResolution",1,"ofSpherePrimitive *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofSpherePrimitive::setResolution",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSpherePrimitive,0))){
    SWIG_fail_ptr("SpherePrimitive_setResolution",1,SWIGTYPE_p_ofSpherePrimitive); }  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setResolution(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_SpherePrimitive_setRadius(lua_State* L) { int SWIG_arg = 0; ofSpherePrimitive *arg1 = (ofSpherePrimitive *) 0 ;
  float arg2 ; SWIG_check_num_args("ofSpherePrimitive::setRadius",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSpherePrimitive::setRadius",1,"ofSpherePrimitive *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofSpherePrimitive::setRadius",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSpherePrimitive,0))){
    SWIG_fail_ptr("SpherePrimitive_setRadius",1,SWIGTYPE_p_ofSpherePrimitive); }  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setRadius(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_SpherePrimitive_setMode(lua_State* L) { int SWIG_arg = 0; ofSpherePrimitive *arg1 = (ofSpherePrimitive *) 0 ;
  ofPrimitiveMode arg2 ; SWIG_check_num_args("ofSpherePrimitive::setMode",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSpherePrimitive::setMode",1,"ofSpherePrimitive *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofSpherePrimitive::setMode",2,"ofPrimitiveMode");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSpherePrimitive,0))){
    SWIG_fail_ptr("SpherePrimitive_setMode",1,SWIGTYPE_p_ofSpherePrimitive); }  arg2 = (ofPrimitiveMode)(int)lua_tonumber(L, 2);
  (arg1)->setMode(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_SpherePrimitive_getRadius(lua_State* L) { int SWIG_arg = 0; ofSpherePrimitive *arg1 = (ofSpherePrimitive *) 0 ;
  float result; SWIG_check_num_args("ofSpherePrimitive::getRadius",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSpherePrimitive::getRadius",1,"ofSpherePrimitive const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSpherePrimitive,0))){
    SWIG_fail_ptr("SpherePrimitive_getRadius",1,SWIGTYPE_p_ofSpherePrimitive); } 
  result = (float)((ofSpherePrimitive const *)arg1)->getRadius(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_SpherePrimitive_getResolution(lua_State* L) { int SWIG_arg = 0;
  ofSpherePrimitive *arg1 = (ofSpherePrimitive *) 0 ; int result; SWIG_check_num_args("ofSpherePrimitive::getResolution",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSpherePrimitive::getResolution",1,"ofSpherePrimitive const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSpherePrimitive,0))){
    SWIG_fail_ptr("SpherePrimitive_getResolution",1,SWIGTYPE_p_ofSpherePrimitive); } 
  result = (int)((ofSpherePrimitive const *)arg1)->getResolution(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static void swig_delete_SpherePrimitive(void *obj) {
ofSpherePrimitive *arg1 = (ofSpherePrimitive *) obj;
delete arg1;
}
static int _proxy__wrap_new_SpherePrimitive(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_SpherePrimitive);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_SpherePrimitive_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_SpherePrimitive_methods[]= {
    { "set", _wrap_SpherePrimitive_set},
    { "setResolution", _wrap_SpherePrimitive_setResolution},
    { "setRadius", _wrap_SpherePrimitive_setRadius},
    { "setMode", _wrap_SpherePrimitive_setMode},
    { "getRadius", _wrap_SpherePrimitive_getRadius},
    { "getResolution", _wrap_SpherePrimitive_getResolution},
    {0,0}
};
static swig_lua_method swig_SpherePrimitive_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_SpherePrimitive_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_SpherePrimitive_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_SpherePrimitive_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_SpherePrimitive_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_SpherePrimitive_Sf_SwigStatic = {
    "SpherePrimitive",
    swig_SpherePrimitive_Sf_SwigStatic_methods,
    swig_SpherePrimitive_Sf_SwigStatic_attributes,
    swig_SpherePrimitive_Sf_SwigStatic_constants,
    swig_SpherePrimitive_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_SpherePrimitive_bases[] = {0,0};
static const char *swig_SpherePrimitive_base_names[] = {"of3dPrimitive *",0};
static swig_lua_class _wrap_class_SpherePrimitive = { "SpherePrimitive", "SpherePrimitive", &SWIGTYPE_p_ofSpherePrimitive,_proxy__wrap_new_SpherePrimitive, swig_delete_SpherePrimitive, swig_SpherePrimitive_methods, swig_SpherePrimitive_attributes, &swig_SpherePrimitive_Sf_SwigStatic, swig_SpherePrimitive_meta, swig_SpherePrimitive_bases, swig_SpherePrimitive_base_names };

static int _wrap_new_IcoSpherePrimitive__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofIcoSpherePrimitive *result = 0 ;
  SWIG_check_num_args("ofIcoSpherePrimitive::ofIcoSpherePrimitive",0,0)
  result = (ofIcoSpherePrimitive *)new ofIcoSpherePrimitive();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofIcoSpherePrimitive,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_IcoSpherePrimitive__SWIG_1(lua_State* L) { int SWIG_arg = 0; float arg1 ; int arg2 ;
  ofIcoSpherePrimitive *result = 0 ; SWIG_check_num_args("ofIcoSpherePrimitive::ofIcoSpherePrimitive",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofIcoSpherePrimitive::ofIcoSpherePrimitive",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofIcoSpherePrimitive::ofIcoSpherePrimitive",2,"int"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (int)lua_tonumber(L, 2); result = (ofIcoSpherePrimitive *)new ofIcoSpherePrimitive(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofIcoSpherePrimitive,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_IcoSpherePrimitive(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 0) {
    return _wrap_new_IcoSpherePrimitive__SWIG_0(L);}  if (argc == 2) { int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { {
        _v = lua_isnumber(L,argv[1]); }  if (_v) { return _wrap_new_IcoSpherePrimitive__SWIG_1(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_IcoSpherePrimitive'\n"
  "  Possible C/C++ prototypes are:\n" "    ofIcoSpherePrimitive::ofIcoSpherePrimitive()\n"
  "    ofIcoSpherePrimitive::ofIcoSpherePrimitive(float,int)\n"); lua_error(L);return 0; }
static int _wrap_IcoSpherePrimitive_set(lua_State* L) { int SWIG_arg = 0;
  ofIcoSpherePrimitive *arg1 = (ofIcoSpherePrimitive *) 0 ; float arg2 ; int arg3 ;
  SWIG_check_num_args("ofIcoSpherePrimitive::set",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofIcoSpherePrimitive::set",1,"ofIcoSpherePrimitive *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofIcoSpherePrimitive::set",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofIcoSpherePrimitive::set",3,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofIcoSpherePrimitive,0))){
    SWIG_fail_ptr("IcoSpherePrimitive_set",1,SWIGTYPE_p_ofIcoSpherePrimitive); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3); (arg1)->set(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_IcoSpherePrimitive_setResolution(lua_State* L) { int SWIG_arg = 0;
  ofIcoSpherePrimitive *arg1 = (ofIcoSpherePrimitive *) 0 ; int arg2 ;
  SWIG_check_num_args("ofIcoSpherePrimitive::setResolution",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofIcoSpherePrimitive::setResolution",1,"ofIcoSpherePrimitive *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofIcoSpherePrimitive::setResolution",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofIcoSpherePrimitive,0))){
    SWIG_fail_ptr("IcoSpherePrimitive_setResolution",1,SWIGTYPE_p_ofIcoSpherePrimitive); }  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setResolution(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_IcoSpherePrimitive_setRadius(lua_State* L) { int SWIG_arg = 0;
  ofIcoSpherePrimitive *arg1 = (ofIcoSpherePrimitive *) 0 ; float arg2 ;
  SWIG_check_num_args("ofIcoSpherePrimitive::setRadius",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofIcoSpherePrimitive::setRadius",1,"ofIcoSpherePrimitive *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofIcoSpherePrimitive::setRadius",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofIcoSpherePrimitive,0))){
    SWIG_fail_ptr("IcoSpherePrimitive_setRadius",1,SWIGTYPE_p_ofIcoSpherePrimitive); }  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setRadius(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_IcoSpherePrimitive_setMode(lua_State* L) { int SWIG_arg = 0;
  ofIcoSpherePrimitive *arg1 = (ofIcoSpherePrimitive *) 0 ; ofPrimitiveMode arg2 ;
  SWIG_check_num_args("ofIcoSpherePrimitive::setMode",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofIcoSpherePrimitive::setMode",1,"ofIcoSpherePrimitive *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofIcoSpherePrimitive::setMode",2,"ofPrimitiveMode");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofIcoSpherePrimitive,0))){
    SWIG_fail_ptr("IcoSpherePrimitive_setMode",1,SWIGTYPE_p_ofIcoSpherePrimitive); } 
  arg2 = (ofPrimitiveMode)(int)lua_tonumber(L, 2); (arg1)->setMode(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_IcoSpherePrimitive_getRadius(lua_State* L) { int SWIG_arg = 0;
  ofIcoSpherePrimitive *arg1 = (ofIcoSpherePrimitive *) 0 ; float result;
  SWIG_check_num_args("ofIcoSpherePrimitive::getRadius",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofIcoSpherePrimitive::getRadius",1,"ofIcoSpherePrimitive const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofIcoSpherePrimitive,0))){
    SWIG_fail_ptr("IcoSpherePrimitive_getRadius",1,SWIGTYPE_p_ofIcoSpherePrimitive); } 
  result = (float)((ofIcoSpherePrimitive const *)arg1)->getRadius(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_IcoSpherePrimitive_getResolution(lua_State* L) { int SWIG_arg = 0;
  ofIcoSpherePrimitive *arg1 = (ofIcoSpherePrimitive *) 0 ; int result;
  SWIG_check_num_args("ofIcoSpherePrimitive::getResolution",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofIcoSpherePrimitive::getResolution",1,"ofIcoSpherePrimitive const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofIcoSpherePrimitive,0))){
    SWIG_fail_ptr("IcoSpherePrimitive_getResolution",1,SWIGTYPE_p_ofIcoSpherePrimitive); } 
  result = (int)((ofIcoSpherePrimitive const *)arg1)->getResolution(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static void swig_delete_IcoSpherePrimitive(void *obj) {
ofIcoSpherePrimitive *arg1 = (ofIcoSpherePrimitive *) obj;
delete arg1;
}
static int _proxy__wrap_new_IcoSpherePrimitive(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_IcoSpherePrimitive);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_IcoSpherePrimitive_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_IcoSpherePrimitive_methods[]= {
    { "set", _wrap_IcoSpherePrimitive_set},
    { "setResolution", _wrap_IcoSpherePrimitive_setResolution},
    { "setRadius", _wrap_IcoSpherePrimitive_setRadius},
    { "setMode", _wrap_IcoSpherePrimitive_setMode},
    { "getRadius", _wrap_IcoSpherePrimitive_getRadius},
    { "getResolution", _wrap_IcoSpherePrimitive_getResolution},
    {0,0}
};
static swig_lua_method swig_IcoSpherePrimitive_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_IcoSpherePrimitive_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_IcoSpherePrimitive_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_IcoSpherePrimitive_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_IcoSpherePrimitive_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_IcoSpherePrimitive_Sf_SwigStatic = {
    "IcoSpherePrimitive",
    swig_IcoSpherePrimitive_Sf_SwigStatic_methods,
    swig_IcoSpherePrimitive_Sf_SwigStatic_attributes,
    swig_IcoSpherePrimitive_Sf_SwigStatic_constants,
    swig_IcoSpherePrimitive_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_IcoSpherePrimitive_bases[] = {0,0};
static const char *swig_IcoSpherePrimitive_base_names[] = {"of3dPrimitive *",0};
static swig_lua_class _wrap_class_IcoSpherePrimitive = { "IcoSpherePrimitive", "IcoSpherePrimitive", &SWIGTYPE_p_ofIcoSpherePrimitive,_proxy__wrap_new_IcoSpherePrimitive, swig_delete_IcoSpherePrimitive, swig_IcoSpherePrimitive_methods, swig_IcoSpherePrimitive_attributes, &swig_IcoSpherePrimitive_Sf_SwigStatic, swig_IcoSpherePrimitive_meta, swig_IcoSpherePrimitive_bases, swig_IcoSpherePrimitive_base_names };

static int _wrap_new_CylinderPrimitive__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofCylinderPrimitive *result = 0 ;
  SWIG_check_num_args("ofCylinderPrimitive::ofCylinderPrimitive",0,0) result = (ofCylinderPrimitive *)new ofCylinderPrimitive();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofCylinderPrimitive,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_CylinderPrimitive__SWIG_1(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; int arg3 ; int arg4 ;
  int arg5 ; bool arg6 ; ofPrimitiveMode arg7 ; ofCylinderPrimitive *result = 0 ;
  SWIG_check_num_args("ofCylinderPrimitive::ofCylinderPrimitive",7,7)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofCylinderPrimitive::ofCylinderPrimitive",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofCylinderPrimitive::ofCylinderPrimitive",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofCylinderPrimitive::ofCylinderPrimitive",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofCylinderPrimitive::ofCylinderPrimitive",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofCylinderPrimitive::ofCylinderPrimitive",5,"int");
  if(!lua_isboolean(L,6)) SWIG_fail_arg("ofCylinderPrimitive::ofCylinderPrimitive",6,"bool");
  if(!lua_isnumber(L,7)) SWIG_fail_arg("ofCylinderPrimitive::ofCylinderPrimitive",7,"ofPrimitiveMode");
  arg1 = (float)lua_tonumber(L, 1); arg2 = (float)lua_tonumber(L, 2); arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4); arg5 = (int)lua_tonumber(L, 5); arg6 = (lua_toboolean(L, 6)!=0);
  arg7 = (ofPrimitiveMode)(int)lua_tonumber(L, 7);
  result = (ofCylinderPrimitive *)new ofCylinderPrimitive(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofCylinderPrimitive,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_CylinderPrimitive__SWIG_2(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; int arg3 ; int arg4 ;
  int arg5 ; bool arg6 ; ofCylinderPrimitive *result = 0 ; SWIG_check_num_args("ofCylinderPrimitive::ofCylinderPrimitive",6,6)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofCylinderPrimitive::ofCylinderPrimitive",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofCylinderPrimitive::ofCylinderPrimitive",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofCylinderPrimitive::ofCylinderPrimitive",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofCylinderPrimitive::ofCylinderPrimitive",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofCylinderPrimitive::ofCylinderPrimitive",5,"int");
  if(!lua_isboolean(L,6)) SWIG_fail_arg("ofCylinderPrimitive::ofCylinderPrimitive",6,"bool"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (int)lua_tonumber(L, 3); arg4 = (int)lua_tonumber(L, 4);
  arg5 = (int)lua_tonumber(L, 5); arg6 = (lua_toboolean(L, 6)!=0);
  result = (ofCylinderPrimitive *)new ofCylinderPrimitive(arg1,arg2,arg3,arg4,arg5,arg6);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofCylinderPrimitive,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_CylinderPrimitive__SWIG_3(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; int arg3 ; int arg4 ;
  int arg5 ; ofCylinderPrimitive *result = 0 ; SWIG_check_num_args("ofCylinderPrimitive::ofCylinderPrimitive",5,5)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofCylinderPrimitive::ofCylinderPrimitive",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofCylinderPrimitive::ofCylinderPrimitive",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofCylinderPrimitive::ofCylinderPrimitive",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofCylinderPrimitive::ofCylinderPrimitive",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofCylinderPrimitive::ofCylinderPrimitive",5,"int"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (int)lua_tonumber(L, 3); arg4 = (int)lua_tonumber(L, 4);
  arg5 = (int)lua_tonumber(L, 5); result = (ofCylinderPrimitive *)new ofCylinderPrimitive(arg1,arg2,arg3,arg4,arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofCylinderPrimitive,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_CylinderPrimitive__SWIG_4(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; int arg3 ; int arg4 ;
  ofCylinderPrimitive *result = 0 ; SWIG_check_num_args("ofCylinderPrimitive::ofCylinderPrimitive",4,4)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofCylinderPrimitive::ofCylinderPrimitive",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofCylinderPrimitive::ofCylinderPrimitive",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofCylinderPrimitive::ofCylinderPrimitive",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofCylinderPrimitive::ofCylinderPrimitive",4,"int"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (int)lua_tonumber(L, 3); arg4 = (int)lua_tonumber(L, 4);
  result = (ofCylinderPrimitive *)new ofCylinderPrimitive(arg1,arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofCylinderPrimitive,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_CylinderPrimitive(lua_State* L) { int argc; int argv[8]={ 1,2,3,4,5,6,7,8} ; argc = lua_gettop(L);
  if (argc == 0) { return _wrap_new_CylinderPrimitive__SWIG_0(L);}  if (argc == 4) { int _v; { _v = lua_isnumber(L,argv[0]); } 
    if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { {
            _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_new_CylinderPrimitive__SWIG_4(L);}  }  }  }  } 
  if (argc == 5) { int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { {
          _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { {
              _v = lua_isnumber(L,argv[4]); }  if (_v) { return _wrap_new_CylinderPrimitive__SWIG_3(L);}  }  }  }  }  } 
  if (argc == 6) { int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { {
          _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { {
              _v = lua_isnumber(L,argv[4]); }  if (_v) { { _v = lua_isboolean(L,argv[5]); }  if (_v) {
                return _wrap_new_CylinderPrimitive__SWIG_2(L);}  }  }  }  }  }  }  if (argc == 7) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); } 
        if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) { {
                _v = lua_isboolean(L,argv[5]); }  if (_v) { { _v = lua_isnumber(L,argv[6]); }  if (_v) {
                  return _wrap_new_CylinderPrimitive__SWIG_1(L);}  }  }  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_CylinderPrimitive'\n"
  "  Possible C/C++ prototypes are:\n" "    ofCylinderPrimitive::ofCylinderPrimitive()\n"
  "    ofCylinderPrimitive::ofCylinderPrimitive(float,float,int,int,int,bool,ofPrimitiveMode)\n"
  "    ofCylinderPrimitive::ofCylinderPrimitive(float,float,int,int,int,bool)\n"
  "    ofCylinderPrimitive::ofCylinderPrimitive(float,float,int,int,int)\n"
  "    ofCylinderPrimitive::ofCylinderPrimitive(float,float,int,int)\n"); lua_error(L);return 0; }
static int _wrap_CylinderPrimitive_set__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofCylinderPrimitive *arg1 = (ofCylinderPrimitive *) 0 ; float arg2 ; float arg3 ; int arg4 ; int arg5 ; int arg6 ; bool arg7 ;
  ofPrimitiveMode arg8 ; SWIG_check_num_args("ofCylinderPrimitive::set",8,8)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofCylinderPrimitive::set",1,"ofCylinderPrimitive *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofCylinderPrimitive::set",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofCylinderPrimitive::set",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofCylinderPrimitive::set",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofCylinderPrimitive::set",5,"int");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofCylinderPrimitive::set",6,"int");
  if(!lua_isboolean(L,7)) SWIG_fail_arg("ofCylinderPrimitive::set",7,"bool");
  if(!lua_isnumber(L,8)) SWIG_fail_arg("ofCylinderPrimitive::set",8,"ofPrimitiveMode");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofCylinderPrimitive,0))){
    SWIG_fail_ptr("CylinderPrimitive_set",1,SWIGTYPE_p_ofCylinderPrimitive); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (int)lua_tonumber(L, 4); arg5 = (int)lua_tonumber(L, 5);
  arg6 = (int)lua_tonumber(L, 6); arg7 = (lua_toboolean(L, 7)!=0); arg8 = (ofPrimitiveMode)(int)lua_tonumber(L, 8);
  (arg1)->set(arg2,arg3,arg4,arg5,arg6,arg7,arg8); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_CylinderPrimitive_set__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofCylinderPrimitive *arg1 = (ofCylinderPrimitive *) 0 ; float arg2 ; float arg3 ; int arg4 ; int arg5 ; int arg6 ; bool arg7 ;
  SWIG_check_num_args("ofCylinderPrimitive::set",7,7)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofCylinderPrimitive::set",1,"ofCylinderPrimitive *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofCylinderPrimitive::set",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofCylinderPrimitive::set",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofCylinderPrimitive::set",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofCylinderPrimitive::set",5,"int");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofCylinderPrimitive::set",6,"int");
  if(!lua_isboolean(L,7)) SWIG_fail_arg("ofCylinderPrimitive::set",7,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofCylinderPrimitive,0))){
    SWIG_fail_ptr("CylinderPrimitive_set",1,SWIGTYPE_p_ofCylinderPrimitive); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (int)lua_tonumber(L, 4); arg5 = (int)lua_tonumber(L, 5);
  arg6 = (int)lua_tonumber(L, 6); arg7 = (lua_toboolean(L, 7)!=0); (arg1)->set(arg2,arg3,arg4,arg5,arg6,arg7); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_CylinderPrimitive_set__SWIG_2(lua_State* L) { int SWIG_arg = 0;
  ofCylinderPrimitive *arg1 = (ofCylinderPrimitive *) 0 ; float arg2 ; float arg3 ; int arg4 ; int arg5 ; int arg6 ;
  SWIG_check_num_args("ofCylinderPrimitive::set",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofCylinderPrimitive::set",1,"ofCylinderPrimitive *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofCylinderPrimitive::set",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofCylinderPrimitive::set",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofCylinderPrimitive::set",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofCylinderPrimitive::set",5,"int");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofCylinderPrimitive::set",6,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofCylinderPrimitive,0))){
    SWIG_fail_ptr("CylinderPrimitive_set",1,SWIGTYPE_p_ofCylinderPrimitive); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (int)lua_tonumber(L, 4); arg5 = (int)lua_tonumber(L, 5);
  arg6 = (int)lua_tonumber(L, 6); (arg1)->set(arg2,arg3,arg4,arg5,arg6); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_CylinderPrimitive_set__SWIG_3(lua_State* L) { int SWIG_arg = 0;
  ofCylinderPrimitive *arg1 = (ofCylinderPrimitive *) 0 ; float arg2 ; float arg3 ; int arg4 ; int arg5 ;
  SWIG_check_num_args("ofCylinderPrimitive::set",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofCylinderPrimitive::set",1,"ofCylinderPrimitive *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofCylinderPrimitive::set",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofCylinderPrimitive::set",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofCylinderPrimitive::set",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofCylinderPrimitive::set",5,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofCylinderPrimitive,0))){
    SWIG_fail_ptr("CylinderPrimitive_set",1,SWIGTYPE_p_ofCylinderPrimitive); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (int)lua_tonumber(L, 4); arg5 = (int)lua_tonumber(L, 5);
  (arg1)->set(arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_CylinderPrimitive_set__SWIG_4(lua_State* L) { int SWIG_arg = 0;
  ofCylinderPrimitive *arg1 = (ofCylinderPrimitive *) 0 ; float arg2 ; float arg3 ; bool arg4 ;
  SWIG_check_num_args("ofCylinderPrimitive::set",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofCylinderPrimitive::set",1,"ofCylinderPrimitive *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofCylinderPrimitive::set",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofCylinderPrimitive::set",3,"float");
  if(!lua_isboolean(L,4)) SWIG_fail_arg("ofCylinderPrimitive::set",4,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofCylinderPrimitive,0))){
    SWIG_fail_ptr("CylinderPrimitive_set",1,SWIGTYPE_p_ofCylinderPrimitive); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (lua_toboolean(L, 4)!=0); (arg1)->set(arg2,arg3,arg4); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_CylinderPrimitive_set__SWIG_5(lua_State* L) { int SWIG_arg = 0;
  ofCylinderPrimitive *arg1 = (ofCylinderPrimitive *) 0 ; float arg2 ; float arg3 ;
  SWIG_check_num_args("ofCylinderPrimitive::set",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofCylinderPrimitive::set",1,"ofCylinderPrimitive *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofCylinderPrimitive::set",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofCylinderPrimitive::set",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofCylinderPrimitive,0))){
    SWIG_fail_ptr("CylinderPrimitive_set",1,SWIGTYPE_p_ofCylinderPrimitive); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); (arg1)->set(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_CylinderPrimitive_set(lua_State* L) { int argc; int argv[9]={ 1,2,3,4,5,6,7,8,9} ; argc = lua_gettop(L);
  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofCylinderPrimitive, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { return _wrap_CylinderPrimitive_set__SWIG_5(L);}  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofCylinderPrimitive, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { { _v = lua_isboolean(L,argv[3]); }  if (_v) { return _wrap_CylinderPrimitive_set__SWIG_4(L);}  }  }  }  } 
  if (argc == 5) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofCylinderPrimitive, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) {
              return _wrap_CylinderPrimitive_set__SWIG_3(L);}  }  }  }  }  }  if (argc == 6) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofCylinderPrimitive, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) { {
                _v = lua_isnumber(L,argv[5]); }  if (_v) { return _wrap_CylinderPrimitive_set__SWIG_2(L);}  }  }  }  }  }  } 
  if (argc == 7) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofCylinderPrimitive, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) { {
                _v = lua_isnumber(L,argv[5]); }  if (_v) { { _v = lua_isboolean(L,argv[6]); }  if (_v) {
                  return _wrap_CylinderPrimitive_set__SWIG_1(L);}  }  }  }  }  }  }  }  if (argc == 8) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofCylinderPrimitive, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) { {
                _v = lua_isnumber(L,argv[5]); }  if (_v) { { _v = lua_isboolean(L,argv[6]); }  if (_v) { {
                    _v = lua_isnumber(L,argv[7]); }  if (_v) { return _wrap_CylinderPrimitive_set__SWIG_0(L);}  }  }  }  }  }  }
       }  }  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'CylinderPrimitive_set'\n"
  "  Possible C/C++ prototypes are:\n" "    ofCylinderPrimitive::set(float,float,int,int,int,bool,ofPrimitiveMode)\n"
  "    ofCylinderPrimitive::set(float,float,int,int,int,bool)\n" "    ofCylinderPrimitive::set(float,float,int,int,int)\n"
  "    ofCylinderPrimitive::set(float,float,int,int)\n" "    ofCylinderPrimitive::set(float,float,bool)\n"
  "    ofCylinderPrimitive::set(float,float)\n"); lua_error(L);return 0; }
static int _wrap_CylinderPrimitive_setRadius(lua_State* L) { int SWIG_arg = 0;
  ofCylinderPrimitive *arg1 = (ofCylinderPrimitive *) 0 ; float arg2 ; SWIG_check_num_args("ofCylinderPrimitive::setRadius",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofCylinderPrimitive::setRadius",1,"ofCylinderPrimitive *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofCylinderPrimitive::setRadius",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofCylinderPrimitive,0))){
    SWIG_fail_ptr("CylinderPrimitive_setRadius",1,SWIGTYPE_p_ofCylinderPrimitive); }  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setRadius(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_CylinderPrimitive_setHeight(lua_State* L) { int SWIG_arg = 0;
  ofCylinderPrimitive *arg1 = (ofCylinderPrimitive *) 0 ; float arg2 ; SWIG_check_num_args("ofCylinderPrimitive::setHeight",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofCylinderPrimitive::setHeight",1,"ofCylinderPrimitive *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofCylinderPrimitive::setHeight",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofCylinderPrimitive,0))){
    SWIG_fail_ptr("CylinderPrimitive_setHeight",1,SWIGTYPE_p_ofCylinderPrimitive); }  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setHeight(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_CylinderPrimitive_setCapped(lua_State* L) { int SWIG_arg = 0;
  ofCylinderPrimitive *arg1 = (ofCylinderPrimitive *) 0 ; bool arg2 ; SWIG_check_num_args("ofCylinderPrimitive::setCapped",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofCylinderPrimitive::setCapped",1,"ofCylinderPrimitive *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofCylinderPrimitive::setCapped",2,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofCylinderPrimitive,0))){
    SWIG_fail_ptr("CylinderPrimitive_setCapped",1,SWIGTYPE_p_ofCylinderPrimitive); }  arg2 = (lua_toboolean(L, 2)!=0);
  (arg1)->setCapped(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_CylinderPrimitive_setResolutionRadius(lua_State* L) { int SWIG_arg = 0;
  ofCylinderPrimitive *arg1 = (ofCylinderPrimitive *) 0 ; int arg2 ;
  SWIG_check_num_args("ofCylinderPrimitive::setResolutionRadius",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofCylinderPrimitive::setResolutionRadius",1,"ofCylinderPrimitive *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofCylinderPrimitive::setResolutionRadius",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofCylinderPrimitive,0))){
    SWIG_fail_ptr("CylinderPrimitive_setResolutionRadius",1,SWIGTYPE_p_ofCylinderPrimitive); }  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setResolutionRadius(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_CylinderPrimitive_setResolutionHeight(lua_State* L) { int SWIG_arg = 0;
  ofCylinderPrimitive *arg1 = (ofCylinderPrimitive *) 0 ; int arg2 ;
  SWIG_check_num_args("ofCylinderPrimitive::setResolutionHeight",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofCylinderPrimitive::setResolutionHeight",1,"ofCylinderPrimitive *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofCylinderPrimitive::setResolutionHeight",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofCylinderPrimitive,0))){
    SWIG_fail_ptr("CylinderPrimitive_setResolutionHeight",1,SWIGTYPE_p_ofCylinderPrimitive); }  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setResolutionHeight(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_CylinderPrimitive_setResolutionCap(lua_State* L) { int SWIG_arg = 0;
  ofCylinderPrimitive *arg1 = (ofCylinderPrimitive *) 0 ; int arg2 ;
  SWIG_check_num_args("ofCylinderPrimitive::setResolutionCap",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofCylinderPrimitive::setResolutionCap",1,"ofCylinderPrimitive *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofCylinderPrimitive::setResolutionCap",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofCylinderPrimitive,0))){
    SWIG_fail_ptr("CylinderPrimitive_setResolutionCap",1,SWIGTYPE_p_ofCylinderPrimitive); }  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setResolutionCap(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_CylinderPrimitive_setResolution__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofCylinderPrimitive *arg1 = (ofCylinderPrimitive *) 0 ; int arg2 ; int arg3 ; int arg4 ;
  SWIG_check_num_args("ofCylinderPrimitive::setResolution",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofCylinderPrimitive::setResolution",1,"ofCylinderPrimitive *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofCylinderPrimitive::setResolution",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofCylinderPrimitive::setResolution",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofCylinderPrimitive::setResolution",4,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofCylinderPrimitive,0))){
    SWIG_fail_ptr("CylinderPrimitive_setResolution",1,SWIGTYPE_p_ofCylinderPrimitive); }  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3); arg4 = (int)lua_tonumber(L, 4); (arg1)->setResolution(arg2,arg3,arg4); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_CylinderPrimitive_setResolution__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofCylinderPrimitive *arg1 = (ofCylinderPrimitive *) 0 ; int arg2 ; int arg3 ;
  SWIG_check_num_args("ofCylinderPrimitive::setResolution",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofCylinderPrimitive::setResolution",1,"ofCylinderPrimitive *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofCylinderPrimitive::setResolution",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofCylinderPrimitive::setResolution",3,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofCylinderPrimitive,0))){
    SWIG_fail_ptr("CylinderPrimitive_setResolution",1,SWIGTYPE_p_ofCylinderPrimitive); }  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3); (arg1)->setResolution(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_CylinderPrimitive_setResolution(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L);
  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofCylinderPrimitive, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { return _wrap_CylinderPrimitive_setResolution__SWIG_1(L);}  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofCylinderPrimitive, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_CylinderPrimitive_setResolution__SWIG_0(L);}  }  }
       }  }  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'CylinderPrimitive_setResolution'\n"
  "  Possible C/C++ prototypes are:\n" "    ofCylinderPrimitive::setResolution(int,int,int)\n"
  "    ofCylinderPrimitive::setResolution(int,int)\n"); lua_error(L);return 0; }
static int _wrap_CylinderPrimitive_setMode(lua_State* L) { int SWIG_arg = 0;
  ofCylinderPrimitive *arg1 = (ofCylinderPrimitive *) 0 ; ofPrimitiveMode arg2 ;
  SWIG_check_num_args("ofCylinderPrimitive::setMode",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofCylinderPrimitive::setMode",1,"ofCylinderPrimitive *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofCylinderPrimitive::setMode",2,"ofPrimitiveMode");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofCylinderPrimitive,0))){
    SWIG_fail_ptr("CylinderPrimitive_setMode",1,SWIGTYPE_p_ofCylinderPrimitive); } 
  arg2 = (ofPrimitiveMode)(int)lua_tonumber(L, 2); (arg1)->setMode(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_CylinderPrimitive_setTopCapColor(lua_State* L) { int SWIG_arg = 0;
  ofCylinderPrimitive *arg1 = (ofCylinderPrimitive *) 0 ; ofColor arg2 ; ofColor *argp2 ;
  SWIG_check_num_args("ofCylinderPrimitive::setTopCapColor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofCylinderPrimitive::setTopCapColor",1,"ofCylinderPrimitive *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofCylinderPrimitive::setTopCapColor",2,"ofColor");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofCylinderPrimitive,0))){
    SWIG_fail_ptr("CylinderPrimitive_setTopCapColor",1,SWIGTYPE_p_ofCylinderPrimitive); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("CylinderPrimitive_setTopCapColor",2,SWIGTYPE_p_ofColor_T_unsigned_char_t); }  arg2 = *argp2;
  (arg1)->setTopCapColor(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_CylinderPrimitive_setCylinderColor(lua_State* L) { int SWIG_arg = 0;
  ofCylinderPrimitive *arg1 = (ofCylinderPrimitive *) 0 ; ofColor arg2 ; ofColor *argp2 ;
  SWIG_check_num_args("ofCylinderPrimitive::setCylinderColor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofCylinderPrimitive::setCylinderColor",1,"ofCylinderPrimitive *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofCylinderPrimitive::setCylinderColor",2,"ofColor");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofCylinderPrimitive,0))){
    SWIG_fail_ptr("CylinderPrimitive_setCylinderColor",1,SWIGTYPE_p_ofCylinderPrimitive); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("CylinderPrimitive_setCylinderColor",2,SWIGTYPE_p_ofColor_T_unsigned_char_t); }  arg2 = *argp2;
  (arg1)->setCylinderColor(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_CylinderPrimitive_setBottomCapColor(lua_State* L) { int SWIG_arg = 0;
  ofCylinderPrimitive *arg1 = (ofCylinderPrimitive *) 0 ; ofColor arg2 ; ofColor *argp2 ;
  SWIG_check_num_args("ofCylinderPrimitive::setBottomCapColor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofCylinderPrimitive::setBottomCapColor",1,"ofCylinderPrimitive *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofCylinderPrimitive::setBottomCapColor",2,"ofColor");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofCylinderPrimitive,0))){
    SWIG_fail_ptr("CylinderPrimitive_setBottomCapColor",1,SWIGTYPE_p_ofCylinderPrimitive); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("CylinderPrimitive_setBottomCapColor",2,SWIGTYPE_p_ofColor_T_unsigned_char_t); }  arg2 = *argp2;
  (arg1)->setBottomCapColor(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_CylinderPrimitive_getTopCapIndices(lua_State* L) { int SWIG_arg = 0;
  ofCylinderPrimitive *arg1 = (ofCylinderPrimitive *) 0 ; SwigValueWrapper< std::vector< TESSindex > > result;
  SWIG_check_num_args("ofCylinderPrimitive::getTopCapIndices",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofCylinderPrimitive::getTopCapIndices",1,"ofCylinderPrimitive const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofCylinderPrimitive,0))){
    SWIG_fail_ptr("CylinderPrimitive_getTopCapIndices",1,SWIGTYPE_p_ofCylinderPrimitive); } 
  result = ((ofCylinderPrimitive const *)arg1)->getTopCapIndices(); {
    std::vector< ofIndexType > * resultptr = new std::vector< ofIndexType >((const std::vector< ofIndexType > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_std__vectorT_TESSindex_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_CylinderPrimitive_getTopCapMesh(lua_State* L) { int SWIG_arg = 0;
  ofCylinderPrimitive *arg1 = (ofCylinderPrimitive *) 0 ; ofMesh result;
  SWIG_check_num_args("ofCylinderPrimitive::getTopCapMesh",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofCylinderPrimitive::getTopCapMesh",1,"ofCylinderPrimitive const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofCylinderPrimitive,0))){
    SWIG_fail_ptr("CylinderPrimitive_getTopCapMesh",1,SWIGTYPE_p_ofCylinderPrimitive); } 
  result = ((ofCylinderPrimitive const *)arg1)->getTopCapMesh(); { ofMesh * resultptr = new ofMesh((const ofMesh &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,1); SWIG_arg++; }
   return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_CylinderPrimitive_getCylinderIndices(lua_State* L) { int SWIG_arg = 0;
  ofCylinderPrimitive *arg1 = (ofCylinderPrimitive *) 0 ; SwigValueWrapper< std::vector< TESSindex > > result;
  SWIG_check_num_args("ofCylinderPrimitive::getCylinderIndices",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofCylinderPrimitive::getCylinderIndices",1,"ofCylinderPrimitive const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofCylinderPrimitive,0))){
    SWIG_fail_ptr("CylinderPrimitive_getCylinderIndices",1,SWIGTYPE_p_ofCylinderPrimitive); } 
  result = ((ofCylinderPrimitive const *)arg1)->getCylinderIndices(); {
    std::vector< ofIndexType > * resultptr = new std::vector< ofIndexType >((const std::vector< ofIndexType > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_std__vectorT_TESSindex_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_CylinderPrimitive_getCylinderMesh(lua_State* L) { int SWIG_arg = 0;
  ofCylinderPrimitive *arg1 = (ofCylinderPrimitive *) 0 ; ofMesh result;
  SWIG_check_num_args("ofCylinderPrimitive::getCylinderMesh",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofCylinderPrimitive::getCylinderMesh",1,"ofCylinderPrimitive const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofCylinderPrimitive,0))){
    SWIG_fail_ptr("CylinderPrimitive_getCylinderMesh",1,SWIGTYPE_p_ofCylinderPrimitive); } 
  result = ((ofCylinderPrimitive const *)arg1)->getCylinderMesh(); { ofMesh * resultptr = new ofMesh((const ofMesh &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,1); SWIG_arg++; }
   return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_CylinderPrimitive_getBottomCapIndices(lua_State* L) { int SWIG_arg = 0;
  ofCylinderPrimitive *arg1 = (ofCylinderPrimitive *) 0 ; SwigValueWrapper< std::vector< TESSindex > > result;
  SWIG_check_num_args("ofCylinderPrimitive::getBottomCapIndices",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofCylinderPrimitive::getBottomCapIndices",1,"ofCylinderPrimitive const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofCylinderPrimitive,0))){
    SWIG_fail_ptr("CylinderPrimitive_getBottomCapIndices",1,SWIGTYPE_p_ofCylinderPrimitive); } 
  result = ((ofCylinderPrimitive const *)arg1)->getBottomCapIndices(); {
    std::vector< ofIndexType > * resultptr = new std::vector< ofIndexType >((const std::vector< ofIndexType > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_std__vectorT_TESSindex_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_CylinderPrimitive_getBottomCapMesh(lua_State* L) { int SWIG_arg = 0;
  ofCylinderPrimitive *arg1 = (ofCylinderPrimitive *) 0 ; ofMesh result;
  SWIG_check_num_args("ofCylinderPrimitive::getBottomCapMesh",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofCylinderPrimitive::getBottomCapMesh",1,"ofCylinderPrimitive const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofCylinderPrimitive,0))){
    SWIG_fail_ptr("CylinderPrimitive_getBottomCapMesh",1,SWIGTYPE_p_ofCylinderPrimitive); } 
  result = ((ofCylinderPrimitive const *)arg1)->getBottomCapMesh(); { ofMesh * resultptr = new ofMesh((const ofMesh &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,1); SWIG_arg++; }
   return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_CylinderPrimitive_getResolutionRadius(lua_State* L) { int SWIG_arg = 0;
  ofCylinderPrimitive *arg1 = (ofCylinderPrimitive *) 0 ; int result;
  SWIG_check_num_args("ofCylinderPrimitive::getResolutionRadius",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofCylinderPrimitive::getResolutionRadius",1,"ofCylinderPrimitive const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofCylinderPrimitive,0))){
    SWIG_fail_ptr("CylinderPrimitive_getResolutionRadius",1,SWIGTYPE_p_ofCylinderPrimitive); } 
  result = (int)((ofCylinderPrimitive const *)arg1)->getResolutionRadius(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_CylinderPrimitive_getResolutionHeight(lua_State* L) { int SWIG_arg = 0;
  ofCylinderPrimitive *arg1 = (ofCylinderPrimitive *) 0 ; int result;
  SWIG_check_num_args("ofCylinderPrimitive::getResolutionHeight",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofCylinderPrimitive::getResolutionHeight",1,"ofCylinderPrimitive const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofCylinderPrimitive,0))){
    SWIG_fail_ptr("CylinderPrimitive_getResolutionHeight",1,SWIGTYPE_p_ofCylinderPrimitive); } 
  result = (int)((ofCylinderPrimitive const *)arg1)->getResolutionHeight(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_CylinderPrimitive_getResolutionCap(lua_State* L) { int SWIG_arg = 0;
  ofCylinderPrimitive *arg1 = (ofCylinderPrimitive *) 0 ; int result;
  SWIG_check_num_args("ofCylinderPrimitive::getResolutionCap",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofCylinderPrimitive::getResolutionCap",1,"ofCylinderPrimitive const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofCylinderPrimitive,0))){
    SWIG_fail_ptr("CylinderPrimitive_getResolutionCap",1,SWIGTYPE_p_ofCylinderPrimitive); } 
  result = (int)((ofCylinderPrimitive const *)arg1)->getResolutionCap(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_CylinderPrimitive_getResolution(lua_State* L) { int SWIG_arg = 0;
  ofCylinderPrimitive *arg1 = (ofCylinderPrimitive *) 0 ; glm::vec3 result;
  SWIG_check_num_args("ofCylinderPrimitive::getResolution",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofCylinderPrimitive::getResolution",1,"ofCylinderPrimitive const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofCylinderPrimitive,0))){
    SWIG_fail_ptr("CylinderPrimitive_getResolution",1,SWIGTYPE_p_ofCylinderPrimitive); } 
  result = ((ofCylinderPrimitive const *)arg1)->getResolution(); {
    glm::vec3 * resultptr = new glm::vec3((const glm::vec3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_glm__vec3,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_CylinderPrimitive_getHeight(lua_State* L) { int SWIG_arg = 0;
  ofCylinderPrimitive *arg1 = (ofCylinderPrimitive *) 0 ; float result;
  SWIG_check_num_args("ofCylinderPrimitive::getHeight",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofCylinderPrimitive::getHeight",1,"ofCylinderPrimitive const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofCylinderPrimitive,0))){
    SWIG_fail_ptr("CylinderPrimitive_getHeight",1,SWIGTYPE_p_ofCylinderPrimitive); } 
  result = (float)((ofCylinderPrimitive const *)arg1)->getHeight(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_CylinderPrimitive_getRadius(lua_State* L) { int SWIG_arg = 0;
  ofCylinderPrimitive *arg1 = (ofCylinderPrimitive *) 0 ; float result;
  SWIG_check_num_args("ofCylinderPrimitive::getRadius",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofCylinderPrimitive::getRadius",1,"ofCylinderPrimitive const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofCylinderPrimitive,0))){
    SWIG_fail_ptr("CylinderPrimitive_getRadius",1,SWIGTYPE_p_ofCylinderPrimitive); } 
  result = (float)((ofCylinderPrimitive const *)arg1)->getRadius(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_CylinderPrimitive_getCapped(lua_State* L) { int SWIG_arg = 0;
  ofCylinderPrimitive *arg1 = (ofCylinderPrimitive *) 0 ; bool result; SWIG_check_num_args("ofCylinderPrimitive::getCapped",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofCylinderPrimitive::getCapped",1,"ofCylinderPrimitive const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofCylinderPrimitive,0))){
    SWIG_fail_ptr("CylinderPrimitive_getCapped",1,SWIGTYPE_p_ofCylinderPrimitive); } 
  result = (bool)((ofCylinderPrimitive const *)arg1)->getCapped(); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static void swig_delete_CylinderPrimitive(void *obj) {
ofCylinderPrimitive *arg1 = (ofCylinderPrimitive *) obj;
delete arg1;
}
static int _proxy__wrap_new_CylinderPrimitive(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_CylinderPrimitive);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_CylinderPrimitive_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_CylinderPrimitive_methods[]= {
    { "set", _wrap_CylinderPrimitive_set},
    { "setRadius", _wrap_CylinderPrimitive_setRadius},
    { "setHeight", _wrap_CylinderPrimitive_setHeight},
    { "setCapped", _wrap_CylinderPrimitive_setCapped},
    { "setResolutionRadius", _wrap_CylinderPrimitive_setResolutionRadius},
    { "setResolutionHeight", _wrap_CylinderPrimitive_setResolutionHeight},
    { "setResolutionCap", _wrap_CylinderPrimitive_setResolutionCap},
    { "setResolution", _wrap_CylinderPrimitive_setResolution},
    { "setMode", _wrap_CylinderPrimitive_setMode},
    { "setTopCapColor", _wrap_CylinderPrimitive_setTopCapColor},
    { "setCylinderColor", _wrap_CylinderPrimitive_setCylinderColor},
    { "setBottomCapColor", _wrap_CylinderPrimitive_setBottomCapColor},
    { "getTopCapIndices", _wrap_CylinderPrimitive_getTopCapIndices},
    { "getTopCapMesh", _wrap_CylinderPrimitive_getTopCapMesh},
    { "getCylinderIndices", _wrap_CylinderPrimitive_getCylinderIndices},
    { "getCylinderMesh", _wrap_CylinderPrimitive_getCylinderMesh},
    { "getBottomCapIndices", _wrap_CylinderPrimitive_getBottomCapIndices},
    { "getBottomCapMesh", _wrap_CylinderPrimitive_getBottomCapMesh},
    { "getResolutionRadius", _wrap_CylinderPrimitive_getResolutionRadius},
    { "getResolutionHeight", _wrap_CylinderPrimitive_getResolutionHeight},
    { "getResolutionCap", _wrap_CylinderPrimitive_getResolutionCap},
    { "getResolution", _wrap_CylinderPrimitive_getResolution},
    { "getHeight", _wrap_CylinderPrimitive_getHeight},
    { "getRadius", _wrap_CylinderPrimitive_getRadius},
    { "getCapped", _wrap_CylinderPrimitive_getCapped},
    {0,0}
};
static swig_lua_method swig_CylinderPrimitive_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_CylinderPrimitive_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_CylinderPrimitive_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_CylinderPrimitive_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_CylinderPrimitive_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_CylinderPrimitive_Sf_SwigStatic = {
    "CylinderPrimitive",
    swig_CylinderPrimitive_Sf_SwigStatic_methods,
    swig_CylinderPrimitive_Sf_SwigStatic_attributes,
    swig_CylinderPrimitive_Sf_SwigStatic_constants,
    swig_CylinderPrimitive_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_CylinderPrimitive_bases[] = {0,0};
static const char *swig_CylinderPrimitive_base_names[] = {"of3dPrimitive *",0};
static swig_lua_class _wrap_class_CylinderPrimitive = { "CylinderPrimitive", "CylinderPrimitive", &SWIGTYPE_p_ofCylinderPrimitive,_proxy__wrap_new_CylinderPrimitive, swig_delete_CylinderPrimitive, swig_CylinderPrimitive_methods, swig_CylinderPrimitive_attributes, &swig_CylinderPrimitive_Sf_SwigStatic, swig_CylinderPrimitive_meta, swig_CylinderPrimitive_bases, swig_CylinderPrimitive_base_names };

static int _wrap_new_ConePrimitive__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofConePrimitive *result = 0 ;
  SWIG_check_num_args("ofConePrimitive::ofConePrimitive",0,0) result = (ofConePrimitive *)new ofConePrimitive();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofConePrimitive,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_ConePrimitive__SWIG_1(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; int arg3 ; int arg4 ;
  int arg5 ; ofPrimitiveMode arg6 ; ofConePrimitive *result = 0 ; SWIG_check_num_args("ofConePrimitive::ofConePrimitive",6,6)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofConePrimitive::ofConePrimitive",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofConePrimitive::ofConePrimitive",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofConePrimitive::ofConePrimitive",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofConePrimitive::ofConePrimitive",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofConePrimitive::ofConePrimitive",5,"int");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofConePrimitive::ofConePrimitive",6,"ofPrimitiveMode");
  arg1 = (float)lua_tonumber(L, 1); arg2 = (float)lua_tonumber(L, 2); arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4); arg5 = (int)lua_tonumber(L, 5); arg6 = (ofPrimitiveMode)(int)lua_tonumber(L, 6);
  result = (ofConePrimitive *)new ofConePrimitive(arg1,arg2,arg3,arg4,arg5,arg6);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofConePrimitive,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_ConePrimitive__SWIG_2(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; int arg3 ; int arg4 ;
  int arg5 ; ofConePrimitive *result = 0 ; SWIG_check_num_args("ofConePrimitive::ofConePrimitive",5,5)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofConePrimitive::ofConePrimitive",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofConePrimitive::ofConePrimitive",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofConePrimitive::ofConePrimitive",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofConePrimitive::ofConePrimitive",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofConePrimitive::ofConePrimitive",5,"int"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (int)lua_tonumber(L, 3); arg4 = (int)lua_tonumber(L, 4);
  arg5 = (int)lua_tonumber(L, 5); result = (ofConePrimitive *)new ofConePrimitive(arg1,arg2,arg3,arg4,arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofConePrimitive,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_ConePrimitive__SWIG_3(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; int arg3 ; int arg4 ;
  ofConePrimitive *result = 0 ; SWIG_check_num_args("ofConePrimitive::ofConePrimitive",4,4)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofConePrimitive::ofConePrimitive",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofConePrimitive::ofConePrimitive",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofConePrimitive::ofConePrimitive",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofConePrimitive::ofConePrimitive",4,"int"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (int)lua_tonumber(L, 3); arg4 = (int)lua_tonumber(L, 4);
  result = (ofConePrimitive *)new ofConePrimitive(arg1,arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofConePrimitive,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_ConePrimitive(lua_State* L) { int argc; int argv[7]={ 1,2,3,4,5,6,7} ; argc = lua_gettop(L);
  if (argc == 0) { return _wrap_new_ConePrimitive__SWIG_0(L);}  if (argc == 4) { int _v; { _v = lua_isnumber(L,argv[0]); } 
    if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { {
            _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_new_ConePrimitive__SWIG_3(L);}  }  }  }  }  if (argc == 5) {
    int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { {
          _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { {
              _v = lua_isnumber(L,argv[4]); }  if (_v) { return _wrap_new_ConePrimitive__SWIG_2(L);}  }  }  }  }  } 
  if (argc == 6) { int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { {
          _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { {
              _v = lua_isnumber(L,argv[4]); }  if (_v) { { _v = lua_isnumber(L,argv[5]); }  if (_v) {
                return _wrap_new_ConePrimitive__SWIG_1(L);}  }  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_ConePrimitive'\n" "  Possible C/C++ prototypes are:\n"
  "    ofConePrimitive::ofConePrimitive()\n" "    ofConePrimitive::ofConePrimitive(float,float,int,int,int,ofPrimitiveMode)\n"
  "    ofConePrimitive::ofConePrimitive(float,float,int,int,int)\n"
  "    ofConePrimitive::ofConePrimitive(float,float,int,int)\n"); lua_error(L);return 0; }
static int _wrap_ConePrimitive_set__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofConePrimitive *arg1 = (ofConePrimitive *) 0 ;
  float arg2 ; float arg3 ; int arg4 ; int arg5 ; int arg6 ; ofPrimitiveMode arg7 ;
  SWIG_check_num_args("ofConePrimitive::set",7,7)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofConePrimitive::set",1,"ofConePrimitive *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofConePrimitive::set",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofConePrimitive::set",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofConePrimitive::set",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofConePrimitive::set",5,"int");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofConePrimitive::set",6,"int");
  if(!lua_isnumber(L,7)) SWIG_fail_arg("ofConePrimitive::set",7,"ofPrimitiveMode");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofConePrimitive,0))){
    SWIG_fail_ptr("ConePrimitive_set",1,SWIGTYPE_p_ofConePrimitive); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (int)lua_tonumber(L, 4); arg5 = (int)lua_tonumber(L, 5);
  arg6 = (int)lua_tonumber(L, 6); arg7 = (ofPrimitiveMode)(int)lua_tonumber(L, 7); (arg1)->set(arg2,arg3,arg4,arg5,arg6,arg7);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ConePrimitive_set__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofConePrimitive *arg1 = (ofConePrimitive *) 0 ;
  float arg2 ; float arg3 ; int arg4 ; int arg5 ; int arg6 ; SWIG_check_num_args("ofConePrimitive::set",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofConePrimitive::set",1,"ofConePrimitive *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofConePrimitive::set",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofConePrimitive::set",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofConePrimitive::set",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofConePrimitive::set",5,"int");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofConePrimitive::set",6,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofConePrimitive,0))){
    SWIG_fail_ptr("ConePrimitive_set",1,SWIGTYPE_p_ofConePrimitive); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (int)lua_tonumber(L, 4); arg5 = (int)lua_tonumber(L, 5);
  arg6 = (int)lua_tonumber(L, 6); (arg1)->set(arg2,arg3,arg4,arg5,arg6); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_ConePrimitive_set__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofConePrimitive *arg1 = (ofConePrimitive *) 0 ;
  float arg2 ; float arg3 ; int arg4 ; int arg5 ; SWIG_check_num_args("ofConePrimitive::set",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofConePrimitive::set",1,"ofConePrimitive *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofConePrimitive::set",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofConePrimitive::set",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofConePrimitive::set",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofConePrimitive::set",5,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofConePrimitive,0))){
    SWIG_fail_ptr("ConePrimitive_set",1,SWIGTYPE_p_ofConePrimitive); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (int)lua_tonumber(L, 4); arg5 = (int)lua_tonumber(L, 5);
  (arg1)->set(arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ConePrimitive_set__SWIG_3(lua_State* L) { int SWIG_arg = 0; ofConePrimitive *arg1 = (ofConePrimitive *) 0 ;
  float arg2 ; float arg3 ; SWIG_check_num_args("ofConePrimitive::set",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofConePrimitive::set",1,"ofConePrimitive *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofConePrimitive::set",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofConePrimitive::set",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofConePrimitive,0))){
    SWIG_fail_ptr("ConePrimitive_set",1,SWIGTYPE_p_ofConePrimitive); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); (arg1)->set(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_ConePrimitive_set(lua_State* L) { int argc; int argv[8]={ 1,2,3,4,5,6,7,8} ; argc = lua_gettop(L);
  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofConePrimitive, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_ConePrimitive_set__SWIG_3(L);}  }  }  }  if (argc == 5) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofConePrimitive, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) {
              return _wrap_ConePrimitive_set__SWIG_2(L);}  }  }  }  }  }  if (argc == 6) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofConePrimitive, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) { {
                _v = lua_isnumber(L,argv[5]); }  if (_v) { return _wrap_ConePrimitive_set__SWIG_1(L);}  }  }  }  }  }  } 
  if (argc == 7) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofConePrimitive, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) { {
                _v = lua_isnumber(L,argv[5]); }  if (_v) { { _v = lua_isnumber(L,argv[6]); }  if (_v) {
                  return _wrap_ConePrimitive_set__SWIG_0(L);}  }  }  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'ConePrimitive_set'\n" "  Possible C/C++ prototypes are:\n"
  "    ofConePrimitive::set(float,float,int,int,int,ofPrimitiveMode)\n" "    ofConePrimitive::set(float,float,int,int,int)\n"
  "    ofConePrimitive::set(float,float,int,int)\n" "    ofConePrimitive::set(float,float)\n"); lua_error(L);return 0; }
static int _wrap_ConePrimitive_setResolutionRadius(lua_State* L) { int SWIG_arg = 0;
  ofConePrimitive *arg1 = (ofConePrimitive *) 0 ; int arg2 ; SWIG_check_num_args("ofConePrimitive::setResolutionRadius",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofConePrimitive::setResolutionRadius",1,"ofConePrimitive *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofConePrimitive::setResolutionRadius",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofConePrimitive,0))){
    SWIG_fail_ptr("ConePrimitive_setResolutionRadius",1,SWIGTYPE_p_ofConePrimitive); }  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setResolutionRadius(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ConePrimitive_setResolutionHeight(lua_State* L) { int SWIG_arg = 0;
  ofConePrimitive *arg1 = (ofConePrimitive *) 0 ; int arg2 ; SWIG_check_num_args("ofConePrimitive::setResolutionHeight",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofConePrimitive::setResolutionHeight",1,"ofConePrimitive *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofConePrimitive::setResolutionHeight",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofConePrimitive,0))){
    SWIG_fail_ptr("ConePrimitive_setResolutionHeight",1,SWIGTYPE_p_ofConePrimitive); }  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setResolutionHeight(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ConePrimitive_setResolutionCap(lua_State* L) { int SWIG_arg = 0;
  ofConePrimitive *arg1 = (ofConePrimitive *) 0 ; int arg2 ; SWIG_check_num_args("ofConePrimitive::setResolutionCap",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofConePrimitive::setResolutionCap",1,"ofConePrimitive *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofConePrimitive::setResolutionCap",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofConePrimitive,0))){
    SWIG_fail_ptr("ConePrimitive_setResolutionCap",1,SWIGTYPE_p_ofConePrimitive); }  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setResolutionCap(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ConePrimitive_setResolution(lua_State* L) { int SWIG_arg = 0; ofConePrimitive *arg1 = (ofConePrimitive *) 0 ;
  int arg2 ; int arg3 ; int arg4 ; SWIG_check_num_args("ofConePrimitive::setResolution",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofConePrimitive::setResolution",1,"ofConePrimitive *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofConePrimitive::setResolution",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofConePrimitive::setResolution",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofConePrimitive::setResolution",4,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofConePrimitive,0))){
    SWIG_fail_ptr("ConePrimitive_setResolution",1,SWIGTYPE_p_ofConePrimitive); }  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3); arg4 = (int)lua_tonumber(L, 4); (arg1)->setResolution(arg2,arg3,arg4); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ConePrimitive_setMode(lua_State* L) { int SWIG_arg = 0; ofConePrimitive *arg1 = (ofConePrimitive *) 0 ;
  ofPrimitiveMode arg2 ; SWIG_check_num_args("ofConePrimitive::setMode",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofConePrimitive::setMode",1,"ofConePrimitive *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofConePrimitive::setMode",2,"ofPrimitiveMode");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofConePrimitive,0))){
    SWIG_fail_ptr("ConePrimitive_setMode",1,SWIGTYPE_p_ofConePrimitive); }  arg2 = (ofPrimitiveMode)(int)lua_tonumber(L, 2);
  (arg1)->setMode(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ConePrimitive_setRadius(lua_State* L) { int SWIG_arg = 0; ofConePrimitive *arg1 = (ofConePrimitive *) 0 ;
  float arg2 ; SWIG_check_num_args("ofConePrimitive::setRadius",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofConePrimitive::setRadius",1,"ofConePrimitive *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofConePrimitive::setRadius",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofConePrimitive,0))){
    SWIG_fail_ptr("ConePrimitive_setRadius",1,SWIGTYPE_p_ofConePrimitive); }  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setRadius(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ConePrimitive_setHeight(lua_State* L) { int SWIG_arg = 0; ofConePrimitive *arg1 = (ofConePrimitive *) 0 ;
  float arg2 ; SWIG_check_num_args("ofConePrimitive::setHeight",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofConePrimitive::setHeight",1,"ofConePrimitive *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofConePrimitive::setHeight",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofConePrimitive,0))){
    SWIG_fail_ptr("ConePrimitive_setHeight",1,SWIGTYPE_p_ofConePrimitive); }  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setHeight(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ConePrimitive_setTopColor(lua_State* L) { int SWIG_arg = 0; ofConePrimitive *arg1 = (ofConePrimitive *) 0 ;
  ofColor arg2 ; ofColor *argp2 ; SWIG_check_num_args("ofConePrimitive::setTopColor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofConePrimitive::setTopColor",1,"ofConePrimitive *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofConePrimitive::setTopColor",2,"ofColor");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofConePrimitive,0))){
    SWIG_fail_ptr("ConePrimitive_setTopColor",1,SWIGTYPE_p_ofConePrimitive); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("ConePrimitive_setTopColor",2,SWIGTYPE_p_ofColor_T_unsigned_char_t); }  arg2 = *argp2;
  (arg1)->setTopColor(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ConePrimitive_setCapColor(lua_State* L) { int SWIG_arg = 0; ofConePrimitive *arg1 = (ofConePrimitive *) 0 ;
  ofColor arg2 ; ofColor *argp2 ; SWIG_check_num_args("ofConePrimitive::setCapColor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofConePrimitive::setCapColor",1,"ofConePrimitive *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofConePrimitive::setCapColor",2,"ofColor");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofConePrimitive,0))){
    SWIG_fail_ptr("ConePrimitive_setCapColor",1,SWIGTYPE_p_ofConePrimitive); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("ConePrimitive_setCapColor",2,SWIGTYPE_p_ofColor_T_unsigned_char_t); }  arg2 = *argp2;
  (arg1)->setCapColor(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ConePrimitive_getConeIndices(lua_State* L) { int SWIG_arg = 0; ofConePrimitive *arg1 = (ofConePrimitive *) 0 ;
  SwigValueWrapper< std::vector< TESSindex > > result; SWIG_check_num_args("ofConePrimitive::getConeIndices",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofConePrimitive::getConeIndices",1,"ofConePrimitive const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofConePrimitive,0))){
    SWIG_fail_ptr("ConePrimitive_getConeIndices",1,SWIGTYPE_p_ofConePrimitive); } 
  result = ((ofConePrimitive const *)arg1)->getConeIndices(); {
    std::vector< ofIndexType > * resultptr = new std::vector< ofIndexType >((const std::vector< ofIndexType > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_std__vectorT_TESSindex_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ConePrimitive_getConeMesh(lua_State* L) { int SWIG_arg = 0; ofConePrimitive *arg1 = (ofConePrimitive *) 0 ;
  ofMesh result; SWIG_check_num_args("ofConePrimitive::getConeMesh",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofConePrimitive::getConeMesh",1,"ofConePrimitive const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofConePrimitive,0))){
    SWIG_fail_ptr("ConePrimitive_getConeMesh",1,SWIGTYPE_p_ofConePrimitive); } 
  result = ((ofConePrimitive const *)arg1)->getConeMesh(); { ofMesh * resultptr = new ofMesh((const ofMesh &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,1); SWIG_arg++; }
   return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ConePrimitive_getCapIndices(lua_State* L) { int SWIG_arg = 0; ofConePrimitive *arg1 = (ofConePrimitive *) 0 ;
  SwigValueWrapper< std::vector< TESSindex > > result; SWIG_check_num_args("ofConePrimitive::getCapIndices",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofConePrimitive::getCapIndices",1,"ofConePrimitive const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofConePrimitive,0))){
    SWIG_fail_ptr("ConePrimitive_getCapIndices",1,SWIGTYPE_p_ofConePrimitive); } 
  result = ((ofConePrimitive const *)arg1)->getCapIndices(); {
    std::vector< ofIndexType > * resultptr = new std::vector< ofIndexType >((const std::vector< ofIndexType > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_std__vectorT_TESSindex_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ConePrimitive_getCapMesh(lua_State* L) { int SWIG_arg = 0; ofConePrimitive *arg1 = (ofConePrimitive *) 0 ;
  ofMesh result; SWIG_check_num_args("ofConePrimitive::getCapMesh",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofConePrimitive::getCapMesh",1,"ofConePrimitive const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofConePrimitive,0))){
    SWIG_fail_ptr("ConePrimitive_getCapMesh",1,SWIGTYPE_p_ofConePrimitive); } 
  result = ((ofConePrimitive const *)arg1)->getCapMesh(); { ofMesh * resultptr = new ofMesh((const ofMesh &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,1); SWIG_arg++; }
   return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ConePrimitive_getResolutionRadius(lua_State* L) { int SWIG_arg = 0;
  ofConePrimitive *arg1 = (ofConePrimitive *) 0 ; int result; SWIG_check_num_args("ofConePrimitive::getResolutionRadius",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofConePrimitive::getResolutionRadius",1,"ofConePrimitive const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofConePrimitive,0))){
    SWIG_fail_ptr("ConePrimitive_getResolutionRadius",1,SWIGTYPE_p_ofConePrimitive); } 
  result = (int)((ofConePrimitive const *)arg1)->getResolutionRadius(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ConePrimitive_getResolutionHeight(lua_State* L) { int SWIG_arg = 0;
  ofConePrimitive *arg1 = (ofConePrimitive *) 0 ; int result; SWIG_check_num_args("ofConePrimitive::getResolutionHeight",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofConePrimitive::getResolutionHeight",1,"ofConePrimitive const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofConePrimitive,0))){
    SWIG_fail_ptr("ConePrimitive_getResolutionHeight",1,SWIGTYPE_p_ofConePrimitive); } 
  result = (int)((ofConePrimitive const *)arg1)->getResolutionHeight(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ConePrimitive_getResolutionCap(lua_State* L) { int SWIG_arg = 0;
  ofConePrimitive *arg1 = (ofConePrimitive *) 0 ; int result; SWIG_check_num_args("ofConePrimitive::getResolutionCap",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofConePrimitive::getResolutionCap",1,"ofConePrimitive const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofConePrimitive,0))){
    SWIG_fail_ptr("ConePrimitive_getResolutionCap",1,SWIGTYPE_p_ofConePrimitive); } 
  result = (int)((ofConePrimitive const *)arg1)->getResolutionCap(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ConePrimitive_getResolution(lua_State* L) { int SWIG_arg = 0; ofConePrimitive *arg1 = (ofConePrimitive *) 0 ;
  glm::vec3 result; SWIG_check_num_args("ofConePrimitive::getResolution",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofConePrimitive::getResolution",1,"ofConePrimitive const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofConePrimitive,0))){
    SWIG_fail_ptr("ConePrimitive_getResolution",1,SWIGTYPE_p_ofConePrimitive); } 
  result = ((ofConePrimitive const *)arg1)->getResolution(); {
    glm::vec3 * resultptr = new glm::vec3((const glm::vec3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_glm__vec3,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ConePrimitive_getRadius(lua_State* L) { int SWIG_arg = 0; ofConePrimitive *arg1 = (ofConePrimitive *) 0 ;
  float result; SWIG_check_num_args("ofConePrimitive::getRadius",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofConePrimitive::getRadius",1,"ofConePrimitive const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofConePrimitive,0))){
    SWIG_fail_ptr("ConePrimitive_getRadius",1,SWIGTYPE_p_ofConePrimitive); } 
  result = (float)((ofConePrimitive const *)arg1)->getRadius(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ConePrimitive_getHeight(lua_State* L) { int SWIG_arg = 0; ofConePrimitive *arg1 = (ofConePrimitive *) 0 ;
  float result; SWIG_check_num_args("ofConePrimitive::getHeight",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofConePrimitive::getHeight",1,"ofConePrimitive const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofConePrimitive,0))){
    SWIG_fail_ptr("ConePrimitive_getHeight",1,SWIGTYPE_p_ofConePrimitive); } 
  result = (float)((ofConePrimitive const *)arg1)->getHeight(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static void swig_delete_ConePrimitive(void *obj) {
ofConePrimitive *arg1 = (ofConePrimitive *) obj;
delete arg1;
}
static int _proxy__wrap_new_ConePrimitive(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_ConePrimitive);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_ConePrimitive_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_ConePrimitive_methods[]= {
    { "set", _wrap_ConePrimitive_set},
    { "setResolutionRadius", _wrap_ConePrimitive_setResolutionRadius},
    { "setResolutionHeight", _wrap_ConePrimitive_setResolutionHeight},
    { "setResolutionCap", _wrap_ConePrimitive_setResolutionCap},
    { "setResolution", _wrap_ConePrimitive_setResolution},
    { "setMode", _wrap_ConePrimitive_setMode},
    { "setRadius", _wrap_ConePrimitive_setRadius},
    { "setHeight", _wrap_ConePrimitive_setHeight},
    { "setTopColor", _wrap_ConePrimitive_setTopColor},
    { "setCapColor", _wrap_ConePrimitive_setCapColor},
    { "getConeIndices", _wrap_ConePrimitive_getConeIndices},
    { "getConeMesh", _wrap_ConePrimitive_getConeMesh},
    { "getCapIndices", _wrap_ConePrimitive_getCapIndices},
    { "getCapMesh", _wrap_ConePrimitive_getCapMesh},
    { "getResolutionRadius", _wrap_ConePrimitive_getResolutionRadius},
    { "getResolutionHeight", _wrap_ConePrimitive_getResolutionHeight},
    { "getResolutionCap", _wrap_ConePrimitive_getResolutionCap},
    { "getResolution", _wrap_ConePrimitive_getResolution},
    { "getRadius", _wrap_ConePrimitive_getRadius},
    { "getHeight", _wrap_ConePrimitive_getHeight},
    {0,0}
};
static swig_lua_method swig_ConePrimitive_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_ConePrimitive_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_ConePrimitive_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_ConePrimitive_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_ConePrimitive_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_ConePrimitive_Sf_SwigStatic = {
    "ConePrimitive",
    swig_ConePrimitive_Sf_SwigStatic_methods,
    swig_ConePrimitive_Sf_SwigStatic_attributes,
    swig_ConePrimitive_Sf_SwigStatic_constants,
    swig_ConePrimitive_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_ConePrimitive_bases[] = {0,0};
static const char *swig_ConePrimitive_base_names[] = {"of3dPrimitive *",0};
static swig_lua_class _wrap_class_ConePrimitive = { "ConePrimitive", "ConePrimitive", &SWIGTYPE_p_ofConePrimitive,_proxy__wrap_new_ConePrimitive, swig_delete_ConePrimitive, swig_ConePrimitive_methods, swig_ConePrimitive_attributes, &swig_ConePrimitive_Sf_SwigStatic, swig_ConePrimitive_meta, swig_ConePrimitive_bases, swig_ConePrimitive_base_names };

static int _wrap_new_BoxPrimitive__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofBoxPrimitive *result = 0 ;
  SWIG_check_num_args("ofBoxPrimitive::ofBoxPrimitive",0,0) result = (ofBoxPrimitive *)new ofBoxPrimitive();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofBoxPrimitive,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_BoxPrimitive__SWIG_1(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ; int arg4 ;
  int arg5 ; int arg6 ; ofBoxPrimitive *result = 0 ; SWIG_check_num_args("ofBoxPrimitive::ofBoxPrimitive",6,6)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofBoxPrimitive::ofBoxPrimitive",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofBoxPrimitive::ofBoxPrimitive",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofBoxPrimitive::ofBoxPrimitive",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofBoxPrimitive::ofBoxPrimitive",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofBoxPrimitive::ofBoxPrimitive",5,"int");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofBoxPrimitive::ofBoxPrimitive",6,"int"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); arg4 = (int)lua_tonumber(L, 4);
  arg5 = (int)lua_tonumber(L, 5); arg6 = (int)lua_tonumber(L, 6);
  result = (ofBoxPrimitive *)new ofBoxPrimitive(arg1,arg2,arg3,arg4,arg5,arg6);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofBoxPrimitive,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_BoxPrimitive__SWIG_2(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ; int arg4 ;
  int arg5 ; ofBoxPrimitive *result = 0 ; SWIG_check_num_args("ofBoxPrimitive::ofBoxPrimitive",5,5)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofBoxPrimitive::ofBoxPrimitive",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofBoxPrimitive::ofBoxPrimitive",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofBoxPrimitive::ofBoxPrimitive",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofBoxPrimitive::ofBoxPrimitive",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofBoxPrimitive::ofBoxPrimitive",5,"int"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); arg4 = (int)lua_tonumber(L, 4);
  arg5 = (int)lua_tonumber(L, 5); result = (ofBoxPrimitive *)new ofBoxPrimitive(arg1,arg2,arg3,arg4,arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofBoxPrimitive,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_BoxPrimitive__SWIG_3(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ; int arg4 ;
  ofBoxPrimitive *result = 0 ; SWIG_check_num_args("ofBoxPrimitive::ofBoxPrimitive",4,4)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofBoxPrimitive::ofBoxPrimitive",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofBoxPrimitive::ofBoxPrimitive",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofBoxPrimitive::ofBoxPrimitive",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofBoxPrimitive::ofBoxPrimitive",4,"int"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); arg4 = (int)lua_tonumber(L, 4);
  result = (ofBoxPrimitive *)new ofBoxPrimitive(arg1,arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofBoxPrimitive,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_BoxPrimitive__SWIG_4(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ;
  ofBoxPrimitive *result = 0 ; SWIG_check_num_args("ofBoxPrimitive::ofBoxPrimitive",3,3)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofBoxPrimitive::ofBoxPrimitive",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofBoxPrimitive::ofBoxPrimitive",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofBoxPrimitive::ofBoxPrimitive",3,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3);
  result = (ofBoxPrimitive *)new ofBoxPrimitive(arg1,arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofBoxPrimitive,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_BoxPrimitive(lua_State* L) { int argc; int argv[7]={ 1,2,3,4,5,6,7} ; argc = lua_gettop(L);
  if (argc == 0) { return _wrap_new_BoxPrimitive__SWIG_0(L);}  if (argc == 3) { int _v; { _v = lua_isnumber(L,argv[0]); } 
    if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_new_BoxPrimitive__SWIG_4(L);}  }  }  }  if (argc == 4) { int _v; { _v = lua_isnumber(L,argv[0]); } 
    if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { {
            _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_new_BoxPrimitive__SWIG_3(L);}  }  }  }  }  if (argc == 5) {
    int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { {
          _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { {
              _v = lua_isnumber(L,argv[4]); }  if (_v) { return _wrap_new_BoxPrimitive__SWIG_2(L);}  }  }  }  }  } 
  if (argc == 6) { int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { {
          _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { {
              _v = lua_isnumber(L,argv[4]); }  if (_v) { { _v = lua_isnumber(L,argv[5]); }  if (_v) {
                return _wrap_new_BoxPrimitive__SWIG_1(L);}  }  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_BoxPrimitive'\n" "  Possible C/C++ prototypes are:\n"
  "    ofBoxPrimitive::ofBoxPrimitive()\n" "    ofBoxPrimitive::ofBoxPrimitive(float,float,float,int,int,int)\n"
  "    ofBoxPrimitive::ofBoxPrimitive(float,float,float,int,int)\n"
  "    ofBoxPrimitive::ofBoxPrimitive(float,float,float,int)\n" "    ofBoxPrimitive::ofBoxPrimitive(float,float,float)\n");
  lua_error(L);return 0; }
static int _wrap_BoxPrimitive_set__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofBoxPrimitive *arg1 = (ofBoxPrimitive *) 0 ;
  float arg2 ; float arg3 ; float arg4 ; int arg5 ; int arg6 ; int arg7 ; SWIG_check_num_args("ofBoxPrimitive::set",7,7)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBoxPrimitive::set",1,"ofBoxPrimitive *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofBoxPrimitive::set",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofBoxPrimitive::set",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofBoxPrimitive::set",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofBoxPrimitive::set",5,"int");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofBoxPrimitive::set",6,"int");
  if(!lua_isnumber(L,7)) SWIG_fail_arg("ofBoxPrimitive::set",7,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBoxPrimitive,0))){
    SWIG_fail_ptr("BoxPrimitive_set",1,SWIGTYPE_p_ofBoxPrimitive); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); arg5 = (int)lua_tonumber(L, 5);
  arg6 = (int)lua_tonumber(L, 6); arg7 = (int)lua_tonumber(L, 7); (arg1)->set(arg2,arg3,arg4,arg5,arg6,arg7); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_BoxPrimitive_set__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofBoxPrimitive *arg1 = (ofBoxPrimitive *) 0 ;
  float arg2 ; float arg3 ; float arg4 ; SWIG_check_num_args("ofBoxPrimitive::set",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBoxPrimitive::set",1,"ofBoxPrimitive *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofBoxPrimitive::set",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofBoxPrimitive::set",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofBoxPrimitive::set",4,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBoxPrimitive,0))){
    SWIG_fail_ptr("BoxPrimitive_set",1,SWIGTYPE_p_ofBoxPrimitive); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); (arg1)->set(arg2,arg3,arg4); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_BoxPrimitive_set__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofBoxPrimitive *arg1 = (ofBoxPrimitive *) 0 ;
  float arg2 ; SWIG_check_num_args("ofBoxPrimitive::set",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBoxPrimitive::set",1,"ofBoxPrimitive *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofBoxPrimitive::set",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBoxPrimitive,0))){
    SWIG_fail_ptr("BoxPrimitive_set",1,SWIGTYPE_p_ofBoxPrimitive); }  arg2 = (float)lua_tonumber(L, 2); (arg1)->set(arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_BoxPrimitive_set(lua_State* L) { int argc; int argv[8]={ 1,2,3,4,5,6,7,8} ; argc = lua_gettop(L);
  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofBoxPrimitive, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { return _wrap_BoxPrimitive_set__SWIG_2(L);}  }
     }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofBoxPrimitive, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          { _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_BoxPrimitive_set__SWIG_1(L);}  }  }  }  }  if (argc == 7) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofBoxPrimitive, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) { {
                _v = lua_isnumber(L,argv[5]); }  if (_v) { { _v = lua_isnumber(L,argv[6]); }  if (_v) {
                  return _wrap_BoxPrimitive_set__SWIG_0(L);}  }  }  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'BoxPrimitive_set'\n" "  Possible C/C++ prototypes are:\n"
  "    ofBoxPrimitive::set(float,float,float,int,int,int)\n" "    ofBoxPrimitive::set(float,float,float)\n"
  "    ofBoxPrimitive::set(float)\n"); lua_error(L);return 0; }
static int _wrap_BoxPrimitive_setWidth(lua_State* L) { int SWIG_arg = 0; ofBoxPrimitive *arg1 = (ofBoxPrimitive *) 0 ;
  float arg2 ; SWIG_check_num_args("ofBoxPrimitive::setWidth",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBoxPrimitive::setWidth",1,"ofBoxPrimitive *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofBoxPrimitive::setWidth",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBoxPrimitive,0))){
    SWIG_fail_ptr("BoxPrimitive_setWidth",1,SWIGTYPE_p_ofBoxPrimitive); }  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setWidth(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_BoxPrimitive_setHeight(lua_State* L) { int SWIG_arg = 0; ofBoxPrimitive *arg1 = (ofBoxPrimitive *) 0 ;
  float arg2 ; SWIG_check_num_args("ofBoxPrimitive::setHeight",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBoxPrimitive::setHeight",1,"ofBoxPrimitive *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofBoxPrimitive::setHeight",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBoxPrimitive,0))){
    SWIG_fail_ptr("BoxPrimitive_setHeight",1,SWIGTYPE_p_ofBoxPrimitive); }  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setHeight(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_BoxPrimitive_setDepth(lua_State* L) { int SWIG_arg = 0; ofBoxPrimitive *arg1 = (ofBoxPrimitive *) 0 ;
  float arg2 ; SWIG_check_num_args("ofBoxPrimitive::setDepth",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBoxPrimitive::setDepth",1,"ofBoxPrimitive *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofBoxPrimitive::setDepth",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBoxPrimitive,0))){
    SWIG_fail_ptr("BoxPrimitive_setDepth",1,SWIGTYPE_p_ofBoxPrimitive); }  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setDepth(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_BoxPrimitive_resizeToTexture(lua_State* L) { int SWIG_arg = 0; ofBoxPrimitive *arg1 = (ofBoxPrimitive *) 0 ;
  ofTexture *arg2 = 0 ; SWIG_check_num_args("ofBoxPrimitive::resizeToTexture",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBoxPrimitive::resizeToTexture",1,"ofBoxPrimitive *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofBoxPrimitive::resizeToTexture",2,"ofTexture &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBoxPrimitive,0))){
    SWIG_fail_ptr("BoxPrimitive_resizeToTexture",1,SWIGTYPE_p_ofBoxPrimitive); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("BoxPrimitive_resizeToTexture",2,SWIGTYPE_p_ofTexture); }  (arg1)->resizeToTexture(*arg2); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_BoxPrimitive_getSideIndices(lua_State* L) { int SWIG_arg = 0; ofBoxPrimitive *arg1 = (ofBoxPrimitive *) 0 ;
  int arg2 ; SwigValueWrapper< std::vector< TESSindex > > result; SWIG_check_num_args("ofBoxPrimitive::getSideIndices",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBoxPrimitive::getSideIndices",1,"ofBoxPrimitive const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofBoxPrimitive::getSideIndices",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBoxPrimitive,0))){
    SWIG_fail_ptr("BoxPrimitive_getSideIndices",1,SWIGTYPE_p_ofBoxPrimitive); }  arg2 = (int)lua_tonumber(L, 2);
  result = ((ofBoxPrimitive const *)arg1)->getSideIndices(arg2); {
    std::vector< ofIndexType > * resultptr = new std::vector< ofIndexType >((const std::vector< ofIndexType > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_std__vectorT_TESSindex_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_BoxPrimitive_getSideMesh(lua_State* L) { int SWIG_arg = 0; ofBoxPrimitive *arg1 = (ofBoxPrimitive *) 0 ;
  int arg2 ; ofMesh result; SWIG_check_num_args("ofBoxPrimitive::getSideMesh",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBoxPrimitive::getSideMesh",1,"ofBoxPrimitive const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofBoxPrimitive::getSideMesh",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBoxPrimitive,0))){
    SWIG_fail_ptr("BoxPrimitive_getSideMesh",1,SWIGTYPE_p_ofBoxPrimitive); }  arg2 = (int)lua_tonumber(L, 2);
  result = ((ofBoxPrimitive const *)arg1)->getSideMesh(arg2); { ofMesh * resultptr = new ofMesh((const ofMesh &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,1); SWIG_arg++; }
   return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_BoxPrimitive_setResolution__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofBoxPrimitive *arg1 = (ofBoxPrimitive *) 0 ; int arg2 ; SWIG_check_num_args("ofBoxPrimitive::setResolution",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBoxPrimitive::setResolution",1,"ofBoxPrimitive *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofBoxPrimitive::setResolution",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBoxPrimitive,0))){
    SWIG_fail_ptr("BoxPrimitive_setResolution",1,SWIGTYPE_p_ofBoxPrimitive); }  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setResolution(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_BoxPrimitive_setResolutionWidth(lua_State* L) { int SWIG_arg = 0; ofBoxPrimitive *arg1 = (ofBoxPrimitive *) 0 ;
  int arg2 ; SWIG_check_num_args("ofBoxPrimitive::setResolutionWidth",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBoxPrimitive::setResolutionWidth",1,"ofBoxPrimitive *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofBoxPrimitive::setResolutionWidth",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBoxPrimitive,0))){
    SWIG_fail_ptr("BoxPrimitive_setResolutionWidth",1,SWIGTYPE_p_ofBoxPrimitive); }  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setResolutionWidth(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_BoxPrimitive_setResolutionHeight(lua_State* L) { int SWIG_arg = 0;
  ofBoxPrimitive *arg1 = (ofBoxPrimitive *) 0 ; int arg2 ; SWIG_check_num_args("ofBoxPrimitive::setResolutionHeight",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBoxPrimitive::setResolutionHeight",1,"ofBoxPrimitive *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofBoxPrimitive::setResolutionHeight",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBoxPrimitive,0))){
    SWIG_fail_ptr("BoxPrimitive_setResolutionHeight",1,SWIGTYPE_p_ofBoxPrimitive); }  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setResolutionHeight(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_BoxPrimitive_setResolutionDepth(lua_State* L) { int SWIG_arg = 0; ofBoxPrimitive *arg1 = (ofBoxPrimitive *) 0 ;
  int arg2 ; SWIG_check_num_args("ofBoxPrimitive::setResolutionDepth",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBoxPrimitive::setResolutionDepth",1,"ofBoxPrimitive *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofBoxPrimitive::setResolutionDepth",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBoxPrimitive,0))){
    SWIG_fail_ptr("BoxPrimitive_setResolutionDepth",1,SWIGTYPE_p_ofBoxPrimitive); }  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setResolutionDepth(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_BoxPrimitive_setResolution__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofBoxPrimitive *arg1 = (ofBoxPrimitive *) 0 ; int arg2 ; int arg3 ; int arg4 ;
  SWIG_check_num_args("ofBoxPrimitive::setResolution",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBoxPrimitive::setResolution",1,"ofBoxPrimitive *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofBoxPrimitive::setResolution",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofBoxPrimitive::setResolution",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofBoxPrimitive::setResolution",4,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBoxPrimitive,0))){
    SWIG_fail_ptr("BoxPrimitive_setResolution",1,SWIGTYPE_p_ofBoxPrimitive); }  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3); arg4 = (int)lua_tonumber(L, 4); (arg1)->setResolution(arg2,arg3,arg4); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_BoxPrimitive_setResolution(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L);
  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofBoxPrimitive, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_BoxPrimitive_setResolution__SWIG_0(L);}  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofBoxPrimitive, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          { _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_BoxPrimitive_setResolution__SWIG_1(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'BoxPrimitive_setResolution'\n"
  "  Possible C/C++ prototypes are:\n" "    ofBoxPrimitive::setResolution(int)\n"
  "    ofBoxPrimitive::setResolution(int,int,int)\n"); lua_error(L);return 0; }
static int _wrap_BoxPrimitive_setMode(lua_State* L) { int SWIG_arg = 0; ofBoxPrimitive *arg1 = (ofBoxPrimitive *) 0 ;
  ofPrimitiveMode arg2 ; SWIG_check_num_args("ofBoxPrimitive::setMode",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBoxPrimitive::setMode",1,"ofBoxPrimitive *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofBoxPrimitive::setMode",2,"ofPrimitiveMode");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBoxPrimitive,0))){
    SWIG_fail_ptr("BoxPrimitive_setMode",1,SWIGTYPE_p_ofBoxPrimitive); }  arg2 = (ofPrimitiveMode)(int)lua_tonumber(L, 2);
  (arg1)->setMode(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_BoxPrimitive_setSideColor(lua_State* L) { int SWIG_arg = 0; ofBoxPrimitive *arg1 = (ofBoxPrimitive *) 0 ;
  int arg2 ; ofColor arg3 ; ofColor *argp3 ; SWIG_check_num_args("ofBoxPrimitive::setSideColor",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBoxPrimitive::setSideColor",1,"ofBoxPrimitive *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofBoxPrimitive::setSideColor",2,"int");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofBoxPrimitive::setSideColor",3,"ofColor");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBoxPrimitive,0))){
    SWIG_fail_ptr("BoxPrimitive_setSideColor",1,SWIGTYPE_p_ofBoxPrimitive); }  arg2 = (int)lua_tonumber(L, 2);
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("BoxPrimitive_setSideColor",3,SWIGTYPE_p_ofColor_T_unsigned_char_t); }  arg3 = *argp3;
  (arg1)->setSideColor(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_BoxPrimitive_getResolutionWidth(lua_State* L) { int SWIG_arg = 0; ofBoxPrimitive *arg1 = (ofBoxPrimitive *) 0 ;
  int result; SWIG_check_num_args("ofBoxPrimitive::getResolutionWidth",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBoxPrimitive::getResolutionWidth",1,"ofBoxPrimitive const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBoxPrimitive,0))){
    SWIG_fail_ptr("BoxPrimitive_getResolutionWidth",1,SWIGTYPE_p_ofBoxPrimitive); } 
  result = (int)((ofBoxPrimitive const *)arg1)->getResolutionWidth(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_BoxPrimitive_getResolutionHeight(lua_State* L) { int SWIG_arg = 0;
  ofBoxPrimitive *arg1 = (ofBoxPrimitive *) 0 ; int result; SWIG_check_num_args("ofBoxPrimitive::getResolutionHeight",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBoxPrimitive::getResolutionHeight",1,"ofBoxPrimitive const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBoxPrimitive,0))){
    SWIG_fail_ptr("BoxPrimitive_getResolutionHeight",1,SWIGTYPE_p_ofBoxPrimitive); } 
  result = (int)((ofBoxPrimitive const *)arg1)->getResolutionHeight(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_BoxPrimitive_getResolutionDepth(lua_State* L) { int SWIG_arg = 0; ofBoxPrimitive *arg1 = (ofBoxPrimitive *) 0 ;
  int result; SWIG_check_num_args("ofBoxPrimitive::getResolutionDepth",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBoxPrimitive::getResolutionDepth",1,"ofBoxPrimitive const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBoxPrimitive,0))){
    SWIG_fail_ptr("BoxPrimitive_getResolutionDepth",1,SWIGTYPE_p_ofBoxPrimitive); } 
  result = (int)((ofBoxPrimitive const *)arg1)->getResolutionDepth(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_BoxPrimitive_getResolution(lua_State* L) { int SWIG_arg = 0; ofBoxPrimitive *arg1 = (ofBoxPrimitive *) 0 ;
  glm::vec3 result; SWIG_check_num_args("ofBoxPrimitive::getResolution",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBoxPrimitive::getResolution",1,"ofBoxPrimitive const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBoxPrimitive,0))){
    SWIG_fail_ptr("BoxPrimitive_getResolution",1,SWIGTYPE_p_ofBoxPrimitive); } 
  result = ((ofBoxPrimitive const *)arg1)->getResolution(); { glm::vec3 * resultptr = new glm::vec3((const glm::vec3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_glm__vec3,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_BoxPrimitive_getWidth(lua_State* L) { int SWIG_arg = 0; ofBoxPrimitive *arg1 = (ofBoxPrimitive *) 0 ;
  float result; SWIG_check_num_args("ofBoxPrimitive::getWidth",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBoxPrimitive::getWidth",1,"ofBoxPrimitive const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBoxPrimitive,0))){
    SWIG_fail_ptr("BoxPrimitive_getWidth",1,SWIGTYPE_p_ofBoxPrimitive); } 
  result = (float)((ofBoxPrimitive const *)arg1)->getWidth(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_BoxPrimitive_getHeight(lua_State* L) { int SWIG_arg = 0; ofBoxPrimitive *arg1 = (ofBoxPrimitive *) 0 ;
  float result; SWIG_check_num_args("ofBoxPrimitive::getHeight",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBoxPrimitive::getHeight",1,"ofBoxPrimitive const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBoxPrimitive,0))){
    SWIG_fail_ptr("BoxPrimitive_getHeight",1,SWIGTYPE_p_ofBoxPrimitive); } 
  result = (float)((ofBoxPrimitive const *)arg1)->getHeight(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_BoxPrimitive_getDepth(lua_State* L) { int SWIG_arg = 0; ofBoxPrimitive *arg1 = (ofBoxPrimitive *) 0 ;
  float result; SWIG_check_num_args("ofBoxPrimitive::getDepth",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBoxPrimitive::getDepth",1,"ofBoxPrimitive const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBoxPrimitive,0))){
    SWIG_fail_ptr("BoxPrimitive_getDepth",1,SWIGTYPE_p_ofBoxPrimitive); } 
  result = (float)((ofBoxPrimitive const *)arg1)->getDepth(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_BoxPrimitive_getSize(lua_State* L) { int SWIG_arg = 0; ofBoxPrimitive *arg1 = (ofBoxPrimitive *) 0 ;
  glm::vec3 result; SWIG_check_num_args("ofBoxPrimitive::getSize",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBoxPrimitive::getSize",1,"ofBoxPrimitive const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBoxPrimitive,0))){
    SWIG_fail_ptr("BoxPrimitive_getSize",1,SWIGTYPE_p_ofBoxPrimitive); }  result = ((ofBoxPrimitive const *)arg1)->getSize(); {
    glm::vec3 * resultptr = new glm::vec3((const glm::vec3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_glm__vec3,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static void swig_delete_BoxPrimitive(void *obj) {
ofBoxPrimitive *arg1 = (ofBoxPrimitive *) obj;
delete arg1;
}
static int _proxy__wrap_new_BoxPrimitive(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_BoxPrimitive);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_BoxPrimitive_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_BoxPrimitive_methods[]= {
    { "set", _wrap_BoxPrimitive_set},
    { "setWidth", _wrap_BoxPrimitive_setWidth},
    { "setHeight", _wrap_BoxPrimitive_setHeight},
    { "setDepth", _wrap_BoxPrimitive_setDepth},
    { "resizeToTexture", _wrap_BoxPrimitive_resizeToTexture},
    { "getSideIndices", _wrap_BoxPrimitive_getSideIndices},
    { "getSideMesh", _wrap_BoxPrimitive_getSideMesh},
    { "setResolutionWidth", _wrap_BoxPrimitive_setResolutionWidth},
    { "setResolutionHeight", _wrap_BoxPrimitive_setResolutionHeight},
    { "setResolutionDepth", _wrap_BoxPrimitive_setResolutionDepth},
    { "setResolution", _wrap_BoxPrimitive_setResolution},
    { "setMode", _wrap_BoxPrimitive_setMode},
    { "setSideColor", _wrap_BoxPrimitive_setSideColor},
    { "getResolutionWidth", _wrap_BoxPrimitive_getResolutionWidth},
    { "getResolutionHeight", _wrap_BoxPrimitive_getResolutionHeight},
    { "getResolutionDepth", _wrap_BoxPrimitive_getResolutionDepth},
    { "getResolution", _wrap_BoxPrimitive_getResolution},
    { "getWidth", _wrap_BoxPrimitive_getWidth},
    { "getHeight", _wrap_BoxPrimitive_getHeight},
    { "getDepth", _wrap_BoxPrimitive_getDepth},
    { "getSize", _wrap_BoxPrimitive_getSize},
    {0,0}
};
static swig_lua_method swig_BoxPrimitive_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_BoxPrimitive_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_BoxPrimitive_Sf_SwigStatic_constants[]= {
    {SWIG_LUA_CONSTTAB_INT("SIDE_FRONT", ofBoxPrimitive::SIDE_FRONT)},
    {SWIG_LUA_CONSTTAB_INT("SIDE_RIGHT", ofBoxPrimitive::SIDE_RIGHT)},
    {SWIG_LUA_CONSTTAB_INT("SIDE_LEFT", ofBoxPrimitive::SIDE_LEFT)},
    {SWIG_LUA_CONSTTAB_INT("SIDE_BACK", ofBoxPrimitive::SIDE_BACK)},
    {SWIG_LUA_CONSTTAB_INT("SIDE_TOP", ofBoxPrimitive::SIDE_TOP)},
    {SWIG_LUA_CONSTTAB_INT("SIDE_BOTTOM", ofBoxPrimitive::SIDE_BOTTOM)},
    {SWIG_LUA_CONSTTAB_INT("SIDES_TOTAL", ofBoxPrimitive::SIDES_TOTAL)},
    {0,0,0,0,0,0}
};
static swig_lua_method swig_BoxPrimitive_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_BoxPrimitive_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_BoxPrimitive_Sf_SwigStatic = {
    "BoxPrimitive",
    swig_BoxPrimitive_Sf_SwigStatic_methods,
    swig_BoxPrimitive_Sf_SwigStatic_attributes,
    swig_BoxPrimitive_Sf_SwigStatic_constants,
    swig_BoxPrimitive_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_BoxPrimitive_bases[] = {0,0};
static const char *swig_BoxPrimitive_base_names[] = {"of3dPrimitive *",0};
static swig_lua_class _wrap_class_BoxPrimitive = { "BoxPrimitive", "BoxPrimitive", &SWIGTYPE_p_ofBoxPrimitive,_proxy__wrap_new_BoxPrimitive, swig_delete_BoxPrimitive, swig_BoxPrimitive_methods, swig_BoxPrimitive_attributes, &swig_BoxPrimitive_Sf_SwigStatic, swig_BoxPrimitive_meta, swig_BoxPrimitive_bases, swig_BoxPrimitive_base_names };

static int _wrap_exit__SWIG_0(lua_State* L) { int SWIG_arg = 0; int arg1 ; SWIG_check_num_args("ofExit",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofExit",1,"int"); arg1 = (int)lua_tonumber(L, 1); ofExit(arg1); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_exit__SWIG_1(lua_State* L) { int SWIG_arg = 0; SWIG_check_num_args("ofExit",0,0) ofExit(); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_exit(lua_State* L) { int argc; int argv[2]={ 1,2} ; argc = lua_gettop(L); if (argc == 0) {
    return _wrap_exit__SWIG_1(L);}  if (argc == 1) { int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) {
      return _wrap_exit__SWIG_0(L);}  }  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'exit'\n"
  "  Possible C/C++ prototypes are:\n" "    ofExit(int)\n" "    ofExit()\n"); lua_error(L);return 0; }
static int _wrap_getFrameRate(lua_State* L) { int SWIG_arg = 0; float result; SWIG_check_num_args("ofGetFrameRate",0,0)
  result = (float)ofGetFrameRate(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_getTargetFrameRate(lua_State* L) { int SWIG_arg = 0; float result;
  SWIG_check_num_args("ofGetTargetFrameRate",0,0) result = (float)ofGetTargetFrameRate();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_setFrameRate(lua_State* L) { int SWIG_arg = 0; int arg1 ; SWIG_check_num_args("ofSetFrameRate",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofSetFrameRate",1,"int"); arg1 = (int)lua_tonumber(L, 1); ofSetFrameRate(arg1);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_getLastFrameTime(lua_State* L) { int SWIG_arg = 0; double result; SWIG_check_num_args("ofGetLastFrameTime",0,0)
  result = (double)ofGetLastFrameTime(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_setTimeModeSystem(lua_State* L) { int SWIG_arg = 0; SWIG_check_num_args("ofSetTimeModeSystem",0,0)
  ofSetTimeModeSystem(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_getFixedStepForFps(lua_State* L) { int SWIG_arg = 0; double arg1 ; uint64_t result;
  SWIG_check_num_args("ofGetFixedStepForFps",1,1) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofGetFixedStepForFps",1,"double");
  arg1 = (double)lua_tonumber(L, 1); result = (uint64_t)ofGetFixedStepForFps(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_setTimeModeFixedRate__SWIG_0(lua_State* L) { int SWIG_arg = 0; uint64_t arg1 ;
  SWIG_check_num_args("ofSetTimeModeFixedRate",1,1) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofSetTimeModeFixedRate",1,"uint64_t");
  arg1 = (uint64_t)lua_tonumber(L, 1); ofSetTimeModeFixedRate(arg1); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_setTimeModeFixedRate__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  SWIG_check_num_args("ofSetTimeModeFixedRate",0,0) ofSetTimeModeFixedRate(); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_setTimeModeFixedRate(lua_State* L) { int argc; int argv[2]={ 1,2} ; argc = lua_gettop(L); if (argc == 0) {
    return _wrap_setTimeModeFixedRate__SWIG_1(L);}  if (argc == 1) { int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) {
      return _wrap_setTimeModeFixedRate__SWIG_0(L);}  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'setTimeModeFixedRate'\n"
  "  Possible C/C++ prototypes are:\n" "    ofSetTimeModeFixedRate(uint64_t)\n" "    ofSetTimeModeFixedRate()\n");
  lua_error(L);return 0; }
static int _wrap_setTimeModeFiltered__SWIG_0(lua_State* L) { int SWIG_arg = 0; float arg1 ;
  SWIG_check_num_args("ofSetTimeModeFiltered",1,1) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofSetTimeModeFiltered",1,"float");
  arg1 = (float)lua_tonumber(L, 1); ofSetTimeModeFiltered(arg1); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_setTimeModeFiltered__SWIG_1(lua_State* L) { int SWIG_arg = 0; SWIG_check_num_args("ofSetTimeModeFiltered",0,0)
  ofSetTimeModeFiltered(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_setTimeModeFiltered(lua_State* L) { int argc; int argv[2]={ 1,2} ; argc = lua_gettop(L); if (argc == 0) {
    return _wrap_setTimeModeFiltered__SWIG_1(L);}  if (argc == 1) { int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) {
      return _wrap_setTimeModeFiltered__SWIG_0(L);}  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'setTimeModeFiltered'\n"
  "  Possible C/C++ prototypes are:\n" "    ofSetTimeModeFiltered(float)\n" "    ofSetTimeModeFiltered()\n");
  lua_error(L);return 0; }
static int _wrap_setOrientation__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofOrientation arg1 ; bool arg2 ;
  SWIG_check_num_args("ofSetOrientation",2,2) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofSetOrientation",1,"ofOrientation");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofSetOrientation",2,"bool"); arg1 = (ofOrientation)(int)lua_tonumber(L, 1);
  arg2 = (lua_toboolean(L, 2)!=0); ofSetOrientation(arg1,arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_setOrientation__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofOrientation arg1 ;
  SWIG_check_num_args("ofSetOrientation",1,1) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofSetOrientation",1,"ofOrientation");
  arg1 = (ofOrientation)(int)lua_tonumber(L, 1); ofSetOrientation(arg1); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_setOrientation(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 1) { int _v;
    { _v = lua_isnumber(L,argv[0]); }  if (_v) { return _wrap_setOrientation__SWIG_1(L);}  }  if (argc == 2) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isboolean(L,argv[1]); }  if (_v) {
        return _wrap_setOrientation__SWIG_0(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'setOrientation'\n" "  Possible C/C++ prototypes are:\n"
  "    ofSetOrientation(ofOrientation,bool)\n" "    ofSetOrientation(ofOrientation)\n"); lua_error(L);return 0; }
static int _wrap_getOrientation(lua_State* L) { int SWIG_arg = 0; ofOrientation result;
  SWIG_check_num_args("ofGetOrientation",0,0) result = (ofOrientation)ofGetOrientation();
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_hideCursor(lua_State* L) { int SWIG_arg = 0; SWIG_check_num_args("ofHideCursor",0,0) ofHideCursor();
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_showCursor(lua_State* L) { int SWIG_arg = 0; SWIG_check_num_args("ofShowCursor",0,0) ofShowCursor();
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_getWindowPositionX(lua_State* L) { int SWIG_arg = 0; int result;
  SWIG_check_num_args("ofGetWindowPositionX",0,0) result = (int)ofGetWindowPositionX();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_getWindowPositionY(lua_State* L) { int SWIG_arg = 0; int result;
  SWIG_check_num_args("ofGetWindowPositionY",0,0) result = (int)ofGetWindowPositionY();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_getScreenWidth(lua_State* L) { int SWIG_arg = 0; int result; SWIG_check_num_args("ofGetScreenWidth",0,0)
  result = (int)ofGetScreenWidth(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_getScreenHeight(lua_State* L) { int SWIG_arg = 0; int result; SWIG_check_num_args("ofGetScreenHeight",0,0)
  result = (int)ofGetScreenHeight(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_getWindowMode(lua_State* L) { int SWIG_arg = 0; int result; SWIG_check_num_args("ofGetWindowMode",0,0)
  result = (int)ofGetWindowMode(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_getWidth(lua_State* L) { int SWIG_arg = 0; int result; SWIG_check_num_args("ofGetWidth",0,0)
  result = (int)ofGetWidth(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_getHeight(lua_State* L) { int SWIG_arg = 0; int result; SWIG_check_num_args("ofGetHeight",0,0)
  result = (int)ofGetHeight(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_getWindowWidth(lua_State* L) { int SWIG_arg = 0; int result; SWIG_check_num_args("ofGetWindowWidth",0,0)
  result = (int)ofGetWindowWidth(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_getWindowHeight(lua_State* L) { int SWIG_arg = 0; int result; SWIG_check_num_args("ofGetWindowHeight",0,0)
  result = (int)ofGetWindowHeight(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_getClipboardString(lua_State* L) { int SWIG_arg = 0; std::string result;
  SWIG_check_num_args("ofGetClipboardString",0,0) result = ofGetClipboardString();
  lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_setClipboardString(lua_State* L) { int SWIG_arg = 0; std::string *arg1 = 0 ; std::string temp1 ;
  SWIG_check_num_args("ofSetClipboardString",1,1)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofSetClipboardString",1,"std::string const &");
  temp1.assign(lua_tostring(L,1),lua_rawlen(L,1)); arg1=&temp1; ofSetClipboardString((std::string const &)*arg1);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_randomWidth(lua_State* L) { int SWIG_arg = 0; float result; SWIG_check_num_args("ofRandomWidth",0,0)
  result = (float)ofRandomWidth(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_randomHeight(lua_State* L) { int SWIG_arg = 0; float result; SWIG_check_num_args("ofRandomHeight",0,0)
  result = (float)ofRandomHeight(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_doesHWOrientation(lua_State* L) { int SWIG_arg = 0; bool result; SWIG_check_num_args("ofDoesHWOrientation",0,0)
  result = (bool)ofDoesHWOrientation(); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_getWindowSize(lua_State* L) { int SWIG_arg = 0; glm::vec2 result; SWIG_check_num_args("ofGetWindowSize",0,0)
  result = ofGetWindowSize(); { glm::vec2 * resultptr = new glm::vec2((const glm::vec2 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_glm__vec2,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_getWindowRect(lua_State* L) { int SWIG_arg = 0; ofRectangle result; SWIG_check_num_args("ofGetWindowRect",0,0)
  result = ofGetWindowRect(); { ofRectangle * resultptr = new ofRectangle((const ofRectangle &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofRectangle,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_setWindowPosition(lua_State* L) { int SWIG_arg = 0; int arg1 ; int arg2 ;
  SWIG_check_num_args("ofSetWindowPosition",2,2) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofSetWindowPosition",1,"int");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofSetWindowPosition",2,"int"); arg1 = (int)lua_tonumber(L, 1);
  arg2 = (int)lua_tonumber(L, 2); ofSetWindowPosition(arg1,arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_setWindowShape(lua_State* L) { int SWIG_arg = 0; int arg1 ; int arg2 ;
  SWIG_check_num_args("ofSetWindowShape",2,2) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofSetWindowShape",1,"int");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofSetWindowShape",2,"int"); arg1 = (int)lua_tonumber(L, 1);
  arg2 = (int)lua_tonumber(L, 2); ofSetWindowShape(arg1,arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_setWindowTitle(lua_State* L) { int SWIG_arg = 0; std::string arg1 ; SWIG_check_num_args("ofSetWindowTitle",1,1)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofSetWindowTitle",1,"std::string"); (&arg1)->assign(lua_tostring(L,1),lua_rawlen(L,1));
  ofSetWindowTitle(arg1); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_enableSetupScreen(lua_State* L) { int SWIG_arg = 0; SWIG_check_num_args("ofEnableSetupScreen",0,0)
  ofEnableSetupScreen(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_disableSetupScreen(lua_State* L) { int SWIG_arg = 0; SWIG_check_num_args("ofDisableSetupScreen",0,0)
  ofDisableSetupScreen(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_setFullscreen(lua_State* L) { int SWIG_arg = 0; bool arg1 ; SWIG_check_num_args("ofSetFullscreen",1,1)
  if(!lua_isboolean(L,1)) SWIG_fail_arg("ofSetFullscreen",1,"bool"); arg1 = (lua_toboolean(L, 1)!=0); ofSetFullscreen(arg1);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_toggleFullscreen(lua_State* L) { int SWIG_arg = 0; SWIG_check_num_args("ofToggleFullscreen",0,0)
  ofToggleFullscreen(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_setVerticalSync(lua_State* L) { int SWIG_arg = 0; bool arg1 ; SWIG_check_num_args("ofSetVerticalSync",1,1)
  if(!lua_isboolean(L,1)) SWIG_fail_arg("ofSetVerticalSync",1,"bool"); arg1 = (lua_toboolean(L, 1)!=0); ofSetVerticalSync(arg1);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_events(lua_State* L) { int SWIG_arg = 0; ofCoreEvents *result = 0 ; SWIG_check_num_args("ofEvents",0,0)
  result = (ofCoreEvents *) &ofEvents(); SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofCoreEvents,0); SWIG_arg++;  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_setEscapeQuitsApp(lua_State* L) { int SWIG_arg = 0; bool arg1 ; SWIG_check_num_args("ofSetEscapeQuitsApp",1,1)
  if(!lua_isboolean(L,1)) SWIG_fail_arg("ofSetEscapeQuitsApp",1,"bool"); arg1 = (lua_toboolean(L, 1)!=0);
  ofSetEscapeQuitsApp(arg1); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_supportedPinTypes_inputSupported_set(lua_State* L) { int SWIG_arg = 0;
  supportedPinTypes *arg1 = (supportedPinTypes *) 0 ; bool arg2 ; SWIG_check_num_args("supportedPinTypes::inputSupported",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("supportedPinTypes::inputSupported",1,"supportedPinTypes *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("supportedPinTypes::inputSupported",2,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_supportedPinTypes,0))){
    SWIG_fail_ptr("supportedPinTypes_inputSupported_set",1,SWIGTYPE_p_supportedPinTypes); }  arg2 = (lua_toboolean(L, 2)!=0);
  if (arg1) (arg1)->inputSupported = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_supportedPinTypes_inputSupported_get(lua_State* L) { int SWIG_arg = 0;
  supportedPinTypes *arg1 = (supportedPinTypes *) 0 ; bool result; SWIG_check_num_args("supportedPinTypes::inputSupported",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("supportedPinTypes::inputSupported",1,"supportedPinTypes *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_supportedPinTypes,0))){
    SWIG_fail_ptr("supportedPinTypes_inputSupported_get",1,SWIGTYPE_p_supportedPinTypes); } 
  result = (bool) ((arg1)->inputSupported); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_supportedPinTypes_outputSupported_set(lua_State* L) { int SWIG_arg = 0;
  supportedPinTypes *arg1 = (supportedPinTypes *) 0 ; bool arg2 ; SWIG_check_num_args("supportedPinTypes::outputSupported",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("supportedPinTypes::outputSupported",1,"supportedPinTypes *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("supportedPinTypes::outputSupported",2,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_supportedPinTypes,0))){
    SWIG_fail_ptr("supportedPinTypes_outputSupported_set",1,SWIGTYPE_p_supportedPinTypes); }  arg2 = (lua_toboolean(L, 2)!=0);
  if (arg1) (arg1)->outputSupported = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_supportedPinTypes_outputSupported_get(lua_State* L) { int SWIG_arg = 0;
  supportedPinTypes *arg1 = (supportedPinTypes *) 0 ; bool result; SWIG_check_num_args("supportedPinTypes::outputSupported",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("supportedPinTypes::outputSupported",1,"supportedPinTypes *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_supportedPinTypes,0))){
    SWIG_fail_ptr("supportedPinTypes_outputSupported_get",1,SWIGTYPE_p_supportedPinTypes); } 
  result = (bool) ((arg1)->outputSupported); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_supportedPinTypes_analogSupported_set(lua_State* L) { int SWIG_arg = 0;
  supportedPinTypes *arg1 = (supportedPinTypes *) 0 ; bool arg2 ; SWIG_check_num_args("supportedPinTypes::analogSupported",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("supportedPinTypes::analogSupported",1,"supportedPinTypes *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("supportedPinTypes::analogSupported",2,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_supportedPinTypes,0))){
    SWIG_fail_ptr("supportedPinTypes_analogSupported_set",1,SWIGTYPE_p_supportedPinTypes); }  arg2 = (lua_toboolean(L, 2)!=0);
  if (arg1) (arg1)->analogSupported = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_supportedPinTypes_analogSupported_get(lua_State* L) { int SWIG_arg = 0;
  supportedPinTypes *arg1 = (supportedPinTypes *) 0 ; bool result; SWIG_check_num_args("supportedPinTypes::analogSupported",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("supportedPinTypes::analogSupported",1,"supportedPinTypes *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_supportedPinTypes,0))){
    SWIG_fail_ptr("supportedPinTypes_analogSupported_get",1,SWIGTYPE_p_supportedPinTypes); } 
  result = (bool) ((arg1)->analogSupported); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_supportedPinTypes_pwmSupported_set(lua_State* L) { int SWIG_arg = 0;
  supportedPinTypes *arg1 = (supportedPinTypes *) 0 ; bool arg2 ; SWIG_check_num_args("supportedPinTypes::pwmSupported",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("supportedPinTypes::pwmSupported",1,"supportedPinTypes *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("supportedPinTypes::pwmSupported",2,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_supportedPinTypes,0))){
    SWIG_fail_ptr("supportedPinTypes_pwmSupported_set",1,SWIGTYPE_p_supportedPinTypes); }  arg2 = (lua_toboolean(L, 2)!=0);
  if (arg1) (arg1)->pwmSupported = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_supportedPinTypes_pwmSupported_get(lua_State* L) { int SWIG_arg = 0;
  supportedPinTypes *arg1 = (supportedPinTypes *) 0 ; bool result; SWIG_check_num_args("supportedPinTypes::pwmSupported",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("supportedPinTypes::pwmSupported",1,"supportedPinTypes *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_supportedPinTypes,0))){
    SWIG_fail_ptr("supportedPinTypes_pwmSupported_get",1,SWIGTYPE_p_supportedPinTypes); } 
  result = (bool) ((arg1)->pwmSupported); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_supportedPinTypes_servoSupported_set(lua_State* L) { int SWIG_arg = 0;
  supportedPinTypes *arg1 = (supportedPinTypes *) 0 ; bool arg2 ; SWIG_check_num_args("supportedPinTypes::servoSupported",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("supportedPinTypes::servoSupported",1,"supportedPinTypes *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("supportedPinTypes::servoSupported",2,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_supportedPinTypes,0))){
    SWIG_fail_ptr("supportedPinTypes_servoSupported_set",1,SWIGTYPE_p_supportedPinTypes); }  arg2 = (lua_toboolean(L, 2)!=0);
  if (arg1) (arg1)->servoSupported = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_supportedPinTypes_servoSupported_get(lua_State* L) { int SWIG_arg = 0;
  supportedPinTypes *arg1 = (supportedPinTypes *) 0 ; bool result; SWIG_check_num_args("supportedPinTypes::servoSupported",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("supportedPinTypes::servoSupported",1,"supportedPinTypes *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_supportedPinTypes,0))){
    SWIG_fail_ptr("supportedPinTypes_servoSupported_get",1,SWIGTYPE_p_supportedPinTypes); } 
  result = (bool) ((arg1)->servoSupported); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_supportedPinTypes_i2cSupported_set(lua_State* L) { int SWIG_arg = 0;
  supportedPinTypes *arg1 = (supportedPinTypes *) 0 ; bool arg2 ; SWIG_check_num_args("supportedPinTypes::i2cSupported",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("supportedPinTypes::i2cSupported",1,"supportedPinTypes *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("supportedPinTypes::i2cSupported",2,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_supportedPinTypes,0))){
    SWIG_fail_ptr("supportedPinTypes_i2cSupported_set",1,SWIGTYPE_p_supportedPinTypes); }  arg2 = (lua_toboolean(L, 2)!=0);
  if (arg1) (arg1)->i2cSupported = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_supportedPinTypes_i2cSupported_get(lua_State* L) { int SWIG_arg = 0;
  supportedPinTypes *arg1 = (supportedPinTypes *) 0 ; bool result; SWIG_check_num_args("supportedPinTypes::i2cSupported",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("supportedPinTypes::i2cSupported",1,"supportedPinTypes *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_supportedPinTypes,0))){
    SWIG_fail_ptr("supportedPinTypes_i2cSupported_get",1,SWIGTYPE_p_supportedPinTypes); } 
  result = (bool) ((arg1)->i2cSupported); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_supportedPinTypes_serialSupported_set(lua_State* L) { int SWIG_arg = 0;
  supportedPinTypes *arg1 = (supportedPinTypes *) 0 ; bool arg2 ; SWIG_check_num_args("supportedPinTypes::serialSupported",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("supportedPinTypes::serialSupported",1,"supportedPinTypes *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("supportedPinTypes::serialSupported",2,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_supportedPinTypes,0))){
    SWIG_fail_ptr("supportedPinTypes_serialSupported_set",1,SWIGTYPE_p_supportedPinTypes); }  arg2 = (lua_toboolean(L, 2)!=0);
  if (arg1) (arg1)->serialSupported = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_supportedPinTypes_serialSupported_get(lua_State* L) { int SWIG_arg = 0;
  supportedPinTypes *arg1 = (supportedPinTypes *) 0 ; bool result; SWIG_check_num_args("supportedPinTypes::serialSupported",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("supportedPinTypes::serialSupported",1,"supportedPinTypes *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_supportedPinTypes,0))){
    SWIG_fail_ptr("supportedPinTypes_serialSupported_get",1,SWIGTYPE_p_supportedPinTypes); } 
  result = (bool) ((arg1)->serialSupported); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_supportedPinTypes_onewireSupported_set(lua_State* L) { int SWIG_arg = 0;
  supportedPinTypes *arg1 = (supportedPinTypes *) 0 ; bool arg2 ; SWIG_check_num_args("supportedPinTypes::onewireSupported",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("supportedPinTypes::onewireSupported",1,"supportedPinTypes *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("supportedPinTypes::onewireSupported",2,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_supportedPinTypes,0))){
    SWIG_fail_ptr("supportedPinTypes_onewireSupported_set",1,SWIGTYPE_p_supportedPinTypes); }  arg2 = (lua_toboolean(L, 2)!=0);
  if (arg1) (arg1)->onewireSupported = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_supportedPinTypes_onewireSupported_get(lua_State* L) { int SWIG_arg = 0;
  supportedPinTypes *arg1 = (supportedPinTypes *) 0 ; bool result;
  SWIG_check_num_args("supportedPinTypes::onewireSupported",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("supportedPinTypes::onewireSupported",1,"supportedPinTypes *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_supportedPinTypes,0))){
    SWIG_fail_ptr("supportedPinTypes_onewireSupported_get",1,SWIGTYPE_p_supportedPinTypes); } 
  result = (bool) ((arg1)->onewireSupported); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_supportedPinTypes_stepperSupported_set(lua_State* L) { int SWIG_arg = 0;
  supportedPinTypes *arg1 = (supportedPinTypes *) 0 ; bool arg2 ; SWIG_check_num_args("supportedPinTypes::stepperSupported",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("supportedPinTypes::stepperSupported",1,"supportedPinTypes *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("supportedPinTypes::stepperSupported",2,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_supportedPinTypes,0))){
    SWIG_fail_ptr("supportedPinTypes_stepperSupported_set",1,SWIGTYPE_p_supportedPinTypes); }  arg2 = (lua_toboolean(L, 2)!=0);
  if (arg1) (arg1)->stepperSupported = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_supportedPinTypes_stepperSupported_get(lua_State* L) { int SWIG_arg = 0;
  supportedPinTypes *arg1 = (supportedPinTypes *) 0 ; bool result;
  SWIG_check_num_args("supportedPinTypes::stepperSupported",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("supportedPinTypes::stepperSupported",1,"supportedPinTypes *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_supportedPinTypes,0))){
    SWIG_fail_ptr("supportedPinTypes_stepperSupported_get",1,SWIGTYPE_p_supportedPinTypes); } 
  result = (bool) ((arg1)->stepperSupported); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_supportedPinTypes_encoderSupported_set(lua_State* L) { int SWIG_arg = 0;
  supportedPinTypes *arg1 = (supportedPinTypes *) 0 ; bool arg2 ; SWIG_check_num_args("supportedPinTypes::encoderSupported",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("supportedPinTypes::encoderSupported",1,"supportedPinTypes *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("supportedPinTypes::encoderSupported",2,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_supportedPinTypes,0))){
    SWIG_fail_ptr("supportedPinTypes_encoderSupported_set",1,SWIGTYPE_p_supportedPinTypes); }  arg2 = (lua_toboolean(L, 2)!=0);
  if (arg1) (arg1)->encoderSupported = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_supportedPinTypes_encoderSupported_get(lua_State* L) { int SWIG_arg = 0;
  supportedPinTypes *arg1 = (supportedPinTypes *) 0 ; bool result;
  SWIG_check_num_args("supportedPinTypes::encoderSupported",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("supportedPinTypes::encoderSupported",1,"supportedPinTypes *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_supportedPinTypes,0))){
    SWIG_fail_ptr("supportedPinTypes_encoderSupported_get",1,SWIGTYPE_p_supportedPinTypes); } 
  result = (bool) ((arg1)->encoderSupported); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_new_supportedPinTypes(lua_State* L) { int SWIG_arg = 0; supportedPinTypes *result = 0 ;
  SWIG_check_num_args("supportedPinTypes::supportedPinTypes",0,0) result = (supportedPinTypes *)new supportedPinTypes();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_supportedPinTypes,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static void swig_delete_supportedPinTypes(void *obj) {
supportedPinTypes *arg1 = (supportedPinTypes *) obj;
delete arg1;
}
static int _proxy__wrap_new_supportedPinTypes(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_supportedPinTypes);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_supportedPinTypes_attributes[] = {
    { "inputSupported", _wrap_supportedPinTypes_inputSupported_get, _wrap_supportedPinTypes_inputSupported_set },
    { "outputSupported", _wrap_supportedPinTypes_outputSupported_get, _wrap_supportedPinTypes_outputSupported_set },
    { "analogSupported", _wrap_supportedPinTypes_analogSupported_get, _wrap_supportedPinTypes_analogSupported_set },
    { "pwmSupported", _wrap_supportedPinTypes_pwmSupported_get, _wrap_supportedPinTypes_pwmSupported_set },
    { "servoSupported", _wrap_supportedPinTypes_servoSupported_get, _wrap_supportedPinTypes_servoSupported_set },
    { "i2cSupported", _wrap_supportedPinTypes_i2cSupported_get, _wrap_supportedPinTypes_i2cSupported_set },
    { "serialSupported", _wrap_supportedPinTypes_serialSupported_get, _wrap_supportedPinTypes_serialSupported_set },
    { "onewireSupported", _wrap_supportedPinTypes_onewireSupported_get, _wrap_supportedPinTypes_onewireSupported_set },
    { "stepperSupported", _wrap_supportedPinTypes_stepperSupported_get, _wrap_supportedPinTypes_stepperSupported_set },
    { "encoderSupported", _wrap_supportedPinTypes_encoderSupported_get, _wrap_supportedPinTypes_encoderSupported_set },
    {0,0,0}
};
static swig_lua_method swig_supportedPinTypes_methods[]= {
    {0,0}
};
static swig_lua_method swig_supportedPinTypes_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_supportedPinTypes_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_supportedPinTypes_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_supportedPinTypes_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_supportedPinTypes_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_supportedPinTypes_Sf_SwigStatic = {
    "supportedPinTypes",
    swig_supportedPinTypes_Sf_SwigStatic_methods,
    swig_supportedPinTypes_Sf_SwigStatic_attributes,
    swig_supportedPinTypes_Sf_SwigStatic_constants,
    swig_supportedPinTypes_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_supportedPinTypes_bases[] = {0};
static const char *swig_supportedPinTypes_base_names[] = {0};
static swig_lua_class _wrap_class_supportedPinTypes = { "supportedPinTypes", "supportedPinTypes", &SWIGTYPE_p_supportedPinTypes,_proxy__wrap_new_supportedPinTypes, swig_delete_supportedPinTypes, swig_supportedPinTypes_methods, swig_supportedPinTypes_attributes, &swig_supportedPinTypes_Sf_SwigStatic, swig_supportedPinTypes_meta, swig_supportedPinTypes_bases, swig_supportedPinTypes_base_names };

static int _wrap_Firmata_I2C_Data_address_set(lua_State* L) { int SWIG_arg = 0;
  Firmata_I2C_Data *arg1 = (Firmata_I2C_Data *) 0 ; int arg2 ; SWIG_check_num_args("Firmata_I2C_Data::address",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Firmata_I2C_Data::address",1,"Firmata_I2C_Data *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Firmata_I2C_Data::address",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Firmata_I2C_Data,0))){
    SWIG_fail_ptr("Firmata_I2C_Data_address_set",1,SWIGTYPE_p_Firmata_I2C_Data); }  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->address = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Firmata_I2C_Data_address_get(lua_State* L) { int SWIG_arg = 0;
  Firmata_I2C_Data *arg1 = (Firmata_I2C_Data *) 0 ; int result; SWIG_check_num_args("Firmata_I2C_Data::address",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Firmata_I2C_Data::address",1,"Firmata_I2C_Data *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Firmata_I2C_Data,0))){
    SWIG_fail_ptr("Firmata_I2C_Data_address_get",1,SWIGTYPE_p_Firmata_I2C_Data); }  result = (int) ((arg1)->address);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Firmata_I2C_Data_reg_set(lua_State* L) { int SWIG_arg = 0; Firmata_I2C_Data *arg1 = (Firmata_I2C_Data *) 0 ;
  int arg2 ; SWIG_check_num_args("Firmata_I2C_Data::reg",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Firmata_I2C_Data::reg",1,"Firmata_I2C_Data *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Firmata_I2C_Data::reg",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Firmata_I2C_Data,0))){
    SWIG_fail_ptr("Firmata_I2C_Data_reg_set",1,SWIGTYPE_p_Firmata_I2C_Data); }  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->reg = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Firmata_I2C_Data_reg_get(lua_State* L) { int SWIG_arg = 0; Firmata_I2C_Data *arg1 = (Firmata_I2C_Data *) 0 ;
  int result; SWIG_check_num_args("Firmata_I2C_Data::reg",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Firmata_I2C_Data::reg",1,"Firmata_I2C_Data *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Firmata_I2C_Data,0))){
    SWIG_fail_ptr("Firmata_I2C_Data_reg_get",1,SWIGTYPE_p_Firmata_I2C_Data); }  result = (int) ((arg1)->reg);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Firmata_I2C_Data_data_set(lua_State* L) { int SWIG_arg = 0; Firmata_I2C_Data *arg1 = (Firmata_I2C_Data *) 0 ;
  std::string *arg2 = 0 ; std::string temp2 ; SWIG_check_num_args("Firmata_I2C_Data::data",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Firmata_I2C_Data::data",1,"Firmata_I2C_Data *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Firmata_I2C_Data::data",2,"std::string const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Firmata_I2C_Data,0))){
    SWIG_fail_ptr("Firmata_I2C_Data_data_set",1,SWIGTYPE_p_Firmata_I2C_Data); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2; if (arg1) (arg1)->data = *arg2; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Firmata_I2C_Data_data_get(lua_State* L) { int SWIG_arg = 0; Firmata_I2C_Data *arg1 = (Firmata_I2C_Data *) 0 ;
  std::string *result = 0 ; SWIG_check_num_args("Firmata_I2C_Data::data",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Firmata_I2C_Data::data",1,"Firmata_I2C_Data *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Firmata_I2C_Data,0))){
    SWIG_fail_ptr("Firmata_I2C_Data_data_get",1,SWIGTYPE_p_Firmata_I2C_Data); }  result = (std::string *) & ((arg1)->data);
  lua_pushlstring(L,result->data(),result->size()); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_Firmata_I2C_Data(lua_State* L) { int SWIG_arg = 0; Firmata_I2C_Data *result = 0 ;
  SWIG_check_num_args("Firmata_I2C_Data::Firmata_I2C_Data",0,0) result = (Firmata_I2C_Data *)new Firmata_I2C_Data();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Firmata_I2C_Data,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static void swig_delete_Firmata_I2C_Data(void *obj) {
Firmata_I2C_Data *arg1 = (Firmata_I2C_Data *) obj;
delete arg1;
}
static int _proxy__wrap_new_Firmata_I2C_Data(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_Firmata_I2C_Data);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_Firmata_I2C_Data_attributes[] = {
    { "address", _wrap_Firmata_I2C_Data_address_get, _wrap_Firmata_I2C_Data_address_set },
    { "reg", _wrap_Firmata_I2C_Data_reg_get, _wrap_Firmata_I2C_Data_reg_set },
    { "data", _wrap_Firmata_I2C_Data_data_get, _wrap_Firmata_I2C_Data_data_set },
    {0,0,0}
};
static swig_lua_method swig_Firmata_I2C_Data_methods[]= {
    {0,0}
};
static swig_lua_method swig_Firmata_I2C_Data_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_Firmata_I2C_Data_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_Firmata_I2C_Data_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_Firmata_I2C_Data_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_Firmata_I2C_Data_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_Firmata_I2C_Data_Sf_SwigStatic = {
    "Firmata_I2C_Data",
    swig_Firmata_I2C_Data_Sf_SwigStatic_methods,
    swig_Firmata_I2C_Data_Sf_SwigStatic_attributes,
    swig_Firmata_I2C_Data_Sf_SwigStatic_constants,
    swig_Firmata_I2C_Data_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_Firmata_I2C_Data_bases[] = {0};
static const char *swig_Firmata_I2C_Data_base_names[] = {0};
static swig_lua_class _wrap_class_Firmata_I2C_Data = { "Firmata_I2C_Data", "Firmata_I2C_Data", &SWIGTYPE_p_Firmata_I2C_Data,_proxy__wrap_new_Firmata_I2C_Data, swig_delete_Firmata_I2C_Data, swig_Firmata_I2C_Data_methods, swig_Firmata_I2C_Data_attributes, &swig_Firmata_I2C_Data_Sf_SwigStatic, swig_Firmata_I2C_Data_meta, swig_Firmata_I2C_Data_bases, swig_Firmata_I2C_Data_base_names };

static int _wrap_Firmata_Encoder_Data_ID_set(lua_State* L) { int SWIG_arg = 0;
  Firmata_Encoder_Data *arg1 = (Firmata_Encoder_Data *) 0 ; int arg2 ; SWIG_check_num_args("Firmata_Encoder_Data::ID",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Firmata_Encoder_Data::ID",1,"Firmata_Encoder_Data *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Firmata_Encoder_Data::ID",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Firmata_Encoder_Data,0))){
    SWIG_fail_ptr("Firmata_Encoder_Data_ID_set",1,SWIGTYPE_p_Firmata_Encoder_Data); }  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->ID = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Firmata_Encoder_Data_ID_get(lua_State* L) { int SWIG_arg = 0;
  Firmata_Encoder_Data *arg1 = (Firmata_Encoder_Data *) 0 ; int result; SWIG_check_num_args("Firmata_Encoder_Data::ID",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Firmata_Encoder_Data::ID",1,"Firmata_Encoder_Data *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Firmata_Encoder_Data,0))){
    SWIG_fail_ptr("Firmata_Encoder_Data_ID_get",1,SWIGTYPE_p_Firmata_Encoder_Data); }  result = (int) ((arg1)->ID);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Firmata_Encoder_Data_direction_set(lua_State* L) { int SWIG_arg = 0;
  Firmata_Encoder_Data *arg1 = (Firmata_Encoder_Data *) 0 ; bool arg2 ;
  SWIG_check_num_args("Firmata_Encoder_Data::direction",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Firmata_Encoder_Data::direction",1,"Firmata_Encoder_Data *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("Firmata_Encoder_Data::direction",2,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Firmata_Encoder_Data,0))){
    SWIG_fail_ptr("Firmata_Encoder_Data_direction_set",1,SWIGTYPE_p_Firmata_Encoder_Data); }  arg2 = (lua_toboolean(L, 2)!=0);
  if (arg1) (arg1)->direction = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Firmata_Encoder_Data_direction_get(lua_State* L) { int SWIG_arg = 0;
  Firmata_Encoder_Data *arg1 = (Firmata_Encoder_Data *) 0 ; bool result;
  SWIG_check_num_args("Firmata_Encoder_Data::direction",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Firmata_Encoder_Data::direction",1,"Firmata_Encoder_Data *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Firmata_Encoder_Data,0))){
    SWIG_fail_ptr("Firmata_Encoder_Data_direction_get",1,SWIGTYPE_p_Firmata_Encoder_Data); } 
  result = (bool) ((arg1)->direction); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Firmata_Encoder_Data_position_set(lua_State* L) { int SWIG_arg = 0;
  Firmata_Encoder_Data *arg1 = (Firmata_Encoder_Data *) 0 ; int arg2 ; SWIG_check_num_args("Firmata_Encoder_Data::position",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Firmata_Encoder_Data::position",1,"Firmata_Encoder_Data *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Firmata_Encoder_Data::position",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Firmata_Encoder_Data,0))){
    SWIG_fail_ptr("Firmata_Encoder_Data_position_set",1,SWIGTYPE_p_Firmata_Encoder_Data); }  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->position = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Firmata_Encoder_Data_position_get(lua_State* L) { int SWIG_arg = 0;
  Firmata_Encoder_Data *arg1 = (Firmata_Encoder_Data *) 0 ; int result;
  SWIG_check_num_args("Firmata_Encoder_Data::position",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Firmata_Encoder_Data::position",1,"Firmata_Encoder_Data *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Firmata_Encoder_Data,0))){
    SWIG_fail_ptr("Firmata_Encoder_Data_position_get",1,SWIGTYPE_p_Firmata_Encoder_Data); }  result = (int) ((arg1)->position);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_new_Firmata_Encoder_Data(lua_State* L) { int SWIG_arg = 0; Firmata_Encoder_Data *result = 0 ;
  SWIG_check_num_args("Firmata_Encoder_Data::Firmata_Encoder_Data",0,0)
  result = (Firmata_Encoder_Data *)new Firmata_Encoder_Data();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Firmata_Encoder_Data,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static void swig_delete_Firmata_Encoder_Data(void *obj) {
Firmata_Encoder_Data *arg1 = (Firmata_Encoder_Data *) obj;
delete arg1;
}
static int _proxy__wrap_new_Firmata_Encoder_Data(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_Firmata_Encoder_Data);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_Firmata_Encoder_Data_attributes[] = {
    { "ID", _wrap_Firmata_Encoder_Data_ID_get, _wrap_Firmata_Encoder_Data_ID_set },
    { "direction", _wrap_Firmata_Encoder_Data_direction_get, _wrap_Firmata_Encoder_Data_direction_set },
    { "position", _wrap_Firmata_Encoder_Data_position_get, _wrap_Firmata_Encoder_Data_position_set },
    {0,0,0}
};
static swig_lua_method swig_Firmata_Encoder_Data_methods[]= {
    {0,0}
};
static swig_lua_method swig_Firmata_Encoder_Data_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_Firmata_Encoder_Data_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_Firmata_Encoder_Data_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_Firmata_Encoder_Data_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_Firmata_Encoder_Data_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_Firmata_Encoder_Data_Sf_SwigStatic = {
    "Firmata_Encoder_Data",
    swig_Firmata_Encoder_Data_Sf_SwigStatic_methods,
    swig_Firmata_Encoder_Data_Sf_SwigStatic_attributes,
    swig_Firmata_Encoder_Data_Sf_SwigStatic_constants,
    swig_Firmata_Encoder_Data_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_Firmata_Encoder_Data_bases[] = {0};
static const char *swig_Firmata_Encoder_Data_base_names[] = {0};
static swig_lua_class _wrap_class_Firmata_Encoder_Data = { "Firmata_Encoder_Data", "Firmata_Encoder_Data", &SWIGTYPE_p_Firmata_Encoder_Data,_proxy__wrap_new_Firmata_Encoder_Data, swig_delete_Firmata_Encoder_Data, swig_Firmata_Encoder_Data_methods, swig_Firmata_Encoder_Data_attributes, &swig_Firmata_Encoder_Data_Sf_SwigStatic, swig_Firmata_Encoder_Data_meta, swig_Firmata_Encoder_Data_bases, swig_Firmata_Encoder_Data_base_names };

static int _wrap_Firmata_Stepper_Data_id_set(lua_State* L) { int SWIG_arg = 0;
  Firmata_Stepper_Data *arg1 = (Firmata_Stepper_Data *) 0 ; int arg2 ; SWIG_check_num_args("Firmata_Stepper_Data::id",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Firmata_Stepper_Data::id",1,"Firmata_Stepper_Data *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Firmata_Stepper_Data::id",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Firmata_Stepper_Data,0))){
    SWIG_fail_ptr("Firmata_Stepper_Data_id_set",1,SWIGTYPE_p_Firmata_Stepper_Data); }  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->id = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Firmata_Stepper_Data_id_get(lua_State* L) { int SWIG_arg = 0;
  Firmata_Stepper_Data *arg1 = (Firmata_Stepper_Data *) 0 ; int result; SWIG_check_num_args("Firmata_Stepper_Data::id",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Firmata_Stepper_Data::id",1,"Firmata_Stepper_Data *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Firmata_Stepper_Data,0))){
    SWIG_fail_ptr("Firmata_Stepper_Data_id_get",1,SWIGTYPE_p_Firmata_Stepper_Data); }  result = (int) ((arg1)->id);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Firmata_Stepper_Data_type_set(lua_State* L) { int SWIG_arg = 0;
  Firmata_Stepper_Data *arg1 = (Firmata_Stepper_Data *) 0 ; int arg2 ; SWIG_check_num_args("Firmata_Stepper_Data::type",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Firmata_Stepper_Data::type",1,"Firmata_Stepper_Data *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Firmata_Stepper_Data::type",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Firmata_Stepper_Data,0))){
    SWIG_fail_ptr("Firmata_Stepper_Data_type_set",1,SWIGTYPE_p_Firmata_Stepper_Data); }  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->type = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Firmata_Stepper_Data_type_get(lua_State* L) { int SWIG_arg = 0;
  Firmata_Stepper_Data *arg1 = (Firmata_Stepper_Data *) 0 ; int result; SWIG_check_num_args("Firmata_Stepper_Data::type",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Firmata_Stepper_Data::type",1,"Firmata_Stepper_Data *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Firmata_Stepper_Data,0))){
    SWIG_fail_ptr("Firmata_Stepper_Data_type_get",1,SWIGTYPE_p_Firmata_Stepper_Data); }  result = (int) ((arg1)->type);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Firmata_Stepper_Data_data_set(lua_State* L) { int SWIG_arg = 0;
  Firmata_Stepper_Data *arg1 = (Firmata_Stepper_Data *) 0 ; int arg2 ; SWIG_check_num_args("Firmata_Stepper_Data::data",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Firmata_Stepper_Data::data",1,"Firmata_Stepper_Data *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Firmata_Stepper_Data::data",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Firmata_Stepper_Data,0))){
    SWIG_fail_ptr("Firmata_Stepper_Data_data_set",1,SWIGTYPE_p_Firmata_Stepper_Data); }  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->data = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Firmata_Stepper_Data_data_get(lua_State* L) { int SWIG_arg = 0;
  Firmata_Stepper_Data *arg1 = (Firmata_Stepper_Data *) 0 ; int result; SWIG_check_num_args("Firmata_Stepper_Data::data",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Firmata_Stepper_Data::data",1,"Firmata_Stepper_Data *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Firmata_Stepper_Data,0))){
    SWIG_fail_ptr("Firmata_Stepper_Data_data_get",1,SWIGTYPE_p_Firmata_Stepper_Data); }  result = (int) ((arg1)->data);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_new_Firmata_Stepper_Data(lua_State* L) { int SWIG_arg = 0; Firmata_Stepper_Data *result = 0 ;
  SWIG_check_num_args("Firmata_Stepper_Data::Firmata_Stepper_Data",0,0)
  result = (Firmata_Stepper_Data *)new Firmata_Stepper_Data();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Firmata_Stepper_Data,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static void swig_delete_Firmata_Stepper_Data(void *obj) {
Firmata_Stepper_Data *arg1 = (Firmata_Stepper_Data *) obj;
delete arg1;
}
static int _proxy__wrap_new_Firmata_Stepper_Data(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_Firmata_Stepper_Data);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_Firmata_Stepper_Data_attributes[] = {
    { "id", _wrap_Firmata_Stepper_Data_id_get, _wrap_Firmata_Stepper_Data_id_set },
    { "type", _wrap_Firmata_Stepper_Data_type_get, _wrap_Firmata_Stepper_Data_type_set },
    { "data", _wrap_Firmata_Stepper_Data_data_get, _wrap_Firmata_Stepper_Data_data_set },
    {0,0,0}
};
static swig_lua_method swig_Firmata_Stepper_Data_methods[]= {
    {0,0}
};
static swig_lua_method swig_Firmata_Stepper_Data_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_Firmata_Stepper_Data_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_Firmata_Stepper_Data_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_Firmata_Stepper_Data_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_Firmata_Stepper_Data_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_Firmata_Stepper_Data_Sf_SwigStatic = {
    "Firmata_Stepper_Data",
    swig_Firmata_Stepper_Data_Sf_SwigStatic_methods,
    swig_Firmata_Stepper_Data_Sf_SwigStatic_attributes,
    swig_Firmata_Stepper_Data_Sf_SwigStatic_constants,
    swig_Firmata_Stepper_Data_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_Firmata_Stepper_Data_bases[] = {0};
static const char *swig_Firmata_Stepper_Data_base_names[] = {0};
static swig_lua_class _wrap_class_Firmata_Stepper_Data = { "Firmata_Stepper_Data", "Firmata_Stepper_Data", &SWIGTYPE_p_Firmata_Stepper_Data,_proxy__wrap_new_Firmata_Stepper_Data, swig_delete_Firmata_Stepper_Data, swig_Firmata_Stepper_Data_methods, swig_Firmata_Stepper_Data_attributes, &swig_Firmata_Stepper_Data_Sf_SwigStatic, swig_Firmata_Stepper_Data_meta, swig_Firmata_Stepper_Data_bases, swig_Firmata_Stepper_Data_base_names };

static int _wrap_Firmata_Serial_Data_portID_set(lua_State* L) { int SWIG_arg = 0;
  Firmata_Serial_Data *arg1 = (Firmata_Serial_Data *) 0 ; Firmata_Serial_Ports arg2 ;
  SWIG_check_num_args("Firmata_Serial_Data::portID",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Firmata_Serial_Data::portID",1,"Firmata_Serial_Data *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Firmata_Serial_Data::portID",2,"Firmata_Serial_Ports");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Firmata_Serial_Data,0))){
    SWIG_fail_ptr("Firmata_Serial_Data_portID_set",1,SWIGTYPE_p_Firmata_Serial_Data); } 
  arg2 = (Firmata_Serial_Ports)(int)lua_tonumber(L, 2); if (arg1) (arg1)->portID = arg2; return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Firmata_Serial_Data_portID_get(lua_State* L) { int SWIG_arg = 0;
  Firmata_Serial_Data *arg1 = (Firmata_Serial_Data *) 0 ; Firmata_Serial_Ports result;
  SWIG_check_num_args("Firmata_Serial_Data::portID",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Firmata_Serial_Data::portID",1,"Firmata_Serial_Data *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Firmata_Serial_Data,0))){
    SWIG_fail_ptr("Firmata_Serial_Data_portID_get",1,SWIGTYPE_p_Firmata_Serial_Data); } 
  result = (Firmata_Serial_Ports) ((arg1)->portID); lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Firmata_Serial_Data_data_set(lua_State* L) { int SWIG_arg = 0;
  Firmata_Serial_Data *arg1 = (Firmata_Serial_Data *) 0 ; std::string *arg2 = 0 ; std::string temp2 ;
  SWIG_check_num_args("Firmata_Serial_Data::data",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Firmata_Serial_Data::data",1,"Firmata_Serial_Data *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("Firmata_Serial_Data::data",2,"std::string const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Firmata_Serial_Data,0))){
    SWIG_fail_ptr("Firmata_Serial_Data_data_set",1,SWIGTYPE_p_Firmata_Serial_Data); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2; if (arg1) (arg1)->data = *arg2; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Firmata_Serial_Data_data_get(lua_State* L) { int SWIG_arg = 0;
  Firmata_Serial_Data *arg1 = (Firmata_Serial_Data *) 0 ; std::string *result = 0 ;
  SWIG_check_num_args("Firmata_Serial_Data::data",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Firmata_Serial_Data::data",1,"Firmata_Serial_Data *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Firmata_Serial_Data,0))){
    SWIG_fail_ptr("Firmata_Serial_Data_data_get",1,SWIGTYPE_p_Firmata_Serial_Data); } 
  result = (std::string *) & ((arg1)->data); lua_pushlstring(L,result->data(),result->size()); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_new_Firmata_Serial_Data(lua_State* L) { int SWIG_arg = 0; Firmata_Serial_Data *result = 0 ;
  SWIG_check_num_args("Firmata_Serial_Data::Firmata_Serial_Data",0,0) result = (Firmata_Serial_Data *)new Firmata_Serial_Data();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Firmata_Serial_Data,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static void swig_delete_Firmata_Serial_Data(void *obj) {
Firmata_Serial_Data *arg1 = (Firmata_Serial_Data *) obj;
delete arg1;
}
static int _proxy__wrap_new_Firmata_Serial_Data(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_Firmata_Serial_Data);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_Firmata_Serial_Data_attributes[] = {
    { "portID", _wrap_Firmata_Serial_Data_portID_get, _wrap_Firmata_Serial_Data_portID_set },
    { "data", _wrap_Firmata_Serial_Data_data_get, _wrap_Firmata_Serial_Data_data_set },
    {0,0,0}
};
static swig_lua_method swig_Firmata_Serial_Data_methods[]= {
    {0,0}
};
static swig_lua_method swig_Firmata_Serial_Data_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_Firmata_Serial_Data_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_Firmata_Serial_Data_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_Firmata_Serial_Data_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_Firmata_Serial_Data_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_Firmata_Serial_Data_Sf_SwigStatic = {
    "Firmata_Serial_Data",
    swig_Firmata_Serial_Data_Sf_SwigStatic_methods,
    swig_Firmata_Serial_Data_Sf_SwigStatic_attributes,
    swig_Firmata_Serial_Data_Sf_SwigStatic_constants,
    swig_Firmata_Serial_Data_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_Firmata_Serial_Data_bases[] = {0};
static const char *swig_Firmata_Serial_Data_base_names[] = {0};
static swig_lua_class _wrap_class_Firmata_Serial_Data = { "Firmata_Serial_Data", "Firmata_Serial_Data", &SWIGTYPE_p_Firmata_Serial_Data,_proxy__wrap_new_Firmata_Serial_Data, swig_delete_Firmata_Serial_Data, swig_Firmata_Serial_Data_methods, swig_Firmata_Serial_Data_attributes, &swig_Firmata_Serial_Data_Sf_SwigStatic, swig_Firmata_Serial_Data_meta, swig_Firmata_Serial_Data_bases, swig_Firmata_Serial_Data_base_names };

static int _wrap_new_Arduino(lua_State* L) { int SWIG_arg = 0; ofArduino *result = 0 ;
  SWIG_check_num_args("ofArduino::ofArduino",0,0) result = (ofArduino *)new ofArduino();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofArduino,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Arduino_connect__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ;
  std::string *arg2 = 0 ; int arg3 ; std::string temp2 ; bool result; SWIG_check_num_args("ofArduino::connect",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::connect",1,"ofArduino *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofArduino::connect",2,"std::string const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofArduino::connect",3,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_connect",1,SWIGTYPE_p_ofArduino); }  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  arg3 = (int)lua_tonumber(L, 3); result = (bool)(arg1)->connect((std::string const &)*arg2,arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_connect__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ;
  std::string *arg2 = 0 ; std::string temp2 ; bool result; SWIG_check_num_args("ofArduino::connect",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::connect",1,"ofArduino *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofArduino::connect",2,"std::string const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_connect",1,SWIGTYPE_p_ofArduino); }  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  result = (bool)(arg1)->connect((std::string const &)*arg2); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_connect(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofArduino, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L,argv[1]); }  if (_v) { return _wrap_Arduino_connect__SWIG_1(L);}  }
     }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofArduino, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_Arduino_connect__SWIG_0(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Arduino_connect'\n" "  Possible C/C++ prototypes are:\n"
  "    ofArduino::connect(std::string const &,int)\n" "    ofArduino::connect(std::string const &)\n"); lua_error(L);return 0; }
static int _wrap_Arduino_isInitialized(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ; bool result;
  SWIG_check_num_args("ofArduino::isInitialized",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::isInitialized",1,"ofArduino const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_isInitialized",1,SWIGTYPE_p_ofArduino); }  result = (bool)((ofArduino const *)arg1)->isInitialized();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_isArduinoReady(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ; bool result;
  SWIG_check_num_args("ofArduino::isArduinoReady",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::isArduinoReady",1,"ofArduino *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_isArduinoReady",1,SWIGTYPE_p_ofArduino); }  result = (bool)(arg1)->isArduinoReady();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_disconnect(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ;
  SWIG_check_num_args("ofArduino::disconnect",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::disconnect",1,"ofArduino *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_disconnect",1,SWIGTYPE_p_ofArduino); }  (arg1)->disconnect(); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_update(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ;
  SWIG_check_num_args("ofArduino::update",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::update",1,"ofArduino *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_update",1,SWIGTYPE_p_ofArduino); }  (arg1)->update(); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_sendDigitalPinMode(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ; int arg2 ;
  int arg3 ; SWIG_check_num_args("ofArduino::sendDigitalPinMode",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::sendDigitalPinMode",1,"ofArduino *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofArduino::sendDigitalPinMode",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofArduino::sendDigitalPinMode",3,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_sendDigitalPinMode",1,SWIGTYPE_p_ofArduino); }  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3); (arg1)->sendDigitalPinMode(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Arduino_sendAnalogPinReporting(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ; int arg2 ;
  int arg3 ; SWIG_check_num_args("ofArduino::sendAnalogPinReporting",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::sendAnalogPinReporting",1,"ofArduino *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofArduino::sendAnalogPinReporting",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofArduino::sendAnalogPinReporting",3,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_sendAnalogPinReporting",1,SWIGTYPE_p_ofArduino); }  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3); (arg1)->sendAnalogPinReporting(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_setUseDelay(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ; bool arg2 ;
  SWIG_check_num_args("ofArduino::setUseDelay",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::setUseDelay",1,"ofArduino *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofArduino::setUseDelay",2,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_setUseDelay",1,SWIGTYPE_p_ofArduino); }  arg2 = (lua_toboolean(L, 2)!=0); (arg1)->setUseDelay(arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_setDigitalHistoryLength(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ;
  int arg2 ; SWIG_check_num_args("ofArduino::setDigitalHistoryLength",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::setDigitalHistoryLength",1,"ofArduino *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofArduino::setDigitalHistoryLength",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_setDigitalHistoryLength",1,SWIGTYPE_p_ofArduino); }  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setDigitalHistoryLength(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_setAnalogHistoryLength(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ; int arg2 ;
  SWIG_check_num_args("ofArduino::setAnalogHistoryLength",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::setAnalogHistoryLength",1,"ofArduino *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofArduino::setAnalogHistoryLength",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_setAnalogHistoryLength",1,SWIGTYPE_p_ofArduino); }  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setAnalogHistoryLength(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_setStringHistoryLength(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ; int arg2 ;
  SWIG_check_num_args("ofArduino::setStringHistoryLength",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::setStringHistoryLength",1,"ofArduino *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofArduino::setStringHistoryLength",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_setStringHistoryLength",1,SWIGTYPE_p_ofArduino); }  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setStringHistoryLength(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_setSysExHistoryLength(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ; int arg2 ;
  SWIG_check_num_args("ofArduino::setSysExHistoryLength",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::setSysExHistoryLength",1,"ofArduino *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofArduino::setSysExHistoryLength",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_setSysExHistoryLength",1,SWIGTYPE_p_ofArduino); }  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setSysExHistoryLength(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_sendDigital__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ; int arg2 ;
  int arg3 ; bool arg4 ; SWIG_check_num_args("ofArduino::sendDigital",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::sendDigital",1,"ofArduino *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofArduino::sendDigital",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofArduino::sendDigital",3,"int");
  if(!lua_isboolean(L,4)) SWIG_fail_arg("ofArduino::sendDigital",4,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_sendDigital",1,SWIGTYPE_p_ofArduino); }  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3); arg4 = (lua_toboolean(L, 4)!=0); (arg1)->sendDigital(arg2,arg3,arg4); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_sendDigital__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ; int arg2 ;
  int arg3 ; SWIG_check_num_args("ofArduino::sendDigital",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::sendDigital",1,"ofArduino *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofArduino::sendDigital",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofArduino::sendDigital",3,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_sendDigital",1,SWIGTYPE_p_ofArduino); }  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3); (arg1)->sendDigital(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Arduino_sendDigital(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L); if (argc == 3) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofArduino, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_Arduino_sendDigital__SWIG_1(L);}  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofArduino, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          { _v = lua_isboolean(L,argv[3]); }  if (_v) { return _wrap_Arduino_sendDigital__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Arduino_sendDigital'\n"
  "  Possible C/C++ prototypes are:\n" "    ofArduino::sendDigital(int,int,bool)\n" "    ofArduino::sendDigital(int,int)\n");
  lua_error(L);return 0; }
static int _wrap_Arduino_sendPwm__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ; int arg2 ;
  int arg3 ; bool arg4 ; SWIG_check_num_args("ofArduino::sendPwm",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::sendPwm",1,"ofArduino *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofArduino::sendPwm",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofArduino::sendPwm",3,"int");
  if(!lua_isboolean(L,4)) SWIG_fail_arg("ofArduino::sendPwm",4,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_sendPwm",1,SWIGTYPE_p_ofArduino); }  arg2 = (int)lua_tonumber(L, 2); arg3 = (int)lua_tonumber(L, 3);
  arg4 = (lua_toboolean(L, 4)!=0); (arg1)->sendPwm(arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Arduino_sendPwm__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ; int arg2 ;
  int arg3 ; SWIG_check_num_args("ofArduino::sendPwm",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::sendPwm",1,"ofArduino *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofArduino::sendPwm",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofArduino::sendPwm",3,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_sendPwm",1,SWIGTYPE_p_ofArduino); }  arg2 = (int)lua_tonumber(L, 2); arg3 = (int)lua_tonumber(L, 3);
  (arg1)->sendPwm(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_sendPwm(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L); if (argc == 3) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofArduino, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_Arduino_sendPwm__SWIG_1(L);}  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofArduino, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          { _v = lua_isboolean(L,argv[3]); }  if (_v) { return _wrap_Arduino_sendPwm__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Arduino_sendPwm'\n" "  Possible C/C++ prototypes are:\n"
  "    ofArduino::sendPwm(int,int,bool)\n" "    ofArduino::sendPwm(int,int)\n"); lua_error(L);return 0; }
static int _wrap_Arduino_sendSysEx(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ; int arg2 ;
  std::vector< unsigned char > arg3 ; std::vector< unsigned char > *argp3 ; SWIG_check_num_args("ofArduino::sendSysEx",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::sendSysEx",1,"ofArduino *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofArduino::sendSysEx",2,"int");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofArduino::sendSysEx",3,"std::vector< unsigned char >");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_sendSysEx",1,SWIGTYPE_p_ofArduino); }  arg2 = (int)lua_tonumber(L, 2);
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_std__vectorT_unsigned_char_t,0))){
    SWIG_fail_ptr("Arduino_sendSysEx",3,SWIGTYPE_p_std__vectorT_unsigned_char_t); }  arg3 = *argp3;
  (arg1)->sendSysEx(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_isAttached(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ; bool result;
  SWIG_check_num_args("ofArduino::isAttached",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::isAttached",1,"ofArduino *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_isAttached",1,SWIGTYPE_p_ofArduino); }  result = (bool)(arg1)->isAttached();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_sendString(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ; std::string arg2 ;
  SWIG_check_num_args("ofArduino::sendString",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::sendString",1,"ofArduino *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofArduino::sendString",2,"std::string");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_sendString",1,SWIGTYPE_p_ofArduino); }  (&arg2)->assign(lua_tostring(L,2),lua_rawlen(L,2));
  (arg1)->sendString(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_sendProtocolVersionRequest(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ;
  SWIG_check_num_args("ofArduino::sendProtocolVersionRequest",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::sendProtocolVersionRequest",1,"ofArduino *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_sendProtocolVersionRequest",1,SWIGTYPE_p_ofArduino); }  (arg1)->sendProtocolVersionRequest();
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_sendFirmwareVersionRequest(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ;
  SWIG_check_num_args("ofArduino::sendFirmwareVersionRequest",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::sendFirmwareVersionRequest",1,"ofArduino *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_sendFirmwareVersionRequest",1,SWIGTYPE_p_ofArduino); }  (arg1)->sendFirmwareVersionRequest();
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_igurationRequest(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ;
  SWIG_check_num_args("ofArduino::sendPinCofigurationRequest",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::sendPinCofigurationRequest",1,"ofArduino *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_igurationRequest",1,SWIGTYPE_p_ofArduino); }  (arg1)->sendPinCofigurationRequest(); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_sendPinCapabilityRequest(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ;
  SWIG_check_num_args("ofArduino::sendPinCapabilityRequest",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::sendPinCapabilityRequest",1,"ofArduino *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_sendPinCapabilityRequest",1,SWIGTYPE_p_ofArduino); }  (arg1)->sendPinCapabilityRequest();
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_sendAnalogMappingRequest(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ;
  SWIG_check_num_args("ofArduino::sendAnalogMappingRequest",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::sendAnalogMappingRequest",1,"ofArduino *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_sendAnalogMappingRequest",1,SWIGTYPE_p_ofArduino); }  (arg1)->sendAnalogMappingRequest();
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_sendPinStateQuery(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ; int arg2 ;
  SWIG_check_num_args("ofArduino::sendPinStateQuery",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::sendPinStateQuery",1,"ofArduino *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofArduino::sendPinStateQuery",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_sendPinStateQuery",1,SWIGTYPE_p_ofArduino); }  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->sendPinStateQuery(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_sendReset(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ;
  SWIG_check_num_args("ofArduino::sendReset",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::sendReset",1,"ofArduino *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_sendReset",1,SWIGTYPE_p_ofArduino); }  (arg1)->sendReset(); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_sendSysExBegin(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ;
  SWIG_check_num_args("ofArduino::sendSysExBegin",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::sendSysExBegin",1,"ofArduino *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_sendSysExBegin",1,SWIGTYPE_p_ofArduino); }  (arg1)->sendSysExBegin(); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_sendSysExEnd(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ;
  SWIG_check_num_args("ofArduino::sendSysExEnd",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::sendSysExEnd",1,"ofArduino *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_sendSysExEnd",1,SWIGTYPE_p_ofArduino); }  (arg1)->sendSysExEnd(); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_sendByte(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ; unsigned char arg2 ;
  SWIG_check_num_args("ofArduino::sendByte",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::sendByte",1,"ofArduino *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofArduino::sendByte",2,"unsigned char");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_sendByte",1,SWIGTYPE_p_ofArduino); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (unsigned char)lua_tonumber(L, 2);
  (arg1)->sendByte(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_sendValueAsTwo7bitBytes(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ;
  int arg2 ; SWIG_check_num_args("ofArduino::sendValueAsTwo7bitBytes",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::sendValueAsTwo7bitBytes",1,"ofArduino *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofArduino::sendValueAsTwo7bitBytes",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_sendValueAsTwo7bitBytes",1,SWIGTYPE_p_ofArduino); }  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->sendValueAsTwo7bitBytes(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_getPwm(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ; int arg2 ; int result;
  SWIG_check_num_args("ofArduino::getPwm",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::getPwm",1,"ofArduino const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofArduino::getPwm",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_getPwm",1,SWIGTYPE_p_ofArduino); }  arg2 = (int)lua_tonumber(L, 2);
  result = (int)((ofArduino const *)arg1)->getPwm(arg2); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_getDigital(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ; int arg2 ; int result;
  SWIG_check_num_args("ofArduino::getDigital",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::getDigital",1,"ofArduino const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofArduino::getDigital",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_getDigital",1,SWIGTYPE_p_ofArduino); }  arg2 = (int)lua_tonumber(L, 2);
  result = (int)((ofArduino const *)arg1)->getDigital(arg2); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_getAnalog(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ; int arg2 ; int result;
  SWIG_check_num_args("ofArduino::getAnalog",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::getAnalog",1,"ofArduino const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofArduino::getAnalog",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_getAnalog",1,SWIGTYPE_p_ofArduino); }  arg2 = (int)lua_tonumber(L, 2);
  result = (int)((ofArduino const *)arg1)->getAnalog(arg2); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_getSysEx(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ;
  std::vector< unsigned char > result; SWIG_check_num_args("ofArduino::getSysEx",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::getSysEx",1,"ofArduino const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_getSysEx",1,SWIGTYPE_p_ofArduino); }  result = ((ofArduino const *)arg1)->getSysEx(); {
    std::vector< unsigned char > * resultptr = new std::vector< unsigned char >((const std::vector< unsigned char > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_std__vectorT_unsigned_char_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_getString(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ; std::string result;
  SWIG_check_num_args("ofArduino::getString",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::getString",1,"ofArduino const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_getString",1,SWIGTYPE_p_ofArduino); }  result = ((ofArduino const *)arg1)->getString();
  lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Arduino_getMajorFirmwareVersion(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ;
  int result; SWIG_check_num_args("ofArduino::getMajorFirmwareVersion",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::getMajorFirmwareVersion",1,"ofArduino const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_getMajorFirmwareVersion",1,SWIGTYPE_p_ofArduino); } 
  result = (int)((ofArduino const *)arg1)->getMajorFirmwareVersion(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_getMinorFirmwareVersion(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ;
  int result; SWIG_check_num_args("ofArduino::getMinorFirmwareVersion",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::getMinorFirmwareVersion",1,"ofArduino const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_getMinorFirmwareVersion",1,SWIGTYPE_p_ofArduino); } 
  result = (int)((ofArduino const *)arg1)->getMinorFirmwareVersion(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_getFirmwareName(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ;
  std::string result; SWIG_check_num_args("ofArduino::getFirmwareName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::getFirmwareName",1,"ofArduino const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_getFirmwareName",1,SWIGTYPE_p_ofArduino); }  result = ((ofArduino const *)arg1)->getFirmwareName();
  lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Arduino_getDigitalPinMode(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ; int arg2 ;
  int result; SWIG_check_num_args("ofArduino::getDigitalPinMode",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::getDigitalPinMode",1,"ofArduino const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofArduino::getDigitalPinMode",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_getDigitalPinMode",1,SWIGTYPE_p_ofArduino); }  arg2 = (int)lua_tonumber(L, 2);
  result = (int)((ofArduino const *)arg1)->getDigitalPinMode(arg2); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_getAnalogPinReporting(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ; int arg2 ;
  int result; SWIG_check_num_args("ofArduino::getAnalogPinReporting",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::getAnalogPinReporting",1,"ofArduino const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofArduino::getAnalogPinReporting",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_getAnalogPinReporting",1,SWIGTYPE_p_ofArduino); }  arg2 = (int)lua_tonumber(L, 2);
  result = (int)((ofArduino const *)arg1)->getAnalogPinReporting(arg2); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_getValueFromTwo7bitBytes(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ;
  unsigned char arg2 ; unsigned char arg3 ; int result; SWIG_check_num_args("ofArduino::getValueFromTwo7bitBytes",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::getValueFromTwo7bitBytes",1,"ofArduino *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofArduino::getValueFromTwo7bitBytes",2,"unsigned char");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofArduino::getValueFromTwo7bitBytes",3,"unsigned char");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_getValueFromTwo7bitBytes",1,SWIGTYPE_p_ofArduino); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (unsigned char)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (unsigned char)lua_tonumber(L, 3);
  result = (int)(arg1)->getValueFromTwo7bitBytes(arg2,arg3); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_getInvertedValueFromTwo7bitBytes(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ;
  unsigned char arg2 ; unsigned char arg3 ; int result; SWIG_check_num_args("ofArduino::getInvertedValueFromTwo7bitBytes",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::getInvertedValueFromTwo7bitBytes",1,"ofArduino *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofArduino::getInvertedValueFromTwo7bitBytes",2,"unsigned char");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofArduino::getInvertedValueFromTwo7bitBytes",3,"unsigned char");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_getInvertedValueFromTwo7bitBytes",1,SWIGTYPE_p_ofArduino); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (unsigned char)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (unsigned char)lua_tonumber(L, 3);
  result = (int)(arg1)->getInvertedValueFromTwo7bitBytes(arg2,arg3); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_EDigitalPinChanged_set(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ;
  ofEvent< int const > arg2 ; ofEvent< int const > *argp2 ; SWIG_check_num_args("ofArduino::EDigitalPinChanged",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::EDigitalPinChanged",1,"ofArduino *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofArduino::EDigitalPinChanged",2,"ofEvent< int const >");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_EDigitalPinChanged_set",1,SWIGTYPE_p_ofArduino); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_ofEventT_int_const_t,0))){
    SWIG_fail_ptr("Arduino_EDigitalPinChanged_set",2,SWIGTYPE_p_ofEventT_int_const_t); }  arg2 = *argp2;
  if (arg1) (arg1)->EDigitalPinChanged = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_EDigitalPinChanged_get(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ;
  ofEvent< int const > result; SWIG_check_num_args("ofArduino::EDigitalPinChanged",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::EDigitalPinChanged",1,"ofArduino *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_EDigitalPinChanged_get",1,SWIGTYPE_p_ofArduino); }  result =  ((arg1)->EDigitalPinChanged); {
    ofEvent< int const > * resultptr = new ofEvent< int const >((const ofEvent< int const > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofEventT_int_const_t,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_EAnalogPinChanged_set(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ;
  ofEvent< int const > arg2 ; ofEvent< int const > *argp2 ; SWIG_check_num_args("ofArduino::EAnalogPinChanged",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::EAnalogPinChanged",1,"ofArduino *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofArduino::EAnalogPinChanged",2,"ofEvent< int const >");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_EAnalogPinChanged_set",1,SWIGTYPE_p_ofArduino); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_ofEventT_int_const_t,0))){
    SWIG_fail_ptr("Arduino_EAnalogPinChanged_set",2,SWIGTYPE_p_ofEventT_int_const_t); }  arg2 = *argp2;
  if (arg1) (arg1)->EAnalogPinChanged = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_EAnalogPinChanged_get(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ;
  ofEvent< int const > result; SWIG_check_num_args("ofArduino::EAnalogPinChanged",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::EAnalogPinChanged",1,"ofArduino *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_EAnalogPinChanged_get",1,SWIGTYPE_p_ofArduino); }  result =  ((arg1)->EAnalogPinChanged); {
    ofEvent< int const > * resultptr = new ofEvent< int const >((const ofEvent< int const > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofEventT_int_const_t,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_ESysExReceived_set(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ;
  ofEvent< std::vector< unsigned char > const > *arg2 = (ofEvent< std::vector< unsigned char > const > *) 0 ;
  SWIG_check_num_args("ofArduino::ESysExReceived",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::ESysExReceived",1,"ofArduino *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofArduino::ESysExReceived",2,"ofEvent< std::vector< unsigned char > const > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_ESysExReceived_set",1,SWIGTYPE_p_ofArduino); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofEventT_std__vectorT_unsigned_char_t_const_t,0))){
    SWIG_fail_ptr("Arduino_ESysExReceived_set",2,SWIGTYPE_p_ofEventT_std__vectorT_unsigned_char_t_const_t); } 
  if (arg1) (arg1)->ESysExReceived = *arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_ESysExReceived_get(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ;
  ofEvent< std::vector< unsigned char > const > *result = 0 ; SWIG_check_num_args("ofArduino::ESysExReceived",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::ESysExReceived",1,"ofArduino *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_ESysExReceived_get",1,SWIGTYPE_p_ofArduino); } 
  result = (ofEvent< std::vector< unsigned char > const > *)& ((arg1)->ESysExReceived);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofEventT_std__vectorT_unsigned_char_t_const_t,0); SWIG_arg++;  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_EFirmwareVersionReceived_set(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ;
  ofEvent< int const > arg2 ; ofEvent< int const > *argp2 ; SWIG_check_num_args("ofArduino::EFirmwareVersionReceived",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::EFirmwareVersionReceived",1,"ofArduino *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofArduino::EFirmwareVersionReceived",2,"ofEvent< int const >");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_EFirmwareVersionReceived_set",1,SWIGTYPE_p_ofArduino); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_ofEventT_int_const_t,0))){
    SWIG_fail_ptr("Arduino_EFirmwareVersionReceived_set",2,SWIGTYPE_p_ofEventT_int_const_t); }  arg2 = *argp2;
  if (arg1) (arg1)->EFirmwareVersionReceived = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_EFirmwareVersionReceived_get(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ;
  ofEvent< int const > result; SWIG_check_num_args("ofArduino::EFirmwareVersionReceived",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::EFirmwareVersionReceived",1,"ofArduino *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_EFirmwareVersionReceived_get",1,SWIGTYPE_p_ofArduino); } 
  result =  ((arg1)->EFirmwareVersionReceived); {
    ofEvent< int const > * resultptr = new ofEvent< int const >((const ofEvent< int const > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofEventT_int_const_t,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_EInitialized_set(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ;
  ofEvent< int const > arg2 ; ofEvent< int const > *argp2 ; SWIG_check_num_args("ofArduino::EInitialized",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::EInitialized",1,"ofArduino *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofArduino::EInitialized",2,"ofEvent< int const >");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_EInitialized_set",1,SWIGTYPE_p_ofArduino); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_ofEventT_int_const_t,0))){
    SWIG_fail_ptr("Arduino_EInitialized_set",2,SWIGTYPE_p_ofEventT_int_const_t); }  arg2 = *argp2;
  if (arg1) (arg1)->EInitialized = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_EInitialized_get(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ;
  ofEvent< int const > result; SWIG_check_num_args("ofArduino::EInitialized",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::EInitialized",1,"ofArduino *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_EInitialized_get",1,SWIGTYPE_p_ofArduino); }  result =  ((arg1)->EInitialized); {
    ofEvent< int const > * resultptr = new ofEvent< int const >((const ofEvent< int const > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofEventT_int_const_t,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_EStringReceived_set(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ;
  ofEvent< std::string const > *arg2 = (ofEvent< std::string const > *) 0 ;
  SWIG_check_num_args("ofArduino::EStringReceived",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::EStringReceived",1,"ofArduino *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofArduino::EStringReceived",2,"ofEvent< std::string const > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_EStringReceived_set",1,SWIGTYPE_p_ofArduino); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofEventT_std__string_const_t,0))){
    SWIG_fail_ptr("Arduino_EStringReceived_set",2,SWIGTYPE_p_ofEventT_std__string_const_t); } 
  if (arg1) (arg1)->EStringReceived = *arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_EStringReceived_get(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ;
  ofEvent< std::string const > *result = 0 ; SWIG_check_num_args("ofArduino::EStringReceived",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::EStringReceived",1,"ofArduino *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_EStringReceived_get",1,SWIGTYPE_p_ofArduino); } 
  result = (ofEvent< std::string const > *)& ((arg1)->EStringReceived);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofEventT_std__string_const_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_EStepperDataReceived_set(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ;
  ofEvent< Firmata_Stepper_Data const > *arg2 = (ofEvent< Firmata_Stepper_Data const > *) 0 ;
  SWIG_check_num_args("ofArduino::EStepperDataReceived",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::EStepperDataReceived",1,"ofArduino *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofArduino::EStepperDataReceived",2,"ofEvent< Firmata_Stepper_Data const > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_EStepperDataReceived_set",1,SWIGTYPE_p_ofArduino); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofEventT_Firmata_Stepper_Data_const_t,0))){
    SWIG_fail_ptr("Arduino_EStepperDataReceived_set",2,SWIGTYPE_p_ofEventT_Firmata_Stepper_Data_const_t); } 
  if (arg1) (arg1)->EStepperDataReceived = *arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_EStepperDataReceived_get(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ;
  ofEvent< Firmata_Stepper_Data const > *result = 0 ; SWIG_check_num_args("ofArduino::EStepperDataReceived",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::EStepperDataReceived",1,"ofArduino *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_EStepperDataReceived_get",1,SWIGTYPE_p_ofArduino); } 
  result = (ofEvent< Firmata_Stepper_Data const > *)& ((arg1)->EStepperDataReceived);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofEventT_Firmata_Stepper_Data_const_t,0); SWIG_arg++;  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_EI2CDataRecieved_set(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ;
  ofEvent< Firmata_I2C_Data const > *arg2 = (ofEvent< Firmata_I2C_Data const > *) 0 ;
  SWIG_check_num_args("ofArduino::EI2CDataRecieved",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::EI2CDataRecieved",1,"ofArduino *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofArduino::EI2CDataRecieved",2,"ofEvent< Firmata_I2C_Data const > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_EI2CDataRecieved_set",1,SWIGTYPE_p_ofArduino); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofEventT_Firmata_I2C_Data_const_t,0))){
    SWIG_fail_ptr("Arduino_EI2CDataRecieved_set",2,SWIGTYPE_p_ofEventT_Firmata_I2C_Data_const_t); } 
  if (arg1) (arg1)->EI2CDataRecieved = *arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_EI2CDataRecieved_get(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ;
  ofEvent< Firmata_I2C_Data const > *result = 0 ; SWIG_check_num_args("ofArduino::EI2CDataRecieved",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::EI2CDataRecieved",1,"ofArduino *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_EI2CDataRecieved_get",1,SWIGTYPE_p_ofArduino); } 
  result = (ofEvent< Firmata_I2C_Data const > *)& ((arg1)->EI2CDataRecieved);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofEventT_Firmata_I2C_Data_const_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_EEncoderDataReceived_set(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ;
  ofEvent< std::vector< Firmata_Encoder_Data > const > *arg2 = (ofEvent< std::vector< Firmata_Encoder_Data > const > *) 0 ;
  SWIG_check_num_args("ofArduino::EEncoderDataReceived",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::EEncoderDataReceived",1,"ofArduino *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofArduino::EEncoderDataReceived",2,"ofEvent< std::vector< Firmata_Encoder_Data > const > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_EEncoderDataReceived_set",1,SWIGTYPE_p_ofArduino); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofEventT_std__vectorT_Firmata_Encoder_Data_t_const_t,0))){
    SWIG_fail_ptr("Arduino_EEncoderDataReceived_set",2,SWIGTYPE_p_ofEventT_std__vectorT_Firmata_Encoder_Data_t_const_t); } 
  if (arg1) (arg1)->EEncoderDataReceived = *arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_EEncoderDataReceived_get(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ;
  ofEvent< std::vector< Firmata_Encoder_Data > const > *result = 0 ; SWIG_check_num_args("ofArduino::EEncoderDataReceived",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::EEncoderDataReceived",1,"ofArduino *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_EEncoderDataReceived_get",1,SWIGTYPE_p_ofArduino); } 
  result = (ofEvent< std::vector< Firmata_Encoder_Data > const > *)& ((arg1)->EEncoderDataReceived);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofEventT_std__vectorT_Firmata_Encoder_Data_t_const_t,0); SWIG_arg++;  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_ESerialDataReceived_set(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ;
  ofEvent< Firmata_Serial_Data const > *arg2 = (ofEvent< Firmata_Serial_Data const > *) 0 ;
  SWIG_check_num_args("ofArduino::ESerialDataReceived",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::ESerialDataReceived",1,"ofArduino *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofArduino::ESerialDataReceived",2,"ofEvent< Firmata_Serial_Data const > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_ESerialDataReceived_set",1,SWIGTYPE_p_ofArduino); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofEventT_Firmata_Serial_Data_const_t,0))){
    SWIG_fail_ptr("Arduino_ESerialDataReceived_set",2,SWIGTYPE_p_ofEventT_Firmata_Serial_Data_const_t); } 
  if (arg1) (arg1)->ESerialDataReceived = *arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_ESerialDataReceived_get(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ;
  ofEvent< Firmata_Serial_Data const > *result = 0 ; SWIG_check_num_args("ofArduino::ESerialDataReceived",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::ESerialDataReceived",1,"ofArduino *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_ESerialDataReceived_get",1,SWIGTYPE_p_ofArduino); } 
  result = (ofEvent< Firmata_Serial_Data const > *)& ((arg1)->ESerialDataReceived);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofEventT_Firmata_Serial_Data_const_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_EPinStateResponseReceived_set(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ;
  ofEvent< std::pair< int,Firmata_Pin_Modes > const > arg2 ; ofEvent< std::pair< int,Firmata_Pin_Modes > const > *argp2 ;
  SWIG_check_num_args("ofArduino::EPinStateResponseReceived",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::EPinStateResponseReceived",1,"ofArduino *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofArduino::EPinStateResponseReceived",2,"ofEvent< std::pair< int,Firmata_Pin_Modes > const >");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_EPinStateResponseReceived_set",1,SWIGTYPE_p_ofArduino); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_ofEventT_std__pairT_int_Firmata_Pin_Modes_t_const_t,0))){
    SWIG_fail_ptr("Arduino_EPinStateResponseReceived_set",2,SWIGTYPE_p_ofEventT_std__pairT_int_Firmata_Pin_Modes_t_const_t); } 
  arg2 = *argp2; if (arg1) (arg1)->EPinStateResponseReceived = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Arduino_EPinStateResponseReceived_get(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ;
  ofEvent< std::pair< int,Firmata_Pin_Modes > const > result; SWIG_check_num_args("ofArduino::EPinStateResponseReceived",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::EPinStateResponseReceived",1,"ofArduino *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_EPinStateResponseReceived_get",1,SWIGTYPE_p_ofArduino); } 
  result =  ((arg1)->EPinStateResponseReceived); {
    ofEvent< std::pair< int,Firmata_Pin_Modes > const > * resultptr = new ofEvent< std::pair< int,Firmata_Pin_Modes > const >((const ofEvent< std::pair< int,Firmata_Pin_Modes > const > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofEventT_std__pairT_int_Firmata_Pin_Modes_t_const_t,1); SWIG_arg++; } 
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_sendServo__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ; int arg2 ;
  int arg3 ; bool arg4 ; SWIG_check_num_args("ofArduino::sendServo",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::sendServo",1,"ofArduino *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofArduino::sendServo",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofArduino::sendServo",3,"int");
  if(!lua_isboolean(L,4)) SWIG_fail_arg("ofArduino::sendServo",4,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_sendServo",1,SWIGTYPE_p_ofArduino); }  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3); arg4 = (lua_toboolean(L, 4)!=0); (arg1)->sendServo(arg2,arg3,arg4); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_sendServo__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ; int arg2 ;
  int arg3 ; SWIG_check_num_args("ofArduino::sendServo",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::sendServo",1,"ofArduino *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofArduino::sendServo",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofArduino::sendServo",3,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_sendServo",1,SWIGTYPE_p_ofArduino); }  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3); (arg1)->sendServo(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Arduino_sendServo(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L); if (argc == 3) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofArduino, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_Arduino_sendServo__SWIG_1(L);}  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofArduino, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          { _v = lua_isboolean(L,argv[3]); }  if (_v) { return _wrap_Arduino_sendServo__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Arduino_sendServo'\n" "  Possible C/C++ prototypes are:\n"
  "    ofArduino::sendServo(int,int,bool)\n" "    ofArduino::sendServo(int,int)\n"); lua_error(L);return 0; }
static int _wrap_Arduino_sendServoAttach__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ;
  int arg2 ; int arg3 ; int arg4 ; SWIG_check_num_args("ofArduino::sendServoAttach",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::sendServoAttach",1,"ofArduino *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofArduino::sendServoAttach",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofArduino::sendServoAttach",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofArduino::sendServoAttach",4,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_sendServoAttach",1,SWIGTYPE_p_ofArduino); }  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3); arg4 = (int)lua_tonumber(L, 4); (arg1)->sendServoAttach(arg2,arg3,arg4); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_sendServoAttach__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ;
  int arg2 ; int arg3 ; SWIG_check_num_args("ofArduino::sendServoAttach",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::sendServoAttach",1,"ofArduino *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofArduino::sendServoAttach",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofArduino::sendServoAttach",3,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_sendServoAttach",1,SWIGTYPE_p_ofArduino); }  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3); (arg1)->sendServoAttach(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Arduino_sendServoAttach__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ;
  int arg2 ; SWIG_check_num_args("ofArduino::sendServoAttach",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::sendServoAttach",1,"ofArduino *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofArduino::sendServoAttach",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_sendServoAttach",1,SWIGTYPE_p_ofArduino); }  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->sendServoAttach(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_sendServoAttach(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L);
  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofArduino, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_Arduino_sendServoAttach__SWIG_2(L);}  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofArduino, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_Arduino_sendServoAttach__SWIG_1(L);}  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofArduino, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          { _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_Arduino_sendServoAttach__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Arduino_sendServoAttach'\n"
  "  Possible C/C++ prototypes are:\n" "    ofArduino::sendServoAttach(int,int,int)\n"
  "    ofArduino::sendServoAttach(int,int)\n" "    ofArduino::sendServoAttach(int)\n"); lua_error(L);return 0; }
static int _wrap_Arduino_getServo(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ; int arg2 ; int result;
  SWIG_check_num_args("ofArduino::getServo",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::getServo",1,"ofArduino const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofArduino::getServo",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_getServo",1,SWIGTYPE_p_ofArduino); }  arg2 = (int)lua_tonumber(L, 2);
  result = (int)((ofArduino const *)arg1)->getServo(arg2); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_sendStepper2Wire__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ;
  int arg2 ; int arg3 ; int arg4 ; SWIG_check_num_args("ofArduino::sendStepper2Wire",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::sendStepper2Wire",1,"ofArduino *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofArduino::sendStepper2Wire",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofArduino::sendStepper2Wire",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofArduino::sendStepper2Wire",4,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_sendStepper2Wire",1,SWIGTYPE_p_ofArduino); }  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3); arg4 = (int)lua_tonumber(L, 4); (arg1)->sendStepper2Wire(arg2,arg3,arg4); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_sendStepper2Wire__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ;
  int arg2 ; int arg3 ; SWIG_check_num_args("ofArduino::sendStepper2Wire",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::sendStepper2Wire",1,"ofArduino *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofArduino::sendStepper2Wire",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofArduino::sendStepper2Wire",3,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_sendStepper2Wire",1,SWIGTYPE_p_ofArduino); }  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3); (arg1)->sendStepper2Wire(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Arduino_sendStepper2Wire(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L);
  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofArduino, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_Arduino_sendStepper2Wire__SWIG_1(L);}  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofArduino, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          { _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_Arduino_sendStepper2Wire__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Arduino_sendStepper2Wire'\n"
  "  Possible C/C++ prototypes are:\n" "    ofArduino::sendStepper2Wire(int,int,int)\n"
  "    ofArduino::sendStepper2Wire(int,int)\n"); lua_error(L);return 0; }
static int _wrap_Arduino_sendStepper4Wire__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ;
  int arg2 ; int arg3 ; int arg4 ; int arg5 ; int arg6 ; SWIG_check_num_args("ofArduino::sendStepper4Wire",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::sendStepper4Wire",1,"ofArduino *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofArduino::sendStepper4Wire",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofArduino::sendStepper4Wire",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofArduino::sendStepper4Wire",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofArduino::sendStepper4Wire",5,"int");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofArduino::sendStepper4Wire",6,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_sendStepper4Wire",1,SWIGTYPE_p_ofArduino); }  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3); arg4 = (int)lua_tonumber(L, 4); arg5 = (int)lua_tonumber(L, 5);
  arg6 = (int)lua_tonumber(L, 6); (arg1)->sendStepper4Wire(arg2,arg3,arg4,arg5,arg6); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_sendStepper4Wire__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ;
  int arg2 ; int arg3 ; int arg4 ; int arg5 ; SWIG_check_num_args("ofArduino::sendStepper4Wire",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::sendStepper4Wire",1,"ofArduino *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofArduino::sendStepper4Wire",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofArduino::sendStepper4Wire",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofArduino::sendStepper4Wire",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofArduino::sendStepper4Wire",5,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_sendStepper4Wire",1,SWIGTYPE_p_ofArduino); }  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3); arg4 = (int)lua_tonumber(L, 4); arg5 = (int)lua_tonumber(L, 5);
  (arg1)->sendStepper4Wire(arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_sendStepper4Wire(lua_State* L) { int argc; int argv[7]={ 1,2,3,4,5,6,7} ; argc = lua_gettop(L);
  if (argc == 5) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofArduino, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) {
              return _wrap_Arduino_sendStepper4Wire__SWIG_1(L);}  }  }  }  }  }  if (argc == 6) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofArduino, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) { {
                _v = lua_isnumber(L,argv[5]); }  if (_v) { return _wrap_Arduino_sendStepper4Wire__SWIG_0(L);}  }  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Arduino_sendStepper4Wire'\n"
  "  Possible C/C++ prototypes are:\n" "    ofArduino::sendStepper4Wire(int,int,int,int,int)\n"
  "    ofArduino::sendStepper4Wire(int,int,int,int)\n"); lua_error(L);return 0; }
static int _wrap_Arduino_sendStepperMove__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ;
  int arg2 ; int arg3 ; int arg4 ; int arg5 ; float arg6 ; float arg7 ; SWIG_check_num_args("ofArduino::sendStepperMove",7,7)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::sendStepperMove",1,"ofArduino *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofArduino::sendStepperMove",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofArduino::sendStepperMove",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofArduino::sendStepperMove",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofArduino::sendStepperMove",5,"int");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofArduino::sendStepperMove",6,"float");
  if(!lua_isnumber(L,7)) SWIG_fail_arg("ofArduino::sendStepperMove",7,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_sendStepperMove",1,SWIGTYPE_p_ofArduino); }  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3); arg4 = (int)lua_tonumber(L, 4); arg5 = (int)lua_tonumber(L, 5);
  arg6 = (float)lua_tonumber(L, 6); arg7 = (float)lua_tonumber(L, 7); (arg1)->sendStepperMove(arg2,arg3,arg4,arg5,arg6,arg7);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_sendStepperMove__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ;
  int arg2 ; int arg3 ; int arg4 ; int arg5 ; float arg6 ; SWIG_check_num_args("ofArduino::sendStepperMove",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::sendStepperMove",1,"ofArduino *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofArduino::sendStepperMove",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofArduino::sendStepperMove",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofArduino::sendStepperMove",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofArduino::sendStepperMove",5,"int");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofArduino::sendStepperMove",6,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_sendStepperMove",1,SWIGTYPE_p_ofArduino); }  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3); arg4 = (int)lua_tonumber(L, 4); arg5 = (int)lua_tonumber(L, 5);
  arg6 = (float)lua_tonumber(L, 6); (arg1)->sendStepperMove(arg2,arg3,arg4,arg5,arg6); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_sendStepperMove__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ;
  int arg2 ; int arg3 ; int arg4 ; int arg5 ; SWIG_check_num_args("ofArduino::sendStepperMove",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::sendStepperMove",1,"ofArduino *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofArduino::sendStepperMove",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofArduino::sendStepperMove",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofArduino::sendStepperMove",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofArduino::sendStepperMove",5,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_sendStepperMove",1,SWIGTYPE_p_ofArduino); }  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3); arg4 = (int)lua_tonumber(L, 4); arg5 = (int)lua_tonumber(L, 5);
  (arg1)->sendStepperMove(arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_sendStepperMove__SWIG_3(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ;
  int arg2 ; int arg3 ; int arg4 ; SWIG_check_num_args("ofArduino::sendStepperMove",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::sendStepperMove",1,"ofArduino *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofArduino::sendStepperMove",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofArduino::sendStepperMove",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofArduino::sendStepperMove",4,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_sendStepperMove",1,SWIGTYPE_p_ofArduino); }  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3); arg4 = (int)lua_tonumber(L, 4); (arg1)->sendStepperMove(arg2,arg3,arg4); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_sendStepperMove(lua_State* L) { int argc; int argv[8]={ 1,2,3,4,5,6,7,8} ; argc = lua_gettop(L);
  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofArduino, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          { _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_Arduino_sendStepperMove__SWIG_3(L);}  }  }  }  } 
  if (argc == 5) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofArduino, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) {
              return _wrap_Arduino_sendStepperMove__SWIG_2(L);}  }  }  }  }  }  if (argc == 6) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofArduino, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) { {
                _v = lua_isnumber(L,argv[5]); }  if (_v) { return _wrap_Arduino_sendStepperMove__SWIG_1(L);}  }  }  }  }  }  } 
  if (argc == 7) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofArduino, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) { {
                _v = lua_isnumber(L,argv[5]); }  if (_v) { { _v = lua_isnumber(L,argv[6]); }  if (_v) {
                  return _wrap_Arduino_sendStepperMove__SWIG_0(L);}  }  }  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Arduino_sendStepperMove'\n"
  "  Possible C/C++ prototypes are:\n" "    ofArduino::sendStepperMove(int,int,int,int,float,float)\n"
  "    ofArduino::sendStepperMove(int,int,int,int,float)\n" "    ofArduino::sendStepperMove(int,int,int,int)\n"
  "    ofArduino::sendStepperMove(int,int,int)\n"); lua_error(L);return 0; }
static int _wrap_Arduino_sendI2CConfig(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ; int arg2 ;
  SWIG_check_num_args("ofArduino::sendI2CConfig",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::sendI2CConfig",1,"ofArduino *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofArduino::sendI2CConfig",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_sendI2CConfig",1,SWIGTYPE_p_ofArduino); }  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->sendI2CConfig(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_isI2CConfigured(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ; bool result;
  SWIG_check_num_args("ofArduino::isI2CConfigured",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::isI2CConfigured",1,"ofArduino *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_isI2CConfigured",1,SWIGTYPE_p_ofArduino); }  result = (bool)(arg1)->isI2CConfigured();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_sendI2CWriteRequest__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ;
  char arg2 ; char *arg3 = (char *) 0 ; int arg4 ; int arg5 ; SWIG_check_num_args("ofArduino::sendI2CWriteRequest",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::sendI2CWriteRequest",1,"ofArduino *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("ofArduino::sendI2CWriteRequest",2,"char");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("ofArduino::sendI2CWriteRequest",3,"char const *");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofArduino::sendI2CWriteRequest",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofArduino::sendI2CWriteRequest",5,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_sendI2CWriteRequest",1,SWIGTYPE_p_ofArduino); }  arg2 = (lua_tostring(L, 2))[0];
  arg3 = (char *)lua_tostring(L, 3); arg4 = (int)lua_tonumber(L, 4); arg5 = (int)lua_tonumber(L, 5);
  (arg1)->sendI2CWriteRequest(arg2,(char const *)arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Arduino_sendI2CWriteRequest__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ;
  char arg2 ; char *arg3 = (char *) 0 ; int arg4 ; SWIG_check_num_args("ofArduino::sendI2CWriteRequest",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::sendI2CWriteRequest",1,"ofArduino *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("ofArduino::sendI2CWriteRequest",2,"char");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("ofArduino::sendI2CWriteRequest",3,"char const *");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofArduino::sendI2CWriteRequest",4,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_sendI2CWriteRequest",1,SWIGTYPE_p_ofArduino); }  arg2 = (lua_tostring(L, 2))[0];
  arg3 = (char *)lua_tostring(L, 3); arg4 = (int)lua_tonumber(L, 4); (arg1)->sendI2CWriteRequest(arg2,(char const *)arg3,arg4);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_sendI2CWriteRequest(lua_State* L) { int argc; int argv[6]={ 1,2,3,4,5,6} ; argc = lua_gettop(L);
  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofArduino, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = SWIG_lua_isnilstring(L,argv[1]) && (lua_rawlen(L,argv[1])==1); }  if (_v) { {
          _v = SWIG_lua_isnilstring(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) {
            return _wrap_Arduino_sendI2CWriteRequest__SWIG_1(L);}  }  }  }  }  if (argc == 5) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofArduino, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = SWIG_lua_isnilstring(L,argv[1]) && (lua_rawlen(L,argv[1])==1); }  if (_v) { {
          _v = SWIG_lua_isnilstring(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { {
              _v = lua_isnumber(L,argv[4]); }  if (_v) { return _wrap_Arduino_sendI2CWriteRequest__SWIG_0(L);}  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Arduino_sendI2CWriteRequest'\n"
  "  Possible C/C++ prototypes are:\n" "    ofArduino::sendI2CWriteRequest(char,char const *,int,int)\n"
  "    ofArduino::sendI2CWriteRequest(char,char const *,int)\n"); lua_error(L);return 0; }
static int _wrap_Arduino_sendI2CReadRequest__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ;
  char arg2 ; int arg3 ; int arg4 ; SWIG_check_num_args("ofArduino::sendI2CReadRequest",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::sendI2CReadRequest",1,"ofArduino *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("ofArduino::sendI2CReadRequest",2,"char");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofArduino::sendI2CReadRequest",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofArduino::sendI2CReadRequest",4,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_sendI2CReadRequest",1,SWIGTYPE_p_ofArduino); }  arg2 = (lua_tostring(L, 2))[0];
  arg3 = (int)lua_tonumber(L, 3); arg4 = (int)lua_tonumber(L, 4); (arg1)->sendI2CReadRequest(arg2,arg3,arg4); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_sendI2CReadRequest__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ;
  char arg2 ; int arg3 ; SWIG_check_num_args("ofArduino::sendI2CReadRequest",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::sendI2CReadRequest",1,"ofArduino *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("ofArduino::sendI2CReadRequest",2,"char");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofArduino::sendI2CReadRequest",3,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_sendI2CReadRequest",1,SWIGTYPE_p_ofArduino); }  arg2 = (lua_tostring(L, 2))[0];
  arg3 = (int)lua_tonumber(L, 3); (arg1)->sendI2CReadRequest(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Arduino_sendI2CReadRequest(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L);
  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofArduino, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = SWIG_lua_isnilstring(L,argv[1]) && (lua_rawlen(L,argv[1])==1); }  if (_v) { {
          _v = lua_isnumber(L,argv[2]); }  if (_v) { return _wrap_Arduino_sendI2CReadRequest__SWIG_1(L);}  }  }  } 
  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofArduino, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = SWIG_lua_isnilstring(L,argv[1]) && (lua_rawlen(L,argv[1])==1); }  if (_v) { {
          _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) {
            return _wrap_Arduino_sendI2CReadRequest__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Arduino_sendI2CReadRequest'\n"
  "  Possible C/C++ prototypes are:\n" "    ofArduino::sendI2CReadRequest(char,int,int)\n"
  "    ofArduino::sendI2CReadRequest(char,int)\n"); lua_error(L);return 0; }
static int _wrap_Arduino_sendI2ContinuousReadRequest__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofArduino *arg1 = (ofArduino *) 0 ; char arg2 ; int arg3 ; int arg4 ;
  SWIG_check_num_args("ofArduino::sendI2ContinuousReadRequest",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::sendI2ContinuousReadRequest",1,"ofArduino *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("ofArduino::sendI2ContinuousReadRequest",2,"char");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofArduino::sendI2ContinuousReadRequest",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofArduino::sendI2ContinuousReadRequest",4,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_sendI2ContinuousReadRequest",1,SWIGTYPE_p_ofArduino); }  arg2 = (lua_tostring(L, 2))[0];
  arg3 = (int)lua_tonumber(L, 3); arg4 = (int)lua_tonumber(L, 4); (arg1)->sendI2ContinuousReadRequest(arg2,arg3,arg4);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_sendI2ContinuousReadRequest__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofArduino *arg1 = (ofArduino *) 0 ; char arg2 ; int arg3 ; SWIG_check_num_args("ofArduino::sendI2ContinuousReadRequest",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::sendI2ContinuousReadRequest",1,"ofArduino *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("ofArduino::sendI2ContinuousReadRequest",2,"char");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofArduino::sendI2ContinuousReadRequest",3,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_sendI2ContinuousReadRequest",1,SWIGTYPE_p_ofArduino); }  arg2 = (lua_tostring(L, 2))[0];
  arg3 = (int)lua_tonumber(L, 3); (arg1)->sendI2ContinuousReadRequest(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_sendI2ContinuousReadRequest(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L);
  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofArduino, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = SWIG_lua_isnilstring(L,argv[1]) && (lua_rawlen(L,argv[1])==1); }  if (_v) { {
          _v = lua_isnumber(L,argv[2]); }  if (_v) { return _wrap_Arduino_sendI2ContinuousReadRequest__SWIG_1(L);}  }  }  } 
  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofArduino, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = SWIG_lua_isnilstring(L,argv[1]) && (lua_rawlen(L,argv[1])==1); }  if (_v) { {
          _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) {
            return _wrap_Arduino_sendI2ContinuousReadRequest__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Arduino_sendI2ContinuousReadRequest'\n"
  "  Possible C/C++ prototypes are:\n" "    ofArduino::sendI2ContinuousReadRequest(char,int,int)\n"
  "    ofArduino::sendI2ContinuousReadRequest(char,int)\n"); lua_error(L);return 0; }
static int _wrap_Arduino_sendOneWireConfig(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ; int arg2 ;
  bool arg3 ; SWIG_check_num_args("ofArduino::sendOneWireConfig",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::sendOneWireConfig",1,"ofArduino *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofArduino::sendOneWireConfig",2,"int");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("ofArduino::sendOneWireConfig",3,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_sendOneWireConfig",1,SWIGTYPE_p_ofArduino); }  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (lua_toboolean(L, 3)!=0); (arg1)->sendOneWireConfig(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Arduino_sendOneWireSearch__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ;
  int arg2 ; SWIG_check_num_args("ofArduino::sendOneWireSearch",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::sendOneWireSearch",1,"ofArduino *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofArduino::sendOneWireSearch",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_sendOneWireSearch",1,SWIGTYPE_p_ofArduino); }  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->sendOneWireSearch(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_sendOneWireAlarmsSearch(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ;
  int arg2 ; SWIG_check_num_args("ofArduino::sendOneWireAlarmsSearch",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::sendOneWireAlarmsSearch",1,"ofArduino *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofArduino::sendOneWireAlarmsSearch",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_sendOneWireAlarmsSearch",1,SWIGTYPE_p_ofArduino); }  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->sendOneWireAlarmsSearch(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_sendOneWireSearch__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ;
  char arg2 ; int arg3 ; SWIG_check_num_args("ofArduino::sendOneWireSearch",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::sendOneWireSearch",1,"ofArduino *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("ofArduino::sendOneWireSearch",2,"char");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofArduino::sendOneWireSearch",3,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_sendOneWireSearch",1,SWIGTYPE_p_ofArduino); }  arg2 = (lua_tostring(L, 2))[0];
  arg3 = (int)lua_tonumber(L, 3); (arg1)->sendOneWireSearch(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Arduino_sendOneWireSearch(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L);
  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofArduino, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_Arduino_sendOneWireSearch__SWIG_0(L);}  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofArduino, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = SWIG_lua_isnilstring(L,argv[1]) && (lua_rawlen(L,argv[1])==1); }  if (_v) { {
          _v = lua_isnumber(L,argv[2]); }  if (_v) { return _wrap_Arduino_sendOneWireSearch__SWIG_1(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Arduino_sendOneWireSearch'\n"
  "  Possible C/C++ prototypes are:\n" "    ofArduino::sendOneWireSearch(int)\n"
  "    ofArduino::sendOneWireSearch(char,int)\n"); lua_error(L);return 0; }
static int _wrap_Arduino_sendOneWireRead(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ; int arg2 ;
  std::vector< unsigned char > arg3 ; int arg4 ; std::vector< unsigned char > *argp3 ;
  SWIG_check_num_args("ofArduino::sendOneWireRead",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::sendOneWireRead",1,"ofArduino *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofArduino::sendOneWireRead",2,"int");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofArduino::sendOneWireRead",3,"std::vector< unsigned char >");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofArduino::sendOneWireRead",4,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_sendOneWireRead",1,SWIGTYPE_p_ofArduino); }  arg2 = (int)lua_tonumber(L, 2);
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_std__vectorT_unsigned_char_t,0))){
    SWIG_fail_ptr("Arduino_sendOneWireRead",3,SWIGTYPE_p_std__vectorT_unsigned_char_t); }  arg3 = *argp3;
  arg4 = (int)lua_tonumber(L, 4); (arg1)->sendOneWireRead(arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Arduino_sendOneWireReset(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ; int arg2 ;
  SWIG_check_num_args("ofArduino::sendOneWireReset",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::sendOneWireReset",1,"ofArduino *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofArduino::sendOneWireReset",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_sendOneWireReset",1,SWIGTYPE_p_ofArduino); }  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->sendOneWireReset(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_sendOneWireWrite(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ; int arg2 ;
  std::vector< unsigned char > arg3 ; std::vector< unsigned char > arg4 ; std::vector< unsigned char > *argp3 ;
  std::vector< unsigned char > *argp4 ; SWIG_check_num_args("ofArduino::sendOneWireWrite",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::sendOneWireWrite",1,"ofArduino *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofArduino::sendOneWireWrite",2,"int");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofArduino::sendOneWireWrite",3,"std::vector< unsigned char >");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("ofArduino::sendOneWireWrite",4,"std::vector< unsigned char >");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_sendOneWireWrite",1,SWIGTYPE_p_ofArduino); }  arg2 = (int)lua_tonumber(L, 2);
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_std__vectorT_unsigned_char_t,0))){
    SWIG_fail_ptr("Arduino_sendOneWireWrite",3,SWIGTYPE_p_std__vectorT_unsigned_char_t); }  arg3 = *argp3;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&argp4,SWIGTYPE_p_std__vectorT_unsigned_char_t,0))){
    SWIG_fail_ptr("Arduino_sendOneWireWrite",4,SWIGTYPE_p_std__vectorT_unsigned_char_t); }  arg4 = *argp4;
  (arg1)->sendOneWireWrite(arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_sendOneWireDelay(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ; int arg2 ;
  unsigned int arg3 ; SWIG_check_num_args("ofArduino::sendOneWireDelay",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::sendOneWireDelay",1,"ofArduino *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofArduino::sendOneWireDelay",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofArduino::sendOneWireDelay",3,"unsigned int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_sendOneWireDelay",1,SWIGTYPE_p_ofArduino); }  arg2 = (int)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (unsigned int)lua_tonumber(L, 3);
  (arg1)->sendOneWireDelay(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_sendOneWireWriteAndRead(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ;
  int arg2 ; std::vector< unsigned char > arg3 ; std::vector< unsigned char > arg4 ; int arg5 ;
  std::vector< unsigned char > *argp3 ; std::vector< unsigned char > *argp4 ;
  SWIG_check_num_args("ofArduino::sendOneWireWriteAndRead",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::sendOneWireWriteAndRead",1,"ofArduino *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofArduino::sendOneWireWriteAndRead",2,"int");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofArduino::sendOneWireWriteAndRead",3,"std::vector< unsigned char >");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("ofArduino::sendOneWireWriteAndRead",4,"std::vector< unsigned char >");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofArduino::sendOneWireWriteAndRead",5,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_sendOneWireWriteAndRead",1,SWIGTYPE_p_ofArduino); }  arg2 = (int)lua_tonumber(L, 2);
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_std__vectorT_unsigned_char_t,0))){
    SWIG_fail_ptr("Arduino_sendOneWireWriteAndRead",3,SWIGTYPE_p_std__vectorT_unsigned_char_t); }  arg3 = *argp3;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&argp4,SWIGTYPE_p_std__vectorT_unsigned_char_t,0))){
    SWIG_fail_ptr("Arduino_sendOneWireWriteAndRead",4,SWIGTYPE_p_std__vectorT_unsigned_char_t); }  arg4 = *argp4;
  arg5 = (int)lua_tonumber(L, 5); (arg1)->sendOneWireWriteAndRead(arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_sendOneWireRequest(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ; int arg2 ;
  unsigned char arg3 ; std::vector< unsigned char > arg4 ; int arg5 ; unsigned char arg6 ; unsigned int arg7 ;
  std::vector< unsigned char > arg8 ; std::vector< unsigned char > *argp4 ; std::vector< unsigned char > *argp8 ;
  SWIG_check_num_args("ofArduino::sendOneWireRequest",8,8)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::sendOneWireRequest",1,"ofArduino *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofArduino::sendOneWireRequest",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofArduino::sendOneWireRequest",3,"unsigned char");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("ofArduino::sendOneWireRequest",4,"std::vector< unsigned char >");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofArduino::sendOneWireRequest",5,"int");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofArduino::sendOneWireRequest",6,"unsigned char");
  if(!lua_isnumber(L,7)) SWIG_fail_arg("ofArduino::sendOneWireRequest",7,"unsigned int");
  if(!lua_isuserdata(L,8)) SWIG_fail_arg("ofArduino::sendOneWireRequest",8,"std::vector< unsigned char >");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_sendOneWireRequest",1,SWIGTYPE_p_ofArduino); }  arg2 = (int)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (unsigned char)lua_tonumber(L, 3);
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&argp4,SWIGTYPE_p_std__vectorT_unsigned_char_t,0))){
    SWIG_fail_ptr("Arduino_sendOneWireRequest",4,SWIGTYPE_p_std__vectorT_unsigned_char_t); }  arg4 = *argp4;
  arg5 = (int)lua_tonumber(L, 5); SWIG_contract_assert((lua_tonumber(L,6)>=0),"number must not be negative")
  arg6 = (unsigned char)lua_tonumber(L, 6); SWIG_contract_assert((lua_tonumber(L,7)>=0),"number must not be negative")
  arg7 = (unsigned int)lua_tonumber(L, 7);
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,8,(void**)&argp8,SWIGTYPE_p_std__vectorT_unsigned_char_t,0))){
    SWIG_fail_ptr("Arduino_sendOneWireRequest",8,SWIGTYPE_p_std__vectorT_unsigned_char_t); }  arg8 = *argp8;
  (arg1)->sendOneWireRequest(arg2,arg3,arg4,arg5,arg6,arg7,arg8); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Arduino_attachEncoder(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ; int arg2 ;
  int arg3 ; SWIG_check_num_args("ofArduino::attachEncoder",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::attachEncoder",1,"ofArduino *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofArduino::attachEncoder",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofArduino::attachEncoder",3,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_attachEncoder",1,SWIGTYPE_p_ofArduino); }  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3); (arg1)->attachEncoder(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Arduino_getEncoderPosition(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ; int arg2 ;
  SWIG_check_num_args("ofArduino::getEncoderPosition",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::getEncoderPosition",1,"ofArduino *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofArduino::getEncoderPosition",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_getEncoderPosition",1,SWIGTYPE_p_ofArduino); }  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->getEncoderPosition(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_getAllEncoderPositions(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ;
  SWIG_check_num_args("ofArduino::getAllEncoderPositions",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::getAllEncoderPositions",1,"ofArduino *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_getAllEncoderPositions",1,SWIGTYPE_p_ofArduino); }  (arg1)->getAllEncoderPositions();
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_resetEncoderPosition(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ; int arg2 ;
  SWIG_check_num_args("ofArduino::resetEncoderPosition",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::resetEncoderPosition",1,"ofArduino *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofArduino::resetEncoderPosition",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_resetEncoderPosition",1,SWIGTYPE_p_ofArduino); }  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->resetEncoderPosition(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_enableEncoderReporting(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ;
  SWIG_check_num_args("ofArduino::enableEncoderReporting",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::enableEncoderReporting",1,"ofArduino *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_enableEncoderReporting",1,SWIGTYPE_p_ofArduino); }  (arg1)->enableEncoderReporting();
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_disableEncoderReporting(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ;
  SWIG_check_num_args("ofArduino::disableEncoderReporting",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::disableEncoderReporting",1,"ofArduino *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_disableEncoderReporting",1,SWIGTYPE_p_ofArduino); }  (arg1)->disableEncoderReporting();
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_detachEncoder(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ; int arg2 ;
  SWIG_check_num_args("ofArduino::detachEncoder",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::detachEncoder",1,"ofArduino *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofArduino::detachEncoder",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_detachEncoder",1,SWIGTYPE_p_ofArduino); }  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->detachEncoder(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_sendSerialConfig(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ;
  Firmata_Serial_Ports arg2 ; int arg3 ; int arg4 ; int arg5 ; SWIG_check_num_args("ofArduino::sendSerialConfig",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::sendSerialConfig",1,"ofArduino *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofArduino::sendSerialConfig",2,"Firmata_Serial_Ports");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofArduino::sendSerialConfig",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofArduino::sendSerialConfig",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofArduino::sendSerialConfig",5,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_sendSerialConfig",1,SWIGTYPE_p_ofArduino); }  arg2 = (Firmata_Serial_Ports)(int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3); arg4 = (int)lua_tonumber(L, 4); arg5 = (int)lua_tonumber(L, 5);
  (arg1)->sendSerialConfig(arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_serialWrite(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ;
  Firmata_Serial_Ports arg2 ; unsigned char *arg3 = (unsigned char *) 0 ; int arg4 ;
  SWIG_check_num_args("ofArduino::serialWrite",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::serialWrite",1,"ofArduino *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofArduino::serialWrite",2,"Firmata_Serial_Ports");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("ofArduino::serialWrite",3,"unsigned char *");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofArduino::serialWrite",4,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_serialWrite",1,SWIGTYPE_p_ofArduino); }  arg2 = (Firmata_Serial_Ports)(int)lua_tonumber(L, 2);
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_unsigned_char,0))){
    SWIG_fail_ptr("Arduino_serialWrite",3,SWIGTYPE_p_unsigned_char); }  arg4 = (int)lua_tonumber(L, 4);
  (arg1)->serialWrite(arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_serialRead(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ;
  Firmata_Serial_Ports arg2 ; int arg3 ; SWIG_check_num_args("ofArduino::serialRead",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::serialRead",1,"ofArduino *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofArduino::serialRead",2,"Firmata_Serial_Ports");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofArduino::serialRead",3,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_serialRead",1,SWIGTYPE_p_ofArduino); }  arg2 = (Firmata_Serial_Ports)(int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3); (arg1)->serialRead(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Arduino_serialStop(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ;
  Firmata_Serial_Ports arg2 ; SWIG_check_num_args("ofArduino::serialStop",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::serialStop",1,"ofArduino *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofArduino::serialStop",2,"Firmata_Serial_Ports");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_serialStop",1,SWIGTYPE_p_ofArduino); }  arg2 = (Firmata_Serial_Ports)(int)lua_tonumber(L, 2);
  (arg1)->serialStop(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_serialClose(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ;
  Firmata_Serial_Ports arg2 ; SWIG_check_num_args("ofArduino::serialClose",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::serialClose",1,"ofArduino *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofArduino::serialClose",2,"Firmata_Serial_Ports");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_serialClose",1,SWIGTYPE_p_ofArduino); }  arg2 = (Firmata_Serial_Ports)(int)lua_tonumber(L, 2);
  (arg1)->serialClose(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_serialFlush(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ;
  Firmata_Serial_Ports arg2 ; SWIG_check_num_args("ofArduino::serialFlush",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::serialFlush",1,"ofArduino *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofArduino::serialFlush",2,"Firmata_Serial_Ports");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_serialFlush",1,SWIGTYPE_p_ofArduino); }  arg2 = (Firmata_Serial_Ports)(int)lua_tonumber(L, 2);
  (arg1)->serialFlush(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_serialListen(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ;
  Firmata_Serial_Ports arg2 ; SWIG_check_num_args("ofArduino::serialListen",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::serialListen",1,"ofArduino *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofArduino::serialListen",2,"Firmata_Serial_Ports");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_serialListen",1,SWIGTYPE_p_ofArduino); }  arg2 = (Firmata_Serial_Ports)(int)lua_tonumber(L, 2);
  (arg1)->serialListen(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_getPinCapabilities(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ;
  SwigValueWrapper< std::map< int,supportedPinTypes > > result; SWIG_check_num_args("ofArduino::getPinCapabilities",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::getPinCapabilities",1,"ofArduino *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_getPinCapabilities",1,SWIGTYPE_p_ofArduino); }  result = (arg1)->getPinCapabilities(); {
    std::map< int,supportedPinTypes > * resultptr = new std::map< int,supportedPinTypes >((const std::map< int,supportedPinTypes > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_std__mapT_int_supportedPinTypes_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_getTotalPins(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ; int result;
  SWIG_check_num_args("ofArduino::getTotalPins",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::getTotalPins",1,"ofArduino *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_getTotalPins",1,SWIGTYPE_p_ofArduino); }  result = (int)(arg1)->getTotalPins();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Arduino_getNumAnalogPins(lua_State* L) { int SWIG_arg = 0; ofArduino *arg1 = (ofArduino *) 0 ; int result;
  SWIG_check_num_args("ofArduino::getNumAnalogPins",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofArduino::getNumAnalogPins",1,"ofArduino *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofArduino,0))){
    SWIG_fail_ptr("Arduino_getNumAnalogPins",1,SWIGTYPE_p_ofArduino); }  result = (int)(arg1)->getNumAnalogPins();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static void swig_delete_Arduino(void *obj) {
ofArduino *arg1 = (ofArduino *) obj;
delete arg1;
}
static int _proxy__wrap_new_Arduino(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_Arduino);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_Arduino_attributes[] = {
    { "EDigitalPinChanged", _wrap_Arduino_EDigitalPinChanged_get, _wrap_Arduino_EDigitalPinChanged_set },
    { "EAnalogPinChanged", _wrap_Arduino_EAnalogPinChanged_get, _wrap_Arduino_EAnalogPinChanged_set },
    { "ESysExReceived", _wrap_Arduino_ESysExReceived_get, _wrap_Arduino_ESysExReceived_set },
    { "EFirmwareVersionReceived", _wrap_Arduino_EFirmwareVersionReceived_get, _wrap_Arduino_EFirmwareVersionReceived_set },
    { "EInitialized", _wrap_Arduino_EInitialized_get, _wrap_Arduino_EInitialized_set },
    { "EStringReceived", _wrap_Arduino_EStringReceived_get, _wrap_Arduino_EStringReceived_set },
    { "EStepperDataReceived", _wrap_Arduino_EStepperDataReceived_get, _wrap_Arduino_EStepperDataReceived_set },
    { "EI2CDataRecieved", _wrap_Arduino_EI2CDataRecieved_get, _wrap_Arduino_EI2CDataRecieved_set },
    { "EEncoderDataReceived", _wrap_Arduino_EEncoderDataReceived_get, _wrap_Arduino_EEncoderDataReceived_set },
    { "ESerialDataReceived", _wrap_Arduino_ESerialDataReceived_get, _wrap_Arduino_ESerialDataReceived_set },
    { "EPinStateResponseReceived", _wrap_Arduino_EPinStateResponseReceived_get, _wrap_Arduino_EPinStateResponseReceived_set },
    {0,0,0}
};
static swig_lua_method swig_Arduino_methods[]= {
    { "connect", _wrap_Arduino_connect},
    { "isInitialized", _wrap_Arduino_isInitialized},
    { "isArduinoReady", _wrap_Arduino_isArduinoReady},
    { "disconnect", _wrap_Arduino_disconnect},
    { "update", _wrap_Arduino_update},
    { "sendDigitalPinMode", _wrap_Arduino_sendDigitalPinMode},
    { "sendAnalogPinReporting", _wrap_Arduino_sendAnalogPinReporting},
    { "setUseDelay", _wrap_Arduino_setUseDelay},
    { "setDigitalHistoryLength", _wrap_Arduino_setDigitalHistoryLength},
    { "setAnalogHistoryLength", _wrap_Arduino_setAnalogHistoryLength},
    { "setStringHistoryLength", _wrap_Arduino_setStringHistoryLength},
    { "setSysExHistoryLength", _wrap_Arduino_setSysExHistoryLength},
    { "sendDigital", _wrap_Arduino_sendDigital},
    { "sendPwm", _wrap_Arduino_sendPwm},
    { "sendSysEx", _wrap_Arduino_sendSysEx},
    { "isAttached", _wrap_Arduino_isAttached},
    { "sendString", _wrap_Arduino_sendString},
    { "sendProtocolVersionRequest", _wrap_Arduino_sendProtocolVersionRequest},
    { "sendFirmwareVersionRequest", _wrap_Arduino_sendFirmwareVersionRequest},
    { "igurationRequest", _wrap_Arduino_igurationRequest},
    { "sendPinCapabilityRequest", _wrap_Arduino_sendPinCapabilityRequest},
    { "sendAnalogMappingRequest", _wrap_Arduino_sendAnalogMappingRequest},
    { "sendPinStateQuery", _wrap_Arduino_sendPinStateQuery},
    { "sendReset", _wrap_Arduino_sendReset},
    { "sendSysExBegin", _wrap_Arduino_sendSysExBegin},
    { "sendSysExEnd", _wrap_Arduino_sendSysExEnd},
    { "sendByte", _wrap_Arduino_sendByte},
    { "sendValueAsTwo7bitBytes", _wrap_Arduino_sendValueAsTwo7bitBytes},
    { "getPwm", _wrap_Arduino_getPwm},
    { "getDigital", _wrap_Arduino_getDigital},
    { "getAnalog", _wrap_Arduino_getAnalog},
    { "getSysEx", _wrap_Arduino_getSysEx},
    { "getString", _wrap_Arduino_getString},
    { "getMajorFirmwareVersion", _wrap_Arduino_getMajorFirmwareVersion},
    { "getMinorFirmwareVersion", _wrap_Arduino_getMinorFirmwareVersion},
    { "getFirmwareName", _wrap_Arduino_getFirmwareName},
    { "getDigitalPinMode", _wrap_Arduino_getDigitalPinMode},
    { "getAnalogPinReporting", _wrap_Arduino_getAnalogPinReporting},
    { "getValueFromTwo7bitBytes", _wrap_Arduino_getValueFromTwo7bitBytes},
    { "getInvertedValueFromTwo7bitBytes", _wrap_Arduino_getInvertedValueFromTwo7bitBytes},
    { "sendServo", _wrap_Arduino_sendServo},
    { "sendServoAttach", _wrap_Arduino_sendServoAttach},
    { "getServo", _wrap_Arduino_getServo},
    { "sendStepper2Wire", _wrap_Arduino_sendStepper2Wire},
    { "sendStepper4Wire", _wrap_Arduino_sendStepper4Wire},
    { "sendStepperMove", _wrap_Arduino_sendStepperMove},
    { "sendI2CConfig", _wrap_Arduino_sendI2CConfig},
    { "isI2CConfigured", _wrap_Arduino_isI2CConfigured},
    { "sendI2CWriteRequest", _wrap_Arduino_sendI2CWriteRequest},
    { "sendI2CReadRequest", _wrap_Arduino_sendI2CReadRequest},
    { "sendI2ContinuousReadRequest", _wrap_Arduino_sendI2ContinuousReadRequest},
    { "sendOneWireConfig", _wrap_Arduino_sendOneWireConfig},
    { "sendOneWireAlarmsSearch", _wrap_Arduino_sendOneWireAlarmsSearch},
    { "sendOneWireSearch", _wrap_Arduino_sendOneWireSearch},
    { "sendOneWireRead", _wrap_Arduino_sendOneWireRead},
    { "sendOneWireReset", _wrap_Arduino_sendOneWireReset},
    { "sendOneWireWrite", _wrap_Arduino_sendOneWireWrite},
    { "sendOneWireDelay", _wrap_Arduino_sendOneWireDelay},
    { "sendOneWireWriteAndRead", _wrap_Arduino_sendOneWireWriteAndRead},
    { "sendOneWireRequest", _wrap_Arduino_sendOneWireRequest},
    { "attachEncoder", _wrap_Arduino_attachEncoder},
    { "getEncoderPosition", _wrap_Arduino_getEncoderPosition},
    { "getAllEncoderPositions", _wrap_Arduino_getAllEncoderPositions},
    { "resetEncoderPosition", _wrap_Arduino_resetEncoderPosition},
    { "enableEncoderReporting", _wrap_Arduino_enableEncoderReporting},
    { "disableEncoderReporting", _wrap_Arduino_disableEncoderReporting},
    { "detachEncoder", _wrap_Arduino_detachEncoder},
    { "sendSerialConfig", _wrap_Arduino_sendSerialConfig},
    { "serialWrite", _wrap_Arduino_serialWrite},
    { "serialRead", _wrap_Arduino_serialRead},
    { "serialStop", _wrap_Arduino_serialStop},
    { "serialClose", _wrap_Arduino_serialClose},
    { "serialFlush", _wrap_Arduino_serialFlush},
    { "serialListen", _wrap_Arduino_serialListen},
    { "getPinCapabilities", _wrap_Arduino_getPinCapabilities},
    { "getTotalPins", _wrap_Arduino_getTotalPins},
    { "getNumAnalogPins", _wrap_Arduino_getNumAnalogPins},
    {0,0}
};
static swig_lua_method swig_Arduino_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_Arduino_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_Arduino_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_Arduino_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_Arduino_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_Arduino_Sf_SwigStatic = {
    "Arduino",
    swig_Arduino_Sf_SwigStatic_methods,
    swig_Arduino_Sf_SwigStatic_attributes,
    swig_Arduino_Sf_SwigStatic_constants,
    swig_Arduino_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_Arduino_bases[] = {0};
static const char *swig_Arduino_base_names[] = {0};
static swig_lua_class _wrap_class_Arduino = { "Arduino", "Arduino", &SWIGTYPE_p_ofArduino,_proxy__wrap_new_Arduino, swig_delete_Arduino, swig_Arduino_methods, swig_Arduino_attributes, &swig_Arduino_Sf_SwigStatic, swig_Arduino_meta, swig_Arduino_bases, swig_Arduino_base_names };

static int _wrap_new_SerialDeviceInfo__SWIG_0(lua_State* L) { int SWIG_arg = 0; std::string arg1 ; std::string arg2 ; int arg3 ;
  ofSerialDeviceInfo *result = 0 ; SWIG_check_num_args("ofSerialDeviceInfo::ofSerialDeviceInfo",3,3)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofSerialDeviceInfo::ofSerialDeviceInfo",1,"std::string");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofSerialDeviceInfo::ofSerialDeviceInfo",2,"std::string");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofSerialDeviceInfo::ofSerialDeviceInfo",3,"int");
  (&arg1)->assign(lua_tostring(L,1),lua_rawlen(L,1)); (&arg2)->assign(lua_tostring(L,2),lua_rawlen(L,2));
  arg3 = (int)lua_tonumber(L, 3); result = (ofSerialDeviceInfo *)new ofSerialDeviceInfo(arg1,arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofSerialDeviceInfo,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_SerialDeviceInfo__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofSerialDeviceInfo *result = 0 ;
  SWIG_check_num_args("ofSerialDeviceInfo::ofSerialDeviceInfo",0,0) result = (ofSerialDeviceInfo *)new ofSerialDeviceInfo();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofSerialDeviceInfo,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_SerialDeviceInfo(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 0) {
    return _wrap_new_SerialDeviceInfo__SWIG_1(L);}  if (argc == 3) { int _v; { _v = lua_isstring(L,argv[0]); }  if (_v) { {
        _v = lua_isstring(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_new_SerialDeviceInfo__SWIG_0(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_SerialDeviceInfo'\n"
  "  Possible C/C++ prototypes are:\n" "    ofSerialDeviceInfo::ofSerialDeviceInfo(std::string,std::string,int)\n"
  "    ofSerialDeviceInfo::ofSerialDeviceInfo()\n"); lua_error(L);return 0; }
static int _wrap_SerialDeviceInfo_getDevicePath(lua_State* L) { int SWIG_arg = 0;
  ofSerialDeviceInfo *arg1 = (ofSerialDeviceInfo *) 0 ; std::string result;
  SWIG_check_num_args("ofSerialDeviceInfo::getDevicePath",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSerialDeviceInfo::getDevicePath",1,"ofSerialDeviceInfo *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSerialDeviceInfo,0))){
    SWIG_fail_ptr("SerialDeviceInfo_getDevicePath",1,SWIGTYPE_p_ofSerialDeviceInfo); }  result = (arg1)->getDevicePath();
  lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_SerialDeviceInfo_getDeviceName(lua_State* L) { int SWIG_arg = 0;
  ofSerialDeviceInfo *arg1 = (ofSerialDeviceInfo *) 0 ; std::string result;
  SWIG_check_num_args("ofSerialDeviceInfo::getDeviceName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSerialDeviceInfo::getDeviceName",1,"ofSerialDeviceInfo *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSerialDeviceInfo,0))){
    SWIG_fail_ptr("SerialDeviceInfo_getDeviceName",1,SWIGTYPE_p_ofSerialDeviceInfo); }  result = (arg1)->getDeviceName();
  lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_SerialDeviceInfo_getDeviceID(lua_State* L) { int SWIG_arg = 0;
  ofSerialDeviceInfo *arg1 = (ofSerialDeviceInfo *) 0 ; int result; SWIG_check_num_args("ofSerialDeviceInfo::getDeviceID",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSerialDeviceInfo::getDeviceID",1,"ofSerialDeviceInfo *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSerialDeviceInfo,0))){
    SWIG_fail_ptr("SerialDeviceInfo_getDeviceID",1,SWIGTYPE_p_ofSerialDeviceInfo); }  result = (int)(arg1)->getDeviceID();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static void swig_delete_SerialDeviceInfo(void *obj) {
ofSerialDeviceInfo *arg1 = (ofSerialDeviceInfo *) obj;
delete arg1;
}
static int _proxy__wrap_new_SerialDeviceInfo(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_SerialDeviceInfo);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_SerialDeviceInfo_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_SerialDeviceInfo_methods[]= {
    { "getDevicePath", _wrap_SerialDeviceInfo_getDevicePath},
    { "getDeviceName", _wrap_SerialDeviceInfo_getDeviceName},
    { "getDeviceID", _wrap_SerialDeviceInfo_getDeviceID},
    {0,0}
};
static swig_lua_method swig_SerialDeviceInfo_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_SerialDeviceInfo_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_SerialDeviceInfo_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_SerialDeviceInfo_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_SerialDeviceInfo_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_SerialDeviceInfo_Sf_SwigStatic = {
    "SerialDeviceInfo",
    swig_SerialDeviceInfo_Sf_SwigStatic_methods,
    swig_SerialDeviceInfo_Sf_SwigStatic_attributes,
    swig_SerialDeviceInfo_Sf_SwigStatic_constants,
    swig_SerialDeviceInfo_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_SerialDeviceInfo_bases[] = {0};
static const char *swig_SerialDeviceInfo_base_names[] = {0};
static swig_lua_class _wrap_class_SerialDeviceInfo = { "SerialDeviceInfo", "SerialDeviceInfo", &SWIGTYPE_p_ofSerialDeviceInfo,_proxy__wrap_new_SerialDeviceInfo, swig_delete_SerialDeviceInfo, swig_SerialDeviceInfo_methods, swig_SerialDeviceInfo_attributes, &swig_SerialDeviceInfo_Sf_SwigStatic, swig_SerialDeviceInfo_meta, swig_SerialDeviceInfo_bases, swig_SerialDeviceInfo_base_names };

static int _wrap_new_Serial(lua_State* L) { int SWIG_arg = 0; ofSerial *result = 0 ;
  SWIG_check_num_args("ofSerial::ofSerial",0,0) result = (ofSerial *)new ofSerial();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofSerial,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Serial_listDevices(lua_State* L) { int SWIG_arg = 0; ofSerial *arg1 = (ofSerial *) 0 ;
  SWIG_check_num_args("ofSerial::listDevices",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSerial::listDevices",1,"ofSerial *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSerial,0))){
    SWIG_fail_ptr("Serial_listDevices",1,SWIGTYPE_p_ofSerial); }  (arg1)->listDevices(); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Serial_getDeviceList(lua_State* L) { int SWIG_arg = 0; ofSerial *arg1 = (ofSerial *) 0 ;
  SwigValueWrapper< std::vector< ofSerialDeviceInfo > > result; SWIG_check_num_args("ofSerial::getDeviceList",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSerial::getDeviceList",1,"ofSerial *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSerial,0))){
    SWIG_fail_ptr("Serial_getDeviceList",1,SWIGTYPE_p_ofSerial); }  result = (arg1)->getDeviceList(); {
    std::vector< ofSerialDeviceInfo > * resultptr = new std::vector< ofSerialDeviceInfo >((const std::vector< ofSerialDeviceInfo > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_std__vectorT_ofSerialDeviceInfo_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Serial_setup__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofSerial *arg1 = (ofSerial *) 0 ; bool result;
  SWIG_check_num_args("ofSerial::setup",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSerial::setup",1,"ofSerial *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSerial,0))){
    SWIG_fail_ptr("Serial_setup",1,SWIGTYPE_p_ofSerial); }  result = (bool)(arg1)->setup();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Serial_setup__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofSerial *arg1 = (ofSerial *) 0 ; std::string arg2 ;
  int arg3 ; bool result; SWIG_check_num_args("ofSerial::setup",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSerial::setup",1,"ofSerial *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofSerial::setup",2,"std::string");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofSerial::setup",3,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSerial,0))){
    SWIG_fail_ptr("Serial_setup",1,SWIGTYPE_p_ofSerial); }  (&arg2)->assign(lua_tostring(L,2),lua_rawlen(L,2));
  arg3 = (int)lua_tonumber(L, 3); result = (bool)(arg1)->setup(arg2,arg3); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Serial_setup__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofSerial *arg1 = (ofSerial *) 0 ; int arg2 ; int arg3 ;
  bool result; SWIG_check_num_args("ofSerial::setup",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSerial::setup",1,"ofSerial *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofSerial::setup",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofSerial::setup",3,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSerial,0))){
    SWIG_fail_ptr("Serial_setup",1,SWIGTYPE_p_ofSerial); }  arg2 = (int)lua_tonumber(L, 2); arg3 = (int)lua_tonumber(L, 3);
  result = (bool)(arg1)->setup(arg2,arg3); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Serial_setup(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 1) { int _v;
    { void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofSerial, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Serial_setup__SWIG_0(L);}  }  if (argc == 3) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofSerial, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { return _wrap_Serial_setup__SWIG_2(L);}  }  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofSerial, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_Serial_setup__SWIG_1(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Serial_setup'\n" "  Possible C/C++ prototypes are:\n"
  "    ofSerial::setup()\n" "    ofSerial::setup(std::string,int)\n" "    ofSerial::setup(int,int)\n"); lua_error(L);return 0; }
static int _wrap_Serial_isInitialized(lua_State* L) { int SWIG_arg = 0; ofSerial *arg1 = (ofSerial *) 0 ; bool result;
  SWIG_check_num_args("ofSerial::isInitialized",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSerial::isInitialized",1,"ofSerial const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSerial,0))){
    SWIG_fail_ptr("Serial_isInitialized",1,SWIGTYPE_p_ofSerial); }  result = (bool)((ofSerial const *)arg1)->isInitialized();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Serial_close(lua_State* L) { int SWIG_arg = 0; ofSerial *arg1 = (ofSerial *) 0 ;
  SWIG_check_num_args("ofSerial::close",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSerial::close",1,"ofSerial *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSerial,0))){
    SWIG_fail_ptr("Serial_close",1,SWIGTYPE_p_ofSerial); }  (arg1)->close(); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Serial_available(lua_State* L) { int SWIG_arg = 0; ofSerial *arg1 = (ofSerial *) 0 ; int result;
  SWIG_check_num_args("ofSerial::available",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSerial::available",1,"ofSerial *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSerial,0))){
    SWIG_fail_ptr("Serial_available",1,SWIGTYPE_p_ofSerial); }  result = (int)(arg1)->available();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Serial_readBytes__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofSerial *arg1 = (ofSerial *) 0 ;
  unsigned char *arg2 = (unsigned char *) 0 ; size_t arg3 ; long result; SWIG_check_num_args("ofSerial::readBytes",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSerial::readBytes",1,"ofSerial *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofSerial::readBytes",2,"unsigned char *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofSerial::readBytes",3,"size_t");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSerial,0))){
    SWIG_fail_ptr("Serial_readBytes",1,SWIGTYPE_p_ofSerial); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_unsigned_char,0))){
    SWIG_fail_ptr("Serial_readBytes",2,SWIGTYPE_p_unsigned_char); } 
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (size_t)lua_tonumber(L, 3);
  result = (long)(arg1)->readBytes(arg2,arg3); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Serial_readBytes__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofSerial *arg1 = (ofSerial *) 0 ;
  char *arg2 = (char *) 0 ; size_t arg3 ; long result; SWIG_check_num_args("ofSerial::readBytes",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSerial::readBytes",1,"ofSerial *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("ofSerial::readBytes",2,"char *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofSerial::readBytes",3,"size_t");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSerial,0))){
    SWIG_fail_ptr("Serial_readBytes",1,SWIGTYPE_p_ofSerial); }  arg2 = (char *)lua_tostring(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (size_t)lua_tonumber(L, 3);
  result = (long)(arg1)->readBytes(arg2,arg3); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Serial_readBytes__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofSerial *arg1 = (ofSerial *) 0 ;
  ofBuffer *arg2 = 0 ; size_t arg3 ; long result; SWIG_check_num_args("ofSerial::readBytes",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSerial::readBytes",1,"ofSerial *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofSerial::readBytes",2,"ofBuffer &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofSerial::readBytes",3,"size_t");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSerial,0))){
    SWIG_fail_ptr("Serial_readBytes",1,SWIGTYPE_p_ofSerial); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofBuffer,0))){
    SWIG_fail_ptr("Serial_readBytes",2,SWIGTYPE_p_ofBuffer); } 
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (size_t)lua_tonumber(L, 3);
  result = (long)(arg1)->readBytes(*arg2,arg3); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Serial_readBytes(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 3) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofSerial, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_unsigned_char, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { return _wrap_Serial_readBytes__SWIG_0(L);}
         }  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofSerial, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofBuffer, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { return _wrap_Serial_readBytes__SWIG_2(L);}
         }  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofSerial, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = SWIG_lua_isnilstring(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); } 
        if (_v) { return _wrap_Serial_readBytes__SWIG_1(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Serial_readBytes'\n" "  Possible C/C++ prototypes are:\n"
  "    ofSerial::readBytes(unsigned char *,size_t)\n" "    ofSerial::readBytes(char *,size_t)\n"
  "    ofSerial::readBytes(ofBuffer &,size_t)\n"); lua_error(L);return 0; }
static int _wrap_Serial_readByte(lua_State* L) { int SWIG_arg = 0; ofSerial *arg1 = (ofSerial *) 0 ; int result;
  SWIG_check_num_args("ofSerial::readByte",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSerial::readByte",1,"ofSerial *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSerial,0))){
    SWIG_fail_ptr("Serial_readByte",1,SWIGTYPE_p_ofSerial); }  result = (int)(arg1)->readByte();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Serial_writeBytes__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofSerial *arg1 = (ofSerial *) 0 ;
  unsigned char *arg2 = (unsigned char *) 0 ; size_t arg3 ; long result; SWIG_check_num_args("ofSerial::writeBytes",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSerial::writeBytes",1,"ofSerial *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofSerial::writeBytes",2,"unsigned char const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofSerial::writeBytes",3,"size_t");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSerial,0))){
    SWIG_fail_ptr("Serial_writeBytes",1,SWIGTYPE_p_ofSerial); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_unsigned_char,0))){
    SWIG_fail_ptr("Serial_writeBytes",2,SWIGTYPE_p_unsigned_char); } 
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (size_t)lua_tonumber(L, 3);
  result = (long)(arg1)->writeBytes((unsigned char const *)arg2,arg3); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Serial_writeBytes__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofSerial *arg1 = (ofSerial *) 0 ;
  char *arg2 = (char *) 0 ; size_t arg3 ; long result; SWIG_check_num_args("ofSerial::writeBytes",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSerial::writeBytes",1,"ofSerial *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("ofSerial::writeBytes",2,"char const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofSerial::writeBytes",3,"size_t");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSerial,0))){
    SWIG_fail_ptr("Serial_writeBytes",1,SWIGTYPE_p_ofSerial); }  arg2 = (char *)lua_tostring(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (size_t)lua_tonumber(L, 3);
  result = (long)(arg1)->writeBytes((char const *)arg2,arg3); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Serial_writeBytes__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofSerial *arg1 = (ofSerial *) 0 ;
  ofBuffer *arg2 = 0 ; long result; SWIG_check_num_args("ofSerial::writeBytes",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSerial::writeBytes",1,"ofSerial *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofSerial::writeBytes",2,"ofBuffer const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSerial,0))){
    SWIG_fail_ptr("Serial_writeBytes",1,SWIGTYPE_p_ofSerial); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofBuffer,0))){
    SWIG_fail_ptr("Serial_writeBytes",2,SWIGTYPE_p_ofBuffer); }  result = (long)(arg1)->writeBytes((ofBuffer const &)*arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Serial_writeBytes(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofSerial, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofBuffer, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Serial_writeBytes__SWIG_2(L);}  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofSerial, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_unsigned_char, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { return _wrap_Serial_writeBytes__SWIG_0(L);}
         }  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofSerial, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = SWIG_lua_isnilstring(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); } 
        if (_v) { return _wrap_Serial_writeBytes__SWIG_1(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Serial_writeBytes'\n" "  Possible C/C++ prototypes are:\n"
  "    ofSerial::writeBytes(unsigned char const *,size_t)\n" "    ofSerial::writeBytes(char const *,size_t)\n"
  "    ofSerial::writeBytes(ofBuffer const &)\n"); lua_error(L);return 0; }
static int _wrap_Serial_writeByte__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofSerial *arg1 = (ofSerial *) 0 ;
  unsigned char arg2 ; bool result; SWIG_check_num_args("ofSerial::writeByte",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSerial::writeByte",1,"ofSerial *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofSerial::writeByte",2,"unsigned char");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSerial,0))){
    SWIG_fail_ptr("Serial_writeByte",1,SWIGTYPE_p_ofSerial); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (unsigned char)lua_tonumber(L, 2);
  result = (bool)(arg1)->writeByte(arg2); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Serial_writeByte__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofSerial *arg1 = (ofSerial *) 0 ; char arg2 ;
  bool result; SWIG_check_num_args("ofSerial::writeByte",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSerial::writeByte",1,"ofSerial *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("ofSerial::writeByte",2,"char");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSerial,0))){
    SWIG_fail_ptr("Serial_writeByte",1,SWIGTYPE_p_ofSerial); }  arg2 = (lua_tostring(L, 2))[0];
  result = (bool)(arg1)->writeByte(arg2); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Serial_writeByte(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofSerial, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { return _wrap_Serial_writeByte__SWIG_0(L);}  }
     }  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofSerial, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = SWIG_lua_isnilstring(L,argv[1]) && (lua_rawlen(L,argv[1])==1); }  if (_v) {
        return _wrap_Serial_writeByte__SWIG_1(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Serial_writeByte'\n" "  Possible C/C++ prototypes are:\n"
  "    ofSerial::writeByte(unsigned char)\n" "    ofSerial::writeByte(char)\n"); lua_error(L);return 0; }
static int _wrap_Serial_flush__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofSerial *arg1 = (ofSerial *) 0 ; bool arg2 ;
  bool arg3 ; SWIG_check_num_args("ofSerial::flush",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSerial::flush",1,"ofSerial *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofSerial::flush",2,"bool");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("ofSerial::flush",3,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSerial,0))){
    SWIG_fail_ptr("Serial_flush",1,SWIGTYPE_p_ofSerial); }  arg2 = (lua_toboolean(L, 2)!=0); arg3 = (lua_toboolean(L, 3)!=0);
  (arg1)->flush(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Serial_flush__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofSerial *arg1 = (ofSerial *) 0 ; bool arg2 ;
  SWIG_check_num_args("ofSerial::flush",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSerial::flush",1,"ofSerial *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofSerial::flush",2,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSerial,0))){
    SWIG_fail_ptr("Serial_flush",1,SWIGTYPE_p_ofSerial); }  arg2 = (lua_toboolean(L, 2)!=0); (arg1)->flush(arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Serial_flush__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofSerial *arg1 = (ofSerial *) 0 ;
  SWIG_check_num_args("ofSerial::flush",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSerial::flush",1,"ofSerial *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSerial,0))){
    SWIG_fail_ptr("Serial_flush",1,SWIGTYPE_p_ofSerial); }  (arg1)->flush(); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Serial_flush(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 1) { int _v;
    { void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofSerial, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Serial_flush__SWIG_2(L);}  }  if (argc == 2) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofSerial, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isboolean(L,argv[1]); }  if (_v) {
        return _wrap_Serial_flush__SWIG_1(L);}  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofSerial, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isboolean(L,argv[1]); }  if (_v) { { _v = lua_isboolean(L,argv[2]); } 
        if (_v) { return _wrap_Serial_flush__SWIG_0(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Serial_flush'\n" "  Possible C/C++ prototypes are:\n"
  "    ofSerial::flush(bool,bool)\n" "    ofSerial::flush(bool)\n" "    ofSerial::flush()\n"); lua_error(L);return 0; }
static int _wrap_Serial_drain(lua_State* L) { int SWIG_arg = 0; ofSerial *arg1 = (ofSerial *) 0 ;
  SWIG_check_num_args("ofSerial::drain",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSerial::drain",1,"ofSerial *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSerial,0))){
    SWIG_fail_ptr("Serial_drain",1,SWIGTYPE_p_ofSerial); }  (arg1)->drain(); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static void swig_delete_Serial(void *obj) {
ofSerial *arg1 = (ofSerial *) obj;
delete arg1;
}
static int _proxy__wrap_new_Serial(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_Serial);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_Serial_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_Serial_methods[]= {
    { "listDevices", _wrap_Serial_listDevices},
    { "getDeviceList", _wrap_Serial_getDeviceList},
    { "setup", _wrap_Serial_setup},
    { "isInitialized", _wrap_Serial_isInitialized},
    { "close", _wrap_Serial_close},
    { "available", _wrap_Serial_available},
    { "readBytes", _wrap_Serial_readBytes},
    { "readByte", _wrap_Serial_readByte},
    { "writeBytes", _wrap_Serial_writeBytes},
    { "writeByte", _wrap_Serial_writeByte},
    { "flush", _wrap_Serial_flush},
    { "drain", _wrap_Serial_drain},
    {0,0}
};
static swig_lua_method swig_Serial_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_Serial_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_Serial_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_Serial_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_Serial_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_Serial_Sf_SwigStatic = {
    "Serial",
    swig_Serial_Sf_SwigStatic_methods,
    swig_Serial_Sf_SwigStatic_attributes,
    swig_Serial_Sf_SwigStatic_constants,
    swig_Serial_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_Serial_bases[] = {0};
static const char *swig_Serial_base_names[] = {0};
static swig_lua_class _wrap_class_Serial = { "Serial", "Serial", &SWIGTYPE_p_ofSerial,_proxy__wrap_new_Serial, swig_delete_Serial, swig_Serial_methods, swig_Serial_attributes, &swig_Serial_Sf_SwigStatic, swig_Serial_meta, swig_Serial_bases, swig_Serial_base_names };

static int _wrap_random__SWIG_0(lua_State* L) { int SWIG_arg = 0; float arg1 ; float result; SWIG_check_num_args("ofRandom",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofRandom",1,"float"); arg1 = (float)lua_tonumber(L, 1); result = (float)ofRandom(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_random__SWIG_1(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float result;
  SWIG_check_num_args("ofRandom",2,2) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofRandom",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofRandom",2,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); result = (float)ofRandom(arg1,arg2); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_random(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 1) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { return _wrap_random__SWIG_0(L);}  }  if (argc == 2) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { return _wrap_random__SWIG_1(L);}  }
     }  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'random'\n" "  Possible C/C++ prototypes are:\n"
  "    ofRandom(float)\n" "    ofRandom(float,float)\n"); lua_error(L);return 0; }
static int _wrap_randomf(lua_State* L) { int SWIG_arg = 0; float result; SWIG_check_num_args("ofRandomf",0,0)
  result = (float)ofRandomf(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_randomuf(lua_State* L) { int SWIG_arg = 0; float result; SWIG_check_num_args("ofRandomuf",0,0)
  result = (float)ofRandomuf(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_seedRandom__SWIG_0(lua_State* L) { int SWIG_arg = 0; SWIG_check_num_args("ofSeedRandom",0,0) ofSeedRandom();
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_seedRandom__SWIG_1(lua_State* L) { int SWIG_arg = 0; int arg1 ; SWIG_check_num_args("ofSeedRandom",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofSeedRandom",1,"int"); arg1 = (int)lua_tonumber(L, 1); ofSeedRandom(arg1);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_seedRandom(lua_State* L) { int argc; int argv[2]={ 1,2} ; argc = lua_gettop(L); if (argc == 0) {
    return _wrap_seedRandom__SWIG_0(L);}  if (argc == 1) { int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) {
      return _wrap_seedRandom__SWIG_1(L);}  }  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'seedRandom'\n"
  "  Possible C/C++ prototypes are:\n" "    ofSeedRandom()\n" "    ofSeedRandom(int)\n"); lua_error(L);return 0; }
static int _wrap_normalize(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ; float result;
  SWIG_check_num_args("ofNormalize",3,3) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofNormalize",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofNormalize",2,"float"); if(!lua_isnumber(L,3)) SWIG_fail_arg("ofNormalize",3,"float");
  arg1 = (float)lua_tonumber(L, 1); arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3);
  result = (float)ofNormalize(arg1,arg2,arg3); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_map__SWIG_0(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ; float arg4 ; float arg5 ;
  bool arg6 ; float result; SWIG_check_num_args("ofMap",6,6) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofMap",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMap",2,"float"); if(!lua_isnumber(L,3)) SWIG_fail_arg("ofMap",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofMap",4,"float"); if(!lua_isnumber(L,5)) SWIG_fail_arg("ofMap",5,"float");
  if(!lua_isboolean(L,6)) SWIG_fail_arg("ofMap",6,"bool"); arg1 = (float)lua_tonumber(L, 1); arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); arg5 = (float)lua_tonumber(L, 5);
  arg6 = (lua_toboolean(L, 6)!=0); result = (float)ofMap(arg1,arg2,arg3,arg4,arg5,arg6);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_map__SWIG_1(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ; float arg4 ; float arg5 ;
  float result; SWIG_check_num_args("ofMap",5,5) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofMap",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMap",2,"float"); if(!lua_isnumber(L,3)) SWIG_fail_arg("ofMap",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofMap",4,"float"); if(!lua_isnumber(L,5)) SWIG_fail_arg("ofMap",5,"float");
  arg1 = (float)lua_tonumber(L, 1); arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4); arg5 = (float)lua_tonumber(L, 5); result = (float)ofMap(arg1,arg2,arg3,arg4,arg5);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_map(lua_State* L) { int argc; int argv[7]={ 1,2,3,4,5,6,7} ; argc = lua_gettop(L); if (argc == 5) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); } 
        if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) {
              return _wrap_map__SWIG_1(L);}  }  }  }  }  }  if (argc == 6) { int _v; { _v = lua_isnumber(L,argv[0]); } 
    if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { {
            _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) { {
                _v = lua_isboolean(L,argv[5]); }  if (_v) { return _wrap_map__SWIG_0(L);}  }  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'map'\n" "  Possible C/C++ prototypes are:\n"
  "    ofMap(float,float,float,float,float,bool)\n" "    ofMap(float,float,float,float,float)\n"); lua_error(L);return 0; }
static int _wrap_clamp(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ; float result;
  SWIG_check_num_args("ofClamp",3,3) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofClamp",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofClamp",2,"float"); if(!lua_isnumber(L,3)) SWIG_fail_arg("ofClamp",3,"float");
  arg1 = (float)lua_tonumber(L, 1); arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3);
  result = (float)ofClamp(arg1,arg2,arg3); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_inRange(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ; bool result;
  SWIG_check_num_args("ofInRange",3,3) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofInRange",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofInRange",2,"float"); if(!lua_isnumber(L,3)) SWIG_fail_arg("ofInRange",3,"float");
  arg1 = (float)lua_tonumber(L, 1); arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3);
  result = (bool)ofInRange(arg1,arg2,arg3); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_lerp(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ; float result;
  SWIG_check_num_args("ofLerp",3,3) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofLerp",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofLerp",2,"float"); if(!lua_isnumber(L,3)) SWIG_fail_arg("ofLerp",3,"float");
  arg1 = (float)lua_tonumber(L, 1); arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3);
  result = (float)ofLerp(arg1,arg2,arg3); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_dist__SWIG_0(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ; float arg4 ;
  float result; SWIG_check_num_args("ofDist",4,4) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofDist",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofDist",2,"float"); if(!lua_isnumber(L,3)) SWIG_fail_arg("ofDist",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofDist",4,"float"); arg1 = (float)lua_tonumber(L, 1); arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); result = (float)ofDist(arg1,arg2,arg3,arg4);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_dist__SWIG_1(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ; float arg4 ; float arg5 ;
  float arg6 ; float result; SWIG_check_num_args("ofDist",6,6) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofDist",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofDist",2,"float"); if(!lua_isnumber(L,3)) SWIG_fail_arg("ofDist",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofDist",4,"float"); if(!lua_isnumber(L,5)) SWIG_fail_arg("ofDist",5,"float");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofDist",6,"float"); arg1 = (float)lua_tonumber(L, 1); arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); arg5 = (float)lua_tonumber(L, 5);
  arg6 = (float)lua_tonumber(L, 6); result = (float)ofDist(arg1,arg2,arg3,arg4,arg5,arg6);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_dist(lua_State* L) { int argc; int argv[7]={ 1,2,3,4,5,6,7} ; argc = lua_gettop(L); if (argc == 4) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); } 
        if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_dist__SWIG_0(L);}  }  }  }  }  if (argc == 6) {
    int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { {
          _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { {
              _v = lua_isnumber(L,argv[4]); }  if (_v) { { _v = lua_isnumber(L,argv[5]); }  if (_v) {
                return _wrap_dist__SWIG_1(L);}  }  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'dist'\n" "  Possible C/C++ prototypes are:\n"
  "    ofDist(float,float,float,float)\n" "    ofDist(float,float,float,float,float,float)\n"); lua_error(L);return 0; }
static int _wrap_distSquared__SWIG_0(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ; float arg4 ;
  float result; SWIG_check_num_args("ofDistSquared",4,4) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofDistSquared",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofDistSquared",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofDistSquared",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofDistSquared",4,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  result = (float)ofDistSquared(arg1,arg2,arg3,arg4); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_distSquared__SWIG_1(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ; float arg4 ;
  float arg5 ; float arg6 ; float result; SWIG_check_num_args("ofDistSquared",6,6)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofDistSquared",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofDistSquared",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofDistSquared",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofDistSquared",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofDistSquared",5,"float");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofDistSquared",6,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  arg5 = (float)lua_tonumber(L, 5); arg6 = (float)lua_tonumber(L, 6);
  result = (float)ofDistSquared(arg1,arg2,arg3,arg4,arg5,arg6); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_distSquared(lua_State* L) { int argc; int argv[7]={ 1,2,3,4,5,6,7} ; argc = lua_gettop(L); if (argc == 4) {
    int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { {
          _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) {
            return _wrap_distSquared__SWIG_0(L);}  }  }  }  }  if (argc == 6) { int _v; { _v = lua_isnumber(L,argv[0]); } 
    if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { {
            _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) { {
                _v = lua_isnumber(L,argv[5]); }  if (_v) { return _wrap_distSquared__SWIG_1(L);}  }  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'distSquared'\n" "  Possible C/C++ prototypes are:\n"
  "    ofDistSquared(float,float,float,float)\n" "    ofDistSquared(float,float,float,float,float,float)\n");
  lua_error(L);return 0; }
static int _wrap_radToDeg(lua_State* L) { int SWIG_arg = 0; float arg1 ; float result; SWIG_check_num_args("ofRadToDeg",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofRadToDeg",1,"float"); arg1 = (float)lua_tonumber(L, 1);
  result = (float)ofRadToDeg(arg1); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_degToRad(lua_State* L) { int SWIG_arg = 0; float arg1 ; float result; SWIG_check_num_args("ofDegToRad",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofDegToRad",1,"float"); arg1 = (float)lua_tonumber(L, 1);
  result = (float)ofDegToRad(arg1); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_lerpDegrees(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ; float result;
  SWIG_check_num_args("ofLerpDegrees",3,3) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofLerpDegrees",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofLerpDegrees",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofLerpDegrees",3,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); result = (float)ofLerpDegrees(arg1,arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_lerpRadians(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ; float result;
  SWIG_check_num_args("ofLerpRadians",3,3) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofLerpRadians",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofLerpRadians",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofLerpRadians",3,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); result = (float)ofLerpRadians(arg1,arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_angleDifferenceDegrees(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float result;
  SWIG_check_num_args("ofAngleDifferenceDegrees",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofAngleDifferenceDegrees",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofAngleDifferenceDegrees",2,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); result = (float)ofAngleDifferenceDegrees(arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_angleDifferenceRadians(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float result;
  SWIG_check_num_args("ofAngleDifferenceRadians",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofAngleDifferenceRadians",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofAngleDifferenceRadians",2,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); result = (float)ofAngleDifferenceRadians(arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_wrap(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ; float result;
  SWIG_check_num_args("ofWrap",3,3) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofWrap",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofWrap",2,"float"); if(!lua_isnumber(L,3)) SWIG_fail_arg("ofWrap",3,"float");
  arg1 = (float)lua_tonumber(L, 1); arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3);
  result = (float)ofWrap(arg1,arg2,arg3); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_wrapRadians__SWIG_0(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ; float result;
  SWIG_check_num_args("ofWrapRadians",3,3) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofWrapRadians",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofWrapRadians",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofWrapRadians",3,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); result = (float)ofWrapRadians(arg1,arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_wrapRadians__SWIG_1(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float result;
  SWIG_check_num_args("ofWrapRadians",2,2) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofWrapRadians",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofWrapRadians",2,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); result = (float)ofWrapRadians(arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_wrapRadians__SWIG_2(lua_State* L) { int SWIG_arg = 0; float arg1 ; float result;
  SWIG_check_num_args("ofWrapRadians",1,1) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofWrapRadians",1,"float");
  arg1 = (float)lua_tonumber(L, 1); result = (float)ofWrapRadians(arg1); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_wrapRadians(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 1) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { return _wrap_wrapRadians__SWIG_2(L);}  }  if (argc == 2) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_wrapRadians__SWIG_1(L);}  }  }  if (argc == 3) { int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { {
        _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_wrapRadians__SWIG_0(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'wrapRadians'\n" "  Possible C/C++ prototypes are:\n"
  "    ofWrapRadians(float,float,float)\n" "    ofWrapRadians(float,float)\n" "    ofWrapRadians(float)\n");
  lua_error(L);return 0; }
static int _wrap_wrapDegrees__SWIG_0(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ; float result;
  SWIG_check_num_args("ofWrapDegrees",3,3) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofWrapDegrees",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofWrapDegrees",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofWrapDegrees",3,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); result = (float)ofWrapDegrees(arg1,arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_wrapDegrees__SWIG_1(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float result;
  SWIG_check_num_args("ofWrapDegrees",2,2) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofWrapDegrees",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofWrapDegrees",2,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); result = (float)ofWrapDegrees(arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_wrapDegrees__SWIG_2(lua_State* L) { int SWIG_arg = 0; float arg1 ; float result;
  SWIG_check_num_args("ofWrapDegrees",1,1) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofWrapDegrees",1,"float");
  arg1 = (float)lua_tonumber(L, 1); result = (float)ofWrapDegrees(arg1); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_wrapDegrees(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 1) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { return _wrap_wrapDegrees__SWIG_2(L);}  }  if (argc == 2) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_wrapDegrees__SWIG_1(L);}  }  }  if (argc == 3) { int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { {
        _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_wrapDegrees__SWIG_0(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'wrapDegrees'\n" "  Possible C/C++ prototypes are:\n"
  "    ofWrapDegrees(float,float,float)\n" "    ofWrapDegrees(float,float)\n" "    ofWrapDegrees(float)\n");
  lua_error(L);return 0; }
static int _wrap_noise__SWIG_0(lua_State* L) { int SWIG_arg = 0; float arg1 ; float result; SWIG_check_num_args("ofNoise",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofNoise",1,"float"); arg1 = (float)lua_tonumber(L, 1); result = (float)ofNoise(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_noise__SWIG_1(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float result;
  SWIG_check_num_args("ofNoise",2,2) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofNoise",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofNoise",2,"float"); arg1 = (float)lua_tonumber(L, 1); arg2 = (float)lua_tonumber(L, 2);
  result = (float)ofNoise(arg1,arg2); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_noise__SWIG_2(lua_State* L) { int SWIG_arg = 0; glm::vec2 *arg1 = 0 ; float result;
  SWIG_check_num_args("ofNoise",1,1) if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofNoise",1,"glm::vec2 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glm__vec2,0))){ SWIG_fail_ptr("noise",1,SWIGTYPE_p_glm__vec2); } 
  result = (float)ofNoise((glm::vec2 const &)*arg1); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_noise__SWIG_3(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ; float result;
  SWIG_check_num_args("ofNoise",3,3) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofNoise",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofNoise",2,"float"); if(!lua_isnumber(L,3)) SWIG_fail_arg("ofNoise",3,"float");
  arg1 = (float)lua_tonumber(L, 1); arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3);
  result = (float)ofNoise(arg1,arg2,arg3); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_noise__SWIG_4(lua_State* L) { int SWIG_arg = 0; glm::vec3 *arg1 = 0 ; float result;
  SWIG_check_num_args("ofNoise",1,1) if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofNoise",1,"glm::vec3 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glm__vec3,0))){ SWIG_fail_ptr("noise",1,SWIGTYPE_p_glm__vec3); } 
  result = (float)ofNoise((glm::vec3 const &)*arg1); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_noise__SWIG_5(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ; float arg4 ;
  float result; SWIG_check_num_args("ofNoise",4,4) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofNoise",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofNoise",2,"float"); if(!lua_isnumber(L,3)) SWIG_fail_arg("ofNoise",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofNoise",4,"float"); arg1 = (float)lua_tonumber(L, 1); arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); result = (float)ofNoise(arg1,arg2,arg3,arg4);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_noise__SWIG_6(lua_State* L) { int SWIG_arg = 0; glm::vec4 *arg1 = 0 ; float result;
  SWIG_check_num_args("ofNoise",1,1) if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofNoise",1,"glm::vec4 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glm__vec4,0))){ SWIG_fail_ptr("noise",1,SWIGTYPE_p_glm__vec4); } 
  result = (float)ofNoise((glm::vec4 const &)*arg1); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_noise(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L); if (argc == 1) { int _v; {
      void *ptr; if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_glm__vec2, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_noise__SWIG_2(L);}  }  if (argc == 1) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { return _wrap_noise__SWIG_4(L);}  }  if (argc == 1) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_glm__vec4, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { return _wrap_noise__SWIG_6(L);}  }  if (argc == 1) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { return _wrap_noise__SWIG_0(L);}  }  if (argc == 2) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { return _wrap_noise__SWIG_1(L);}  }
     }  if (argc == 3) { int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { {
          _v = lua_isnumber(L,argv[2]); }  if (_v) { return _wrap_noise__SWIG_3(L);}  }  }  }  if (argc == 4) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); } 
        if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_noise__SWIG_5(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'noise'\n" "  Possible C/C++ prototypes are:\n"
  "    ofNoise(float)\n" "    ofNoise(float,float)\n" "    ofNoise(glm::vec2 const &)\n" "    ofNoise(float,float,float)\n"
  "    ofNoise(glm::vec3 const &)\n" "    ofNoise(float,float,float,float)\n" "    ofNoise(glm::vec4 const &)\n");
  lua_error(L);return 0; }
static int _wrap_signedNoise__SWIG_0(lua_State* L) { int SWIG_arg = 0; float arg1 ; float result;
  SWIG_check_num_args("ofSignedNoise",1,1) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofSignedNoise",1,"float");
  arg1 = (float)lua_tonumber(L, 1); result = (float)ofSignedNoise(arg1); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_signedNoise__SWIG_1(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float result;
  SWIG_check_num_args("ofSignedNoise",2,2) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofSignedNoise",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofSignedNoise",2,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); result = (float)ofSignedNoise(arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_signedNoise__SWIG_2(lua_State* L) { int SWIG_arg = 0; glm::vec2 *arg1 = 0 ; float result;
  SWIG_check_num_args("ofSignedNoise",1,1) if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofSignedNoise",1,"glm::vec2 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glm__vec2,0))){
    SWIG_fail_ptr("signedNoise",1,SWIGTYPE_p_glm__vec2); }  result = (float)ofSignedNoise((glm::vec2 const &)*arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_signedNoise__SWIG_3(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ; float result;
  SWIG_check_num_args("ofSignedNoise",3,3) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofSignedNoise",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofSignedNoise",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofSignedNoise",3,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); result = (float)ofSignedNoise(arg1,arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_signedNoise__SWIG_4(lua_State* L) { int SWIG_arg = 0; glm::vec3 *arg1 = 0 ; float result;
  SWIG_check_num_args("ofSignedNoise",1,1) if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofSignedNoise",1,"glm::vec3 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("signedNoise",1,SWIGTYPE_p_glm__vec3); }  result = (float)ofSignedNoise((glm::vec3 const &)*arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_signedNoise__SWIG_5(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ; float arg4 ;
  float result; SWIG_check_num_args("ofSignedNoise",4,4) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofSignedNoise",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofSignedNoise",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofSignedNoise",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofSignedNoise",4,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  result = (float)ofSignedNoise(arg1,arg2,arg3,arg4); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_signedNoise__SWIG_6(lua_State* L) { int SWIG_arg = 0; glm::vec4 *arg1 = 0 ; float result;
  SWIG_check_num_args("ofSignedNoise",1,1) if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofSignedNoise",1,"glm::vec4 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glm__vec4,0))){
    SWIG_fail_ptr("signedNoise",1,SWIGTYPE_p_glm__vec4); }  result = (float)ofSignedNoise((glm::vec4 const &)*arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_signedNoise(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L); if (argc == 1) { int _v;
    { void *ptr; if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_glm__vec2, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_signedNoise__SWIG_2(L);}  }  if (argc == 1) { int _v; {
      void *ptr; if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_signedNoise__SWIG_4(L);}  }  if (argc == 1) { int _v; {
      void *ptr; if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_glm__vec4, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_signedNoise__SWIG_6(L);}  }  if (argc == 1) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { return _wrap_signedNoise__SWIG_0(L);}  }  if (argc == 2) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_signedNoise__SWIG_1(L);}  }  }  if (argc == 3) { int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { {
        _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_signedNoise__SWIG_3(L);}  }  }  }  if (argc == 4) { int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) {
      { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); }
           if (_v) { return _wrap_signedNoise__SWIG_5(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'signedNoise'\n" "  Possible C/C++ prototypes are:\n"
  "    ofSignedNoise(float)\n" "    ofSignedNoise(float,float)\n" "    ofSignedNoise(glm::vec2 const &)\n"
  "    ofSignedNoise(float,float,float)\n" "    ofSignedNoise(glm::vec3 const &)\n"
  "    ofSignedNoise(float,float,float,float)\n" "    ofSignedNoise(glm::vec4 const &)\n"); lua_error(L);return 0; }
static int _wrap_nextPow2(lua_State* L) { int SWIG_arg = 0; int arg1 ; int result; SWIG_check_num_args("ofNextPow2",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofNextPow2",1,"int"); arg1 = (int)lua_tonumber(L, 1); result = (int)ofNextPow2(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_sign(lua_State* L) { int SWIG_arg = 0; float arg1 ; int result; SWIG_check_num_args("ofSign",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofSign",1,"float"); arg1 = (float)lua_tonumber(L, 1); result = (int)ofSign(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Matrix3x3_a_set(lua_State* L) { int SWIG_arg = 0; ofMatrix3x3 *arg1 = (ofMatrix3x3 *) 0 ; float arg2 ;
  SWIG_check_num_args("ofMatrix3x3::a",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix3x3::a",1,"ofMatrix3x3 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMatrix3x3::a",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix3x3,0))){
    SWIG_fail_ptr("Matrix3x3_a_set",1,SWIGTYPE_p_ofMatrix3x3); }  arg2 = (float)lua_tonumber(L, 2); if (arg1) (arg1)->a = arg2;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Matrix3x3_a_get(lua_State* L) { int SWIG_arg = 0; ofMatrix3x3 *arg1 = (ofMatrix3x3 *) 0 ; float result;
  SWIG_check_num_args("ofMatrix3x3::a",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix3x3::a",1,"ofMatrix3x3 *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix3x3,0))){
    SWIG_fail_ptr("Matrix3x3_a_get",1,SWIGTYPE_p_ofMatrix3x3); }  result = (float) ((arg1)->a);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Matrix3x3_b_set(lua_State* L) { int SWIG_arg = 0; ofMatrix3x3 *arg1 = (ofMatrix3x3 *) 0 ; float arg2 ;
  SWIG_check_num_args("ofMatrix3x3::b",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix3x3::b",1,"ofMatrix3x3 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMatrix3x3::b",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix3x3,0))){
    SWIG_fail_ptr("Matrix3x3_b_set",1,SWIGTYPE_p_ofMatrix3x3); }  arg2 = (float)lua_tonumber(L, 2); if (arg1) (arg1)->b = arg2;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Matrix3x3_b_get(lua_State* L) { int SWIG_arg = 0; ofMatrix3x3 *arg1 = (ofMatrix3x3 *) 0 ; float result;
  SWIG_check_num_args("ofMatrix3x3::b",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix3x3::b",1,"ofMatrix3x3 *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix3x3,0))){
    SWIG_fail_ptr("Matrix3x3_b_get",1,SWIGTYPE_p_ofMatrix3x3); }  result = (float) ((arg1)->b);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Matrix3x3_c_set(lua_State* L) { int SWIG_arg = 0; ofMatrix3x3 *arg1 = (ofMatrix3x3 *) 0 ; float arg2 ;
  SWIG_check_num_args("ofMatrix3x3::c",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix3x3::c",1,"ofMatrix3x3 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMatrix3x3::c",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix3x3,0))){
    SWIG_fail_ptr("Matrix3x3_c_set",1,SWIGTYPE_p_ofMatrix3x3); }  arg2 = (float)lua_tonumber(L, 2); if (arg1) (arg1)->c = arg2;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Matrix3x3_c_get(lua_State* L) { int SWIG_arg = 0; ofMatrix3x3 *arg1 = (ofMatrix3x3 *) 0 ; float result;
  SWIG_check_num_args("ofMatrix3x3::c",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix3x3::c",1,"ofMatrix3x3 *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix3x3,0))){
    SWIG_fail_ptr("Matrix3x3_c_get",1,SWIGTYPE_p_ofMatrix3x3); }  result = (float) ((arg1)->c);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Matrix3x3_d_set(lua_State* L) { int SWIG_arg = 0; ofMatrix3x3 *arg1 = (ofMatrix3x3 *) 0 ; float arg2 ;
  SWIG_check_num_args("ofMatrix3x3::d",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix3x3::d",1,"ofMatrix3x3 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMatrix3x3::d",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix3x3,0))){
    SWIG_fail_ptr("Matrix3x3_d_set",1,SWIGTYPE_p_ofMatrix3x3); }  arg2 = (float)lua_tonumber(L, 2); if (arg1) (arg1)->d = arg2;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Matrix3x3_d_get(lua_State* L) { int SWIG_arg = 0; ofMatrix3x3 *arg1 = (ofMatrix3x3 *) 0 ; float result;
  SWIG_check_num_args("ofMatrix3x3::d",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix3x3::d",1,"ofMatrix3x3 *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix3x3,0))){
    SWIG_fail_ptr("Matrix3x3_d_get",1,SWIGTYPE_p_ofMatrix3x3); }  result = (float) ((arg1)->d);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Matrix3x3_e_set(lua_State* L) { int SWIG_arg = 0; ofMatrix3x3 *arg1 = (ofMatrix3x3 *) 0 ; float arg2 ;
  SWIG_check_num_args("ofMatrix3x3::e",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix3x3::e",1,"ofMatrix3x3 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMatrix3x3::e",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix3x3,0))){
    SWIG_fail_ptr("Matrix3x3_e_set",1,SWIGTYPE_p_ofMatrix3x3); }  arg2 = (float)lua_tonumber(L, 2); if (arg1) (arg1)->e = arg2;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Matrix3x3_e_get(lua_State* L) { int SWIG_arg = 0; ofMatrix3x3 *arg1 = (ofMatrix3x3 *) 0 ; float result;
  SWIG_check_num_args("ofMatrix3x3::e",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix3x3::e",1,"ofMatrix3x3 *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix3x3,0))){
    SWIG_fail_ptr("Matrix3x3_e_get",1,SWIGTYPE_p_ofMatrix3x3); }  result = (float) ((arg1)->e);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Matrix3x3_f_set(lua_State* L) { int SWIG_arg = 0; ofMatrix3x3 *arg1 = (ofMatrix3x3 *) 0 ; float arg2 ;
  SWIG_check_num_args("ofMatrix3x3::f",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix3x3::f",1,"ofMatrix3x3 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMatrix3x3::f",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix3x3,0))){
    SWIG_fail_ptr("Matrix3x3_f_set",1,SWIGTYPE_p_ofMatrix3x3); }  arg2 = (float)lua_tonumber(L, 2); if (arg1) (arg1)->f = arg2;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Matrix3x3_f_get(lua_State* L) { int SWIG_arg = 0; ofMatrix3x3 *arg1 = (ofMatrix3x3 *) 0 ; float result;
  SWIG_check_num_args("ofMatrix3x3::f",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix3x3::f",1,"ofMatrix3x3 *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix3x3,0))){
    SWIG_fail_ptr("Matrix3x3_f_get",1,SWIGTYPE_p_ofMatrix3x3); }  result = (float) ((arg1)->f);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Matrix3x3_g_set(lua_State* L) { int SWIG_arg = 0; ofMatrix3x3 *arg1 = (ofMatrix3x3 *) 0 ; float arg2 ;
  SWIG_check_num_args("ofMatrix3x3::g",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix3x3::g",1,"ofMatrix3x3 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMatrix3x3::g",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix3x3,0))){
    SWIG_fail_ptr("Matrix3x3_g_set",1,SWIGTYPE_p_ofMatrix3x3); }  arg2 = (float)lua_tonumber(L, 2); if (arg1) (arg1)->g = arg2;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Matrix3x3_g_get(lua_State* L) { int SWIG_arg = 0; ofMatrix3x3 *arg1 = (ofMatrix3x3 *) 0 ; float result;
  SWIG_check_num_args("ofMatrix3x3::g",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix3x3::g",1,"ofMatrix3x3 *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix3x3,0))){
    SWIG_fail_ptr("Matrix3x3_g_get",1,SWIGTYPE_p_ofMatrix3x3); }  result = (float) ((arg1)->g);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Matrix3x3_h_set(lua_State* L) { int SWIG_arg = 0; ofMatrix3x3 *arg1 = (ofMatrix3x3 *) 0 ; float arg2 ;
  SWIG_check_num_args("ofMatrix3x3::h",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix3x3::h",1,"ofMatrix3x3 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMatrix3x3::h",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix3x3,0))){
    SWIG_fail_ptr("Matrix3x3_h_set",1,SWIGTYPE_p_ofMatrix3x3); }  arg2 = (float)lua_tonumber(L, 2); if (arg1) (arg1)->h = arg2;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Matrix3x3_h_get(lua_State* L) { int SWIG_arg = 0; ofMatrix3x3 *arg1 = (ofMatrix3x3 *) 0 ; float result;
  SWIG_check_num_args("ofMatrix3x3::h",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix3x3::h",1,"ofMatrix3x3 *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix3x3,0))){
    SWIG_fail_ptr("Matrix3x3_h_get",1,SWIGTYPE_p_ofMatrix3x3); }  result = (float) ((arg1)->h);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Matrix3x3_i_set(lua_State* L) { int SWIG_arg = 0; ofMatrix3x3 *arg1 = (ofMatrix3x3 *) 0 ; float arg2 ;
  SWIG_check_num_args("ofMatrix3x3::i",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix3x3::i",1,"ofMatrix3x3 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMatrix3x3::i",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix3x3,0))){
    SWIG_fail_ptr("Matrix3x3_i_set",1,SWIGTYPE_p_ofMatrix3x3); }  arg2 = (float)lua_tonumber(L, 2); if (arg1) (arg1)->i = arg2;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Matrix3x3_i_get(lua_State* L) { int SWIG_arg = 0; ofMatrix3x3 *arg1 = (ofMatrix3x3 *) 0 ; float result;
  SWIG_check_num_args("ofMatrix3x3::i",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix3x3::i",1,"ofMatrix3x3 *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix3x3,0))){
    SWIG_fail_ptr("Matrix3x3_i_get",1,SWIGTYPE_p_ofMatrix3x3); }  result = (float) ((arg1)->i);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_new_Matrix3x3__SWIG_0(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ; float arg4 ;
  float arg5 ; float arg6 ; float arg7 ; float arg8 ; float arg9 ; ofMatrix3x3 *result = 0 ;
  SWIG_check_num_args("ofMatrix3x3::ofMatrix3x3",9,9)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofMatrix3x3::ofMatrix3x3",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMatrix3x3::ofMatrix3x3",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofMatrix3x3::ofMatrix3x3",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofMatrix3x3::ofMatrix3x3",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofMatrix3x3::ofMatrix3x3",5,"float");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofMatrix3x3::ofMatrix3x3",6,"float");
  if(!lua_isnumber(L,7)) SWIG_fail_arg("ofMatrix3x3::ofMatrix3x3",7,"float");
  if(!lua_isnumber(L,8)) SWIG_fail_arg("ofMatrix3x3::ofMatrix3x3",8,"float");
  if(!lua_isnumber(L,9)) SWIG_fail_arg("ofMatrix3x3::ofMatrix3x3",9,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  arg5 = (float)lua_tonumber(L, 5); arg6 = (float)lua_tonumber(L, 6); arg7 = (float)lua_tonumber(L, 7);
  arg8 = (float)lua_tonumber(L, 8); arg9 = (float)lua_tonumber(L, 9);
  result = (ofMatrix3x3 *)new ofMatrix3x3(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofMatrix3x3,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_Matrix3x3__SWIG_1(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ; float arg4 ;
  float arg5 ; float arg6 ; float arg7 ; float arg8 ; ofMatrix3x3 *result = 0 ;
  SWIG_check_num_args("ofMatrix3x3::ofMatrix3x3",8,8)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofMatrix3x3::ofMatrix3x3",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMatrix3x3::ofMatrix3x3",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofMatrix3x3::ofMatrix3x3",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofMatrix3x3::ofMatrix3x3",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofMatrix3x3::ofMatrix3x3",5,"float");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofMatrix3x3::ofMatrix3x3",6,"float");
  if(!lua_isnumber(L,7)) SWIG_fail_arg("ofMatrix3x3::ofMatrix3x3",7,"float");
  if(!lua_isnumber(L,8)) SWIG_fail_arg("ofMatrix3x3::ofMatrix3x3",8,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  arg5 = (float)lua_tonumber(L, 5); arg6 = (float)lua_tonumber(L, 6); arg7 = (float)lua_tonumber(L, 7);
  arg8 = (float)lua_tonumber(L, 8); result = (ofMatrix3x3 *)new ofMatrix3x3(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofMatrix3x3,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_Matrix3x3__SWIG_2(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ; float arg4 ;
  float arg5 ; float arg6 ; float arg7 ; ofMatrix3x3 *result = 0 ; SWIG_check_num_args("ofMatrix3x3::ofMatrix3x3",7,7)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofMatrix3x3::ofMatrix3x3",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMatrix3x3::ofMatrix3x3",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofMatrix3x3::ofMatrix3x3",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofMatrix3x3::ofMatrix3x3",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofMatrix3x3::ofMatrix3x3",5,"float");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofMatrix3x3::ofMatrix3x3",6,"float");
  if(!lua_isnumber(L,7)) SWIG_fail_arg("ofMatrix3x3::ofMatrix3x3",7,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  arg5 = (float)lua_tonumber(L, 5); arg6 = (float)lua_tonumber(L, 6); arg7 = (float)lua_tonumber(L, 7);
  result = (ofMatrix3x3 *)new ofMatrix3x3(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofMatrix3x3,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_Matrix3x3__SWIG_3(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ; float arg4 ;
  float arg5 ; float arg6 ; ofMatrix3x3 *result = 0 ; SWIG_check_num_args("ofMatrix3x3::ofMatrix3x3",6,6)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofMatrix3x3::ofMatrix3x3",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMatrix3x3::ofMatrix3x3",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofMatrix3x3::ofMatrix3x3",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofMatrix3x3::ofMatrix3x3",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofMatrix3x3::ofMatrix3x3",5,"float");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofMatrix3x3::ofMatrix3x3",6,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  arg5 = (float)lua_tonumber(L, 5); arg6 = (float)lua_tonumber(L, 6);
  result = (ofMatrix3x3 *)new ofMatrix3x3(arg1,arg2,arg3,arg4,arg5,arg6);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofMatrix3x3,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_Matrix3x3__SWIG_4(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ; float arg4 ;
  float arg5 ; ofMatrix3x3 *result = 0 ; SWIG_check_num_args("ofMatrix3x3::ofMatrix3x3",5,5)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofMatrix3x3::ofMatrix3x3",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMatrix3x3::ofMatrix3x3",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofMatrix3x3::ofMatrix3x3",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofMatrix3x3::ofMatrix3x3",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofMatrix3x3::ofMatrix3x3",5,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  arg5 = (float)lua_tonumber(L, 5); result = (ofMatrix3x3 *)new ofMatrix3x3(arg1,arg2,arg3,arg4,arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofMatrix3x3,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_Matrix3x3__SWIG_5(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ; float arg4 ;
  ofMatrix3x3 *result = 0 ; SWIG_check_num_args("ofMatrix3x3::ofMatrix3x3",4,4)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofMatrix3x3::ofMatrix3x3",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMatrix3x3::ofMatrix3x3",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofMatrix3x3::ofMatrix3x3",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofMatrix3x3::ofMatrix3x3",4,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  result = (ofMatrix3x3 *)new ofMatrix3x3(arg1,arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofMatrix3x3,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_Matrix3x3__SWIG_6(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ;
  ofMatrix3x3 *result = 0 ; SWIG_check_num_args("ofMatrix3x3::ofMatrix3x3",3,3)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofMatrix3x3::ofMatrix3x3",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMatrix3x3::ofMatrix3x3",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofMatrix3x3::ofMatrix3x3",3,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); result = (ofMatrix3x3 *)new ofMatrix3x3(arg1,arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofMatrix3x3,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_Matrix3x3__SWIG_7(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; ofMatrix3x3 *result = 0 ;
  SWIG_check_num_args("ofMatrix3x3::ofMatrix3x3",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofMatrix3x3::ofMatrix3x3",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMatrix3x3::ofMatrix3x3",2,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); result = (ofMatrix3x3 *)new ofMatrix3x3(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofMatrix3x3,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_Matrix3x3__SWIG_8(lua_State* L) { int SWIG_arg = 0; float arg1 ; ofMatrix3x3 *result = 0 ;
  SWIG_check_num_args("ofMatrix3x3::ofMatrix3x3",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofMatrix3x3::ofMatrix3x3",1,"float"); arg1 = (float)lua_tonumber(L, 1);
  result = (ofMatrix3x3 *)new ofMatrix3x3(arg1); SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofMatrix3x3,1); SWIG_arg++; 
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_new_Matrix3x3__SWIG_9(lua_State* L) { int SWIG_arg = 0; ofMatrix3x3 *result = 0 ;
  SWIG_check_num_args("ofMatrix3x3::ofMatrix3x3",0,0) result = (ofMatrix3x3 *)new ofMatrix3x3();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofMatrix3x3,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_Matrix3x3__SWIG_10(lua_State* L) { int SWIG_arg = 0; glm::mat3 *arg1 = 0 ; ofMatrix3x3 *result = 0 ;
  SWIG_check_num_args("ofMatrix3x3::ofMatrix3x3",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofMatrix3x3::ofMatrix3x3",1,"glm::mat3 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glm__mat3,0))){
    SWIG_fail_ptr("new_Matrix3x3",1,SWIGTYPE_p_glm__mat3); }  result = (ofMatrix3x3 *)new ofMatrix3x3((glm::mat3 const &)*arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofMatrix3x3,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_Matrix3x3(lua_State* L) { int argc; int argv[10]={ 1,2,3,4,5,6,7,8,9,10} ; argc = lua_gettop(L);
  if (argc == 0) { return _wrap_new_Matrix3x3__SWIG_9(L);}  if (argc == 1) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_glm__mat3, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { return _wrap_new_Matrix3x3__SWIG_10(L);}  }  if (argc == 1) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { return _wrap_new_Matrix3x3__SWIG_8(L);}  }  if (argc == 2) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_new_Matrix3x3__SWIG_7(L);}  }  }  if (argc == 3) { int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { {
        _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_new_Matrix3x3__SWIG_6(L);}  }  }  }  if (argc == 4) { int _v; { _v = lua_isnumber(L,argv[0]); } 
    if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { {
            _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_new_Matrix3x3__SWIG_5(L);}  }  }  }  }  if (argc == 5) {
    int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { {
          _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { {
              _v = lua_isnumber(L,argv[4]); }  if (_v) { return _wrap_new_Matrix3x3__SWIG_4(L);}  }  }  }  }  } 
  if (argc == 6) { int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { {
          _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { {
              _v = lua_isnumber(L,argv[4]); }  if (_v) { { _v = lua_isnumber(L,argv[5]); }  if (_v) {
                return _wrap_new_Matrix3x3__SWIG_3(L);}  }  }  }  }  }  }  if (argc == 7) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); } 
        if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) { {
                _v = lua_isnumber(L,argv[5]); }  if (_v) { { _v = lua_isnumber(L,argv[6]); }  if (_v) {
                  return _wrap_new_Matrix3x3__SWIG_2(L);}  }  }  }  }  }  }  }  if (argc == 8) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); } 
        if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) { {
                _v = lua_isnumber(L,argv[5]); }  if (_v) { { _v = lua_isnumber(L,argv[6]); }  if (_v) { {
                    _v = lua_isnumber(L,argv[7]); }  if (_v) { return _wrap_new_Matrix3x3__SWIG_1(L);}  }  }  }  }  }  }  }  } 
  if (argc == 9) { int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { {
          _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { {
              _v = lua_isnumber(L,argv[4]); }  if (_v) { { _v = lua_isnumber(L,argv[5]); }  if (_v) { {
                  _v = lua_isnumber(L,argv[6]); }  if (_v) { { _v = lua_isnumber(L,argv[7]); }  if (_v) { {
                      _v = lua_isnumber(L,argv[8]); }  if (_v) { return _wrap_new_Matrix3x3__SWIG_0(L);}  }  }  }  }  }  }  }  }
     }  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_Matrix3x3'\n"
  "  Possible C/C++ prototypes are:\n" "    ofMatrix3x3::ofMatrix3x3(float,float,float,float,float,float,float,float,float)\n"
  "    ofMatrix3x3::ofMatrix3x3(float,float,float,float,float,float,float,float)\n"
  "    ofMatrix3x3::ofMatrix3x3(float,float,float,float,float,float,float)\n"
  "    ofMatrix3x3::ofMatrix3x3(float,float,float,float,float,float)\n"
  "    ofMatrix3x3::ofMatrix3x3(float,float,float,float,float)\n" "    ofMatrix3x3::ofMatrix3x3(float,float,float,float)\n"
  "    ofMatrix3x3::ofMatrix3x3(float,float,float)\n" "    ofMatrix3x3::ofMatrix3x3(float,float)\n"
  "    ofMatrix3x3::ofMatrix3x3(float)\n" "    ofMatrix3x3::ofMatrix3x3()\n"
  "    ofMatrix3x3::ofMatrix3x3(glm::mat3 const &)\n"); lua_error(L);return 0; }
static int _wrap_Matrix3x3_set(lua_State* L) { int SWIG_arg = 0; ofMatrix3x3 *arg1 = (ofMatrix3x3 *) 0 ; float arg2 ;
  float arg3 ; float arg4 ; float arg5 ; float arg6 ; float arg7 ; float arg8 ; float arg9 ; float arg10 ;
  SWIG_check_num_args("ofMatrix3x3::set",10,10) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix3x3::set",1,"ofMatrix3x3 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMatrix3x3::set",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofMatrix3x3::set",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofMatrix3x3::set",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofMatrix3x3::set",5,"float");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofMatrix3x3::set",6,"float");
  if(!lua_isnumber(L,7)) SWIG_fail_arg("ofMatrix3x3::set",7,"float");
  if(!lua_isnumber(L,8)) SWIG_fail_arg("ofMatrix3x3::set",8,"float");
  if(!lua_isnumber(L,9)) SWIG_fail_arg("ofMatrix3x3::set",9,"float");
  if(!lua_isnumber(L,10)) SWIG_fail_arg("ofMatrix3x3::set",10,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix3x3,0))){
    SWIG_fail_ptr("Matrix3x3_set",1,SWIGTYPE_p_ofMatrix3x3); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); arg5 = (float)lua_tonumber(L, 5);
  arg6 = (float)lua_tonumber(L, 6); arg7 = (float)lua_tonumber(L, 7); arg8 = (float)lua_tonumber(L, 8);
  arg9 = (float)lua_tonumber(L, 9); arg10 = (float)lua_tonumber(L, 10);
  (arg1)->set(arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Matrix3x3_transpose__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofMatrix3x3 *arg1 = (ofMatrix3x3 *) 0 ;
  SWIG_check_num_args("ofMatrix3x3::transpose",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix3x3::transpose",1,"ofMatrix3x3 *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix3x3,0))){
    SWIG_fail_ptr("Matrix3x3_transpose",1,SWIGTYPE_p_ofMatrix3x3); }  (arg1)->transpose(); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Matrix3x3_transpose__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofMatrix3x3 *arg1 = (ofMatrix3x3 *) 0 ;
  ofMatrix3x3 *arg2 = 0 ; ofMatrix3x3 result; SWIG_check_num_args("ofMatrix3x3::transpose",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix3x3::transpose",1,"ofMatrix3x3 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMatrix3x3::transpose",2,"ofMatrix3x3 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix3x3,0))){
    SWIG_fail_ptr("Matrix3x3_transpose",1,SWIGTYPE_p_ofMatrix3x3); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofMatrix3x3,0))){
    SWIG_fail_ptr("Matrix3x3_transpose",2,SWIGTYPE_p_ofMatrix3x3); }  result = (arg1)->transpose((ofMatrix3x3 const &)*arg2); {
    ofMatrix3x3 * resultptr = new ofMatrix3x3((const ofMatrix3x3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofMatrix3x3,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Matrix3x3_transpose(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 1) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMatrix3x3, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { return _wrap_Matrix3x3_transpose__SWIG_0(L);}  }  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMatrix3x3, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofMatrix3x3, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Matrix3x3_transpose__SWIG_1(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Matrix3x3_transpose'\n"
  "  Possible C/C++ prototypes are:\n" "    ofMatrix3x3::transpose()\n" "    ofMatrix3x3::transpose(ofMatrix3x3 const &)\n");
  lua_error(L);return 0; }
static int _wrap_Matrix3x3_determinant__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofMatrix3x3 *arg1 = (ofMatrix3x3 *) 0 ;
  float result; SWIG_check_num_args("ofMatrix3x3::determinant",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix3x3::determinant",1,"ofMatrix3x3 const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix3x3,0))){
    SWIG_fail_ptr("Matrix3x3_determinant",1,SWIGTYPE_p_ofMatrix3x3); } 
  result = (float)((ofMatrix3x3 const *)arg1)->determinant(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Matrix3x3_determinant__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofMatrix3x3 *arg1 = (ofMatrix3x3 *) 0 ;
  ofMatrix3x3 *arg2 = 0 ; float result; SWIG_check_num_args("ofMatrix3x3::determinant",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix3x3::determinant",1,"ofMatrix3x3 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMatrix3x3::determinant",2,"ofMatrix3x3 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix3x3,0))){
    SWIG_fail_ptr("Matrix3x3_determinant",1,SWIGTYPE_p_ofMatrix3x3); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofMatrix3x3,0))){
    SWIG_fail_ptr("Matrix3x3_determinant",2,SWIGTYPE_p_ofMatrix3x3); } 
  result = (float)(arg1)->determinant((ofMatrix3x3 const &)*arg2); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Matrix3x3_determinant(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 1) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMatrix3x3, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { return _wrap_Matrix3x3_determinant__SWIG_0(L);}  }  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMatrix3x3, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofMatrix3x3, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Matrix3x3_determinant__SWIG_1(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Matrix3x3_determinant'\n"
  "  Possible C/C++ prototypes are:\n" "    ofMatrix3x3::determinant() const\n"
  "    ofMatrix3x3::determinant(ofMatrix3x3 const &)\n"); lua_error(L);return 0; }
static int _wrap_Matrix3x3_inverse(lua_State* L) { int SWIG_arg = 0; ofMatrix3x3 *arg1 = (ofMatrix3x3 *) 0 ;
  ofMatrix3x3 *arg2 = 0 ; ofMatrix3x3 result; SWIG_check_num_args("ofMatrix3x3::inverse",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix3x3::inverse",1,"ofMatrix3x3 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMatrix3x3::inverse",2,"ofMatrix3x3 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix3x3,0))){
    SWIG_fail_ptr("Matrix3x3_inverse",1,SWIGTYPE_p_ofMatrix3x3); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofMatrix3x3,0))){
    SWIG_fail_ptr("Matrix3x3_inverse",2,SWIGTYPE_p_ofMatrix3x3); }  result = (arg1)->inverse((ofMatrix3x3 const &)*arg2); {
    ofMatrix3x3 * resultptr = new ofMatrix3x3((const ofMatrix3x3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofMatrix3x3,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Matrix3x3_invert(lua_State* L) { int SWIG_arg = 0; ofMatrix3x3 *arg1 = (ofMatrix3x3 *) 0 ;
  SWIG_check_num_args("ofMatrix3x3::invert",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix3x3::invert",1,"ofMatrix3x3 *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix3x3,0))){
    SWIG_fail_ptr("Matrix3x3_invert",1,SWIGTYPE_p_ofMatrix3x3); }  (arg1)->invert(); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Matrix3x3_entrywiseTimes(lua_State* L) { int SWIG_arg = 0; ofMatrix3x3 *arg1 = (ofMatrix3x3 *) 0 ;
  ofMatrix3x3 *arg2 = 0 ; ofMatrix3x3 result; SWIG_check_num_args("ofMatrix3x3::entrywiseTimes",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix3x3::entrywiseTimes",1,"ofMatrix3x3 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMatrix3x3::entrywiseTimes",2,"ofMatrix3x3 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix3x3,0))){
    SWIG_fail_ptr("Matrix3x3_entrywiseTimes",1,SWIGTYPE_p_ofMatrix3x3); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofMatrix3x3,0))){
    SWIG_fail_ptr("Matrix3x3_entrywiseTimes",2,SWIGTYPE_p_ofMatrix3x3); } 
  result = (arg1)->entrywiseTimes((ofMatrix3x3 const &)*arg2); {
    ofMatrix3x3 * resultptr = new ofMatrix3x3((const ofMatrix3x3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofMatrix3x3,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Matrix3x3___add(lua_State* L) { int SWIG_arg = 0; ofMatrix3x3 *arg1 = (ofMatrix3x3 *) 0 ;
  ofMatrix3x3 *arg2 = 0 ; ofMatrix3x3 result; SWIG_check_num_args("ofMatrix3x3::operator +",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix3x3::operator +",1,"ofMatrix3x3 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMatrix3x3::operator +",2,"ofMatrix3x3 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix3x3,0))){
    SWIG_fail_ptr("Matrix3x3___add",1,SWIGTYPE_p_ofMatrix3x3); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofMatrix3x3,0))){
    SWIG_fail_ptr("Matrix3x3___add",2,SWIGTYPE_p_ofMatrix3x3); }  result = (arg1)->operator +((ofMatrix3x3 const &)*arg2); {
    ofMatrix3x3 * resultptr = new ofMatrix3x3((const ofMatrix3x3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofMatrix3x3,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Matrix3x3___sub(lua_State* L) { int SWIG_arg = 0; ofMatrix3x3 *arg1 = (ofMatrix3x3 *) 0 ;
  ofMatrix3x3 *arg2 = 0 ; ofMatrix3x3 result; SWIG_check_num_args("ofMatrix3x3::operator -",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix3x3::operator -",1,"ofMatrix3x3 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMatrix3x3::operator -",2,"ofMatrix3x3 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix3x3,0))){
    SWIG_fail_ptr("Matrix3x3___sub",1,SWIGTYPE_p_ofMatrix3x3); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofMatrix3x3,0))){
    SWIG_fail_ptr("Matrix3x3___sub",2,SWIGTYPE_p_ofMatrix3x3); }  result = (arg1)->operator -((ofMatrix3x3 const &)*arg2); {
    ofMatrix3x3 * resultptr = new ofMatrix3x3((const ofMatrix3x3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofMatrix3x3,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Matrix3x3___mul__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofMatrix3x3 *arg1 = (ofMatrix3x3 *) 0 ; float arg2 ;
  ofMatrix3x3 result; SWIG_check_num_args("ofMatrix3x3::operator *",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix3x3::operator *",1,"ofMatrix3x3 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMatrix3x3::operator *",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix3x3,0))){
    SWIG_fail_ptr("Matrix3x3___mul",1,SWIGTYPE_p_ofMatrix3x3); }  arg2 = (float)lua_tonumber(L, 2);
  result = (arg1)->operator *(arg2); { ofMatrix3x3 * resultptr = new ofMatrix3x3((const ofMatrix3x3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofMatrix3x3,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Matrix3x3___mul__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofMatrix3x3 *arg1 = (ofMatrix3x3 *) 0 ;
  ofMatrix3x3 *arg2 = 0 ; ofMatrix3x3 result; SWIG_check_num_args("ofMatrix3x3::operator *",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix3x3::operator *",1,"ofMatrix3x3 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMatrix3x3::operator *",2,"ofMatrix3x3 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix3x3,0))){
    SWIG_fail_ptr("Matrix3x3___mul",1,SWIGTYPE_p_ofMatrix3x3); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofMatrix3x3,0))){
    SWIG_fail_ptr("Matrix3x3___mul",2,SWIGTYPE_p_ofMatrix3x3); }  result = (arg1)->operator *((ofMatrix3x3 const &)*arg2); {
    ofMatrix3x3 * resultptr = new ofMatrix3x3((const ofMatrix3x3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofMatrix3x3,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Matrix3x3___mul(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 2) { int _v;
    { void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMatrix3x3, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofMatrix3x3, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Matrix3x3___mul__SWIG_1(L);}  }  }  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMatrix3x3, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { return _wrap_Matrix3x3___mul__SWIG_0(L);}  }
     }  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Matrix3x3___mul'\n"
  "  Possible C/C++ prototypes are:\n" "    ofMatrix3x3::operator *(float)\n"
  "    ofMatrix3x3::operator *(ofMatrix3x3 const &)\n"); lua_error(L);return 0; }
static int _wrap_Matrix3x3___div(lua_State* L) { int SWIG_arg = 0; ofMatrix3x3 *arg1 = (ofMatrix3x3 *) 0 ; float arg2 ;
  ofMatrix3x3 result; SWIG_check_num_args("ofMatrix3x3::operator /",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix3x3::operator /",1,"ofMatrix3x3 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMatrix3x3::operator /",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix3x3,0))){
    SWIG_fail_ptr("Matrix3x3___div",1,SWIGTYPE_p_ofMatrix3x3); }  arg2 = (float)lua_tonumber(L, 2);
  result = (arg1)->operator /(arg2); { ofMatrix3x3 * resultptr = new ofMatrix3x3((const ofMatrix3x3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofMatrix3x3,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Matrix3x3___tostring(lua_State* L) { int SWIG_arg = 0; ofMatrix3x3 *arg1 = (ofMatrix3x3 *) 0 ;
  char *result = 0 ; SWIG_check_num_args("ofMatrix3x3::__str__",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix3x3::__str__",1,"ofMatrix3x3 *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix3x3,0))){
    SWIG_fail_ptr("Matrix3x3___tostring",1,SWIGTYPE_p_ofMatrix3x3); }  result = (char *)ofMatrix3x3___str__(arg1);
  lua_pushstring(L,(const char *)result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static void swig_delete_Matrix3x3(void *obj) {
ofMatrix3x3 *arg1 = (ofMatrix3x3 *) obj;
delete arg1;
}
static int _proxy__wrap_new_Matrix3x3(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_Matrix3x3);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_Matrix3x3_attributes[] = {
    { "a", _wrap_Matrix3x3_a_get, _wrap_Matrix3x3_a_set },
    { "b", _wrap_Matrix3x3_b_get, _wrap_Matrix3x3_b_set },
    { "c", _wrap_Matrix3x3_c_get, _wrap_Matrix3x3_c_set },
    { "d", _wrap_Matrix3x3_d_get, _wrap_Matrix3x3_d_set },
    { "e", _wrap_Matrix3x3_e_get, _wrap_Matrix3x3_e_set },
    { "f", _wrap_Matrix3x3_f_get, _wrap_Matrix3x3_f_set },
    { "g", _wrap_Matrix3x3_g_get, _wrap_Matrix3x3_g_set },
    { "h", _wrap_Matrix3x3_h_get, _wrap_Matrix3x3_h_set },
    { "i", _wrap_Matrix3x3_i_get, _wrap_Matrix3x3_i_set },
    {0,0,0}
};
static swig_lua_method swig_Matrix3x3_methods[]= {
    { "set", _wrap_Matrix3x3_set},
    { "transpose", _wrap_Matrix3x3_transpose},
    { "determinant", _wrap_Matrix3x3_determinant},
    { "inverse", _wrap_Matrix3x3_inverse},
    { "invert", _wrap_Matrix3x3_invert},
    { "entrywiseTimes", _wrap_Matrix3x3_entrywiseTimes},
    { "__add", _wrap_Matrix3x3___add},
    { "__sub", _wrap_Matrix3x3___sub},
    { "__mul", _wrap_Matrix3x3___mul},
    { "__div", _wrap_Matrix3x3___div},
    { "__tostring", _wrap_Matrix3x3___tostring},
    {0,0}
};
static swig_lua_method swig_Matrix3x3_meta[] = {
    { "__add", _wrap_Matrix3x3___add},
    { "__sub", _wrap_Matrix3x3___sub},
    { "__mul", _wrap_Matrix3x3___mul},
    { "__div", _wrap_Matrix3x3___div},
    { "__tostring", _wrap_Matrix3x3___tostring},
    {0,0}
};

static swig_lua_attribute swig_Matrix3x3_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_Matrix3x3_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_Matrix3x3_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_Matrix3x3_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_Matrix3x3_Sf_SwigStatic = {
    "Matrix3x3",
    swig_Matrix3x3_Sf_SwigStatic_methods,
    swig_Matrix3x3_Sf_SwigStatic_attributes,
    swig_Matrix3x3_Sf_SwigStatic_constants,
    swig_Matrix3x3_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_Matrix3x3_bases[] = {0};
static const char *swig_Matrix3x3_base_names[] = {0};
static swig_lua_class _wrap_class_Matrix3x3 = { "Matrix3x3", "Matrix3x3", &SWIGTYPE_p_ofMatrix3x3,_proxy__wrap_new_Matrix3x3, swig_delete_Matrix3x3, swig_Matrix3x3_methods, swig_Matrix3x3_attributes, &swig_Matrix3x3_Sf_SwigStatic, swig_Matrix3x3_meta, swig_Matrix3x3_bases, swig_Matrix3x3_base_names };

static int _wrap_Matrix4x4__mat_set(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ; ofVec4f *arg2 ;
  SWIG_check_num_args("ofMatrix4x4::_mat",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::_mat",1,"ofMatrix4x4 *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofMatrix4x4::_mat",2,"ofVec4f [4]");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4__mat_set",1,SWIGTYPE_p_ofMatrix4x4); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec4f,0))){
    SWIG_fail_ptr("Matrix4x4__mat_set",2,SWIGTYPE_p_ofVec4f); }  { size_t ii; ofVec4f *b = (ofVec4f *) arg1->_mat;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((ofVec4f *) arg2 + ii); }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4__mat_get(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ;
  ofVec4f *result = 0 ; SWIG_check_num_args("ofMatrix4x4::_mat",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::_mat",1,"ofMatrix4x4 *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4__mat_get",1,SWIGTYPE_p_ofMatrix4x4); }  result = (ofVec4f *)(ofVec4f *) ((arg1)->_mat);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofVec4f,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_Matrix4x4__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *result = 0 ;
  SWIG_check_num_args("ofMatrix4x4::ofMatrix4x4",0,0) result = (ofMatrix4x4 *)new ofMatrix4x4();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofMatrix4x4,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_Matrix4x4__SWIG_1(lua_State* L) { int SWIG_arg = 0; glm::mat4 *arg1 = 0 ; ofMatrix4x4 *result = 0 ;
  SWIG_check_num_args("ofMatrix4x4::ofMatrix4x4",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofMatrix4x4::ofMatrix4x4",1,"glm::mat4 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glm__mat4,0))){
    SWIG_fail_ptr("new_Matrix4x4",1,SWIGTYPE_p_glm__mat4); }  result = (ofMatrix4x4 *)new ofMatrix4x4((glm::mat4 const &)*arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofMatrix4x4,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_Matrix4x4__SWIG_2(lua_State* L) { int SWIG_arg = 0; float *arg1 = (float *) (float *)0 ;
  ofMatrix4x4 *result = 0 ; SWIG_check_num_args("ofMatrix4x4::ofMatrix4x4",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::ofMatrix4x4",1,"float const *const");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_float,0))){ SWIG_fail_ptr("new_Matrix4x4",1,SWIGTYPE_p_float); } 
  result = (ofMatrix4x4 *)new ofMatrix4x4((float const *)arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofMatrix4x4,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_Matrix4x4__SWIG_3(lua_State* L) { int SWIG_arg = 0; ofQuaternion *arg1 = 0 ; ofMatrix4x4 *result = 0 ;
  SWIG_check_num_args("ofMatrix4x4::ofMatrix4x4",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofMatrix4x4::ofMatrix4x4",1,"ofQuaternion const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofQuaternion,0))){
    SWIG_fail_ptr("new_Matrix4x4",1,SWIGTYPE_p_ofQuaternion); } 
  result = (ofMatrix4x4 *)new ofMatrix4x4((ofQuaternion const &)*arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofMatrix4x4,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_Matrix4x4__SWIG_4(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ; float arg4 ;
  float arg5 ; float arg6 ; float arg7 ; float arg8 ; float arg9 ; float arg10 ; float arg11 ; float arg12 ; float arg13 ;
  float arg14 ; float arg15 ; float arg16 ; ofMatrix4x4 *result = 0 ; SWIG_check_num_args("ofMatrix4x4::ofMatrix4x4",16,16)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofMatrix4x4::ofMatrix4x4",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMatrix4x4::ofMatrix4x4",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofMatrix4x4::ofMatrix4x4",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofMatrix4x4::ofMatrix4x4",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofMatrix4x4::ofMatrix4x4",5,"float");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofMatrix4x4::ofMatrix4x4",6,"float");
  if(!lua_isnumber(L,7)) SWIG_fail_arg("ofMatrix4x4::ofMatrix4x4",7,"float");
  if(!lua_isnumber(L,8)) SWIG_fail_arg("ofMatrix4x4::ofMatrix4x4",8,"float");
  if(!lua_isnumber(L,9)) SWIG_fail_arg("ofMatrix4x4::ofMatrix4x4",9,"float");
  if(!lua_isnumber(L,10)) SWIG_fail_arg("ofMatrix4x4::ofMatrix4x4",10,"float");
  if(!lua_isnumber(L,11)) SWIG_fail_arg("ofMatrix4x4::ofMatrix4x4",11,"float");
  if(!lua_isnumber(L,12)) SWIG_fail_arg("ofMatrix4x4::ofMatrix4x4",12,"float");
  if(!lua_isnumber(L,13)) SWIG_fail_arg("ofMatrix4x4::ofMatrix4x4",13,"float");
  if(!lua_isnumber(L,14)) SWIG_fail_arg("ofMatrix4x4::ofMatrix4x4",14,"float");
  if(!lua_isnumber(L,15)) SWIG_fail_arg("ofMatrix4x4::ofMatrix4x4",15,"float");
  if(!lua_isnumber(L,16)) SWIG_fail_arg("ofMatrix4x4::ofMatrix4x4",16,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  arg5 = (float)lua_tonumber(L, 5); arg6 = (float)lua_tonumber(L, 6); arg7 = (float)lua_tonumber(L, 7);
  arg8 = (float)lua_tonumber(L, 8); arg9 = (float)lua_tonumber(L, 9); arg10 = (float)lua_tonumber(L, 10);
  arg11 = (float)lua_tonumber(L, 11); arg12 = (float)lua_tonumber(L, 12); arg13 = (float)lua_tonumber(L, 13);
  arg14 = (float)lua_tonumber(L, 14); arg15 = (float)lua_tonumber(L, 15); arg16 = (float)lua_tonumber(L, 16);
  result = (ofMatrix4x4 *)new ofMatrix4x4(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12,arg13,arg14,arg15,arg16);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofMatrix4x4,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_Matrix4x4(lua_State* L) { int argc; int argv[17]={ 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17} ;
  argc = lua_gettop(L); if (argc == 0) { return _wrap_new_Matrix4x4__SWIG_0(L);}  if (argc == 1) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_glm__mat4, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { return _wrap_new_Matrix4x4__SWIG_1(L);}  }  if (argc == 1) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_float, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { return _wrap_new_Matrix4x4__SWIG_2(L);}  }  if (argc == 1) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofQuaternion, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { return _wrap_new_Matrix4x4__SWIG_3(L);}  }  if (argc == 16) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); } 
        if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) { {
                _v = lua_isnumber(L,argv[5]); }  if (_v) { { _v = lua_isnumber(L,argv[6]); }  if (_v) { {
                    _v = lua_isnumber(L,argv[7]); }  if (_v) { { _v = lua_isnumber(L,argv[8]); }  if (_v) { {
                        _v = lua_isnumber(L,argv[9]); }  if (_v) { { _v = lua_isnumber(L,argv[10]); }  if (_v) { {
                            _v = lua_isnumber(L,argv[11]); }  if (_v) { { _v = lua_isnumber(L,argv[12]); }  if (_v) { {
                                _v = lua_isnumber(L,argv[13]); }  if (_v) { { _v = lua_isnumber(L,argv[14]); }  if (_v) { {
                                    _v = lua_isnumber(L,argv[15]); }  if (_v) { return _wrap_new_Matrix4x4__SWIG_4(L);}  }  }  }
                             }  }  }  }  }  }  }  }  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_Matrix4x4'\n" "  Possible C/C++ prototypes are:\n"
  "    ofMatrix4x4::ofMatrix4x4()\n" "    ofMatrix4x4::ofMatrix4x4(glm::mat4 const &)\n"
  "    ofMatrix4x4::ofMatrix4x4(float const *const)\n" "    ofMatrix4x4::ofMatrix4x4(ofQuaternion const &)\n"
  "    ofMatrix4x4::ofMatrix4x4(float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float)\n");
  lua_error(L);return 0; }
static int _wrap_Matrix4x4_makeIdentityMatrix(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ;
  SWIG_check_num_args("ofMatrix4x4::makeIdentityMatrix",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::makeIdentityMatrix",1,"ofMatrix4x4 *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_makeIdentityMatrix",1,SWIGTYPE_p_ofMatrix4x4); }  (arg1)->makeIdentityMatrix(); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_makeScaleMatrix__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ;
  ofVec3f *arg2 = 0 ; SWIG_check_num_args("ofMatrix4x4::makeScaleMatrix",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::makeScaleMatrix",1,"ofMatrix4x4 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMatrix4x4::makeScaleMatrix",2,"ofVec3f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_makeScaleMatrix",1,SWIGTYPE_p_ofMatrix4x4); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Matrix4x4_makeScaleMatrix",2,SWIGTYPE_p_ofVec3f); }  (arg1)->makeScaleMatrix((ofVec3f const &)*arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_makeScaleMatrix__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ;
  float arg2 ; float arg3 ; float arg4 ; SWIG_check_num_args("ofMatrix4x4::makeScaleMatrix",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::makeScaleMatrix",1,"ofMatrix4x4 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMatrix4x4::makeScaleMatrix",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofMatrix4x4::makeScaleMatrix",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofMatrix4x4::makeScaleMatrix",4,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_makeScaleMatrix",1,SWIGTYPE_p_ofMatrix4x4); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); (arg1)->makeScaleMatrix(arg2,arg3,arg4); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_makeScaleMatrix(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L);
  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMatrix4x4, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Matrix4x4_makeScaleMatrix__SWIG_0(L);}  }  }  if (argc == 4) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMatrix4x4, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_Matrix4x4_makeScaleMatrix__SWIG_1(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Matrix4x4_makeScaleMatrix'\n"
  "  Possible C/C++ prototypes are:\n" "    ofMatrix4x4::makeScaleMatrix(ofVec3f const &)\n"
  "    ofMatrix4x4::makeScaleMatrix(float,float,float)\n"); lua_error(L);return 0; }
static int _wrap_Matrix4x4_makeTranslationMatrix__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ; ofVec3f *arg2 = 0 ; SWIG_check_num_args("ofMatrix4x4::makeTranslationMatrix",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::makeTranslationMatrix",1,"ofMatrix4x4 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMatrix4x4::makeTranslationMatrix",2,"ofVec3f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_makeTranslationMatrix",1,SWIGTYPE_p_ofMatrix4x4); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Matrix4x4_makeTranslationMatrix",2,SWIGTYPE_p_ofVec3f); } 
  (arg1)->makeTranslationMatrix((ofVec3f const &)*arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_makeTranslationMatrix__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ; float arg2 ; float arg3 ; float arg4 ;
  SWIG_check_num_args("ofMatrix4x4::makeTranslationMatrix",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::makeTranslationMatrix",1,"ofMatrix4x4 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMatrix4x4::makeTranslationMatrix",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofMatrix4x4::makeTranslationMatrix",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofMatrix4x4::makeTranslationMatrix",4,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_makeTranslationMatrix",1,SWIGTYPE_p_ofMatrix4x4); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); (arg1)->makeTranslationMatrix(arg2,arg3,arg4);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_makeTranslationMatrix(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L);
  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMatrix4x4, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Matrix4x4_makeTranslationMatrix__SWIG_0(L);}  }  }  if (argc == 4) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMatrix4x4, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          { _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_Matrix4x4_makeTranslationMatrix__SWIG_1(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Matrix4x4_makeTranslationMatrix'\n"
  "  Possible C/C++ prototypes are:\n" "    ofMatrix4x4::makeTranslationMatrix(ofVec3f const &)\n"
  "    ofMatrix4x4::makeTranslationMatrix(float,float,float)\n"); lua_error(L);return 0; }
static int _wrap_Matrix4x4_makeRotationMatrix__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ;
  ofVec3f *arg2 = 0 ; ofVec3f *arg3 = 0 ; SWIG_check_num_args("ofMatrix4x4::makeRotationMatrix",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::makeRotationMatrix",1,"ofMatrix4x4 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMatrix4x4::makeRotationMatrix",2,"ofVec3f const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofMatrix4x4::makeRotationMatrix",3,"ofVec3f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_makeRotationMatrix",1,SWIGTYPE_p_ofMatrix4x4); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Matrix4x4_makeRotationMatrix",2,SWIGTYPE_p_ofVec3f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Matrix4x4_makeRotationMatrix",3,SWIGTYPE_p_ofVec3f); } 
  (arg1)->makeRotationMatrix((ofVec3f const &)*arg2,(ofVec3f const &)*arg3); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_makeRotationMatrix__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ;
  float arg2 ; ofVec3f *arg3 = 0 ; SWIG_check_num_args("ofMatrix4x4::makeRotationMatrix",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::makeRotationMatrix",1,"ofMatrix4x4 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMatrix4x4::makeRotationMatrix",2,"float");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofMatrix4x4::makeRotationMatrix",3,"ofVec3f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_makeRotationMatrix",1,SWIGTYPE_p_ofMatrix4x4); }  arg2 = (float)lua_tonumber(L, 2);
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Matrix4x4_makeRotationMatrix",3,SWIGTYPE_p_ofVec3f); } 
  (arg1)->makeRotationMatrix(arg2,(ofVec3f const &)*arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Matrix4x4_makeRotationMatrix__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ;
  float arg2 ; float arg3 ; float arg4 ; float arg5 ; SWIG_check_num_args("ofMatrix4x4::makeRotationMatrix",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::makeRotationMatrix",1,"ofMatrix4x4 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMatrix4x4::makeRotationMatrix",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofMatrix4x4::makeRotationMatrix",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofMatrix4x4::makeRotationMatrix",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofMatrix4x4::makeRotationMatrix",5,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_makeRotationMatrix",1,SWIGTYPE_p_ofMatrix4x4); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); arg5 = (float)lua_tonumber(L, 5);
  (arg1)->makeRotationMatrix(arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_makeRotationMatrix__SWIG_3(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ;
  ofQuaternion *arg2 = 0 ; SWIG_check_num_args("ofMatrix4x4::makeRotationMatrix",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::makeRotationMatrix",1,"ofMatrix4x4 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMatrix4x4::makeRotationMatrix",2,"ofQuaternion const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_makeRotationMatrix",1,SWIGTYPE_p_ofMatrix4x4); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofQuaternion,0))){
    SWIG_fail_ptr("Matrix4x4_makeRotationMatrix",2,SWIGTYPE_p_ofQuaternion); } 
  (arg1)->makeRotationMatrix((ofQuaternion const &)*arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Matrix4x4_makeRotationMatrix__SWIG_4(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ;
  float arg2 ; ofVec3f *arg3 = 0 ; float arg4 ; ofVec3f *arg5 = 0 ; float arg6 ; ofVec3f *arg7 = 0 ;
  SWIG_check_num_args("ofMatrix4x4::makeRotationMatrix",7,7)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::makeRotationMatrix",1,"ofMatrix4x4 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMatrix4x4::makeRotationMatrix",2,"float");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofMatrix4x4::makeRotationMatrix",3,"ofVec3f const &");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofMatrix4x4::makeRotationMatrix",4,"float");
  if(!lua_isuserdata(L,5)) SWIG_fail_arg("ofMatrix4x4::makeRotationMatrix",5,"ofVec3f const &");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofMatrix4x4::makeRotationMatrix",6,"float");
  if(!lua_isuserdata(L,7)) SWIG_fail_arg("ofMatrix4x4::makeRotationMatrix",7,"ofVec3f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_makeRotationMatrix",1,SWIGTYPE_p_ofMatrix4x4); }  arg2 = (float)lua_tonumber(L, 2);
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Matrix4x4_makeRotationMatrix",3,SWIGTYPE_p_ofVec3f); }  arg4 = (float)lua_tonumber(L, 4);
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&arg5,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Matrix4x4_makeRotationMatrix",5,SWIGTYPE_p_ofVec3f); }  arg6 = (float)lua_tonumber(L, 6);
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,7,(void**)&arg7,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Matrix4x4_makeRotationMatrix",7,SWIGTYPE_p_ofVec3f); } 
  (arg1)->makeRotationMatrix(arg2,(ofVec3f const &)*arg3,arg4,(ofVec3f const &)*arg5,arg6,(ofVec3f const &)*arg7);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_makeRotationMatrix(lua_State* L) { int argc; int argv[8]={ 1,2,3,4,5,6,7,8} ; argc = lua_gettop(L);
  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMatrix4x4, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofQuaternion, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Matrix4x4_makeRotationMatrix__SWIG_3(L);}  }  }  if (argc == 3) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMatrix4x4, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }
           else { _v = 1; }  }  if (_v) { return _wrap_Matrix4x4_makeRotationMatrix__SWIG_0(L);}  }  }  }  if (argc == 3) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMatrix4x4, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }
           else { _v = 1; }  }  if (_v) { return _wrap_Matrix4x4_makeRotationMatrix__SWIG_1(L);}  }  }  }  if (argc == 5) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMatrix4x4, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) {
              return _wrap_Matrix4x4_makeRotationMatrix__SWIG_2(L);}  }  }  }  }  }  if (argc == 7) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMatrix4x4, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }
           else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { { void *ptr;
              if (lua_isuserdata(L,argv[4])==0 || SWIG_ConvertPtr(L,argv[4], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }
               else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[5]); }  if (_v) { { void *ptr;
                  if (lua_isuserdata(L,argv[6])==0 || SWIG_ConvertPtr(L,argv[6], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) {
                    _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Matrix4x4_makeRotationMatrix__SWIG_4(L);}  }  }  }  }
         }  }  }  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Matrix4x4_makeRotationMatrix'\n"
  "  Possible C/C++ prototypes are:\n" "    ofMatrix4x4::makeRotationMatrix(ofVec3f const &,ofVec3f const &)\n"
  "    ofMatrix4x4::makeRotationMatrix(float,ofVec3f const &)\n"
  "    ofMatrix4x4::makeRotationMatrix(float,float,float,float)\n" "    ofMatrix4x4::makeRotationMatrix(ofQuaternion const &)\n"
  "    ofMatrix4x4::makeRotationMatrix(float,ofVec3f const &,float,ofVec3f const &,float,ofVec3f const &)\n");
  lua_error(L);return 0; }
static int _wrap_Matrix4x4_makeInvertOf(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ;
  ofMatrix4x4 *arg2 = 0 ; bool result; SWIG_check_num_args("ofMatrix4x4::makeInvertOf",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::makeInvertOf",1,"ofMatrix4x4 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMatrix4x4::makeInvertOf",2,"ofMatrix4x4 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_makeInvertOf",1,SWIGTYPE_p_ofMatrix4x4); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_makeInvertOf",2,SWIGTYPE_p_ofMatrix4x4); } 
  result = (bool)(arg1)->makeInvertOf((ofMatrix4x4 const &)*arg2); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_makeOrthoNormalOf(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ;
  ofMatrix4x4 *arg2 = 0 ; SWIG_check_num_args("ofMatrix4x4::makeOrthoNormalOf",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::makeOrthoNormalOf",1,"ofMatrix4x4 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMatrix4x4::makeOrthoNormalOf",2,"ofMatrix4x4 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_makeOrthoNormalOf",1,SWIGTYPE_p_ofMatrix4x4); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_makeOrthoNormalOf",2,SWIGTYPE_p_ofMatrix4x4); } 
  (arg1)->makeOrthoNormalOf((ofMatrix4x4 const &)*arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_makeFromMultiplicationOf(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ;
  ofMatrix4x4 *arg2 = 0 ; ofMatrix4x4 *arg3 = 0 ; SWIG_check_num_args("ofMatrix4x4::makeFromMultiplicationOf",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::makeFromMultiplicationOf",1,"ofMatrix4x4 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMatrix4x4::makeFromMultiplicationOf",2,"ofMatrix4x4 const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofMatrix4x4::makeFromMultiplicationOf",3,"ofMatrix4x4 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_makeFromMultiplicationOf",1,SWIGTYPE_p_ofMatrix4x4); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_makeFromMultiplicationOf",2,SWIGTYPE_p_ofMatrix4x4); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_makeFromMultiplicationOf",3,SWIGTYPE_p_ofMatrix4x4); } 
  (arg1)->makeFromMultiplicationOf((ofMatrix4x4 const &)*arg2,(ofMatrix4x4 const &)*arg3); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_makeOrthoMatrix(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ;
  double arg2 ; double arg3 ; double arg4 ; double arg5 ; double arg6 ; double arg7 ;
  SWIG_check_num_args("ofMatrix4x4::makeOrthoMatrix",7,7)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::makeOrthoMatrix",1,"ofMatrix4x4 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMatrix4x4::makeOrthoMatrix",2,"double");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofMatrix4x4::makeOrthoMatrix",3,"double");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofMatrix4x4::makeOrthoMatrix",4,"double");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofMatrix4x4::makeOrthoMatrix",5,"double");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofMatrix4x4::makeOrthoMatrix",6,"double");
  if(!lua_isnumber(L,7)) SWIG_fail_arg("ofMatrix4x4::makeOrthoMatrix",7,"double");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_makeOrthoMatrix",1,SWIGTYPE_p_ofMatrix4x4); }  arg2 = (double)lua_tonumber(L, 2);
  arg3 = (double)lua_tonumber(L, 3); arg4 = (double)lua_tonumber(L, 4); arg5 = (double)lua_tonumber(L, 5);
  arg6 = (double)lua_tonumber(L, 6); arg7 = (double)lua_tonumber(L, 7); (arg1)->makeOrthoMatrix(arg2,arg3,arg4,arg5,arg6,arg7);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_makeOrtho2DMatrix(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ;
  double arg2 ; double arg3 ; double arg4 ; double arg5 ; SWIG_check_num_args("ofMatrix4x4::makeOrtho2DMatrix",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::makeOrtho2DMatrix",1,"ofMatrix4x4 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMatrix4x4::makeOrtho2DMatrix",2,"double");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofMatrix4x4::makeOrtho2DMatrix",3,"double");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofMatrix4x4::makeOrtho2DMatrix",4,"double");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofMatrix4x4::makeOrtho2DMatrix",5,"double");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_makeOrtho2DMatrix",1,SWIGTYPE_p_ofMatrix4x4); }  arg2 = (double)lua_tonumber(L, 2);
  arg3 = (double)lua_tonumber(L, 3); arg4 = (double)lua_tonumber(L, 4); arg5 = (double)lua_tonumber(L, 5);
  (arg1)->makeOrtho2DMatrix(arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_makeFrustumMatrix(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ;
  double arg2 ; double arg3 ; double arg4 ; double arg5 ; double arg6 ; double arg7 ;
  SWIG_check_num_args("ofMatrix4x4::makeFrustumMatrix",7,7)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::makeFrustumMatrix",1,"ofMatrix4x4 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMatrix4x4::makeFrustumMatrix",2,"double");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofMatrix4x4::makeFrustumMatrix",3,"double");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofMatrix4x4::makeFrustumMatrix",4,"double");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofMatrix4x4::makeFrustumMatrix",5,"double");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofMatrix4x4::makeFrustumMatrix",6,"double");
  if(!lua_isnumber(L,7)) SWIG_fail_arg("ofMatrix4x4::makeFrustumMatrix",7,"double");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_makeFrustumMatrix",1,SWIGTYPE_p_ofMatrix4x4); }  arg2 = (double)lua_tonumber(L, 2);
  arg3 = (double)lua_tonumber(L, 3); arg4 = (double)lua_tonumber(L, 4); arg5 = (double)lua_tonumber(L, 5);
  arg6 = (double)lua_tonumber(L, 6); arg7 = (double)lua_tonumber(L, 7);
  (arg1)->makeFrustumMatrix(arg2,arg3,arg4,arg5,arg6,arg7); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Matrix4x4_makePerspectiveMatrix(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ;
  double arg2 ; double arg3 ; double arg4 ; double arg5 ; SWIG_check_num_args("ofMatrix4x4::makePerspectiveMatrix",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::makePerspectiveMatrix",1,"ofMatrix4x4 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMatrix4x4::makePerspectiveMatrix",2,"double");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofMatrix4x4::makePerspectiveMatrix",3,"double");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofMatrix4x4::makePerspectiveMatrix",4,"double");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofMatrix4x4::makePerspectiveMatrix",5,"double");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_makePerspectiveMatrix",1,SWIGTYPE_p_ofMatrix4x4); }  arg2 = (double)lua_tonumber(L, 2);
  arg3 = (double)lua_tonumber(L, 3); arg4 = (double)lua_tonumber(L, 4); arg5 = (double)lua_tonumber(L, 5);
  (arg1)->makePerspectiveMatrix(arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_makeLookAtMatrix(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ;
  ofVec3f *arg2 = 0 ; ofVec3f *arg3 = 0 ; ofVec3f *arg4 = 0 ; SWIG_check_num_args("ofMatrix4x4::makeLookAtMatrix",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::makeLookAtMatrix",1,"ofMatrix4x4 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMatrix4x4::makeLookAtMatrix",2,"ofVec3f const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofMatrix4x4::makeLookAtMatrix",3,"ofVec3f const &");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("ofMatrix4x4::makeLookAtMatrix",4,"ofVec3f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_makeLookAtMatrix",1,SWIGTYPE_p_ofMatrix4x4); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Matrix4x4_makeLookAtMatrix",2,SWIGTYPE_p_ofVec3f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Matrix4x4_makeLookAtMatrix",3,SWIGTYPE_p_ofVec3f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Matrix4x4_makeLookAtMatrix",4,SWIGTYPE_p_ofVec3f); } 
  (arg1)->makeLookAtMatrix((ofVec3f const &)*arg2,(ofVec3f const &)*arg3,(ofVec3f const &)*arg4); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_makeLookAtViewMatrix(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ;
  ofVec3f *arg2 = 0 ; ofVec3f *arg3 = 0 ; ofVec3f *arg4 = 0 ; SWIG_check_num_args("ofMatrix4x4::makeLookAtViewMatrix",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::makeLookAtViewMatrix",1,"ofMatrix4x4 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMatrix4x4::makeLookAtViewMatrix",2,"ofVec3f const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofMatrix4x4::makeLookAtViewMatrix",3,"ofVec3f const &");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("ofMatrix4x4::makeLookAtViewMatrix",4,"ofVec3f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_makeLookAtViewMatrix",1,SWIGTYPE_p_ofMatrix4x4); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Matrix4x4_makeLookAtViewMatrix",2,SWIGTYPE_p_ofVec3f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Matrix4x4_makeLookAtViewMatrix",3,SWIGTYPE_p_ofVec3f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Matrix4x4_makeLookAtViewMatrix",4,SWIGTYPE_p_ofVec3f); } 
  (arg1)->makeLookAtViewMatrix((ofVec3f const &)*arg2,(ofVec3f const &)*arg3,(ofVec3f const &)*arg4); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_newIdentityMatrix(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 result;
  SWIG_check_num_args("ofMatrix4x4::newIdentityMatrix",0,0) result = ofMatrix4x4::newIdentityMatrix(); {
    ofMatrix4x4 * resultptr = new ofMatrix4x4((const ofMatrix4x4 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofMatrix4x4,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_newScaleMatrix__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofVec3f *arg1 = 0 ; ofMatrix4x4 result;
  SWIG_check_num_args("ofMatrix4x4::newScaleMatrix",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofMatrix4x4::newScaleMatrix",1,"ofVec3f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Matrix4x4_newScaleMatrix",1,SWIGTYPE_p_ofVec3f); } 
  result = ofMatrix4x4::newScaleMatrix((ofVec3f const &)*arg1); {
    ofMatrix4x4 * resultptr = new ofMatrix4x4((const ofMatrix4x4 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofMatrix4x4,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_newScaleMatrix__SWIG_1(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ;
  ofMatrix4x4 result; SWIG_check_num_args("ofMatrix4x4::newScaleMatrix",3,3)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofMatrix4x4::newScaleMatrix",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMatrix4x4::newScaleMatrix",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofMatrix4x4::newScaleMatrix",3,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); result = ofMatrix4x4::newScaleMatrix(arg1,arg2,arg3); {
    ofMatrix4x4 * resultptr = new ofMatrix4x4((const ofMatrix4x4 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofMatrix4x4,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_newScaleMatrix(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L);
  if (argc == 1) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { return _wrap_Matrix4x4_newScaleMatrix__SWIG_0(L);}  }  if (argc == 3) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); } 
        if (_v) { return _wrap_Matrix4x4_newScaleMatrix__SWIG_1(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Matrix4x4_newScaleMatrix'\n"
  "  Possible C/C++ prototypes are:\n" "    ofMatrix4x4::newScaleMatrix(ofVec3f const &)\n"
  "    ofMatrix4x4::newScaleMatrix(float,float,float)\n"); lua_error(L);return 0; }
static int _wrap_Matrix4x4_newTranslationMatrix__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofVec3f *arg1 = 0 ;
  ofMatrix4x4 result; SWIG_check_num_args("ofMatrix4x4::newTranslationMatrix",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofMatrix4x4::newTranslationMatrix",1,"ofVec3f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Matrix4x4_newTranslationMatrix",1,SWIGTYPE_p_ofVec3f); } 
  result = ofMatrix4x4::newTranslationMatrix((ofVec3f const &)*arg1); {
    ofMatrix4x4 * resultptr = new ofMatrix4x4((const ofMatrix4x4 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofMatrix4x4,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_newTranslationMatrix__SWIG_1(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ;
  ofMatrix4x4 result; SWIG_check_num_args("ofMatrix4x4::newTranslationMatrix",3,3)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofMatrix4x4::newTranslationMatrix",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMatrix4x4::newTranslationMatrix",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofMatrix4x4::newTranslationMatrix",3,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3);
  result = ofMatrix4x4::newTranslationMatrix(arg1,arg2,arg3); {
    ofMatrix4x4 * resultptr = new ofMatrix4x4((const ofMatrix4x4 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofMatrix4x4,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_newTranslationMatrix(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L);
  if (argc == 1) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { return _wrap_Matrix4x4_newTranslationMatrix__SWIG_0(L);}  }  if (argc == 3) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); } 
        if (_v) { return _wrap_Matrix4x4_newTranslationMatrix__SWIG_1(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Matrix4x4_newTranslationMatrix'\n"
  "  Possible C/C++ prototypes are:\n" "    ofMatrix4x4::newTranslationMatrix(ofVec3f const &)\n"
  "    ofMatrix4x4::newTranslationMatrix(float,float,float)\n"); lua_error(L);return 0; }
static int _wrap_Matrix4x4_newRotationMatrix__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofVec3f *arg1 = 0 ; ofVec3f *arg2 = 0 ;
  ofMatrix4x4 result; SWIG_check_num_args("ofMatrix4x4::newRotationMatrix",2,2)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofMatrix4x4::newRotationMatrix",1,"ofVec3f const &");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMatrix4x4::newRotationMatrix",2,"ofVec3f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Matrix4x4_newRotationMatrix",1,SWIGTYPE_p_ofVec3f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Matrix4x4_newRotationMatrix",2,SWIGTYPE_p_ofVec3f); } 
  result = ofMatrix4x4::newRotationMatrix((ofVec3f const &)*arg1,(ofVec3f const &)*arg2); {
    ofMatrix4x4 * resultptr = new ofMatrix4x4((const ofMatrix4x4 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofMatrix4x4,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_newRotationMatrix__SWIG_1(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ;
  float arg4 ; ofMatrix4x4 result; SWIG_check_num_args("ofMatrix4x4::newRotationMatrix",4,4)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofMatrix4x4::newRotationMatrix",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMatrix4x4::newRotationMatrix",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofMatrix4x4::newRotationMatrix",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofMatrix4x4::newRotationMatrix",4,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  result = ofMatrix4x4::newRotationMatrix(arg1,arg2,arg3,arg4); {
    ofMatrix4x4 * resultptr = new ofMatrix4x4((const ofMatrix4x4 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofMatrix4x4,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_newRotationMatrix__SWIG_2(lua_State* L) { int SWIG_arg = 0; float arg1 ; ofVec3f *arg2 = 0 ;
  ofMatrix4x4 result; SWIG_check_num_args("ofMatrix4x4::newRotationMatrix",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofMatrix4x4::newRotationMatrix",1,"float");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMatrix4x4::newRotationMatrix",2,"ofVec3f const &");
  arg1 = (float)lua_tonumber(L, 1); if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Matrix4x4_newRotationMatrix",2,SWIGTYPE_p_ofVec3f); } 
  result = ofMatrix4x4::newRotationMatrix(arg1,(ofVec3f const &)*arg2); {
    ofMatrix4x4 * resultptr = new ofMatrix4x4((const ofMatrix4x4 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofMatrix4x4,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_newRotationMatrix__SWIG_3(lua_State* L) { int SWIG_arg = 0; float arg1 ; ofVec3f *arg2 = 0 ;
  float arg3 ; ofVec3f *arg4 = 0 ; float arg5 ; ofVec3f *arg6 = 0 ; ofMatrix4x4 result;
  SWIG_check_num_args("ofMatrix4x4::newRotationMatrix",6,6)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofMatrix4x4::newRotationMatrix",1,"float");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMatrix4x4::newRotationMatrix",2,"ofVec3f const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofMatrix4x4::newRotationMatrix",3,"float");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("ofMatrix4x4::newRotationMatrix",4,"ofVec3f const &");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofMatrix4x4::newRotationMatrix",5,"float");
  if(!lua_isuserdata(L,6)) SWIG_fail_arg("ofMatrix4x4::newRotationMatrix",6,"ofVec3f const &");
  arg1 = (float)lua_tonumber(L, 1); if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Matrix4x4_newRotationMatrix",2,SWIGTYPE_p_ofVec3f); }  arg3 = (float)lua_tonumber(L, 3);
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Matrix4x4_newRotationMatrix",4,SWIGTYPE_p_ofVec3f); }  arg5 = (float)lua_tonumber(L, 5);
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,6,(void**)&arg6,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Matrix4x4_newRotationMatrix",6,SWIGTYPE_p_ofVec3f); } 
  result = ofMatrix4x4::newRotationMatrix(arg1,(ofVec3f const &)*arg2,arg3,(ofVec3f const &)*arg4,arg5,(ofVec3f const &)*arg6);
  { ofMatrix4x4 * resultptr = new ofMatrix4x4((const ofMatrix4x4 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofMatrix4x4,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_newRotationMatrix__SWIG_4(lua_State* L) { int SWIG_arg = 0; ofQuaternion *arg1 = 0 ;
  ofMatrix4x4 result; SWIG_check_num_args("ofMatrix4x4::newRotationMatrix",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofMatrix4x4::newRotationMatrix",1,"ofQuaternion const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofQuaternion,0))){
    SWIG_fail_ptr("Matrix4x4_newRotationMatrix",1,SWIGTYPE_p_ofQuaternion); } 
  result = ofMatrix4x4::newRotationMatrix((ofQuaternion const &)*arg1); {
    ofMatrix4x4 * resultptr = new ofMatrix4x4((const ofMatrix4x4 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofMatrix4x4,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_newRotationMatrix(lua_State* L) { int argc; int argv[7]={ 1,2,3,4,5,6,7} ; argc = lua_gettop(L);
  if (argc == 1) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofQuaternion, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { return _wrap_Matrix4x4_newRotationMatrix__SWIG_4(L);}  }  if (argc == 2) { int _v; {
      void *ptr; if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Matrix4x4_newRotationMatrix__SWIG_0(L);}  }  }  if (argc == 2) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Matrix4x4_newRotationMatrix__SWIG_2(L);}  }  }  if (argc == 4) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); } 
        if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_Matrix4x4_newRotationMatrix__SWIG_1(L);}  }  }  }  }
   if (argc == 6) { int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }
             else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) { { void *ptr;
                if (lua_isuserdata(L,argv[5])==0 || SWIG_ConvertPtr(L,argv[5], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) {
                  _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Matrix4x4_newRotationMatrix__SWIG_3(L);}  }  }  }  }  }
     }  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Matrix4x4_newRotationMatrix'\n"
  "  Possible C/C++ prototypes are:\n" "    ofMatrix4x4::newRotationMatrix(ofVec3f const &,ofVec3f const &)\n"
  "    ofMatrix4x4::newRotationMatrix(float,float,float,float)\n" "    ofMatrix4x4::newRotationMatrix(float,ofVec3f const &)\n"
  "    ofMatrix4x4::newRotationMatrix(float,ofVec3f const &,float,ofVec3f const &,float,ofVec3f const &)\n"
  "    ofMatrix4x4::newRotationMatrix(ofQuaternion const &)\n"); lua_error(L);return 0; }
static int _wrap_Matrix4x4_newOrthoMatrix(lua_State* L) { int SWIG_arg = 0; double arg1 ; double arg2 ; double arg3 ;
  double arg4 ; double arg5 ; double arg6 ; ofMatrix4x4 result; SWIG_check_num_args("ofMatrix4x4::newOrthoMatrix",6,6)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofMatrix4x4::newOrthoMatrix",1,"double");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMatrix4x4::newOrthoMatrix",2,"double");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofMatrix4x4::newOrthoMatrix",3,"double");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofMatrix4x4::newOrthoMatrix",4,"double");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofMatrix4x4::newOrthoMatrix",5,"double");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofMatrix4x4::newOrthoMatrix",6,"double"); arg1 = (double)lua_tonumber(L, 1);
  arg2 = (double)lua_tonumber(L, 2); arg3 = (double)lua_tonumber(L, 3); arg4 = (double)lua_tonumber(L, 4);
  arg5 = (double)lua_tonumber(L, 5); arg6 = (double)lua_tonumber(L, 6);
  result = ofMatrix4x4::newOrthoMatrix(arg1,arg2,arg3,arg4,arg5,arg6); {
    ofMatrix4x4 * resultptr = new ofMatrix4x4((const ofMatrix4x4 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofMatrix4x4,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_newOrtho2DMatrix(lua_State* L) { int SWIG_arg = 0; double arg1 ; double arg2 ; double arg3 ;
  double arg4 ; ofMatrix4x4 result; SWIG_check_num_args("ofMatrix4x4::newOrtho2DMatrix",4,4)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofMatrix4x4::newOrtho2DMatrix",1,"double");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMatrix4x4::newOrtho2DMatrix",2,"double");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofMatrix4x4::newOrtho2DMatrix",3,"double");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofMatrix4x4::newOrtho2DMatrix",4,"double"); arg1 = (double)lua_tonumber(L, 1);
  arg2 = (double)lua_tonumber(L, 2); arg3 = (double)lua_tonumber(L, 3); arg4 = (double)lua_tonumber(L, 4);
  result = ofMatrix4x4::newOrtho2DMatrix(arg1,arg2,arg3,arg4); {
    ofMatrix4x4 * resultptr = new ofMatrix4x4((const ofMatrix4x4 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofMatrix4x4,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_newFrustumMatrix(lua_State* L) { int SWIG_arg = 0; double arg1 ; double arg2 ; double arg3 ;
  double arg4 ; double arg5 ; double arg6 ; ofMatrix4x4 result; SWIG_check_num_args("ofMatrix4x4::newFrustumMatrix",6,6)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofMatrix4x4::newFrustumMatrix",1,"double");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMatrix4x4::newFrustumMatrix",2,"double");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofMatrix4x4::newFrustumMatrix",3,"double");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofMatrix4x4::newFrustumMatrix",4,"double");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofMatrix4x4::newFrustumMatrix",5,"double");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofMatrix4x4::newFrustumMatrix",6,"double"); arg1 = (double)lua_tonumber(L, 1);
  arg2 = (double)lua_tonumber(L, 2); arg3 = (double)lua_tonumber(L, 3); arg4 = (double)lua_tonumber(L, 4);
  arg5 = (double)lua_tonumber(L, 5); arg6 = (double)lua_tonumber(L, 6);
  result = ofMatrix4x4::newFrustumMatrix(arg1,arg2,arg3,arg4,arg5,arg6); {
    ofMatrix4x4 * resultptr = new ofMatrix4x4((const ofMatrix4x4 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofMatrix4x4,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_newPerspectiveMatrix(lua_State* L) { int SWIG_arg = 0; double arg1 ; double arg2 ; double arg3 ;
  double arg4 ; ofMatrix4x4 result; SWIG_check_num_args("ofMatrix4x4::newPerspectiveMatrix",4,4)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofMatrix4x4::newPerspectiveMatrix",1,"double");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMatrix4x4::newPerspectiveMatrix",2,"double");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofMatrix4x4::newPerspectiveMatrix",3,"double");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofMatrix4x4::newPerspectiveMatrix",4,"double"); arg1 = (double)lua_tonumber(L, 1);
  arg2 = (double)lua_tonumber(L, 2); arg3 = (double)lua_tonumber(L, 3); arg4 = (double)lua_tonumber(L, 4);
  result = ofMatrix4x4::newPerspectiveMatrix(arg1,arg2,arg3,arg4); {
    ofMatrix4x4 * resultptr = new ofMatrix4x4((const ofMatrix4x4 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofMatrix4x4,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_newLookAtMatrix(lua_State* L) { int SWIG_arg = 0; ofVec3f *arg1 = 0 ; ofVec3f *arg2 = 0 ;
  ofVec3f *arg3 = 0 ; ofMatrix4x4 result; SWIG_check_num_args("ofMatrix4x4::newLookAtMatrix",3,3)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofMatrix4x4::newLookAtMatrix",1,"ofVec3f const &");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMatrix4x4::newLookAtMatrix",2,"ofVec3f const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofMatrix4x4::newLookAtMatrix",3,"ofVec3f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Matrix4x4_newLookAtMatrix",1,SWIGTYPE_p_ofVec3f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Matrix4x4_newLookAtMatrix",2,SWIGTYPE_p_ofVec3f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Matrix4x4_newLookAtMatrix",3,SWIGTYPE_p_ofVec3f); } 
  result = ofMatrix4x4::newLookAtMatrix((ofVec3f const &)*arg1,(ofVec3f const &)*arg2,(ofVec3f const &)*arg3); {
    ofMatrix4x4 * resultptr = new ofMatrix4x4((const ofMatrix4x4 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofMatrix4x4,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4___call(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ; std::size_t arg2 ;
  std::size_t arg3 ; float *result = 0 ; SWIG_check_num_args("ofMatrix4x4::operator ()",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::operator ()",1,"ofMatrix4x4 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMatrix4x4::operator ()",2,"std::size_t");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofMatrix4x4::operator ()",3,"std::size_t");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4___call",1,SWIGTYPE_p_ofMatrix4x4); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (std::size_t)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (std::size_t)lua_tonumber(L, 3);
  result = (float *) &(arg1)->operator ()(arg2,arg3); SWIG_NewPointerObj(L,result,SWIGTYPE_p_float,0); SWIG_arg++; 
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_getRowAsVec3f(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ;
  std::size_t arg2 ; ofVec3f result; SWIG_check_num_args("ofMatrix4x4::getRowAsVec3f",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::getRowAsVec3f",1,"ofMatrix4x4 const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMatrix4x4::getRowAsVec3f",2,"std::size_t");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_getRowAsVec3f",1,SWIGTYPE_p_ofMatrix4x4); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (std::size_t)lua_tonumber(L, 2);
  result = ((ofMatrix4x4 const *)arg1)->getRowAsVec3f(arg2); { ofVec3f * resultptr = new ofVec3f((const ofVec3f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec3f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_getRowAsVec4f(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ;
  std::size_t arg2 ; ofVec4f result; SWIG_check_num_args("ofMatrix4x4::getRowAsVec4f",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::getRowAsVec4f",1,"ofMatrix4x4 const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMatrix4x4::getRowAsVec4f",2,"std::size_t");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_getRowAsVec4f",1,SWIGTYPE_p_ofMatrix4x4); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (std::size_t)lua_tonumber(L, 2);
  result = ((ofMatrix4x4 const *)arg1)->getRowAsVec4f(arg2); { ofVec4f * resultptr = new ofVec4f((const ofVec4f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec4f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_getPtr__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ;
  float *result = 0 ; SWIG_check_num_args("ofMatrix4x4::getPtr",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::getPtr",1,"ofMatrix4x4 *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_getPtr",1,SWIGTYPE_p_ofMatrix4x4); }  result = (float *)(arg1)->getPtr();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_float,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Matrix4x4_getPtr__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ;
  float *result = 0 ; SWIG_check_num_args("ofMatrix4x4::getPtr",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::getPtr",1,"ofMatrix4x4 const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_getPtr",1,SWIGTYPE_p_ofMatrix4x4); }  result = (float *)((ofMatrix4x4 const *)arg1)->getPtr();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_float,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Matrix4x4_getPtr(lua_State* L) { int argc; int argv[2]={ 1,2} ; argc = lua_gettop(L); if (argc == 1) { int _v;
    { void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMatrix4x4, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Matrix4x4_getPtr__SWIG_0(L);}  }  if (argc == 1) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMatrix4x4, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Matrix4x4_getPtr__SWIG_1(L);}  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Matrix4x4_getPtr'\n" "  Possible C/C++ prototypes are:\n"
  "    ofMatrix4x4::getPtr()\n" "    ofMatrix4x4::getPtr() const\n"); lua_error(L);return 0; }
static int _wrap_Matrix4x4_isValid(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ; bool result;
  SWIG_check_num_args("ofMatrix4x4::isValid",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::isValid",1,"ofMatrix4x4 const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_isValid",1,SWIGTYPE_p_ofMatrix4x4); }  result = (bool)((ofMatrix4x4 const *)arg1)->isValid();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_isNaN(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ; bool result;
  SWIG_check_num_args("ofMatrix4x4::isNaN",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::isNaN",1,"ofMatrix4x4 const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_isNaN",1,SWIGTYPE_p_ofMatrix4x4); }  result = (bool)((ofMatrix4x4 const *)arg1)->isNaN();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_isIdentity(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ; bool result;
  SWIG_check_num_args("ofMatrix4x4::isIdentity",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::isIdentity",1,"ofMatrix4x4 const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_isIdentity",1,SWIGTYPE_p_ofMatrix4x4); }  result = (bool)((ofMatrix4x4 const *)arg1)->isIdentity();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_set__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ;
  ofMatrix4x4 *arg2 = 0 ; SWIG_check_num_args("ofMatrix4x4::set",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::set",1,"ofMatrix4x4 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMatrix4x4::set",2,"ofMatrix4x4 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_set",1,SWIGTYPE_p_ofMatrix4x4); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_set",2,SWIGTYPE_p_ofMatrix4x4); }  (arg1)->set((ofMatrix4x4 const &)*arg2); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_set__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ;
  float *arg2 = (float *) (float *)0 ; SWIG_check_num_args("ofMatrix4x4::set",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::set",1,"ofMatrix4x4 *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofMatrix4x4::set",2,"float const *const");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_set",1,SWIGTYPE_p_ofMatrix4x4); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_float,0))){ SWIG_fail_ptr("Matrix4x4_set",2,SWIGTYPE_p_float); } 
  (arg1)->set((float const *)arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_set__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ;
  double *arg2 = (double *) (double *)0 ; SWIG_check_num_args("ofMatrix4x4::set",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::set",1,"ofMatrix4x4 *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofMatrix4x4::set",2,"double const *const");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_set",1,SWIGTYPE_p_ofMatrix4x4); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_double,0))){ SWIG_fail_ptr("Matrix4x4_set",2,SWIGTYPE_p_double); }
   (arg1)->set((double const *)arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_set__SWIG_3(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ; float arg2 ;
  float arg3 ; float arg4 ; float arg5 ; float arg6 ; float arg7 ; float arg8 ; float arg9 ; float arg10 ; float arg11 ;
  float arg12 ; float arg13 ; float arg14 ; float arg15 ; float arg16 ; float arg17 ;
  SWIG_check_num_args("ofMatrix4x4::set",17,17) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::set",1,"ofMatrix4x4 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMatrix4x4::set",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofMatrix4x4::set",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofMatrix4x4::set",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofMatrix4x4::set",5,"float");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofMatrix4x4::set",6,"float");
  if(!lua_isnumber(L,7)) SWIG_fail_arg("ofMatrix4x4::set",7,"float");
  if(!lua_isnumber(L,8)) SWIG_fail_arg("ofMatrix4x4::set",8,"float");
  if(!lua_isnumber(L,9)) SWIG_fail_arg("ofMatrix4x4::set",9,"float");
  if(!lua_isnumber(L,10)) SWIG_fail_arg("ofMatrix4x4::set",10,"float");
  if(!lua_isnumber(L,11)) SWIG_fail_arg("ofMatrix4x4::set",11,"float");
  if(!lua_isnumber(L,12)) SWIG_fail_arg("ofMatrix4x4::set",12,"float");
  if(!lua_isnumber(L,13)) SWIG_fail_arg("ofMatrix4x4::set",13,"float");
  if(!lua_isnumber(L,14)) SWIG_fail_arg("ofMatrix4x4::set",14,"float");
  if(!lua_isnumber(L,15)) SWIG_fail_arg("ofMatrix4x4::set",15,"float");
  if(!lua_isnumber(L,16)) SWIG_fail_arg("ofMatrix4x4::set",16,"float");
  if(!lua_isnumber(L,17)) SWIG_fail_arg("ofMatrix4x4::set",17,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_set",1,SWIGTYPE_p_ofMatrix4x4); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); arg5 = (float)lua_tonumber(L, 5);
  arg6 = (float)lua_tonumber(L, 6); arg7 = (float)lua_tonumber(L, 7); arg8 = (float)lua_tonumber(L, 8);
  arg9 = (float)lua_tonumber(L, 9); arg10 = (float)lua_tonumber(L, 10); arg11 = (float)lua_tonumber(L, 11);
  arg12 = (float)lua_tonumber(L, 12); arg13 = (float)lua_tonumber(L, 13); arg14 = (float)lua_tonumber(L, 14);
  arg15 = (float)lua_tonumber(L, 15); arg16 = (float)lua_tonumber(L, 16); arg17 = (float)lua_tonumber(L, 17);
  (arg1)->set(arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12,arg13,arg14,arg15,arg16,arg17); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_set(lua_State* L) { int argc; int argv[18]={ 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18} ;
  argc = lua_gettop(L); if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMatrix4x4, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofMatrix4x4, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Matrix4x4_set__SWIG_0(L);}  }  }  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMatrix4x4, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_float, 0)) { _v = 0; }  else {
          _v = 1; }  }  if (_v) { return _wrap_Matrix4x4_set__SWIG_1(L);}  }  }  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMatrix4x4, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_double, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Matrix4x4_set__SWIG_2(L);}  }  }  if (argc == 17) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMatrix4x4, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) { {
                _v = lua_isnumber(L,argv[5]); }  if (_v) { { _v = lua_isnumber(L,argv[6]); }  if (_v) { {
                    _v = lua_isnumber(L,argv[7]); }  if (_v) { { _v = lua_isnumber(L,argv[8]); }  if (_v) { {
                        _v = lua_isnumber(L,argv[9]); }  if (_v) { { _v = lua_isnumber(L,argv[10]); }  if (_v) { {
                            _v = lua_isnumber(L,argv[11]); }  if (_v) { { _v = lua_isnumber(L,argv[12]); }  if (_v) { {
                                _v = lua_isnumber(L,argv[13]); }  if (_v) { { _v = lua_isnumber(L,argv[14]); }  if (_v) { {
                                    _v = lua_isnumber(L,argv[15]); }  if (_v) { { _v = lua_isnumber(L,argv[16]); }  if (_v) {
                                      return _wrap_Matrix4x4_set__SWIG_3(L);}  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }
   SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Matrix4x4_set'\n" "  Possible C/C++ prototypes are:\n"
  "    ofMatrix4x4::set(ofMatrix4x4 const &)\n" "    ofMatrix4x4::set(float const *const)\n"
  "    ofMatrix4x4::set(double const *const)\n"
  "    ofMatrix4x4::set(float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float)\n");
  lua_error(L);return 0; }
static int _wrap_Matrix4x4_getInverse(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ;
  ofMatrix4x4 result; SWIG_check_num_args("ofMatrix4x4::getInverse",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::getInverse",1,"ofMatrix4x4 const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_getInverse",1,SWIGTYPE_p_ofMatrix4x4); }  result = ((ofMatrix4x4 const *)arg1)->getInverse(); {
    ofMatrix4x4 * resultptr = new ofMatrix4x4((const ofMatrix4x4 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofMatrix4x4,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_getOrtho(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ; double *arg2 = 0 ;
  double *arg3 = 0 ; double *arg4 = 0 ; double *arg5 = 0 ; double *arg6 = 0 ; double *arg7 = 0 ; bool result;
  SWIG_check_num_args("ofMatrix4x4::getOrtho",7,7)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::getOrtho",1,"ofMatrix4x4 const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMatrix4x4::getOrtho",2,"double &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofMatrix4x4::getOrtho",3,"double &");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("ofMatrix4x4::getOrtho",4,"double &");
  if(!lua_isuserdata(L,5)) SWIG_fail_arg("ofMatrix4x4::getOrtho",5,"double &");
  if(!lua_isuserdata(L,6)) SWIG_fail_arg("ofMatrix4x4::getOrtho",6,"double &");
  if(!lua_isuserdata(L,7)) SWIG_fail_arg("ofMatrix4x4::getOrtho",7,"double &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_getOrtho",1,SWIGTYPE_p_ofMatrix4x4); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_double,0))){
    SWIG_fail_ptr("Matrix4x4_getOrtho",2,SWIGTYPE_p_double); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_double,0))){
    SWIG_fail_ptr("Matrix4x4_getOrtho",3,SWIGTYPE_p_double); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_double,0))){
    SWIG_fail_ptr("Matrix4x4_getOrtho",4,SWIGTYPE_p_double); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&arg5,SWIGTYPE_p_double,0))){
    SWIG_fail_ptr("Matrix4x4_getOrtho",5,SWIGTYPE_p_double); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,6,(void**)&arg6,SWIGTYPE_p_double,0))){
    SWIG_fail_ptr("Matrix4x4_getOrtho",6,SWIGTYPE_p_double); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,7,(void**)&arg7,SWIGTYPE_p_double,0))){
    SWIG_fail_ptr("Matrix4x4_getOrtho",7,SWIGTYPE_p_double); } 
  result = (bool)((ofMatrix4x4 const *)arg1)->getOrtho(*arg2,*arg3,*arg4,*arg5,*arg6,*arg7);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_getFrustum(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ;
  double *arg2 = 0 ; double *arg3 = 0 ; double *arg4 = 0 ; double *arg5 = 0 ; double *arg6 = 0 ; double *arg7 = 0 ; bool result;
  SWIG_check_num_args("ofMatrix4x4::getFrustum",7,7)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::getFrustum",1,"ofMatrix4x4 const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMatrix4x4::getFrustum",2,"double &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofMatrix4x4::getFrustum",3,"double &");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("ofMatrix4x4::getFrustum",4,"double &");
  if(!lua_isuserdata(L,5)) SWIG_fail_arg("ofMatrix4x4::getFrustum",5,"double &");
  if(!lua_isuserdata(L,6)) SWIG_fail_arg("ofMatrix4x4::getFrustum",6,"double &");
  if(!lua_isuserdata(L,7)) SWIG_fail_arg("ofMatrix4x4::getFrustum",7,"double &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_getFrustum",1,SWIGTYPE_p_ofMatrix4x4); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_double,0))){
    SWIG_fail_ptr("Matrix4x4_getFrustum",2,SWIGTYPE_p_double); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_double,0))){
    SWIG_fail_ptr("Matrix4x4_getFrustum",3,SWIGTYPE_p_double); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_double,0))){
    SWIG_fail_ptr("Matrix4x4_getFrustum",4,SWIGTYPE_p_double); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&arg5,SWIGTYPE_p_double,0))){
    SWIG_fail_ptr("Matrix4x4_getFrustum",5,SWIGTYPE_p_double); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,6,(void**)&arg6,SWIGTYPE_p_double,0))){
    SWIG_fail_ptr("Matrix4x4_getFrustum",6,SWIGTYPE_p_double); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,7,(void**)&arg7,SWIGTYPE_p_double,0))){
    SWIG_fail_ptr("Matrix4x4_getFrustum",7,SWIGTYPE_p_double); } 
  result = (bool)((ofMatrix4x4 const *)arg1)->getFrustum(*arg2,*arg3,*arg4,*arg5,*arg6,*arg7);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_getPerspective(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ;
  double *arg2 = 0 ; double *arg3 = 0 ; double *arg4 = 0 ; double *arg5 = 0 ; bool result;
  SWIG_check_num_args("ofMatrix4x4::getPerspective",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::getPerspective",1,"ofMatrix4x4 const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMatrix4x4::getPerspective",2,"double &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofMatrix4x4::getPerspective",3,"double &");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("ofMatrix4x4::getPerspective",4,"double &");
  if(!lua_isuserdata(L,5)) SWIG_fail_arg("ofMatrix4x4::getPerspective",5,"double &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_getPerspective",1,SWIGTYPE_p_ofMatrix4x4); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_double,0))){
    SWIG_fail_ptr("Matrix4x4_getPerspective",2,SWIGTYPE_p_double); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_double,0))){
    SWIG_fail_ptr("Matrix4x4_getPerspective",3,SWIGTYPE_p_double); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_double,0))){
    SWIG_fail_ptr("Matrix4x4_getPerspective",4,SWIGTYPE_p_double); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&arg5,SWIGTYPE_p_double,0))){
    SWIG_fail_ptr("Matrix4x4_getPerspective",5,SWIGTYPE_p_double); } 
  result = (bool)((ofMatrix4x4 const *)arg1)->getPerspective(*arg2,*arg3,*arg4,*arg5);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_getLookAt__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ;
  ofVec3f *arg2 = 0 ; ofVec3f *arg3 = 0 ; ofVec3f *arg4 = 0 ; float arg5 ; SWIG_check_num_args("ofMatrix4x4::getLookAt",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::getLookAt",1,"ofMatrix4x4 const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMatrix4x4::getLookAt",2,"ofVec3f &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofMatrix4x4::getLookAt",3,"ofVec3f &");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("ofMatrix4x4::getLookAt",4,"ofVec3f &");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofMatrix4x4::getLookAt",5,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_getLookAt",1,SWIGTYPE_p_ofMatrix4x4); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Matrix4x4_getLookAt",2,SWIGTYPE_p_ofVec3f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Matrix4x4_getLookAt",3,SWIGTYPE_p_ofVec3f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Matrix4x4_getLookAt",4,SWIGTYPE_p_ofVec3f); }  arg5 = (float)lua_tonumber(L, 5);
  ((ofMatrix4x4 const *)arg1)->getLookAt(*arg2,*arg3,*arg4,arg5); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Matrix4x4_getLookAt__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ;
  ofVec3f *arg2 = 0 ; ofVec3f *arg3 = 0 ; ofVec3f *arg4 = 0 ; SWIG_check_num_args("ofMatrix4x4::getLookAt",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::getLookAt",1,"ofMatrix4x4 const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMatrix4x4::getLookAt",2,"ofVec3f &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofMatrix4x4::getLookAt",3,"ofVec3f &");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("ofMatrix4x4::getLookAt",4,"ofVec3f &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_getLookAt",1,SWIGTYPE_p_ofMatrix4x4); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Matrix4x4_getLookAt",2,SWIGTYPE_p_ofVec3f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Matrix4x4_getLookAt",3,SWIGTYPE_p_ofVec3f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Matrix4x4_getLookAt",4,SWIGTYPE_p_ofVec3f); }  ((ofMatrix4x4 const *)arg1)->getLookAt(*arg2,*arg3,*arg4);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_getLookAt(lua_State* L) { int argc; int argv[6]={ 1,2,3,4,5,6} ; argc = lua_gettop(L);
  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMatrix4x4, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }
           else { _v = 1; }  }  if (_v) { { void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }
             else { _v = 1; }  }  if (_v) { return _wrap_Matrix4x4_getLookAt__SWIG_1(L);}  }  }  }  }  if (argc == 5) { int _v;
    { void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMatrix4x4, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }
           else { _v = 1; }  }  if (_v) { { void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }
             else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) {
              return _wrap_Matrix4x4_getLookAt__SWIG_0(L);}  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Matrix4x4_getLookAt'\n"
  "  Possible C/C++ prototypes are:\n" "    ofMatrix4x4::getLookAt(ofVec3f &,ofVec3f &,ofVec3f &,float) const\n"
  "    ofMatrix4x4::getLookAt(ofVec3f &,ofVec3f &,ofVec3f &) const\n"); lua_error(L);return 0; }
static int _wrap_Matrix4x4_decompose(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ;
  ofVec3f *arg2 = 0 ; ofQuaternion *arg3 = 0 ; ofVec3f *arg4 = 0 ; ofQuaternion *arg5 = 0 ;
  SWIG_check_num_args("ofMatrix4x4::decompose",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::decompose",1,"ofMatrix4x4 const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMatrix4x4::decompose",2,"ofVec3f &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofMatrix4x4::decompose",3,"ofQuaternion &");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("ofMatrix4x4::decompose",4,"ofVec3f &");
  if(!lua_isuserdata(L,5)) SWIG_fail_arg("ofMatrix4x4::decompose",5,"ofQuaternion &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_decompose",1,SWIGTYPE_p_ofMatrix4x4); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Matrix4x4_decompose",2,SWIGTYPE_p_ofVec3f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_ofQuaternion,0))){
    SWIG_fail_ptr("Matrix4x4_decompose",3,SWIGTYPE_p_ofQuaternion); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Matrix4x4_decompose",4,SWIGTYPE_p_ofVec3f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&arg5,SWIGTYPE_p_ofQuaternion,0))){
    SWIG_fail_ptr("Matrix4x4_decompose",5,SWIGTYPE_p_ofQuaternion); } 
  ((ofMatrix4x4 const *)arg1)->decompose(*arg2,*arg3,*arg4,*arg5); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Matrix4x4_getInverseOf(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = 0 ; ofMatrix4x4 result;
  SWIG_check_num_args("ofMatrix4x4::getInverseOf",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofMatrix4x4::getInverseOf",1,"ofMatrix4x4 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_getInverseOf",1,SWIGTYPE_p_ofMatrix4x4); } 
  result = ofMatrix4x4::getInverseOf((ofMatrix4x4 const &)*arg1); {
    ofMatrix4x4 * resultptr = new ofMatrix4x4((const ofMatrix4x4 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofMatrix4x4,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_getTransposedOf(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = 0 ; ofMatrix4x4 result;
  SWIG_check_num_args("ofMatrix4x4::getTransposedOf",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofMatrix4x4::getTransposedOf",1,"ofMatrix4x4 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_getTransposedOf",1,SWIGTYPE_p_ofMatrix4x4); } 
  result = ofMatrix4x4::getTransposedOf((ofMatrix4x4 const &)*arg1); {
    ofMatrix4x4 * resultptr = new ofMatrix4x4((const ofMatrix4x4 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofMatrix4x4,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_getOrthoNormalOf(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = 0 ; ofMatrix4x4 result;
  SWIG_check_num_args("ofMatrix4x4::getOrthoNormalOf",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofMatrix4x4::getOrthoNormalOf",1,"ofMatrix4x4 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_getOrthoNormalOf",1,SWIGTYPE_p_ofMatrix4x4); } 
  result = ofMatrix4x4::getOrthoNormalOf((ofMatrix4x4 const &)*arg1); {
    ofMatrix4x4 * resultptr = new ofMatrix4x4((const ofMatrix4x4 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofMatrix4x4,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_postMult__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ;
  ofVec3f *arg2 = 0 ; ofVec3f result; SWIG_check_num_args("ofMatrix4x4::postMult",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::postMult",1,"ofMatrix4x4 const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMatrix4x4::postMult",2,"ofVec3f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_postMult",1,SWIGTYPE_p_ofMatrix4x4); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Matrix4x4_postMult",2,SWIGTYPE_p_ofVec3f); } 
  result = ((ofMatrix4x4 const *)arg1)->postMult((ofVec3f const &)*arg2); {
    ofVec3f * resultptr = new ofVec3f((const ofVec3f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec3f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_postMult__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ;
  ofVec4f *arg2 = 0 ; ofVec4f result; SWIG_check_num_args("ofMatrix4x4::postMult",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::postMult",1,"ofMatrix4x4 const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMatrix4x4::postMult",2,"ofVec4f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_postMult",1,SWIGTYPE_p_ofMatrix4x4); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec4f,0))){
    SWIG_fail_ptr("Matrix4x4_postMult",2,SWIGTYPE_p_ofVec4f); } 
  result = ((ofMatrix4x4 const *)arg1)->postMult((ofVec4f const &)*arg2); {
    ofVec4f * resultptr = new ofVec4f((const ofVec4f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec4f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_postMult__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ;
  ofMatrix4x4 *arg2 = 0 ; SWIG_check_num_args("ofMatrix4x4::postMult",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::postMult",1,"ofMatrix4x4 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMatrix4x4::postMult",2,"ofMatrix4x4 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_postMult",1,SWIGTYPE_p_ofMatrix4x4); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_postMult",2,SWIGTYPE_p_ofMatrix4x4); }  (arg1)->postMult((ofMatrix4x4 const &)*arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_postMult(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMatrix4x4, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Matrix4x4_postMult__SWIG_0(L);}  }  }  if (argc == 2) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMatrix4x4, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofVec4f, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Matrix4x4_postMult__SWIG_1(L);}  }  }  if (argc == 2) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMatrix4x4, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofMatrix4x4, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Matrix4x4_postMult__SWIG_2(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Matrix4x4_postMult'\n" "  Possible C/C++ prototypes are:\n"
  "    ofMatrix4x4::postMult(ofVec3f const &) const\n" "    ofMatrix4x4::postMult(ofVec4f const &) const\n"
  "    ofMatrix4x4::postMult(ofMatrix4x4 const &)\n"); lua_error(L);return 0; }
static int _wrap_Matrix4x4_preMult__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ;
  ofVec3f *arg2 = 0 ; ofVec3f result; SWIG_check_num_args("ofMatrix4x4::preMult",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::preMult",1,"ofMatrix4x4 const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMatrix4x4::preMult",2,"ofVec3f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_preMult",1,SWIGTYPE_p_ofMatrix4x4); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Matrix4x4_preMult",2,SWIGTYPE_p_ofVec3f); } 
  result = ((ofMatrix4x4 const *)arg1)->preMult((ofVec3f const &)*arg2); {
    ofVec3f * resultptr = new ofVec3f((const ofVec3f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec3f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_preMult__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ;
  ofVec4f *arg2 = 0 ; ofVec4f result; SWIG_check_num_args("ofMatrix4x4::preMult",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::preMult",1,"ofMatrix4x4 const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMatrix4x4::preMult",2,"ofVec4f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_preMult",1,SWIGTYPE_p_ofMatrix4x4); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec4f,0))){
    SWIG_fail_ptr("Matrix4x4_preMult",2,SWIGTYPE_p_ofVec4f); } 
  result = ((ofMatrix4x4 const *)arg1)->preMult((ofVec4f const &)*arg2); {
    ofVec4f * resultptr = new ofVec4f((const ofVec4f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec4f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_preMult__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ;
  ofMatrix4x4 *arg2 = 0 ; SWIG_check_num_args("ofMatrix4x4::preMult",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::preMult",1,"ofMatrix4x4 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMatrix4x4::preMult",2,"ofMatrix4x4 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_preMult",1,SWIGTYPE_p_ofMatrix4x4); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_preMult",2,SWIGTYPE_p_ofMatrix4x4); }  (arg1)->preMult((ofMatrix4x4 const &)*arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_preMult(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMatrix4x4, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Matrix4x4_preMult__SWIG_0(L);}  }  }  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMatrix4x4, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofVec4f, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Matrix4x4_preMult__SWIG_1(L);}  }  }  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMatrix4x4, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofMatrix4x4, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Matrix4x4_preMult__SWIG_2(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Matrix4x4_preMult'\n" "  Possible C/C++ prototypes are:\n"
  "    ofMatrix4x4::preMult(ofVec3f const &) const\n" "    ofMatrix4x4::preMult(ofVec4f const &) const\n"
  "    ofMatrix4x4::preMult(ofMatrix4x4 const &)\n"); lua_error(L);return 0; }
static int _wrap_Matrix4x4___mul__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ;
  ofMatrix4x4 *arg2 = 0 ; ofMatrix4x4 result; SWIG_check_num_args("ofMatrix4x4::operator *",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::operator *",1,"ofMatrix4x4 const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMatrix4x4::operator *",2,"ofMatrix4x4 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4___mul",1,SWIGTYPE_p_ofMatrix4x4); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4___mul",2,SWIGTYPE_p_ofMatrix4x4); } 
  result = ((ofMatrix4x4 const *)arg1)->operator *((ofMatrix4x4 const &)*arg2); {
    ofMatrix4x4 * resultptr = new ofMatrix4x4((const ofMatrix4x4 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofMatrix4x4,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4___mul__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ;
  ofVec3f *arg2 = 0 ; ofVec3f result; SWIG_check_num_args("ofMatrix4x4::operator *",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::operator *",1,"ofMatrix4x4 const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMatrix4x4::operator *",2,"ofVec3f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4___mul",1,SWIGTYPE_p_ofMatrix4x4); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Matrix4x4___mul",2,SWIGTYPE_p_ofVec3f); } 
  result = ((ofMatrix4x4 const *)arg1)->operator *((ofVec3f const &)*arg2); {
    ofVec3f * resultptr = new ofVec3f((const ofVec3f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec3f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4___mul__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ;
  ofVec4f *arg2 = 0 ; ofVec4f result; SWIG_check_num_args("ofMatrix4x4::operator *",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::operator *",1,"ofMatrix4x4 const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMatrix4x4::operator *",2,"ofVec4f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4___mul",1,SWIGTYPE_p_ofMatrix4x4); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec4f,0))){
    SWIG_fail_ptr("Matrix4x4___mul",2,SWIGTYPE_p_ofVec4f); } 
  result = ((ofMatrix4x4 const *)arg1)->operator *((ofVec4f const &)*arg2); {
    ofVec4f * resultptr = new ofVec4f((const ofVec4f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec4f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4___mul(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 2) { int _v;
    { void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMatrix4x4, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofMatrix4x4, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Matrix4x4___mul__SWIG_0(L);}  }  }  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMatrix4x4, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Matrix4x4___mul__SWIG_1(L);}  }  }  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMatrix4x4, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofVec4f, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Matrix4x4___mul__SWIG_2(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Matrix4x4___mul'\n" "  Possible C/C++ prototypes are:\n"
  "    ofMatrix4x4::operator *(ofMatrix4x4 const &) const\n" "    ofMatrix4x4::operator *(ofVec3f const &) const\n"
  "    ofMatrix4x4::operator *(ofVec4f const &) const\n"); lua_error(L);return 0; }
static int _wrap_Matrix4x4_postMultTranslate__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ;
  ofVec3f *arg2 = 0 ; SWIG_check_num_args("ofMatrix4x4::postMultTranslate",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::postMultTranslate",1,"ofMatrix4x4 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMatrix4x4::postMultTranslate",2,"ofVec3f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_postMultTranslate",1,SWIGTYPE_p_ofMatrix4x4); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Matrix4x4_postMultTranslate",2,SWIGTYPE_p_ofVec3f); }  (arg1)->postMultTranslate((ofVec3f const &)*arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_postMultScale__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ;
  ofVec3f *arg2 = 0 ; SWIG_check_num_args("ofMatrix4x4::postMultScale",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::postMultScale",1,"ofMatrix4x4 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMatrix4x4::postMultScale",2,"ofVec3f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_postMultScale",1,SWIGTYPE_p_ofMatrix4x4); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Matrix4x4_postMultScale",2,SWIGTYPE_p_ofVec3f); }  (arg1)->postMultScale((ofVec3f const &)*arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_postMultRotate__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ;
  ofQuaternion *arg2 = 0 ; SWIG_check_num_args("ofMatrix4x4::postMultRotate",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::postMultRotate",1,"ofMatrix4x4 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMatrix4x4::postMultRotate",2,"ofQuaternion const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_postMultRotate",1,SWIGTYPE_p_ofMatrix4x4); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofQuaternion,0))){
    SWIG_fail_ptr("Matrix4x4_postMultRotate",2,SWIGTYPE_p_ofQuaternion); }  (arg1)->postMultRotate((ofQuaternion const &)*arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_postMultTranslate__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ;
  float arg2 ; float arg3 ; float arg4 ; SWIG_check_num_args("ofMatrix4x4::postMultTranslate",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::postMultTranslate",1,"ofMatrix4x4 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMatrix4x4::postMultTranslate",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofMatrix4x4::postMultTranslate",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofMatrix4x4::postMultTranslate",4,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_postMultTranslate",1,SWIGTYPE_p_ofMatrix4x4); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); (arg1)->postMultTranslate(arg2,arg3,arg4);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_postMultTranslate(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L);
  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMatrix4x4, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Matrix4x4_postMultTranslate__SWIG_0(L);}  }  }  if (argc == 4) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMatrix4x4, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_Matrix4x4_postMultTranslate__SWIG_1(L);}  }  }  }  }
   SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Matrix4x4_postMultTranslate'\n"
  "  Possible C/C++ prototypes are:\n" "    ofMatrix4x4::postMultTranslate(ofVec3f const &)\n"
  "    ofMatrix4x4::postMultTranslate(float,float,float)\n"); lua_error(L);return 0; }
static int _wrap_Matrix4x4_postMultRotate__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ;
  float arg2 ; float arg3 ; float arg4 ; float arg5 ; SWIG_check_num_args("ofMatrix4x4::postMultRotate",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::postMultRotate",1,"ofMatrix4x4 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMatrix4x4::postMultRotate",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofMatrix4x4::postMultRotate",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofMatrix4x4::postMultRotate",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofMatrix4x4::postMultRotate",5,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_postMultRotate",1,SWIGTYPE_p_ofMatrix4x4); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); arg5 = (float)lua_tonumber(L, 5);
  (arg1)->postMultRotate(arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_postMultRotate(lua_State* L) { int argc; int argv[6]={ 1,2,3,4,5,6} ; argc = lua_gettop(L);
  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMatrix4x4, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofQuaternion, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Matrix4x4_postMultRotate__SWIG_0(L);}  }  }  if (argc == 5) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMatrix4x4, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) {
              return _wrap_Matrix4x4_postMultRotate__SWIG_1(L);}  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Matrix4x4_postMultRotate'\n"
  "  Possible C/C++ prototypes are:\n" "    ofMatrix4x4::postMultRotate(ofQuaternion const &)\n"
  "    ofMatrix4x4::postMultRotate(float,float,float,float)\n"); lua_error(L);return 0; }
static int _wrap_Matrix4x4_postMultScale__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ;
  float arg2 ; float arg3 ; float arg4 ; SWIG_check_num_args("ofMatrix4x4::postMultScale",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::postMultScale",1,"ofMatrix4x4 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMatrix4x4::postMultScale",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofMatrix4x4::postMultScale",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofMatrix4x4::postMultScale",4,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_postMultScale",1,SWIGTYPE_p_ofMatrix4x4); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); (arg1)->postMultScale(arg2,arg3,arg4); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_postMultScale(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L);
  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMatrix4x4, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Matrix4x4_postMultScale__SWIG_0(L);}  }  }  if (argc == 4) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMatrix4x4, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_Matrix4x4_postMultScale__SWIG_1(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Matrix4x4_postMultScale'\n"
  "  Possible C/C++ prototypes are:\n" "    ofMatrix4x4::postMultScale(ofVec3f const &)\n"
  "    ofMatrix4x4::postMultScale(float,float,float)\n"); lua_error(L);return 0; }
static int _wrap_Matrix4x4_preMultScale(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ;
  ofVec3f *arg2 = 0 ; SWIG_check_num_args("ofMatrix4x4::preMultScale",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::preMultScale",1,"ofMatrix4x4 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMatrix4x4::preMultScale",2,"ofVec3f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_preMultScale",1,SWIGTYPE_p_ofMatrix4x4); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Matrix4x4_preMultScale",2,SWIGTYPE_p_ofVec3f); }  (arg1)->preMultScale((ofVec3f const &)*arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_preMultTranslate(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ;
  ofVec3f *arg2 = 0 ; SWIG_check_num_args("ofMatrix4x4::preMultTranslate",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::preMultTranslate",1,"ofMatrix4x4 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMatrix4x4::preMultTranslate",2,"ofVec3f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_preMultTranslate",1,SWIGTYPE_p_ofMatrix4x4); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Matrix4x4_preMultTranslate",2,SWIGTYPE_p_ofVec3f); }  (arg1)->preMultTranslate((ofVec3f const &)*arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_preMultRotate(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ;
  ofQuaternion *arg2 = 0 ; SWIG_check_num_args("ofMatrix4x4::preMultRotate",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::preMultRotate",1,"ofMatrix4x4 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMatrix4x4::preMultRotate",2,"ofQuaternion const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_preMultRotate",1,SWIGTYPE_p_ofMatrix4x4); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofQuaternion,0))){
    SWIG_fail_ptr("Matrix4x4_preMultRotate",2,SWIGTYPE_p_ofQuaternion); }  (arg1)->preMultRotate((ofQuaternion const &)*arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_setRotate(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ;
  ofQuaternion *arg2 = 0 ; SWIG_check_num_args("ofMatrix4x4::setRotate",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::setRotate",1,"ofMatrix4x4 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMatrix4x4::setRotate",2,"ofQuaternion const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_setRotate",1,SWIGTYPE_p_ofMatrix4x4); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofQuaternion,0))){
    SWIG_fail_ptr("Matrix4x4_setRotate",2,SWIGTYPE_p_ofQuaternion); }  (arg1)->setRotate((ofQuaternion const &)*arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_setTranslation__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ;
  float arg2 ; float arg3 ; float arg4 ; SWIG_check_num_args("ofMatrix4x4::setTranslation",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::setTranslation",1,"ofMatrix4x4 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMatrix4x4::setTranslation",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofMatrix4x4::setTranslation",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofMatrix4x4::setTranslation",4,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_setTranslation",1,SWIGTYPE_p_ofMatrix4x4); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); (arg1)->setTranslation(arg2,arg3,arg4); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_setTranslation__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ;
  ofVec3f *arg2 = 0 ; SWIG_check_num_args("ofMatrix4x4::setTranslation",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::setTranslation",1,"ofMatrix4x4 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMatrix4x4::setTranslation",2,"ofVec3f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_setTranslation",1,SWIGTYPE_p_ofMatrix4x4); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Matrix4x4_setTranslation",2,SWIGTYPE_p_ofVec3f); }  (arg1)->setTranslation((ofVec3f const &)*arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_setTranslation(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L);
  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMatrix4x4, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Matrix4x4_setTranslation__SWIG_1(L);}  }  }  if (argc == 4) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMatrix4x4, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_Matrix4x4_setTranslation__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Matrix4x4_setTranslation'\n"
  "  Possible C/C++ prototypes are:\n" "    ofMatrix4x4::setTranslation(float,float,float)\n"
  "    ofMatrix4x4::setTranslation(ofVec3f const &)\n"); lua_error(L);return 0; }
static int _wrap_Matrix4x4_rotate__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ; float arg2 ;
  float arg3 ; float arg4 ; float arg5 ; SWIG_check_num_args("ofMatrix4x4::rotate",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::rotate",1,"ofMatrix4x4 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMatrix4x4::rotate",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofMatrix4x4::rotate",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofMatrix4x4::rotate",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofMatrix4x4::rotate",5,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_rotate",1,SWIGTYPE_p_ofMatrix4x4); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); arg5 = (float)lua_tonumber(L, 5);
  (arg1)->rotate(arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_rotateRad(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ; float arg2 ;
  float arg3 ; float arg4 ; float arg5 ; SWIG_check_num_args("ofMatrix4x4::rotateRad",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::rotateRad",1,"ofMatrix4x4 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMatrix4x4::rotateRad",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofMatrix4x4::rotateRad",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofMatrix4x4::rotateRad",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofMatrix4x4::rotateRad",5,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_rotateRad",1,SWIGTYPE_p_ofMatrix4x4); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); arg5 = (float)lua_tonumber(L, 5);
  (arg1)->rotateRad(arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_rotate__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ;
  ofQuaternion *arg2 = 0 ; SWIG_check_num_args("ofMatrix4x4::rotate",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::rotate",1,"ofMatrix4x4 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMatrix4x4::rotate",2,"ofQuaternion const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_rotate",1,SWIGTYPE_p_ofMatrix4x4); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofQuaternion,0))){
    SWIG_fail_ptr("Matrix4x4_rotate",2,SWIGTYPE_p_ofQuaternion); }  (arg1)->rotate((ofQuaternion const &)*arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_rotate(lua_State* L) { int argc; int argv[6]={ 1,2,3,4,5,6} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMatrix4x4, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofQuaternion, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Matrix4x4_rotate__SWIG_1(L);}  }  }  if (argc == 5) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMatrix4x4, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) {
              return _wrap_Matrix4x4_rotate__SWIG_0(L);}  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Matrix4x4_rotate'\n" "  Possible C/C++ prototypes are:\n"
  "    ofMatrix4x4::rotate(float,float,float,float)\n" "    ofMatrix4x4::rotate(ofQuaternion const &)\n");
  lua_error(L);return 0; }
static int _wrap_Matrix4x4_translate__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ;
  float arg2 ; float arg3 ; float arg4 ; SWIG_check_num_args("ofMatrix4x4::translate",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::translate",1,"ofMatrix4x4 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMatrix4x4::translate",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofMatrix4x4::translate",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofMatrix4x4::translate",4,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_translate",1,SWIGTYPE_p_ofMatrix4x4); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); (arg1)->translate(arg2,arg3,arg4); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_translate__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ;
  ofVec3f *arg2 = 0 ; SWIG_check_num_args("ofMatrix4x4::translate",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::translate",1,"ofMatrix4x4 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMatrix4x4::translate",2,"ofVec3f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_translate",1,SWIGTYPE_p_ofMatrix4x4); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Matrix4x4_translate",2,SWIGTYPE_p_ofVec3f); }  (arg1)->translate((ofVec3f const &)*arg2); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_translate(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMatrix4x4, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Matrix4x4_translate__SWIG_1(L);}  }  }  if (argc == 4) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMatrix4x4, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_Matrix4x4_translate__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Matrix4x4_translate'\n"
  "  Possible C/C++ prototypes are:\n" "    ofMatrix4x4::translate(float,float,float)\n"
  "    ofMatrix4x4::translate(ofVec3f const &)\n"); lua_error(L);return 0; }
static int _wrap_Matrix4x4_scale__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ; float arg2 ;
  float arg3 ; float arg4 ; SWIG_check_num_args("ofMatrix4x4::scale",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::scale",1,"ofMatrix4x4 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMatrix4x4::scale",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofMatrix4x4::scale",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofMatrix4x4::scale",4,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_scale",1,SWIGTYPE_p_ofMatrix4x4); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); (arg1)->scale(arg2,arg3,arg4); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_scale__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ;
  ofVec3f *arg2 = 0 ; SWIG_check_num_args("ofMatrix4x4::scale",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::scale",1,"ofMatrix4x4 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMatrix4x4::scale",2,"ofVec3f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_scale",1,SWIGTYPE_p_ofMatrix4x4); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Matrix4x4_scale",2,SWIGTYPE_p_ofVec3f); }  (arg1)->scale((ofVec3f const &)*arg2); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_scale(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMatrix4x4, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Matrix4x4_scale__SWIG_1(L);}  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMatrix4x4, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          { _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_Matrix4x4_scale__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Matrix4x4_scale'\n" "  Possible C/C++ prototypes are:\n"
  "    ofMatrix4x4::scale(float,float,float)\n" "    ofMatrix4x4::scale(ofVec3f const &)\n"); lua_error(L);return 0; }
static int _wrap_Matrix4x4_glRotate__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ;
  float arg2 ; float arg3 ; float arg4 ; float arg5 ; SWIG_check_num_args("ofMatrix4x4::glRotate",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::glRotate",1,"ofMatrix4x4 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMatrix4x4::glRotate",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofMatrix4x4::glRotate",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofMatrix4x4::glRotate",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofMatrix4x4::glRotate",5,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_glRotate",1,SWIGTYPE_p_ofMatrix4x4); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); arg5 = (float)lua_tonumber(L, 5);
  (arg1)->glRotate(arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_glRotateRad(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ; float arg2 ;
  float arg3 ; float arg4 ; float arg5 ; SWIG_check_num_args("ofMatrix4x4::glRotateRad",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::glRotateRad",1,"ofMatrix4x4 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMatrix4x4::glRotateRad",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofMatrix4x4::glRotateRad",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofMatrix4x4::glRotateRad",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofMatrix4x4::glRotateRad",5,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_glRotateRad",1,SWIGTYPE_p_ofMatrix4x4); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); arg5 = (float)lua_tonumber(L, 5);
  (arg1)->glRotateRad(arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_glRotate__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ;
  ofQuaternion *arg2 = 0 ; SWIG_check_num_args("ofMatrix4x4::glRotate",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::glRotate",1,"ofMatrix4x4 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMatrix4x4::glRotate",2,"ofQuaternion const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_glRotate",1,SWIGTYPE_p_ofMatrix4x4); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofQuaternion,0))){
    SWIG_fail_ptr("Matrix4x4_glRotate",2,SWIGTYPE_p_ofQuaternion); }  (arg1)->glRotate((ofQuaternion const &)*arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_glRotate(lua_State* L) { int argc; int argv[6]={ 1,2,3,4,5,6} ; argc = lua_gettop(L);
  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMatrix4x4, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofQuaternion, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Matrix4x4_glRotate__SWIG_1(L);}  }  }  if (argc == 5) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMatrix4x4, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) {
              return _wrap_Matrix4x4_glRotate__SWIG_0(L);}  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Matrix4x4_glRotate'\n" "  Possible C/C++ prototypes are:\n"
  "    ofMatrix4x4::glRotate(float,float,float,float)\n" "    ofMatrix4x4::glRotate(ofQuaternion const &)\n");
  lua_error(L);return 0; }
static int _wrap_Matrix4x4_glTranslate__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ;
  float arg2 ; float arg3 ; float arg4 ; SWIG_check_num_args("ofMatrix4x4::glTranslate",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::glTranslate",1,"ofMatrix4x4 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMatrix4x4::glTranslate",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofMatrix4x4::glTranslate",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofMatrix4x4::glTranslate",4,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_glTranslate",1,SWIGTYPE_p_ofMatrix4x4); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); (arg1)->glTranslate(arg2,arg3,arg4); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_glTranslate__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ;
  ofVec3f *arg2 = 0 ; SWIG_check_num_args("ofMatrix4x4::glTranslate",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::glTranslate",1,"ofMatrix4x4 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMatrix4x4::glTranslate",2,"ofVec3f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_glTranslate",1,SWIGTYPE_p_ofMatrix4x4); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Matrix4x4_glTranslate",2,SWIGTYPE_p_ofVec3f); }  (arg1)->glTranslate((ofVec3f const &)*arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_glTranslate(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L);
  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMatrix4x4, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Matrix4x4_glTranslate__SWIG_1(L);}  }  }  if (argc == 4) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMatrix4x4, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_Matrix4x4_glTranslate__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Matrix4x4_glTranslate'\n"
  "  Possible C/C++ prototypes are:\n" "    ofMatrix4x4::glTranslate(float,float,float)\n"
  "    ofMatrix4x4::glTranslate(ofVec3f const &)\n"); lua_error(L);return 0; }
static int _wrap_Matrix4x4_glScale__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ;
  float arg2 ; float arg3 ; float arg4 ; SWIG_check_num_args("ofMatrix4x4::glScale",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::glScale",1,"ofMatrix4x4 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMatrix4x4::glScale",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofMatrix4x4::glScale",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofMatrix4x4::glScale",4,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_glScale",1,SWIGTYPE_p_ofMatrix4x4); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); (arg1)->glScale(arg2,arg3,arg4); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_glScale__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ;
  ofVec3f *arg2 = 0 ; SWIG_check_num_args("ofMatrix4x4::glScale",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::glScale",1,"ofMatrix4x4 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMatrix4x4::glScale",2,"ofVec3f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_glScale",1,SWIGTYPE_p_ofMatrix4x4); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Matrix4x4_glScale",2,SWIGTYPE_p_ofVec3f); }  (arg1)->glScale((ofVec3f const &)*arg2); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_glScale(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMatrix4x4, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Matrix4x4_glScale__SWIG_1(L);}  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMatrix4x4, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          { _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_Matrix4x4_glScale__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Matrix4x4_glScale'\n" "  Possible C/C++ prototypes are:\n"
  "    ofMatrix4x4::glScale(float,float,float)\n" "    ofMatrix4x4::glScale(ofVec3f const &)\n"); lua_error(L);return 0; }
static int _wrap_Matrix4x4_getRotate(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ;
  ofQuaternion result; SWIG_check_num_args("ofMatrix4x4::getRotate",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::getRotate",1,"ofMatrix4x4 const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_getRotate",1,SWIGTYPE_p_ofMatrix4x4); }  result = ((ofMatrix4x4 const *)arg1)->getRotate(); {
    ofQuaternion * resultptr = new ofQuaternion((const ofQuaternion &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofQuaternion,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_getTranslation(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ;
  ofVec3f result; SWIG_check_num_args("ofMatrix4x4::getTranslation",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::getTranslation",1,"ofMatrix4x4 const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_getTranslation",1,SWIGTYPE_p_ofMatrix4x4); } 
  result = ((ofMatrix4x4 const *)arg1)->getTranslation(); { ofVec3f * resultptr = new ofVec3f((const ofVec3f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec3f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_getScale(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ; ofVec3f result;
  SWIG_check_num_args("ofMatrix4x4::getScale",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::getScale",1,"ofMatrix4x4 const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_getScale",1,SWIGTYPE_p_ofMatrix4x4); }  result = ((ofMatrix4x4 const *)arg1)->getScale(); {
    ofVec3f * resultptr = new ofVec3f((const ofVec3f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec3f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_transform3x3__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofVec3f *arg1 = 0 ; ofMatrix4x4 *arg2 = 0 ;
  ofVec3f result; SWIG_check_num_args("ofMatrix4x4::transform3x3",2,2)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofMatrix4x4::transform3x3",1,"ofVec3f const &");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMatrix4x4::transform3x3",2,"ofMatrix4x4 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Matrix4x4_transform3x3",1,SWIGTYPE_p_ofVec3f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_transform3x3",2,SWIGTYPE_p_ofMatrix4x4); } 
  result = ofMatrix4x4::transform3x3((ofVec3f const &)*arg1,(ofMatrix4x4 const &)*arg2); {
    ofVec3f * resultptr = new ofVec3f((const ofVec3f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec3f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_transform3x3__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = 0 ; ofVec3f *arg2 = 0 ;
  ofVec3f result; SWIG_check_num_args("ofMatrix4x4::transform3x3",2,2)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofMatrix4x4::transform3x3",1,"ofMatrix4x4 const &");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMatrix4x4::transform3x3",2,"ofVec3f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4_transform3x3",1,SWIGTYPE_p_ofMatrix4x4); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Matrix4x4_transform3x3",2,SWIGTYPE_p_ofVec3f); } 
  result = ofMatrix4x4::transform3x3((ofMatrix4x4 const &)*arg1,(ofVec3f const &)*arg2); {
    ofVec3f * resultptr = new ofVec3f((const ofVec3f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec3f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Matrix4x4_transform3x3(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofMatrix4x4, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Matrix4x4_transform3x3__SWIG_0(L);}  }  }  if (argc == 2) { int _v; {
      void *ptr; if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMatrix4x4, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Matrix4x4_transform3x3__SWIG_1(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Matrix4x4_transform3x3'\n"
  "  Possible C/C++ prototypes are:\n" "    ofMatrix4x4::transform3x3(ofVec3f const &,ofMatrix4x4 const &)\n"
  "    ofMatrix4x4::transform3x3(ofMatrix4x4 const &,ofVec3f const &)\n"); lua_error(L);return 0; }
static int _wrap_Matrix4x4___tostring(lua_State* L) { int SWIG_arg = 0; ofMatrix4x4 *arg1 = (ofMatrix4x4 *) 0 ;
  char *result = 0 ; SWIG_check_num_args("ofMatrix4x4::__str__",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrix4x4::__str__",1,"ofMatrix4x4 *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Matrix4x4___tostring",1,SWIGTYPE_p_ofMatrix4x4); }  result = (char *)ofMatrix4x4___str__(arg1);
  lua_pushstring(L,(const char *)result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static void swig_delete_Matrix4x4(void *obj) {
ofMatrix4x4 *arg1 = (ofMatrix4x4 *) obj;
delete arg1;
}
static int _proxy__wrap_new_Matrix4x4(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_Matrix4x4);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_Matrix4x4_attributes[] = {
    { "_mat", _wrap_Matrix4x4__mat_get, _wrap_Matrix4x4__mat_set },
    {0,0,0}
};
static swig_lua_method swig_Matrix4x4_methods[]= {
    { "makeIdentityMatrix", _wrap_Matrix4x4_makeIdentityMatrix},
    { "makeScaleMatrix", _wrap_Matrix4x4_makeScaleMatrix},
    { "makeTranslationMatrix", _wrap_Matrix4x4_makeTranslationMatrix},
    { "makeRotationMatrix", _wrap_Matrix4x4_makeRotationMatrix},
    { "makeInvertOf", _wrap_Matrix4x4_makeInvertOf},
    { "makeOrthoNormalOf", _wrap_Matrix4x4_makeOrthoNormalOf},
    { "makeFromMultiplicationOf", _wrap_Matrix4x4_makeFromMultiplicationOf},
    { "makeOrthoMatrix", _wrap_Matrix4x4_makeOrthoMatrix},
    { "makeOrtho2DMatrix", _wrap_Matrix4x4_makeOrtho2DMatrix},
    { "makeFrustumMatrix", _wrap_Matrix4x4_makeFrustumMatrix},
    { "makePerspectiveMatrix", _wrap_Matrix4x4_makePerspectiveMatrix},
    { "makeLookAtMatrix", _wrap_Matrix4x4_makeLookAtMatrix},
    { "makeLookAtViewMatrix", _wrap_Matrix4x4_makeLookAtViewMatrix},
    { "__call", _wrap_Matrix4x4___call},
    { "getRowAsVec3f", _wrap_Matrix4x4_getRowAsVec3f},
    { "getRowAsVec4f", _wrap_Matrix4x4_getRowAsVec4f},
    { "getPtr", _wrap_Matrix4x4_getPtr},
    { "isValid", _wrap_Matrix4x4_isValid},
    { "isNaN", _wrap_Matrix4x4_isNaN},
    { "isIdentity", _wrap_Matrix4x4_isIdentity},
    { "set", _wrap_Matrix4x4_set},
    { "getInverse", _wrap_Matrix4x4_getInverse},
    { "getOrtho", _wrap_Matrix4x4_getOrtho},
    { "getFrustum", _wrap_Matrix4x4_getFrustum},
    { "getPerspective", _wrap_Matrix4x4_getPerspective},
    { "getLookAt", _wrap_Matrix4x4_getLookAt},
    { "decompose", _wrap_Matrix4x4_decompose},
    { "postMult", _wrap_Matrix4x4_postMult},
    { "preMult", _wrap_Matrix4x4_preMult},
    { "__mul", _wrap_Matrix4x4___mul},
    { "postMultTranslate", _wrap_Matrix4x4_postMultTranslate},
    { "postMultRotate", _wrap_Matrix4x4_postMultRotate},
    { "postMultScale", _wrap_Matrix4x4_postMultScale},
    { "preMultScale", _wrap_Matrix4x4_preMultScale},
    { "preMultTranslate", _wrap_Matrix4x4_preMultTranslate},
    { "preMultRotate", _wrap_Matrix4x4_preMultRotate},
    { "setRotate", _wrap_Matrix4x4_setRotate},
    { "setTranslation", _wrap_Matrix4x4_setTranslation},
    { "rotateRad", _wrap_Matrix4x4_rotateRad},
    { "rotate", _wrap_Matrix4x4_rotate},
    { "translate", _wrap_Matrix4x4_translate},
    { "scale", _wrap_Matrix4x4_scale},
    { "glRotateRad", _wrap_Matrix4x4_glRotateRad},
    { "glRotate", _wrap_Matrix4x4_glRotate},
    { "glTranslate", _wrap_Matrix4x4_glTranslate},
    { "glScale", _wrap_Matrix4x4_glScale},
    { "getRotate", _wrap_Matrix4x4_getRotate},
    { "getTranslation", _wrap_Matrix4x4_getTranslation},
    { "getScale", _wrap_Matrix4x4_getScale},
    { "__tostring", _wrap_Matrix4x4___tostring},
    {0,0}
};
static swig_lua_method swig_Matrix4x4_meta[] = {
    { "__call", _wrap_Matrix4x4___call},
    { "__mul", _wrap_Matrix4x4___mul},
    { "__tostring", _wrap_Matrix4x4___tostring},
    {0,0}
};

static swig_lua_attribute swig_Matrix4x4_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_Matrix4x4_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_Matrix4x4_Sf_SwigStatic_methods[]= {
    { "newIdentityMatrix", _wrap_Matrix4x4_newIdentityMatrix},
    { "newScaleMatrix", _wrap_Matrix4x4_newScaleMatrix},
    { "newTranslationMatrix", _wrap_Matrix4x4_newTranslationMatrix},
    { "newRotationMatrix", _wrap_Matrix4x4_newRotationMatrix},
    { "newOrthoMatrix", _wrap_Matrix4x4_newOrthoMatrix},
    { "newOrtho2DMatrix", _wrap_Matrix4x4_newOrtho2DMatrix},
    { "newFrustumMatrix", _wrap_Matrix4x4_newFrustumMatrix},
    { "newPerspectiveMatrix", _wrap_Matrix4x4_newPerspectiveMatrix},
    { "newLookAtMatrix", _wrap_Matrix4x4_newLookAtMatrix},
    { "getInverseOf", _wrap_Matrix4x4_getInverseOf},
    { "getTransposedOf", _wrap_Matrix4x4_getTransposedOf},
    { "getOrthoNormalOf", _wrap_Matrix4x4_getOrthoNormalOf},
    { "transform3x3", _wrap_Matrix4x4_transform3x3},
    {0,0}
};
static swig_lua_class* swig_Matrix4x4_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_Matrix4x4_Sf_SwigStatic = {
    "Matrix4x4",
    swig_Matrix4x4_Sf_SwigStatic_methods,
    swig_Matrix4x4_Sf_SwigStatic_attributes,
    swig_Matrix4x4_Sf_SwigStatic_constants,
    swig_Matrix4x4_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_Matrix4x4_bases[] = {0};
static const char *swig_Matrix4x4_base_names[] = {0};
static swig_lua_class _wrap_class_Matrix4x4 = { "Matrix4x4", "Matrix4x4", &SWIGTYPE_p_ofMatrix4x4,_proxy__wrap_new_Matrix4x4, swig_delete_Matrix4x4, swig_Matrix4x4_methods, swig_Matrix4x4_attributes, &swig_Matrix4x4_Sf_SwigStatic, swig_Matrix4x4_meta, swig_Matrix4x4_bases, swig_Matrix4x4_base_names };

static int _wrap_Quaternion__v_set(lua_State* L) { int SWIG_arg = 0; ofQuaternion *arg1 = (ofQuaternion *) 0 ;
  ofVec4f *arg2 = (ofVec4f *) 0 ; SWIG_check_num_args("ofQuaternion::_v",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofQuaternion::_v",1,"ofQuaternion *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofQuaternion::_v",2,"ofVec4f *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofQuaternion,0))){
    SWIG_fail_ptr("Quaternion__v_set",1,SWIGTYPE_p_ofQuaternion); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec4f,0))){
    SWIG_fail_ptr("Quaternion__v_set",2,SWIGTYPE_p_ofVec4f); }  if (arg1) (arg1)->_v = *arg2; return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Quaternion__v_get(lua_State* L) { int SWIG_arg = 0; ofQuaternion *arg1 = (ofQuaternion *) 0 ;
  ofVec4f *result = 0 ; SWIG_check_num_args("ofQuaternion::_v",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofQuaternion::_v",1,"ofQuaternion *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofQuaternion,0))){
    SWIG_fail_ptr("Quaternion__v_get",1,SWIGTYPE_p_ofQuaternion); }  result = (ofVec4f *)& ((arg1)->_v);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofVec4f,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_Quaternion__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofQuaternion *result = 0 ;
  SWIG_check_num_args("ofQuaternion::ofQuaternion",0,0) result = (ofQuaternion *)new ofQuaternion();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofQuaternion,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_Quaternion__SWIG_1(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ; float arg4 ;
  ofQuaternion *result = 0 ; SWIG_check_num_args("ofQuaternion::ofQuaternion",4,4)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofQuaternion::ofQuaternion",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofQuaternion::ofQuaternion",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofQuaternion::ofQuaternion",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofQuaternion::ofQuaternion",4,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  result = (ofQuaternion *)new ofQuaternion(arg1,arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofQuaternion,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_Quaternion__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofVec4f *arg1 = 0 ; ofQuaternion *result = 0 ;
  SWIG_check_num_args("ofQuaternion::ofQuaternion",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofQuaternion::ofQuaternion",1,"ofVec4f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec4f,0))){
    SWIG_fail_ptr("new_Quaternion",1,SWIGTYPE_p_ofVec4f); }  result = (ofQuaternion *)new ofQuaternion((ofVec4f const &)*arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofQuaternion,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_Quaternion__SWIG_3(lua_State* L) { int SWIG_arg = 0; float arg1 ; ofVec3f *arg2 = 0 ;
  ofQuaternion *result = 0 ; SWIG_check_num_args("ofQuaternion::ofQuaternion",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofQuaternion::ofQuaternion",1,"float");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofQuaternion::ofQuaternion",2,"ofVec3f const &"); arg1 = (float)lua_tonumber(L, 1);
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("new_Quaternion",2,SWIGTYPE_p_ofVec3f); } 
  result = (ofQuaternion *)new ofQuaternion(arg1,(ofVec3f const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofQuaternion,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_Quaternion__SWIG_4(lua_State* L) { int SWIG_arg = 0; float arg1 ; ofVec3f *arg2 = 0 ; float arg3 ;
  ofVec3f *arg4 = 0 ; float arg5 ; ofVec3f *arg6 = 0 ; ofQuaternion *result = 0 ;
  SWIG_check_num_args("ofQuaternion::ofQuaternion",6,6)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofQuaternion::ofQuaternion",1,"float");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofQuaternion::ofQuaternion",2,"ofVec3f const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofQuaternion::ofQuaternion",3,"float");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("ofQuaternion::ofQuaternion",4,"ofVec3f const &");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofQuaternion::ofQuaternion",5,"float");
  if(!lua_isuserdata(L,6)) SWIG_fail_arg("ofQuaternion::ofQuaternion",6,"ofVec3f const &"); arg1 = (float)lua_tonumber(L, 1);
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("new_Quaternion",2,SWIGTYPE_p_ofVec3f); }  arg3 = (float)lua_tonumber(L, 3);
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("new_Quaternion",4,SWIGTYPE_p_ofVec3f); }  arg5 = (float)lua_tonumber(L, 5);
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,6,(void**)&arg6,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("new_Quaternion",6,SWIGTYPE_p_ofVec3f); } 
  result = (ofQuaternion *)new ofQuaternion(arg1,(ofVec3f const &)*arg2,arg3,(ofVec3f const &)*arg4,arg5,(ofVec3f const &)*arg6);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofQuaternion,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_Quaternion__SWIG_5(lua_State* L) { int SWIG_arg = 0; glm::quat *arg1 = 0 ; ofQuaternion *result = 0 ;
  SWIG_check_num_args("ofQuaternion::ofQuaternion",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofQuaternion::ofQuaternion",1,"glm::quat const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glm__quat,0))){
    SWIG_fail_ptr("new_Quaternion",1,SWIGTYPE_p_glm__quat); } 
  result = (ofQuaternion *)new ofQuaternion((glm::quat const &)*arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofQuaternion,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_Quaternion(lua_State* L) { int argc; int argv[7]={ 1,2,3,4,5,6,7} ; argc = lua_gettop(L); if (argc == 0) {
    return _wrap_new_Quaternion__SWIG_0(L);}  if (argc == 1) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec4f, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { return _wrap_new_Quaternion__SWIG_2(L);}  }  if (argc == 1) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_glm__quat, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { return _wrap_new_Quaternion__SWIG_5(L);}  }  if (argc == 2) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_new_Quaternion__SWIG_3(L);}  }  }  if (argc == 4) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); } 
        if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_new_Quaternion__SWIG_1(L);}  }  }  }  } 
  if (argc == 6) { int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }
             else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) { { void *ptr;
                if (lua_isuserdata(L,argv[5])==0 || SWIG_ConvertPtr(L,argv[5], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) {
                  _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_new_Quaternion__SWIG_4(L);}  }  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_Quaternion'\n" "  Possible C/C++ prototypes are:\n"
  "    ofQuaternion::ofQuaternion()\n" "    ofQuaternion::ofQuaternion(float,float,float,float)\n"
  "    ofQuaternion::ofQuaternion(ofVec4f const &)\n" "    ofQuaternion::ofQuaternion(float,ofVec3f const &)\n"
  "    ofQuaternion::ofQuaternion(float,ofVec3f const &,float,ofVec3f const &,float,ofVec3f const &)\n"
  "    ofQuaternion::ofQuaternion(glm::quat const &)\n"); lua_error(L);return 0; }
static int _wrap_Quaternion_set__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofQuaternion *arg1 = (ofQuaternion *) 0 ; float arg2 ;
  float arg3 ; float arg4 ; float arg5 ; SWIG_check_num_args("ofQuaternion::set",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofQuaternion::set",1,"ofQuaternion *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofQuaternion::set",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofQuaternion::set",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofQuaternion::set",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofQuaternion::set",5,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofQuaternion,0))){
    SWIG_fail_ptr("Quaternion_set",1,SWIGTYPE_p_ofQuaternion); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); arg5 = (float)lua_tonumber(L, 5);
  (arg1)->set(arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Quaternion_set__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofQuaternion *arg1 = (ofQuaternion *) 0 ;
  ofVec4f *arg2 = 0 ; SWIG_check_num_args("ofQuaternion::set",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofQuaternion::set",1,"ofQuaternion *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofQuaternion::set",2,"ofVec4f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofQuaternion,0))){
    SWIG_fail_ptr("Quaternion_set",1,SWIGTYPE_p_ofQuaternion); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec4f,0))){
    SWIG_fail_ptr("Quaternion_set",2,SWIGTYPE_p_ofVec4f); }  (arg1)->set((ofVec4f const &)*arg2); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Quaternion_set__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofQuaternion *arg1 = (ofQuaternion *) 0 ;
  ofMatrix4x4 *arg2 = 0 ; SWIG_check_num_args("ofQuaternion::set",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofQuaternion::set",1,"ofQuaternion *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofQuaternion::set",2,"ofMatrix4x4 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofQuaternion,0))){
    SWIG_fail_ptr("Quaternion_set",1,SWIGTYPE_p_ofQuaternion); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Quaternion_set",2,SWIGTYPE_p_ofMatrix4x4); }  (arg1)->set((ofMatrix4x4 const &)*arg2); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Quaternion_set(lua_State* L) { int argc; int argv[6]={ 1,2,3,4,5,6} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofQuaternion, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofVec4f, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Quaternion_set__SWIG_1(L);}  }  }  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofQuaternion, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofMatrix4x4, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Quaternion_set__SWIG_2(L);}  }  }  if (argc == 5) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofQuaternion, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) {
              return _wrap_Quaternion_set__SWIG_0(L);}  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Quaternion_set'\n" "  Possible C/C++ prototypes are:\n"
  "    ofQuaternion::set(float,float,float,float)\n" "    ofQuaternion::set(ofVec4f const &)\n"
  "    ofQuaternion::set(ofMatrix4x4 const &)\n"); lua_error(L);return 0; }
static int _wrap_Quaternion_get(lua_State* L) { int SWIG_arg = 0; ofQuaternion *arg1 = (ofQuaternion *) 0 ;
  ofMatrix4x4 *arg2 = 0 ; SWIG_check_num_args("ofQuaternion::get",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofQuaternion::get",1,"ofQuaternion const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofQuaternion::get",2,"ofMatrix4x4 &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofQuaternion,0))){
    SWIG_fail_ptr("Quaternion_get",1,SWIGTYPE_p_ofQuaternion); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofMatrix4x4,0))){
    SWIG_fail_ptr("Quaternion_get",2,SWIGTYPE_p_ofMatrix4x4); }  ((ofQuaternion const *)arg1)->get(*arg2); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Quaternion_x(lua_State* L) { int SWIG_arg = 0; ofQuaternion *arg1 = (ofQuaternion *) 0 ; float *result = 0 ;
  SWIG_check_num_args("ofQuaternion::x",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofQuaternion::x",1,"ofQuaternion *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofQuaternion,0))){
    SWIG_fail_ptr("Quaternion_x",1,SWIGTYPE_p_ofQuaternion); }  result = (float *) &(arg1)->x();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_float,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Quaternion_y(lua_State* L) { int SWIG_arg = 0; ofQuaternion *arg1 = (ofQuaternion *) 0 ; float *result = 0 ;
  SWIG_check_num_args("ofQuaternion::y",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofQuaternion::y",1,"ofQuaternion *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofQuaternion,0))){
    SWIG_fail_ptr("Quaternion_y",1,SWIGTYPE_p_ofQuaternion); }  result = (float *) &(arg1)->y();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_float,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Quaternion_z(lua_State* L) { int SWIG_arg = 0; ofQuaternion *arg1 = (ofQuaternion *) 0 ; float *result = 0 ;
  SWIG_check_num_args("ofQuaternion::z",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofQuaternion::z",1,"ofQuaternion *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofQuaternion,0))){
    SWIG_fail_ptr("Quaternion_z",1,SWIGTYPE_p_ofQuaternion); }  result = (float *) &(arg1)->z();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_float,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Quaternion_w(lua_State* L) { int SWIG_arg = 0; ofQuaternion *arg1 = (ofQuaternion *) 0 ; float *result = 0 ;
  SWIG_check_num_args("ofQuaternion::w",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofQuaternion::w",1,"ofQuaternion *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofQuaternion,0))){
    SWIG_fail_ptr("Quaternion_w",1,SWIGTYPE_p_ofQuaternion); }  result = (float *) &(arg1)->w();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_float,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Quaternion_asVec4(lua_State* L) { int SWIG_arg = 0; ofQuaternion *arg1 = (ofQuaternion *) 0 ; ofVec4f result;
  SWIG_check_num_args("ofQuaternion::asVec4",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofQuaternion::asVec4",1,"ofQuaternion const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofQuaternion,0))){
    SWIG_fail_ptr("Quaternion_asVec4",1,SWIGTYPE_p_ofQuaternion); }  result = ((ofQuaternion const *)arg1)->asVec4(); {
    ofVec4f * resultptr = new ofVec4f((const ofVec4f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec4f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Quaternion_asVec3(lua_State* L) { int SWIG_arg = 0; ofQuaternion *arg1 = (ofQuaternion *) 0 ; ofVec3f result;
  SWIG_check_num_args("ofQuaternion::asVec3",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofQuaternion::asVec3",1,"ofQuaternion const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofQuaternion,0))){
    SWIG_fail_ptr("Quaternion_asVec3",1,SWIGTYPE_p_ofQuaternion); }  result = ((ofQuaternion const *)arg1)->asVec3(); {
    ofVec3f * resultptr = new ofVec3f((const ofVec3f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec3f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Quaternion_zeroRotation(lua_State* L) { int SWIG_arg = 0; ofQuaternion *arg1 = (ofQuaternion *) 0 ;
  bool result; SWIG_check_num_args("ofQuaternion::zeroRotation",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofQuaternion::zeroRotation",1,"ofQuaternion const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofQuaternion,0))){
    SWIG_fail_ptr("Quaternion_zeroRotation",1,SWIGTYPE_p_ofQuaternion); } 
  result = (bool)((ofQuaternion const *)arg1)->zeroRotation(); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Quaternion_length(lua_State* L) { int SWIG_arg = 0; ofQuaternion *arg1 = (ofQuaternion *) 0 ; float result;
  SWIG_check_num_args("ofQuaternion::length",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofQuaternion::length",1,"ofQuaternion const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofQuaternion,0))){
    SWIG_fail_ptr("Quaternion_length",1,SWIGTYPE_p_ofQuaternion); }  result = (float)((ofQuaternion const *)arg1)->length();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Quaternion_length2(lua_State* L) { int SWIG_arg = 0; ofQuaternion *arg1 = (ofQuaternion *) 0 ; float result;
  SWIG_check_num_args("ofQuaternion::length2",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofQuaternion::length2",1,"ofQuaternion const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofQuaternion,0))){
    SWIG_fail_ptr("Quaternion_length2",1,SWIGTYPE_p_ofQuaternion); }  result = (float)((ofQuaternion const *)arg1)->length2();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Quaternion_conj(lua_State* L) { int SWIG_arg = 0; ofQuaternion *arg1 = (ofQuaternion *) 0 ;
  ofQuaternion result; SWIG_check_num_args("ofQuaternion::conj",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofQuaternion::conj",1,"ofQuaternion const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofQuaternion,0))){
    SWIG_fail_ptr("Quaternion_conj",1,SWIGTYPE_p_ofQuaternion); }  result = ((ofQuaternion const *)arg1)->conj(); {
    ofQuaternion * resultptr = new ofQuaternion((const ofQuaternion &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofQuaternion,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Quaternion_inverse(lua_State* L) { int SWIG_arg = 0; ofQuaternion *arg1 = (ofQuaternion *) 0 ;
  ofQuaternion result; SWIG_check_num_args("ofQuaternion::inverse",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofQuaternion::inverse",1,"ofQuaternion const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofQuaternion,0))){
    SWIG_fail_ptr("Quaternion_inverse",1,SWIGTYPE_p_ofQuaternion); }  result = ((ofQuaternion const *)arg1)->inverse(); {
    ofQuaternion * resultptr = new ofQuaternion((const ofQuaternion &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofQuaternion,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Quaternion_makeRotate__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofQuaternion *arg1 = (ofQuaternion *) 0 ;
  float arg2 ; float arg3 ; float arg4 ; float arg5 ; SWIG_check_num_args("ofQuaternion::makeRotate",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofQuaternion::makeRotate",1,"ofQuaternion *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofQuaternion::makeRotate",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofQuaternion::makeRotate",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofQuaternion::makeRotate",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofQuaternion::makeRotate",5,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofQuaternion,0))){
    SWIG_fail_ptr("Quaternion_makeRotate",1,SWIGTYPE_p_ofQuaternion); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); arg5 = (float)lua_tonumber(L, 5);
  (arg1)->makeRotate(arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Quaternion_makeRotate__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofQuaternion *arg1 = (ofQuaternion *) 0 ;
  float arg2 ; ofVec3f *arg3 = 0 ; SWIG_check_num_args("ofQuaternion::makeRotate",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofQuaternion::makeRotate",1,"ofQuaternion *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofQuaternion::makeRotate",2,"float");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofQuaternion::makeRotate",3,"ofVec3f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofQuaternion,0))){
    SWIG_fail_ptr("Quaternion_makeRotate",1,SWIGTYPE_p_ofQuaternion); }  arg2 = (float)lua_tonumber(L, 2);
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Quaternion_makeRotate",3,SWIGTYPE_p_ofVec3f); }  (arg1)->makeRotate(arg2,(ofVec3f const &)*arg3);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Quaternion_makeRotate__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofQuaternion *arg1 = (ofQuaternion *) 0 ;
  float arg2 ; ofVec3f *arg3 = 0 ; float arg4 ; ofVec3f *arg5 = 0 ; float arg6 ; ofVec3f *arg7 = 0 ;
  SWIG_check_num_args("ofQuaternion::makeRotate",7,7)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofQuaternion::makeRotate",1,"ofQuaternion *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofQuaternion::makeRotate",2,"float");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofQuaternion::makeRotate",3,"ofVec3f const &");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofQuaternion::makeRotate",4,"float");
  if(!lua_isuserdata(L,5)) SWIG_fail_arg("ofQuaternion::makeRotate",5,"ofVec3f const &");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofQuaternion::makeRotate",6,"float");
  if(!lua_isuserdata(L,7)) SWIG_fail_arg("ofQuaternion::makeRotate",7,"ofVec3f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofQuaternion,0))){
    SWIG_fail_ptr("Quaternion_makeRotate",1,SWIGTYPE_p_ofQuaternion); }  arg2 = (float)lua_tonumber(L, 2);
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Quaternion_makeRotate",3,SWIGTYPE_p_ofVec3f); }  arg4 = (float)lua_tonumber(L, 4);
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&arg5,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Quaternion_makeRotate",5,SWIGTYPE_p_ofVec3f); }  arg6 = (float)lua_tonumber(L, 6);
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,7,(void**)&arg7,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Quaternion_makeRotate",7,SWIGTYPE_p_ofVec3f); } 
  (arg1)->makeRotate(arg2,(ofVec3f const &)*arg3,arg4,(ofVec3f const &)*arg5,arg6,(ofVec3f const &)*arg7); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Quaternion_makeRotate__SWIG_3(lua_State* L) { int SWIG_arg = 0; ofQuaternion *arg1 = (ofQuaternion *) 0 ;
  ofVec3f *arg2 = 0 ; ofVec3f *arg3 = 0 ; SWIG_check_num_args("ofQuaternion::makeRotate",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofQuaternion::makeRotate",1,"ofQuaternion *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofQuaternion::makeRotate",2,"ofVec3f const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofQuaternion::makeRotate",3,"ofVec3f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofQuaternion,0))){
    SWIG_fail_ptr("Quaternion_makeRotate",1,SWIGTYPE_p_ofQuaternion); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Quaternion_makeRotate",2,SWIGTYPE_p_ofVec3f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Quaternion_makeRotate",3,SWIGTYPE_p_ofVec3f); } 
  (arg1)->makeRotate((ofVec3f const &)*arg2,(ofVec3f const &)*arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Quaternion_makeRotate(lua_State* L) { int argc; int argv[8]={ 1,2,3,4,5,6,7,8} ; argc = lua_gettop(L);
  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofQuaternion, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }
           else { _v = 1; }  }  if (_v) { return _wrap_Quaternion_makeRotate__SWIG_3(L);}  }  }  }  if (argc == 3) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofQuaternion, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }
           else { _v = 1; }  }  if (_v) { return _wrap_Quaternion_makeRotate__SWIG_1(L);}  }  }  }  if (argc == 5) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofQuaternion, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) {
              return _wrap_Quaternion_makeRotate__SWIG_0(L);}  }  }  }  }  }  if (argc == 7) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofQuaternion, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }
           else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { { void *ptr;
              if (lua_isuserdata(L,argv[4])==0 || SWIG_ConvertPtr(L,argv[4], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }
               else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[5]); }  if (_v) { { void *ptr;
                  if (lua_isuserdata(L,argv[6])==0 || SWIG_ConvertPtr(L,argv[6], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) {
                    _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Quaternion_makeRotate__SWIG_2(L);}  }  }  }  }  }  }
     }  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Quaternion_makeRotate'\n"
  "  Possible C/C++ prototypes are:\n" "    ofQuaternion::makeRotate(float,float,float,float)\n"
  "    ofQuaternion::makeRotate(float,ofVec3f const &)\n"
  "    ofQuaternion::makeRotate(float,ofVec3f const &,float,ofVec3f const &,float,ofVec3f const &)\n"
  "    ofQuaternion::makeRotate(ofVec3f const &,ofVec3f const &)\n"); lua_error(L);return 0; }
static int _wrap_Quaternion_makeRotate_original(lua_State* L) { int SWIG_arg = 0; ofQuaternion *arg1 = (ofQuaternion *) 0 ;
  ofVec3f *arg2 = 0 ; ofVec3f *arg3 = 0 ; SWIG_check_num_args("ofQuaternion::makeRotate_original",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofQuaternion::makeRotate_original",1,"ofQuaternion *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofQuaternion::makeRotate_original",2,"ofVec3f const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofQuaternion::makeRotate_original",3,"ofVec3f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofQuaternion,0))){
    SWIG_fail_ptr("Quaternion_makeRotate_original",1,SWIGTYPE_p_ofQuaternion); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Quaternion_makeRotate_original",2,SWIGTYPE_p_ofVec3f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Quaternion_makeRotate_original",3,SWIGTYPE_p_ofVec3f); } 
  (arg1)->makeRotate_original((ofVec3f const &)*arg2,(ofVec3f const &)*arg3); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Quaternion_getRotate__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofQuaternion *arg1 = (ofQuaternion *) 0 ;
  float *arg2 = 0 ; float *arg3 = 0 ; float *arg4 = 0 ; float *arg5 = 0 ; SWIG_check_num_args("ofQuaternion::getRotate",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofQuaternion::getRotate",1,"ofQuaternion const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofQuaternion::getRotate",2,"float &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofQuaternion::getRotate",3,"float &");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("ofQuaternion::getRotate",4,"float &");
  if(!lua_isuserdata(L,5)) SWIG_fail_arg("ofQuaternion::getRotate",5,"float &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofQuaternion,0))){
    SWIG_fail_ptr("Quaternion_getRotate",1,SWIGTYPE_p_ofQuaternion); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("Quaternion_getRotate",2,SWIGTYPE_p_float); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("Quaternion_getRotate",3,SWIGTYPE_p_float); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("Quaternion_getRotate",4,SWIGTYPE_p_float); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&arg5,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("Quaternion_getRotate",5,SWIGTYPE_p_float); } 
  ((ofQuaternion const *)arg1)->getRotate(*arg2,*arg3,*arg4,*arg5); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Quaternion_getRotate__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofQuaternion *arg1 = (ofQuaternion *) 0 ;
  float *arg2 = 0 ; ofVec3f *arg3 = 0 ; SWIG_check_num_args("ofQuaternion::getRotate",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofQuaternion::getRotate",1,"ofQuaternion const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofQuaternion::getRotate",2,"float &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofQuaternion::getRotate",3,"ofVec3f &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofQuaternion,0))){
    SWIG_fail_ptr("Quaternion_getRotate",1,SWIGTYPE_p_ofQuaternion); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("Quaternion_getRotate",2,SWIGTYPE_p_float); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Quaternion_getRotate",3,SWIGTYPE_p_ofVec3f); }  ((ofQuaternion const *)arg1)->getRotate(*arg2,*arg3);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Quaternion_getRotate(lua_State* L) { int argc; int argv[6]={ 1,2,3,4,5,6} ; argc = lua_gettop(L);
  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofQuaternion, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_float, 0)) { _v = 0; }  else {
          _v = 1; }  }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }
           else { _v = 1; }  }  if (_v) { return _wrap_Quaternion_getRotate__SWIG_1(L);}  }  }  }  if (argc == 5) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofQuaternion, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_float, 0)) { _v = 0; }  else {
          _v = 1; }  }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_float, 0)) { _v = 0; }
           else { _v = 1; }  }  if (_v) { { void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_float, 0)) { _v = 0; }
             else { _v = 1; }  }  if (_v) { { void *ptr;
              if (lua_isuserdata(L,argv[4])==0 || SWIG_ConvertPtr(L,argv[4], (void **) &ptr, SWIGTYPE_p_float, 0)) { _v = 0; }
               else { _v = 1; }  }  if (_v) { return _wrap_Quaternion_getRotate__SWIG_0(L);}  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Quaternion_getRotate'\n"
  "  Possible C/C++ prototypes are:\n" "    ofQuaternion::getRotate(float &,float &,float &,float &) const\n"
  "    ofQuaternion::getRotate(float &,ofVec3f &) const\n"); lua_error(L);return 0; }
static int _wrap_Quaternion_getEuler(lua_State* L) { int SWIG_arg = 0; ofQuaternion *arg1 = (ofQuaternion *) 0 ; ofVec3f result;
  SWIG_check_num_args("ofQuaternion::getEuler",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofQuaternion::getEuler",1,"ofQuaternion const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofQuaternion,0))){
    SWIG_fail_ptr("Quaternion_getEuler",1,SWIGTYPE_p_ofQuaternion); }  result = ((ofQuaternion const *)arg1)->getEuler(); {
    ofVec3f * resultptr = new ofVec3f((const ofVec3f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec3f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Quaternion_slerp(lua_State* L) { int SWIG_arg = 0; ofQuaternion *arg1 = (ofQuaternion *) 0 ; float arg2 ;
  ofQuaternion *arg3 = 0 ; ofQuaternion *arg4 = 0 ; SWIG_check_num_args("ofQuaternion::slerp",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofQuaternion::slerp",1,"ofQuaternion *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofQuaternion::slerp",2,"float");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofQuaternion::slerp",3,"ofQuaternion const &");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("ofQuaternion::slerp",4,"ofQuaternion const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofQuaternion,0))){
    SWIG_fail_ptr("Quaternion_slerp",1,SWIGTYPE_p_ofQuaternion); }  arg2 = (float)lua_tonumber(L, 2);
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_ofQuaternion,0))){
    SWIG_fail_ptr("Quaternion_slerp",3,SWIGTYPE_p_ofQuaternion); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_ofQuaternion,0))){
    SWIG_fail_ptr("Quaternion_slerp",4,SWIGTYPE_p_ofQuaternion); } 
  (arg1)->slerp(arg2,(ofQuaternion const &)*arg3,(ofQuaternion const &)*arg4); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Quaternion_normalize(lua_State* L) { int SWIG_arg = 0; ofQuaternion *arg1 = (ofQuaternion *) 0 ;
  SWIG_check_num_args("ofQuaternion::normalize",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofQuaternion::normalize",1,"ofQuaternion *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofQuaternion,0))){
    SWIG_fail_ptr("Quaternion_normalize",1,SWIGTYPE_p_ofQuaternion); }  (arg1)->normalize(); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Quaternion___eq(lua_State* L) { int SWIG_arg = 0; ofQuaternion *arg1 = (ofQuaternion *) 0 ;
  ofQuaternion *arg2 = 0 ; bool result; SWIG_check_num_args("ofQuaternion::operator ==",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofQuaternion::operator ==",1,"ofQuaternion const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofQuaternion::operator ==",2,"ofQuaternion const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofQuaternion,0))){
    SWIG_fail_ptr("Quaternion___eq",1,SWIGTYPE_p_ofQuaternion); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofQuaternion,0))){
    SWIG_fail_ptr("Quaternion___eq",2,SWIGTYPE_p_ofQuaternion); } 
  result = (bool)((ofQuaternion const *)arg1)->operator ==((ofQuaternion const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Quaternion___mul__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofQuaternion *arg1 = (ofQuaternion *) 0 ;
  float arg2 ; ofQuaternion result; SWIG_check_num_args("ofQuaternion::operator *",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofQuaternion::operator *",1,"ofQuaternion const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofQuaternion::operator *",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofQuaternion,0))){
    SWIG_fail_ptr("Quaternion___mul",1,SWIGTYPE_p_ofQuaternion); }  arg2 = (float)lua_tonumber(L, 2);
  result = ((ofQuaternion const *)arg1)->operator *(arg2); {
    ofQuaternion * resultptr = new ofQuaternion((const ofQuaternion &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofQuaternion,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Quaternion___mul__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofQuaternion *arg1 = (ofQuaternion *) 0 ;
  ofQuaternion *arg2 = 0 ; ofQuaternion result; SWIG_check_num_args("ofQuaternion::operator *",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofQuaternion::operator *",1,"ofQuaternion const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofQuaternion::operator *",2,"ofQuaternion const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofQuaternion,0))){
    SWIG_fail_ptr("Quaternion___mul",1,SWIGTYPE_p_ofQuaternion); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofQuaternion,0))){
    SWIG_fail_ptr("Quaternion___mul",2,SWIGTYPE_p_ofQuaternion); } 
  result = ((ofQuaternion const *)arg1)->operator *((ofQuaternion const &)*arg2); {
    ofQuaternion * resultptr = new ofQuaternion((const ofQuaternion &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofQuaternion,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Quaternion___mul__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofQuaternion *arg1 = (ofQuaternion *) 0 ;
  ofVec3f *arg2 = 0 ; ofVec3f result; SWIG_check_num_args("ofQuaternion::operator *",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofQuaternion::operator *",1,"ofQuaternion const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofQuaternion::operator *",2,"ofVec3f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofQuaternion,0))){
    SWIG_fail_ptr("Quaternion___mul",1,SWIGTYPE_p_ofQuaternion); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Quaternion___mul",2,SWIGTYPE_p_ofVec3f); } 
  result = ((ofQuaternion const *)arg1)->operator *((ofVec3f const &)*arg2); {
    ofVec3f * resultptr = new ofVec3f((const ofVec3f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec3f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Quaternion___mul(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofQuaternion, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofQuaternion, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Quaternion___mul__SWIG_1(L);}  }  }  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofQuaternion, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Quaternion___mul__SWIG_2(L);}  }  }  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofQuaternion, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { return _wrap_Quaternion___mul__SWIG_0(L);}  }
     }  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Quaternion___mul'\n"
  "  Possible C/C++ prototypes are:\n" "    ofQuaternion::operator *(float) const\n"
  "    ofQuaternion::operator *(ofQuaternion const &) const\n" "    ofQuaternion::operator *(ofVec3f const &) const\n");
  lua_error(L);return 0; }
static int _wrap_Quaternion___div__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofQuaternion *arg1 = (ofQuaternion *) 0 ;
  float arg2 ; ofQuaternion result; SWIG_check_num_args("ofQuaternion::operator /",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofQuaternion::operator /",1,"ofQuaternion const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofQuaternion::operator /",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofQuaternion,0))){
    SWIG_fail_ptr("Quaternion___div",1,SWIGTYPE_p_ofQuaternion); }  arg2 = (float)lua_tonumber(L, 2);
  result = ((ofQuaternion const *)arg1)->operator /(arg2); {
    ofQuaternion * resultptr = new ofQuaternion((const ofQuaternion &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofQuaternion,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Quaternion___div__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofQuaternion *arg1 = (ofQuaternion *) 0 ;
  ofQuaternion *arg2 = 0 ; ofQuaternion result; SWIG_check_num_args("ofQuaternion::operator /",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofQuaternion::operator /",1,"ofQuaternion const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofQuaternion::operator /",2,"ofQuaternion const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofQuaternion,0))){
    SWIG_fail_ptr("Quaternion___div",1,SWIGTYPE_p_ofQuaternion); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofQuaternion,0))){
    SWIG_fail_ptr("Quaternion___div",2,SWIGTYPE_p_ofQuaternion); } 
  result = ((ofQuaternion const *)arg1)->operator /((ofQuaternion const &)*arg2); {
    ofQuaternion * resultptr = new ofQuaternion((const ofQuaternion &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofQuaternion,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Quaternion___div(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofQuaternion, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofQuaternion, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Quaternion___div__SWIG_1(L);}  }  }  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofQuaternion, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { return _wrap_Quaternion___div__SWIG_0(L);}  }
     }  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Quaternion___div'\n"
  "  Possible C/C++ prototypes are:\n" "    ofQuaternion::operator /(float) const\n"
  "    ofQuaternion::operator /(ofQuaternion const &) const\n"); lua_error(L);return 0; }
static int _wrap_Quaternion___add(lua_State* L) { int SWIG_arg = 0; ofQuaternion *arg1 = (ofQuaternion *) 0 ;
  ofQuaternion *arg2 = 0 ; ofQuaternion result; SWIG_check_num_args("ofQuaternion::operator +",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofQuaternion::operator +",1,"ofQuaternion const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofQuaternion::operator +",2,"ofQuaternion const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofQuaternion,0))){
    SWIG_fail_ptr("Quaternion___add",1,SWIGTYPE_p_ofQuaternion); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofQuaternion,0))){
    SWIG_fail_ptr("Quaternion___add",2,SWIGTYPE_p_ofQuaternion); } 
  result = ((ofQuaternion const *)arg1)->operator +((ofQuaternion const &)*arg2); {
    ofQuaternion * resultptr = new ofQuaternion((const ofQuaternion &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofQuaternion,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Quaternion___sub(lua_State* L) { int SWIG_arg = 0; ofQuaternion *arg1 = (ofQuaternion *) 0 ;
  ofQuaternion *arg2 = 0 ; ofQuaternion result; SWIG_check_num_args("ofQuaternion::operator -",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofQuaternion::operator -",1,"ofQuaternion const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofQuaternion::operator -",2,"ofQuaternion const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofQuaternion,0))){
    SWIG_fail_ptr("Quaternion___sub",1,SWIGTYPE_p_ofQuaternion); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofQuaternion,0))){
    SWIG_fail_ptr("Quaternion___sub",2,SWIGTYPE_p_ofQuaternion); } 
  result = ((ofQuaternion const *)arg1)->operator -((ofQuaternion const &)*arg2); {
    ofQuaternion * resultptr = new ofQuaternion((const ofQuaternion &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofQuaternion,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Quaternion___unm(lua_State* L) { int SWIG_arg = 0; ofQuaternion *arg1 = (ofQuaternion *) 0 ;
  ofQuaternion result; SWIG_check_num_args("ofQuaternion::operator -",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofQuaternion::operator -",1,"ofQuaternion const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofQuaternion,0))){
    SWIG_fail_ptr("Quaternion___unm",1,SWIGTYPE_p_ofQuaternion); }  result = ((ofQuaternion const *)arg1)->operator -(); {
    ofQuaternion * resultptr = new ofQuaternion((const ofQuaternion &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofQuaternion,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Quaternion___tostring(lua_State* L) { int SWIG_arg = 0; ofQuaternion *arg1 = (ofQuaternion *) 0 ;
  char *result = 0 ; SWIG_check_num_args("ofQuaternion::__str__",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofQuaternion::__str__",1,"ofQuaternion *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofQuaternion,0))){
    SWIG_fail_ptr("Quaternion___tostring",1,SWIGTYPE_p_ofQuaternion); }  result = (char *)ofQuaternion___str__(arg1);
  lua_pushstring(L,(const char *)result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static void swig_delete_Quaternion(void *obj) {
ofQuaternion *arg1 = (ofQuaternion *) obj;
delete arg1;
}
static int _proxy__wrap_new_Quaternion(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_Quaternion);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_Quaternion_attributes[] = {
    { "_v", _wrap_Quaternion__v_get, _wrap_Quaternion__v_set },
    {0,0,0}
};
static swig_lua_method swig_Quaternion_methods[]= {
    { "set", _wrap_Quaternion_set},
    { "get", _wrap_Quaternion_get},
    { "x", _wrap_Quaternion_x},
    { "y", _wrap_Quaternion_y},
    { "z", _wrap_Quaternion_z},
    { "w", _wrap_Quaternion_w},
    { "asVec4", _wrap_Quaternion_asVec4},
    { "asVec3", _wrap_Quaternion_asVec3},
    { "zeroRotation", _wrap_Quaternion_zeroRotation},
    { "length", _wrap_Quaternion_length},
    { "length2", _wrap_Quaternion_length2},
    { "conj", _wrap_Quaternion_conj},
    { "inverse", _wrap_Quaternion_inverse},
    { "makeRotate", _wrap_Quaternion_makeRotate},
    { "makeRotate_original", _wrap_Quaternion_makeRotate_original},
    { "getRotate", _wrap_Quaternion_getRotate},
    { "getEuler", _wrap_Quaternion_getEuler},
    { "slerp", _wrap_Quaternion_slerp},
    { "normalize", _wrap_Quaternion_normalize},
    { "__eq", _wrap_Quaternion___eq},
    { "__mul", _wrap_Quaternion___mul},
    { "__div", _wrap_Quaternion___div},
    { "__add", _wrap_Quaternion___add},
    { "__sub", _wrap_Quaternion___sub},
    { "__unm", _wrap_Quaternion___unm},
    { "__tostring", _wrap_Quaternion___tostring},
    {0,0}
};
static swig_lua_method swig_Quaternion_meta[] = {
    { "__eq", _wrap_Quaternion___eq},
    { "__mul", _wrap_Quaternion___mul},
    { "__div", _wrap_Quaternion___div},
    { "__add", _wrap_Quaternion___add},
    { "__sub", _wrap_Quaternion___sub},
    { "__unm", _wrap_Quaternion___unm},
    { "__tostring", _wrap_Quaternion___tostring},
    {0,0}
};

static swig_lua_attribute swig_Quaternion_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_Quaternion_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_Quaternion_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_Quaternion_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_Quaternion_Sf_SwigStatic = {
    "Quaternion",
    swig_Quaternion_Sf_SwigStatic_methods,
    swig_Quaternion_Sf_SwigStatic_attributes,
    swig_Quaternion_Sf_SwigStatic_constants,
    swig_Quaternion_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_Quaternion_bases[] = {0};
static const char *swig_Quaternion_base_names[] = {0};
static swig_lua_class _wrap_class_Quaternion = { "Quaternion", "Quaternion", &SWIGTYPE_p_ofQuaternion,_proxy__wrap_new_Quaternion, swig_delete_Quaternion, swig_Quaternion_methods, swig_Quaternion_attributes, &swig_Quaternion_Sf_SwigStatic, swig_Quaternion_meta, swig_Quaternion_bases, swig_Quaternion_base_names };

static int _wrap_Vec2f_x_set(lua_State* L) { int SWIG_arg = 0; ofVec2f *arg1 = (ofVec2f *) 0 ; float arg2 ;
  SWIG_check_num_args("ofVec2f::x",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec2f::x",1,"ofVec2f *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVec2f::x",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec2f,0))){ SWIG_fail_ptr("Vec2f_x_set",1,SWIGTYPE_p_ofVec2f); }
   arg2 = (float)lua_tonumber(L, 2); if (arg1) (arg1)->x = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Vec2f_x_get(lua_State* L) { int SWIG_arg = 0; ofVec2f *arg1 = (ofVec2f *) 0 ; float result;
  SWIG_check_num_args("ofVec2f::x",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec2f::x",1,"ofVec2f *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec2f,0))){ SWIG_fail_ptr("Vec2f_x_get",1,SWIGTYPE_p_ofVec2f); }
   result = (float) ((arg1)->x); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vec2f_y_set(lua_State* L) { int SWIG_arg = 0; ofVec2f *arg1 = (ofVec2f *) 0 ; float arg2 ;
  SWIG_check_num_args("ofVec2f::y",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec2f::y",1,"ofVec2f *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVec2f::y",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec2f,0))){ SWIG_fail_ptr("Vec2f_y_set",1,SWIGTYPE_p_ofVec2f); }
   arg2 = (float)lua_tonumber(L, 2); if (arg1) (arg1)->y = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Vec2f_y_get(lua_State* L) { int SWIG_arg = 0; ofVec2f *arg1 = (ofVec2f *) 0 ; float result;
  SWIG_check_num_args("ofVec2f::y",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec2f::y",1,"ofVec2f *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec2f,0))){ SWIG_fail_ptr("Vec2f_y_get",1,SWIGTYPE_p_ofVec2f); }
   result = (float) ((arg1)->y); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_Vec2f__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofVec2f *result = 0 ;
  SWIG_check_num_args("ofVec2f::ofVec2f",0,0) result = (ofVec2f *)new ofVec2f();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofVec2f,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_Vec2f__SWIG_1(lua_State* L) { int SWIG_arg = 0; float arg1 ; ofVec2f *result = 0 ;
  SWIG_check_num_args("ofVec2f::ofVec2f",1,1) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofVec2f::ofVec2f",1,"float");
  arg1 = (float)lua_tonumber(L, 1); result = (ofVec2f *)new ofVec2f(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofVec2f,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_Vec2f__SWIG_2(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; ofVec2f *result = 0 ;
  SWIG_check_num_args("ofVec2f::ofVec2f",2,2) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofVec2f::ofVec2f",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVec2f::ofVec2f",2,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); result = (ofVec2f *)new ofVec2f(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofVec2f,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_Vec2f__SWIG_3(lua_State* L) { int SWIG_arg = 0; ofVec3f *arg1 = 0 ; ofVec2f *result = 0 ;
  SWIG_check_num_args("ofVec2f::ofVec2f",1,1) if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofVec2f::ofVec2f",1,"ofVec3f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec3f,0))){ SWIG_fail_ptr("new_Vec2f",1,SWIGTYPE_p_ofVec3f); } 
  result = (ofVec2f *)new ofVec2f((ofVec3f const &)*arg1); SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofVec2f,1); SWIG_arg++; 
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_new_Vec2f__SWIG_4(lua_State* L) { int SWIG_arg = 0; ofVec4f *arg1 = 0 ; ofVec2f *result = 0 ;
  SWIG_check_num_args("ofVec2f::ofVec2f",1,1) if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofVec2f::ofVec2f",1,"ofVec4f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec4f,0))){ SWIG_fail_ptr("new_Vec2f",1,SWIGTYPE_p_ofVec4f); } 
  result = (ofVec2f *)new ofVec2f((ofVec4f const &)*arg1); SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofVec2f,1); SWIG_arg++; 
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_new_Vec2f__SWIG_5(lua_State* L) { int SWIG_arg = 0; glm::vec2 *arg1 = 0 ; ofVec2f *result = 0 ;
  SWIG_check_num_args("ofVec2f::ofVec2f",1,1) if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofVec2f::ofVec2f",1,"glm::vec2 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glm__vec2,0))){
    SWIG_fail_ptr("new_Vec2f",1,SWIGTYPE_p_glm__vec2); }  result = (ofVec2f *)new ofVec2f((glm::vec2 const &)*arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofVec2f,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_Vec2f__SWIG_6(lua_State* L) { int SWIG_arg = 0; glm::vec3 *arg1 = 0 ; ofVec2f *result = 0 ;
  SWIG_check_num_args("ofVec2f::ofVec2f",1,1) if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofVec2f::ofVec2f",1,"glm::vec3 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("new_Vec2f",1,SWIGTYPE_p_glm__vec3); }  result = (ofVec2f *)new ofVec2f((glm::vec3 const &)*arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofVec2f,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_Vec2f__SWIG_7(lua_State* L) { int SWIG_arg = 0; glm::vec4 *arg1 = 0 ; ofVec2f *result = 0 ;
  SWIG_check_num_args("ofVec2f::ofVec2f",1,1) if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofVec2f::ofVec2f",1,"glm::vec4 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glm__vec4,0))){
    SWIG_fail_ptr("new_Vec2f",1,SWIGTYPE_p_glm__vec4); }  result = (ofVec2f *)new ofVec2f((glm::vec4 const &)*arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofVec2f,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_Vec2f(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 0) {
    return _wrap_new_Vec2f__SWIG_0(L);}  if (argc == 1) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { return _wrap_new_Vec2f__SWIG_3(L);}  }  if (argc == 1) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec4f, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { return _wrap_new_Vec2f__SWIG_4(L);}  }  if (argc == 1) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_glm__vec2, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { return _wrap_new_Vec2f__SWIG_5(L);}  }  if (argc == 1) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { return _wrap_new_Vec2f__SWIG_6(L);}  }  if (argc == 1) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_glm__vec4, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { return _wrap_new_Vec2f__SWIG_7(L);}  }  if (argc == 1) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { return _wrap_new_Vec2f__SWIG_1(L);}  }  if (argc == 2) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { return _wrap_new_Vec2f__SWIG_2(L);}
       }  }  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_Vec2f'\n"
  "  Possible C/C++ prototypes are:\n" "    ofVec2f::ofVec2f()\n" "    ofVec2f::ofVec2f(float)\n"
  "    ofVec2f::ofVec2f(float,float)\n" "    ofVec2f::ofVec2f(ofVec3f const &)\n" "    ofVec2f::ofVec2f(ofVec4f const &)\n"
  "    ofVec2f::ofVec2f(glm::vec2 const &)\n" "    ofVec2f::ofVec2f(glm::vec3 const &)\n"
  "    ofVec2f::ofVec2f(glm::vec4 const &)\n"); lua_error(L);return 0; }
static int _wrap_Vec2f_getPtr__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofVec2f *arg1 = (ofVec2f *) 0 ; float *result = 0 ;
  SWIG_check_num_args("ofVec2f::getPtr",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec2f::getPtr",1,"ofVec2f *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec2f,0))){ SWIG_fail_ptr("Vec2f_getPtr",1,SWIGTYPE_p_ofVec2f); }
   result = (float *)(arg1)->getPtr(); SWIG_NewPointerObj(L,result,SWIGTYPE_p_float,0); SWIG_arg++;  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vec2f_getPtr__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofVec2f *arg1 = (ofVec2f *) 0 ; float *result = 0 ;
  SWIG_check_num_args("ofVec2f::getPtr",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec2f::getPtr",1,"ofVec2f const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec2f,0))){ SWIG_fail_ptr("Vec2f_getPtr",1,SWIGTYPE_p_ofVec2f); }
   result = (float *)((ofVec2f const *)arg1)->getPtr(); SWIG_NewPointerObj(L,result,SWIGTYPE_p_float,0); SWIG_arg++; 
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vec2f_getPtr(lua_State* L) { int argc; int argv[2]={ 1,2} ; argc = lua_gettop(L); if (argc == 1) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec2f, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Vec2f_getPtr__SWIG_0(L);}  }  if (argc == 1) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec2f, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Vec2f_getPtr__SWIG_1(L);}  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Vec2f_getPtr'\n" "  Possible C/C++ prototypes are:\n"
  "    ofVec2f::getPtr()\n" "    ofVec2f::getPtr() const\n"); lua_error(L);return 0; }
static int _wrap_Vec2f_set__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofVec2f *arg1 = (ofVec2f *) 0 ; float arg2 ; float arg3 ;
  SWIG_check_num_args("ofVec2f::set",3,3) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec2f::set",1,"ofVec2f *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVec2f::set",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVec2f::set",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec2f,0))){ SWIG_fail_ptr("Vec2f_set",1,SWIGTYPE_p_ofVec2f); } 
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); (arg1)->set(arg2,arg3); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vec2f_set__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofVec2f *arg1 = (ofVec2f *) 0 ; ofVec2f *arg2 = 0 ;
  SWIG_check_num_args("ofVec2f::set",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec2f::set",1,"ofVec2f *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVec2f::set",2,"ofVec2f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec2f,0))){ SWIG_fail_ptr("Vec2f_set",1,SWIGTYPE_p_ofVec2f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec2f,0))){ SWIG_fail_ptr("Vec2f_set",2,SWIGTYPE_p_ofVec2f); } 
  (arg1)->set((ofVec2f const &)*arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vec2f_set__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofVec2f *arg1 = (ofVec2f *) 0 ; float arg2 ;
  SWIG_check_num_args("ofVec2f::set",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec2f::set",1,"ofVec2f *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVec2f::set",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec2f,0))){ SWIG_fail_ptr("Vec2f_set",1,SWIGTYPE_p_ofVec2f); } 
  arg2 = (float)lua_tonumber(L, 2); (arg1)->set(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vec2f_set(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 2) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec2f, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofVec2f, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Vec2f_set__SWIG_1(L);}  }  }  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec2f, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { return _wrap_Vec2f_set__SWIG_2(L);}  }  } 
  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec2f, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_Vec2f_set__SWIG_0(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Vec2f_set'\n" "  Possible C/C++ prototypes are:\n"
  "    ofVec2f::set(float,float)\n" "    ofVec2f::set(ofVec2f const &)\n" "    ofVec2f::set(float)\n"); lua_error(L);return 0; }
static int _wrap_Vec2f___eq(lua_State* L) { int SWIG_arg = 0; ofVec2f *arg1 = (ofVec2f *) 0 ; ofVec2f *arg2 = 0 ; bool result;
  SWIG_check_num_args("ofVec2f::operator ==",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec2f::operator ==",1,"ofVec2f const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVec2f::operator ==",2,"ofVec2f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec2f,0))){ SWIG_fail_ptr("Vec2f___eq",1,SWIGTYPE_p_ofVec2f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec2f,0))){ SWIG_fail_ptr("Vec2f___eq",2,SWIGTYPE_p_ofVec2f); } 
  result = (bool)((ofVec2f const *)arg1)->operator ==((ofVec2f const &)*arg2); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vec2f_match__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofVec2f *arg1 = (ofVec2f *) 0 ; ofVec2f *arg2 = 0 ;
  float arg3 ; bool result; SWIG_check_num_args("ofVec2f::match",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec2f::match",1,"ofVec2f const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVec2f::match",2,"ofVec2f const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVec2f::match",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec2f,0))){ SWIG_fail_ptr("Vec2f_match",1,SWIGTYPE_p_ofVec2f); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec2f,0))){ SWIG_fail_ptr("Vec2f_match",2,SWIGTYPE_p_ofVec2f); }
   arg3 = (float)lua_tonumber(L, 3); result = (bool)((ofVec2f const *)arg1)->match((ofVec2f const &)*arg2,arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vec2f_match__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofVec2f *arg1 = (ofVec2f *) 0 ; ofVec2f *arg2 = 0 ;
  bool result; SWIG_check_num_args("ofVec2f::match",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec2f::match",1,"ofVec2f const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVec2f::match",2,"ofVec2f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec2f,0))){ SWIG_fail_ptr("Vec2f_match",1,SWIGTYPE_p_ofVec2f); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec2f,0))){ SWIG_fail_ptr("Vec2f_match",2,SWIGTYPE_p_ofVec2f); }
   result = (bool)((ofVec2f const *)arg1)->match((ofVec2f const &)*arg2); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vec2f_match(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 2) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec2f, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofVec2f, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Vec2f_match__SWIG_1(L);}  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec2f, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofVec2f, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { return _wrap_Vec2f_match__SWIG_0(L);}  }  }
     }  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Vec2f_match'\n" "  Possible C/C++ prototypes are:\n"
  "    ofVec2f::match(ofVec2f const &,float) const\n" "    ofVec2f::match(ofVec2f const &) const\n"); lua_error(L);return 0; }
static int _wrap_Vec2f_isAligned__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofVec2f *arg1 = (ofVec2f *) 0 ; ofVec2f *arg2 = 0 ;
  float arg3 ; bool result; SWIG_check_num_args("ofVec2f::isAligned",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec2f::isAligned",1,"ofVec2f const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVec2f::isAligned",2,"ofVec2f const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVec2f::isAligned",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec2f,0))){
    SWIG_fail_ptr("Vec2f_isAligned",1,SWIGTYPE_p_ofVec2f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec2f,0))){
    SWIG_fail_ptr("Vec2f_isAligned",2,SWIGTYPE_p_ofVec2f); }  arg3 = (float)lua_tonumber(L, 3);
  result = (bool)((ofVec2f const *)arg1)->isAligned((ofVec2f const &)*arg2,arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vec2f_isAligned__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofVec2f *arg1 = (ofVec2f *) 0 ; ofVec2f *arg2 = 0 ;
  bool result; SWIG_check_num_args("ofVec2f::isAligned",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec2f::isAligned",1,"ofVec2f const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVec2f::isAligned",2,"ofVec2f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec2f,0))){
    SWIG_fail_ptr("Vec2f_isAligned",1,SWIGTYPE_p_ofVec2f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec2f,0))){
    SWIG_fail_ptr("Vec2f_isAligned",2,SWIGTYPE_p_ofVec2f); } 
  result = (bool)((ofVec2f const *)arg1)->isAligned((ofVec2f const &)*arg2); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vec2f_isAligned(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec2f, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofVec2f, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Vec2f_isAligned__SWIG_1(L);}  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec2f, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofVec2f, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { return _wrap_Vec2f_isAligned__SWIG_0(L);}  }
       }  }  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Vec2f_isAligned'\n"
  "  Possible C/C++ prototypes are:\n" "    ofVec2f::isAligned(ofVec2f const &,float) const\n"
  "    ofVec2f::isAligned(ofVec2f const &) const\n"); lua_error(L);return 0; }
static int _wrap_Vec2f_isAlignedRad__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofVec2f *arg1 = (ofVec2f *) 0 ;
  ofVec2f *arg2 = 0 ; float arg3 ; bool result; SWIG_check_num_args("ofVec2f::isAlignedRad",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec2f::isAlignedRad",1,"ofVec2f const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVec2f::isAlignedRad",2,"ofVec2f const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVec2f::isAlignedRad",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec2f,0))){
    SWIG_fail_ptr("Vec2f_isAlignedRad",1,SWIGTYPE_p_ofVec2f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec2f,0))){
    SWIG_fail_ptr("Vec2f_isAlignedRad",2,SWIGTYPE_p_ofVec2f); }  arg3 = (float)lua_tonumber(L, 3);
  result = (bool)((ofVec2f const *)arg1)->isAlignedRad((ofVec2f const &)*arg2,arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vec2f_isAlignedRad__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofVec2f *arg1 = (ofVec2f *) 0 ;
  ofVec2f *arg2 = 0 ; bool result; SWIG_check_num_args("ofVec2f::isAlignedRad",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec2f::isAlignedRad",1,"ofVec2f const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVec2f::isAlignedRad",2,"ofVec2f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec2f,0))){
    SWIG_fail_ptr("Vec2f_isAlignedRad",1,SWIGTYPE_p_ofVec2f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec2f,0))){
    SWIG_fail_ptr("Vec2f_isAlignedRad",2,SWIGTYPE_p_ofVec2f); } 
  result = (bool)((ofVec2f const *)arg1)->isAlignedRad((ofVec2f const &)*arg2); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vec2f_isAlignedRad(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec2f, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofVec2f, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Vec2f_isAlignedRad__SWIG_1(L);}  }  }  if (argc == 3) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec2f, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofVec2f, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { return _wrap_Vec2f_isAlignedRad__SWIG_0(L);}
         }  }  }  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Vec2f_isAlignedRad'\n"
  "  Possible C/C++ prototypes are:\n" "    ofVec2f::isAlignedRad(ofVec2f const &,float) const\n"
  "    ofVec2f::isAlignedRad(ofVec2f const &) const\n"); lua_error(L);return 0; }
static int _wrap_Vec2f_align__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofVec2f *arg1 = (ofVec2f *) 0 ; ofVec2f *arg2 = 0 ;
  float arg3 ; bool result; SWIG_check_num_args("ofVec2f::align",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec2f::align",1,"ofVec2f const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVec2f::align",2,"ofVec2f const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVec2f::align",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec2f,0))){ SWIG_fail_ptr("Vec2f_align",1,SWIGTYPE_p_ofVec2f); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec2f,0))){ SWIG_fail_ptr("Vec2f_align",2,SWIGTYPE_p_ofVec2f); }
   arg3 = (float)lua_tonumber(L, 3); result = (bool)((ofVec2f const *)arg1)->align((ofVec2f const &)*arg2,arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vec2f_align__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofVec2f *arg1 = (ofVec2f *) 0 ; ofVec2f *arg2 = 0 ;
  bool result; SWIG_check_num_args("ofVec2f::align",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec2f::align",1,"ofVec2f const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVec2f::align",2,"ofVec2f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec2f,0))){ SWIG_fail_ptr("Vec2f_align",1,SWIGTYPE_p_ofVec2f); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec2f,0))){ SWIG_fail_ptr("Vec2f_align",2,SWIGTYPE_p_ofVec2f); }
   result = (bool)((ofVec2f const *)arg1)->align((ofVec2f const &)*arg2); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vec2f_align(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 2) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec2f, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofVec2f, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Vec2f_align__SWIG_1(L);}  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec2f, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofVec2f, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { return _wrap_Vec2f_align__SWIG_0(L);}  }  }
     }  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Vec2f_align'\n" "  Possible C/C++ prototypes are:\n"
  "    ofVec2f::align(ofVec2f const &,float) const\n" "    ofVec2f::align(ofVec2f const &) const\n"); lua_error(L);return 0; }
static int _wrap_Vec2f_alignRad__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofVec2f *arg1 = (ofVec2f *) 0 ; ofVec2f *arg2 = 0 ;
  float arg3 ; bool result; SWIG_check_num_args("ofVec2f::alignRad",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec2f::alignRad",1,"ofVec2f const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVec2f::alignRad",2,"ofVec2f const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVec2f::alignRad",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec2f,0))){
    SWIG_fail_ptr("Vec2f_alignRad",1,SWIGTYPE_p_ofVec2f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec2f,0))){
    SWIG_fail_ptr("Vec2f_alignRad",2,SWIGTYPE_p_ofVec2f); }  arg3 = (float)lua_tonumber(L, 3);
  result = (bool)((ofVec2f const *)arg1)->alignRad((ofVec2f const &)*arg2,arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vec2f_alignRad__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofVec2f *arg1 = (ofVec2f *) 0 ; ofVec2f *arg2 = 0 ;
  bool result; SWIG_check_num_args("ofVec2f::alignRad",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec2f::alignRad",1,"ofVec2f const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVec2f::alignRad",2,"ofVec2f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec2f,0))){
    SWIG_fail_ptr("Vec2f_alignRad",1,SWIGTYPE_p_ofVec2f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec2f,0))){
    SWIG_fail_ptr("Vec2f_alignRad",2,SWIGTYPE_p_ofVec2f); } 
  result = (bool)((ofVec2f const *)arg1)->alignRad((ofVec2f const &)*arg2); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vec2f_alignRad(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec2f, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofVec2f, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Vec2f_alignRad__SWIG_1(L);}  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec2f, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofVec2f, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { return _wrap_Vec2f_alignRad__SWIG_0(L);}  }
       }  }  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Vec2f_alignRad'\n"
  "  Possible C/C++ prototypes are:\n" "    ofVec2f::alignRad(ofVec2f const &,float) const\n"
  "    ofVec2f::alignRad(ofVec2f const &) const\n"); lua_error(L);return 0; }
static int _wrap_Vec2f___add__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofVec2f *arg1 = (ofVec2f *) 0 ; ofVec2f *arg2 = 0 ;
  ofVec2f result; SWIG_check_num_args("ofVec2f::operator +",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec2f::operator +",1,"ofVec2f const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVec2f::operator +",2,"ofVec2f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec2f,0))){ SWIG_fail_ptr("Vec2f___add",1,SWIGTYPE_p_ofVec2f); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec2f,0))){ SWIG_fail_ptr("Vec2f___add",2,SWIGTYPE_p_ofVec2f); }
   result = ((ofVec2f const *)arg1)->operator +((ofVec2f const &)*arg2); {
    ofVec2f * resultptr = new ofVec2f((const ofVec2f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec2f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vec2f___add__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofVec2f *arg1 = (ofVec2f *) 0 ; float arg2 ;
  ofVec2f result; SWIG_check_num_args("ofVec2f::operator +",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec2f::operator +",1,"ofVec2f const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVec2f::operator +",2,"float const");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec2f,0))){ SWIG_fail_ptr("Vec2f___add",1,SWIGTYPE_p_ofVec2f); }
   arg2 = (float const)lua_tonumber(L, 2); result = ((ofVec2f const *)arg1)->operator +(arg2); {
    ofVec2f * resultptr = new ofVec2f((const ofVec2f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec2f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vec2f___add(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 2) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec2f, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofVec2f, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Vec2f___add__SWIG_0(L);}  }  }  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec2f, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { return _wrap_Vec2f___add__SWIG_1(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Vec2f___add'\n" "  Possible C/C++ prototypes are:\n"
  "    ofVec2f::operator +(ofVec2f const &) const\n" "    ofVec2f::operator +(float const) const\n"); lua_error(L);return 0; }
static int _wrap_Vec2f___sub__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofVec2f *arg1 = (ofVec2f *) 0 ; ofVec2f *arg2 = 0 ;
  ofVec2f result; SWIG_check_num_args("ofVec2f::operator -",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec2f::operator -",1,"ofVec2f const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVec2f::operator -",2,"ofVec2f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec2f,0))){ SWIG_fail_ptr("Vec2f___sub",1,SWIGTYPE_p_ofVec2f); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec2f,0))){ SWIG_fail_ptr("Vec2f___sub",2,SWIGTYPE_p_ofVec2f); }
   result = ((ofVec2f const *)arg1)->operator -((ofVec2f const &)*arg2); {
    ofVec2f * resultptr = new ofVec2f((const ofVec2f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec2f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vec2f___sub__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofVec2f *arg1 = (ofVec2f *) 0 ; float arg2 ;
  ofVec2f result; SWIG_check_num_args("ofVec2f::operator -",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec2f::operator -",1,"ofVec2f const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVec2f::operator -",2,"float const");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec2f,0))){ SWIG_fail_ptr("Vec2f___sub",1,SWIGTYPE_p_ofVec2f); }
   arg2 = (float const)lua_tonumber(L, 2); result = ((ofVec2f const *)arg1)->operator -(arg2); {
    ofVec2f * resultptr = new ofVec2f((const ofVec2f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec2f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vec2f___sub(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 2) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec2f, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofVec2f, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Vec2f___sub__SWIG_0(L);}  }  }  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec2f, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { return _wrap_Vec2f___sub__SWIG_1(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Vec2f___sub'\n" "  Possible C/C++ prototypes are:\n"
  "    ofVec2f::operator -(ofVec2f const &) const\n" "    ofVec2f::operator -(float const) const\n"); lua_error(L);return 0; }
static int _wrap_Vec2f___unm(lua_State* L) { int SWIG_arg = 0; ofVec2f *arg1 = (ofVec2f *) 0 ; ofVec2f result;
  SWIG_check_num_args("ofVec2f::operator -",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec2f::operator -",1,"ofVec2f const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec2f,0))){ SWIG_fail_ptr("Vec2f___unm",1,SWIGTYPE_p_ofVec2f); }
   result = ((ofVec2f const *)arg1)->operator -(); { ofVec2f * resultptr = new ofVec2f((const ofVec2f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec2f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vec2f___mul__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofVec2f *arg1 = (ofVec2f *) 0 ; ofVec2f *arg2 = 0 ;
  ofVec2f result; SWIG_check_num_args("ofVec2f::operator *",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec2f::operator *",1,"ofVec2f const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVec2f::operator *",2,"ofVec2f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec2f,0))){ SWIG_fail_ptr("Vec2f___mul",1,SWIGTYPE_p_ofVec2f); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec2f,0))){ SWIG_fail_ptr("Vec2f___mul",2,SWIGTYPE_p_ofVec2f); }
   result = ((ofVec2f const *)arg1)->operator *((ofVec2f const &)*arg2); {
    ofVec2f * resultptr = new ofVec2f((const ofVec2f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec2f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vec2f___mul__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofVec2f *arg1 = (ofVec2f *) 0 ; float arg2 ;
  ofVec2f result; SWIG_check_num_args("ofVec2f::operator *",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec2f::operator *",1,"ofVec2f const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVec2f::operator *",2,"float const");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec2f,0))){ SWIG_fail_ptr("Vec2f___mul",1,SWIGTYPE_p_ofVec2f); }
   arg2 = (float const)lua_tonumber(L, 2); result = ((ofVec2f const *)arg1)->operator *(arg2); {
    ofVec2f * resultptr = new ofVec2f((const ofVec2f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec2f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vec2f___mul(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 2) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec2f, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofVec2f, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Vec2f___mul__SWIG_0(L);}  }  }  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec2f, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { return _wrap_Vec2f___mul__SWIG_1(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Vec2f___mul'\n" "  Possible C/C++ prototypes are:\n"
  "    ofVec2f::operator *(ofVec2f const &) const\n" "    ofVec2f::operator *(float const) const\n"); lua_error(L);return 0; }
static int _wrap_Vec2f___div__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofVec2f *arg1 = (ofVec2f *) 0 ; ofVec2f *arg2 = 0 ;
  ofVec2f result; SWIG_check_num_args("ofVec2f::operator /",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec2f::operator /",1,"ofVec2f const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVec2f::operator /",2,"ofVec2f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec2f,0))){ SWIG_fail_ptr("Vec2f___div",1,SWIGTYPE_p_ofVec2f); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec2f,0))){ SWIG_fail_ptr("Vec2f___div",2,SWIGTYPE_p_ofVec2f); }
   result = ((ofVec2f const *)arg1)->operator /((ofVec2f const &)*arg2); {
    ofVec2f * resultptr = new ofVec2f((const ofVec2f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec2f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vec2f___div__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofVec2f *arg1 = (ofVec2f *) 0 ; float arg2 ;
  ofVec2f result; SWIG_check_num_args("ofVec2f::operator /",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec2f::operator /",1,"ofVec2f const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVec2f::operator /",2,"float const");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec2f,0))){ SWIG_fail_ptr("Vec2f___div",1,SWIGTYPE_p_ofVec2f); }
   arg2 = (float const)lua_tonumber(L, 2); result = ((ofVec2f const *)arg1)->operator /(arg2); {
    ofVec2f * resultptr = new ofVec2f((const ofVec2f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec2f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vec2f___div(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 2) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec2f, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofVec2f, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Vec2f___div__SWIG_0(L);}  }  }  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec2f, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { return _wrap_Vec2f___div__SWIG_1(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Vec2f___div'\n" "  Possible C/C++ prototypes are:\n"
  "    ofVec2f::operator /(ofVec2f const &) const\n" "    ofVec2f::operator /(float const) const\n"); lua_error(L);return 0; }
static int _wrap_Vec2f_getScaled(lua_State* L) { int SWIG_arg = 0; ofVec2f *arg1 = (ofVec2f *) 0 ; float arg2 ; ofVec2f result;
  SWIG_check_num_args("ofVec2f::getScaled",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec2f::getScaled",1,"ofVec2f const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVec2f::getScaled",2,"float const");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec2f,0))){
    SWIG_fail_ptr("Vec2f_getScaled",1,SWIGTYPE_p_ofVec2f); }  arg2 = (float const)lua_tonumber(L, 2);
  result = ((ofVec2f const *)arg1)->getScaled(arg2); { ofVec2f * resultptr = new ofVec2f((const ofVec2f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec2f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vec2f_scale(lua_State* L) { int SWIG_arg = 0; ofVec2f *arg1 = (ofVec2f *) 0 ; float arg2 ;
  ofVec2f *result = 0 ; SWIG_check_num_args("ofVec2f::scale",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec2f::scale",1,"ofVec2f *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVec2f::scale",2,"float const");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec2f,0))){ SWIG_fail_ptr("Vec2f_scale",1,SWIGTYPE_p_ofVec2f); }
   arg2 = (float const)lua_tonumber(L, 2); result = (ofVec2f *) &(arg1)->scale(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofVec2f,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Vec2f_getRotated__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofVec2f *arg1 = (ofVec2f *) 0 ; float arg2 ;
  ofVec2f result; SWIG_check_num_args("ofVec2f::getRotated",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec2f::getRotated",1,"ofVec2f const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVec2f::getRotated",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec2f,0))){
    SWIG_fail_ptr("Vec2f_getRotated",1,SWIGTYPE_p_ofVec2f); }  arg2 = (float)lua_tonumber(L, 2);
  result = ((ofVec2f const *)arg1)->getRotated(arg2); { ofVec2f * resultptr = new ofVec2f((const ofVec2f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec2f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vec2f_getRotated__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofVec2f *arg1 = (ofVec2f *) 0 ; float arg2 ;
  ofVec2f *arg3 = 0 ; ofVec2f result; SWIG_check_num_args("ofVec2f::getRotated",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec2f::getRotated",1,"ofVec2f const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVec2f::getRotated",2,"float");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofVec2f::getRotated",3,"ofVec2f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec2f,0))){
    SWIG_fail_ptr("Vec2f_getRotated",1,SWIGTYPE_p_ofVec2f); }  arg2 = (float)lua_tonumber(L, 2);
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_ofVec2f,0))){
    SWIG_fail_ptr("Vec2f_getRotated",3,SWIGTYPE_p_ofVec2f); } 
  result = ((ofVec2f const *)arg1)->getRotated(arg2,(ofVec2f const &)*arg3); {
    ofVec2f * resultptr = new ofVec2f((const ofVec2f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec2f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vec2f_getRotated(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec2f, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { return _wrap_Vec2f_getRotated__SWIG_0(L);}  }  } 
  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec2f, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_ofVec2f, 0)) { _v = 0; }
           else { _v = 1; }  }  if (_v) { return _wrap_Vec2f_getRotated__SWIG_1(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Vec2f_getRotated'\n" "  Possible C/C++ prototypes are:\n"
  "    ofVec2f::getRotated(float) const\n" "    ofVec2f::getRotated(float,ofVec2f const &) const\n"); lua_error(L);return 0; }
static int _wrap_Vec2f_getRotatedRad__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofVec2f *arg1 = (ofVec2f *) 0 ; float arg2 ;
  ofVec2f result; SWIG_check_num_args("ofVec2f::getRotatedRad",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec2f::getRotatedRad",1,"ofVec2f const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVec2f::getRotatedRad",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec2f,0))){
    SWIG_fail_ptr("Vec2f_getRotatedRad",1,SWIGTYPE_p_ofVec2f); }  arg2 = (float)lua_tonumber(L, 2);
  result = ((ofVec2f const *)arg1)->getRotatedRad(arg2); { ofVec2f * resultptr = new ofVec2f((const ofVec2f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec2f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vec2f_getRotatedRad__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofVec2f *arg1 = (ofVec2f *) 0 ; float arg2 ;
  ofVec2f *arg3 = 0 ; ofVec2f result; SWIG_check_num_args("ofVec2f::getRotatedRad",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec2f::getRotatedRad",1,"ofVec2f const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVec2f::getRotatedRad",2,"float");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofVec2f::getRotatedRad",3,"ofVec2f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec2f,0))){
    SWIG_fail_ptr("Vec2f_getRotatedRad",1,SWIGTYPE_p_ofVec2f); }  arg2 = (float)lua_tonumber(L, 2);
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_ofVec2f,0))){
    SWIG_fail_ptr("Vec2f_getRotatedRad",3,SWIGTYPE_p_ofVec2f); } 
  result = ((ofVec2f const *)arg1)->getRotatedRad(arg2,(ofVec2f const &)*arg3); {
    ofVec2f * resultptr = new ofVec2f((const ofVec2f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec2f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vec2f_getRotatedRad(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec2f, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { return _wrap_Vec2f_getRotatedRad__SWIG_0(L);}  }  }
   if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec2f, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_ofVec2f, 0)) { _v = 0; }
           else { _v = 1; }  }  if (_v) { return _wrap_Vec2f_getRotatedRad__SWIG_1(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Vec2f_getRotatedRad'\n"
  "  Possible C/C++ prototypes are:\n" "    ofVec2f::getRotatedRad(float) const\n"
  "    ofVec2f::getRotatedRad(float,ofVec2f const &) const\n"); lua_error(L);return 0; }
static int _wrap_Vec2f_rotate__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofVec2f *arg1 = (ofVec2f *) 0 ; float arg2 ;
  ofVec2f *result = 0 ; SWIG_check_num_args("ofVec2f::rotate",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec2f::rotate",1,"ofVec2f *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVec2f::rotate",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec2f,0))){ SWIG_fail_ptr("Vec2f_rotate",1,SWIGTYPE_p_ofVec2f); }
   arg2 = (float)lua_tonumber(L, 2); result = (ofVec2f *) &(arg1)->rotate(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofVec2f,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Vec2f_rotate__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofVec2f *arg1 = (ofVec2f *) 0 ; float arg2 ;
  ofVec2f *arg3 = 0 ; ofVec2f *result = 0 ; SWIG_check_num_args("ofVec2f::rotate",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec2f::rotate",1,"ofVec2f *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVec2f::rotate",2,"float");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofVec2f::rotate",3,"ofVec2f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec2f,0))){ SWIG_fail_ptr("Vec2f_rotate",1,SWIGTYPE_p_ofVec2f); }
   arg2 = (float)lua_tonumber(L, 2); if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_ofVec2f,0))){
    SWIG_fail_ptr("Vec2f_rotate",3,SWIGTYPE_p_ofVec2f); }  result = (ofVec2f *) &(arg1)->rotate(arg2,(ofVec2f const &)*arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofVec2f,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Vec2f_rotate(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 2) { int _v;
    { void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec2f, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_Vec2f_rotate__SWIG_0(L);}  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec2f, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_ofVec2f, 0)) { _v = 0; }
           else { _v = 1; }  }  if (_v) { return _wrap_Vec2f_rotate__SWIG_1(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Vec2f_rotate'\n" "  Possible C/C++ prototypes are:\n"
  "    ofVec2f::rotate(float)\n" "    ofVec2f::rotate(float,ofVec2f const &)\n"); lua_error(L);return 0; }
static int _wrap_Vec2f_rotateRad__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofVec2f *arg1 = (ofVec2f *) 0 ; float arg2 ;
  ofVec2f *result = 0 ; SWIG_check_num_args("ofVec2f::rotateRad",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec2f::rotateRad",1,"ofVec2f *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVec2f::rotateRad",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec2f,0))){
    SWIG_fail_ptr("Vec2f_rotateRad",1,SWIGTYPE_p_ofVec2f); }  arg2 = (float)lua_tonumber(L, 2);
  result = (ofVec2f *) &(arg1)->rotateRad(arg2); SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofVec2f,0); SWIG_arg++; 
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vec2f_rotateRad__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofVec2f *arg1 = (ofVec2f *) 0 ; float arg2 ;
  ofVec2f *arg3 = 0 ; ofVec2f *result = 0 ; SWIG_check_num_args("ofVec2f::rotateRad",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec2f::rotateRad",1,"ofVec2f *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVec2f::rotateRad",2,"float");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofVec2f::rotateRad",3,"ofVec2f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec2f,0))){
    SWIG_fail_ptr("Vec2f_rotateRad",1,SWIGTYPE_p_ofVec2f); }  arg2 = (float)lua_tonumber(L, 2);
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_ofVec2f,0))){
    SWIG_fail_ptr("Vec2f_rotateRad",3,SWIGTYPE_p_ofVec2f); } 
  result = (ofVec2f *) &(arg1)->rotateRad(arg2,(ofVec2f const &)*arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofVec2f,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Vec2f_rotateRad(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec2f, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { return _wrap_Vec2f_rotateRad__SWIG_0(L);}  }  } 
  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec2f, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_ofVec2f, 0)) { _v = 0; }
           else { _v = 1; }  }  if (_v) { return _wrap_Vec2f_rotateRad__SWIG_1(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Vec2f_rotateRad'\n" "  Possible C/C++ prototypes are:\n"
  "    ofVec2f::rotateRad(float)\n" "    ofVec2f::rotateRad(float,ofVec2f const &)\n"); lua_error(L);return 0; }
static int _wrap_Vec2f_getMapped(lua_State* L) { int SWIG_arg = 0; ofVec2f *arg1 = (ofVec2f *) 0 ; ofVec2f *arg2 = 0 ;
  ofVec2f *arg3 = 0 ; ofVec2f *arg4 = 0 ; ofVec2f result; SWIG_check_num_args("ofVec2f::getMapped",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec2f::getMapped",1,"ofVec2f const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVec2f::getMapped",2,"ofVec2f const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofVec2f::getMapped",3,"ofVec2f const &");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("ofVec2f::getMapped",4,"ofVec2f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec2f,0))){
    SWIG_fail_ptr("Vec2f_getMapped",1,SWIGTYPE_p_ofVec2f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec2f,0))){
    SWIG_fail_ptr("Vec2f_getMapped",2,SWIGTYPE_p_ofVec2f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_ofVec2f,0))){
    SWIG_fail_ptr("Vec2f_getMapped",3,SWIGTYPE_p_ofVec2f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_ofVec2f,0))){
    SWIG_fail_ptr("Vec2f_getMapped",4,SWIGTYPE_p_ofVec2f); } 
  result = ((ofVec2f const *)arg1)->getMapped((ofVec2f const &)*arg2,(ofVec2f const &)*arg3,(ofVec2f const &)*arg4); {
    ofVec2f * resultptr = new ofVec2f((const ofVec2f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec2f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vec2f_map(lua_State* L) { int SWIG_arg = 0; ofVec2f *arg1 = (ofVec2f *) 0 ; ofVec2f *arg2 = 0 ;
  ofVec2f *arg3 = 0 ; ofVec2f *arg4 = 0 ; ofVec2f *result = 0 ; SWIG_check_num_args("ofVec2f::map",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec2f::map",1,"ofVec2f *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVec2f::map",2,"ofVec2f const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofVec2f::map",3,"ofVec2f const &");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("ofVec2f::map",4,"ofVec2f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec2f,0))){ SWIG_fail_ptr("Vec2f_map",1,SWIGTYPE_p_ofVec2f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec2f,0))){ SWIG_fail_ptr("Vec2f_map",2,SWIGTYPE_p_ofVec2f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_ofVec2f,0))){ SWIG_fail_ptr("Vec2f_map",3,SWIGTYPE_p_ofVec2f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_ofVec2f,0))){ SWIG_fail_ptr("Vec2f_map",4,SWIGTYPE_p_ofVec2f); } 
  result = (ofVec2f *) &(arg1)->map((ofVec2f const &)*arg2,(ofVec2f const &)*arg3,(ofVec2f const &)*arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofVec2f,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Vec2f_distance(lua_State* L) { int SWIG_arg = 0; ofVec2f *arg1 = (ofVec2f *) 0 ; ofVec2f *arg2 = 0 ;
  float result; SWIG_check_num_args("ofVec2f::distance",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec2f::distance",1,"ofVec2f const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVec2f::distance",2,"ofVec2f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec2f,0))){
    SWIG_fail_ptr("Vec2f_distance",1,SWIGTYPE_p_ofVec2f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec2f,0))){
    SWIG_fail_ptr("Vec2f_distance",2,SWIGTYPE_p_ofVec2f); } 
  result = (float)((ofVec2f const *)arg1)->distance((ofVec2f const &)*arg2); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vec2f_squareDistance(lua_State* L) { int SWIG_arg = 0; ofVec2f *arg1 = (ofVec2f *) 0 ; ofVec2f *arg2 = 0 ;
  float result; SWIG_check_num_args("ofVec2f::squareDistance",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec2f::squareDistance",1,"ofVec2f const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVec2f::squareDistance",2,"ofVec2f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec2f,0))){
    SWIG_fail_ptr("Vec2f_squareDistance",1,SWIGTYPE_p_ofVec2f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec2f,0))){
    SWIG_fail_ptr("Vec2f_squareDistance",2,SWIGTYPE_p_ofVec2f); } 
  result = (float)((ofVec2f const *)arg1)->squareDistance((ofVec2f const &)*arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vec2f_getInterpolated(lua_State* L) { int SWIG_arg = 0; ofVec2f *arg1 = (ofVec2f *) 0 ; ofVec2f *arg2 = 0 ;
  float arg3 ; ofVec2f result; SWIG_check_num_args("ofVec2f::getInterpolated",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec2f::getInterpolated",1,"ofVec2f const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVec2f::getInterpolated",2,"ofVec2f const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVec2f::getInterpolated",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec2f,0))){
    SWIG_fail_ptr("Vec2f_getInterpolated",1,SWIGTYPE_p_ofVec2f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec2f,0))){
    SWIG_fail_ptr("Vec2f_getInterpolated",2,SWIGTYPE_p_ofVec2f); }  arg3 = (float)lua_tonumber(L, 3);
  result = ((ofVec2f const *)arg1)->getInterpolated((ofVec2f const &)*arg2,arg3); {
    ofVec2f * resultptr = new ofVec2f((const ofVec2f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec2f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vec2f_interpolate(lua_State* L) { int SWIG_arg = 0; ofVec2f *arg1 = (ofVec2f *) 0 ; ofVec2f *arg2 = 0 ;
  float arg3 ; ofVec2f *result = 0 ; SWIG_check_num_args("ofVec2f::interpolate",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec2f::interpolate",1,"ofVec2f *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVec2f::interpolate",2,"ofVec2f const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVec2f::interpolate",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec2f,0))){
    SWIG_fail_ptr("Vec2f_interpolate",1,SWIGTYPE_p_ofVec2f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec2f,0))){
    SWIG_fail_ptr("Vec2f_interpolate",2,SWIGTYPE_p_ofVec2f); }  arg3 = (float)lua_tonumber(L, 3);
  result = (ofVec2f *) &(arg1)->interpolate((ofVec2f const &)*arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofVec2f,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Vec2f_getMiddle(lua_State* L) { int SWIG_arg = 0; ofVec2f *arg1 = (ofVec2f *) 0 ; ofVec2f *arg2 = 0 ;
  ofVec2f result; SWIG_check_num_args("ofVec2f::getMiddle",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec2f::getMiddle",1,"ofVec2f const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVec2f::getMiddle",2,"ofVec2f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec2f,0))){
    SWIG_fail_ptr("Vec2f_getMiddle",1,SWIGTYPE_p_ofVec2f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec2f,0))){
    SWIG_fail_ptr("Vec2f_getMiddle",2,SWIGTYPE_p_ofVec2f); } 
  result = ((ofVec2f const *)arg1)->getMiddle((ofVec2f const &)*arg2); {
    ofVec2f * resultptr = new ofVec2f((const ofVec2f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec2f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vec2f_middle(lua_State* L) { int SWIG_arg = 0; ofVec2f *arg1 = (ofVec2f *) 0 ; ofVec2f *arg2 = 0 ;
  ofVec2f *result = 0 ; SWIG_check_num_args("ofVec2f::middle",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec2f::middle",1,"ofVec2f *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVec2f::middle",2,"ofVec2f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec2f,0))){ SWIG_fail_ptr("Vec2f_middle",1,SWIGTYPE_p_ofVec2f); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec2f,0))){
    SWIG_fail_ptr("Vec2f_middle",2,SWIGTYPE_p_ofVec2f); }  result = (ofVec2f *) &(arg1)->middle((ofVec2f const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofVec2f,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Vec2f_average(lua_State* L) { int SWIG_arg = 0; ofVec2f *arg1 = (ofVec2f *) 0 ; ofVec2f *arg2 = (ofVec2f *) 0 ;
  std::size_t arg3 ; ofVec2f *result = 0 ; SWIG_check_num_args("ofVec2f::average",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec2f::average",1,"ofVec2f *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofVec2f::average",2,"ofVec2f const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVec2f::average",3,"std::size_t");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec2f,0))){
    SWIG_fail_ptr("Vec2f_average",1,SWIGTYPE_p_ofVec2f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec2f,0))){
    SWIG_fail_ptr("Vec2f_average",2,SWIGTYPE_p_ofVec2f); } 
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (std::size_t)lua_tonumber(L, 3);
  result = (ofVec2f *) &(arg1)->average((ofVec2f const *)arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofVec2f,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Vec2f_getNormalized(lua_State* L) { int SWIG_arg = 0; ofVec2f *arg1 = (ofVec2f *) 0 ; ofVec2f result;
  SWIG_check_num_args("ofVec2f::getNormalized",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec2f::getNormalized",1,"ofVec2f const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec2f,0))){
    SWIG_fail_ptr("Vec2f_getNormalized",1,SWIGTYPE_p_ofVec2f); }  result = ((ofVec2f const *)arg1)->getNormalized(); {
    ofVec2f * resultptr = new ofVec2f((const ofVec2f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec2f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vec2f_normalize(lua_State* L) { int SWIG_arg = 0; ofVec2f *arg1 = (ofVec2f *) 0 ; ofVec2f *result = 0 ;
  SWIG_check_num_args("ofVec2f::normalize",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec2f::normalize",1,"ofVec2f *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec2f,0))){
    SWIG_fail_ptr("Vec2f_normalize",1,SWIGTYPE_p_ofVec2f); }  result = (ofVec2f *) &(arg1)->normalize();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofVec2f,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Vec2f_getLimited(lua_State* L) { int SWIG_arg = 0; ofVec2f *arg1 = (ofVec2f *) 0 ; float arg2 ; ofVec2f result;
  SWIG_check_num_args("ofVec2f::getLimited",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec2f::getLimited",1,"ofVec2f const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVec2f::getLimited",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec2f,0))){
    SWIG_fail_ptr("Vec2f_getLimited",1,SWIGTYPE_p_ofVec2f); }  arg2 = (float)lua_tonumber(L, 2);
  result = ((ofVec2f const *)arg1)->getLimited(arg2); { ofVec2f * resultptr = new ofVec2f((const ofVec2f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec2f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vec2f_limit(lua_State* L) { int SWIG_arg = 0; ofVec2f *arg1 = (ofVec2f *) 0 ; float arg2 ;
  ofVec2f *result = 0 ; SWIG_check_num_args("ofVec2f::limit",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec2f::limit",1,"ofVec2f *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVec2f::limit",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec2f,0))){ SWIG_fail_ptr("Vec2f_limit",1,SWIGTYPE_p_ofVec2f); }
   arg2 = (float)lua_tonumber(L, 2); result = (ofVec2f *) &(arg1)->limit(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofVec2f,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Vec2f_length(lua_State* L) { int SWIG_arg = 0; ofVec2f *arg1 = (ofVec2f *) 0 ; float result;
  SWIG_check_num_args("ofVec2f::length",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec2f::length",1,"ofVec2f const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec2f,0))){ SWIG_fail_ptr("Vec2f_length",1,SWIGTYPE_p_ofVec2f); }
   result = (float)((ofVec2f const *)arg1)->length(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vec2f_lengthSquared(lua_State* L) { int SWIG_arg = 0; ofVec2f *arg1 = (ofVec2f *) 0 ; float result;
  SWIG_check_num_args("ofVec2f::lengthSquared",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec2f::lengthSquared",1,"ofVec2f const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec2f,0))){
    SWIG_fail_ptr("Vec2f_lengthSquared",1,SWIGTYPE_p_ofVec2f); }  result = (float)((ofVec2f const *)arg1)->lengthSquared();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vec2f_angle(lua_State* L) { int SWIG_arg = 0; ofVec2f *arg1 = (ofVec2f *) 0 ; ofVec2f *arg2 = 0 ; float result;
  SWIG_check_num_args("ofVec2f::angle",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec2f::angle",1,"ofVec2f const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVec2f::angle",2,"ofVec2f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec2f,0))){ SWIG_fail_ptr("Vec2f_angle",1,SWIGTYPE_p_ofVec2f); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec2f,0))){ SWIG_fail_ptr("Vec2f_angle",2,SWIGTYPE_p_ofVec2f); }
   result = (float)((ofVec2f const *)arg1)->angle((ofVec2f const &)*arg2); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vec2f_angleRad(lua_State* L) { int SWIG_arg = 0; ofVec2f *arg1 = (ofVec2f *) 0 ; ofVec2f *arg2 = 0 ;
  float result; SWIG_check_num_args("ofVec2f::angleRad",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec2f::angleRad",1,"ofVec2f const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVec2f::angleRad",2,"ofVec2f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec2f,0))){
    SWIG_fail_ptr("Vec2f_angleRad",1,SWIGTYPE_p_ofVec2f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec2f,0))){
    SWIG_fail_ptr("Vec2f_angleRad",2,SWIGTYPE_p_ofVec2f); } 
  result = (float)((ofVec2f const *)arg1)->angleRad((ofVec2f const &)*arg2); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vec2f_getPerpendicular(lua_State* L) { int SWIG_arg = 0; ofVec2f *arg1 = (ofVec2f *) 0 ; ofVec2f result;
  SWIG_check_num_args("ofVec2f::getPerpendicular",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec2f::getPerpendicular",1,"ofVec2f const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec2f,0))){
    SWIG_fail_ptr("Vec2f_getPerpendicular",1,SWIGTYPE_p_ofVec2f); }  result = ((ofVec2f const *)arg1)->getPerpendicular(); {
    ofVec2f * resultptr = new ofVec2f((const ofVec2f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec2f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vec2f_perpendicular(lua_State* L) { int SWIG_arg = 0; ofVec2f *arg1 = (ofVec2f *) 0 ; ofVec2f *result = 0 ;
  SWIG_check_num_args("ofVec2f::perpendicular",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec2f::perpendicular",1,"ofVec2f *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec2f,0))){
    SWIG_fail_ptr("Vec2f_perpendicular",1,SWIGTYPE_p_ofVec2f); }  result = (ofVec2f *) &(arg1)->perpendicular();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofVec2f,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Vec2f_dot(lua_State* L) { int SWIG_arg = 0; ofVec2f *arg1 = (ofVec2f *) 0 ; ofVec2f *arg2 = 0 ; float result;
  SWIG_check_num_args("ofVec2f::dot",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec2f::dot",1,"ofVec2f const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVec2f::dot",2,"ofVec2f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec2f,0))){ SWIG_fail_ptr("Vec2f_dot",1,SWIGTYPE_p_ofVec2f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec2f,0))){ SWIG_fail_ptr("Vec2f_dot",2,SWIGTYPE_p_ofVec2f); } 
  result = (float)((ofVec2f const *)arg1)->dot((ofVec2f const &)*arg2); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vec2f_zero(lua_State* L) { int SWIG_arg = 0; ofVec2f result; SWIG_check_num_args("ofVec2f::zero",0,0)
  result = ofVec2f::zero(); { ofVec2f * resultptr = new ofVec2f((const ofVec2f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec2f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vec2f_one(lua_State* L) { int SWIG_arg = 0; ofVec2f result; SWIG_check_num_args("ofVec2f::one",0,0)
  result = ofVec2f::one(); { ofVec2f * resultptr = new ofVec2f((const ofVec2f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec2f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vec2f___tostring(lua_State* L) { int SWIG_arg = 0; ofVec2f *arg1 = (ofVec2f *) 0 ; char *result = 0 ;
  SWIG_check_num_args("ofVec2f::__str__",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec2f::__str__",1,"ofVec2f *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec2f,0))){
    SWIG_fail_ptr("Vec2f___tostring",1,SWIGTYPE_p_ofVec2f); }  result = (char *)ofVec2f___str__(arg1);
  lua_pushstring(L,(const char *)result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static void swig_delete_Vec2f(void *obj) {
ofVec2f *arg1 = (ofVec2f *) obj;
delete arg1;
}
static int _proxy__wrap_new_Vec2f(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_Vec2f);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_Vec2f_attributes[] = {
    { "x", _wrap_Vec2f_x_get, _wrap_Vec2f_x_set },
    { "y", _wrap_Vec2f_y_get, _wrap_Vec2f_y_set },
    {0,0,0}
};
static swig_lua_method swig_Vec2f_methods[]= {
    { "getPtr", _wrap_Vec2f_getPtr},
    { "set", _wrap_Vec2f_set},
    { "__eq", _wrap_Vec2f___eq},
    { "match", _wrap_Vec2f_match},
    { "isAligned", _wrap_Vec2f_isAligned},
    { "isAlignedRad", _wrap_Vec2f_isAlignedRad},
    { "align", _wrap_Vec2f_align},
    { "alignRad", _wrap_Vec2f_alignRad},
    { "__add", _wrap_Vec2f___add},
    { "__sub", _wrap_Vec2f___sub},
    { "__unm", _wrap_Vec2f___unm},
    { "__mul", _wrap_Vec2f___mul},
    { "__div", _wrap_Vec2f___div},
    { "getScaled", _wrap_Vec2f_getScaled},
    { "scale", _wrap_Vec2f_scale},
    { "getRotated", _wrap_Vec2f_getRotated},
    { "getRotatedRad", _wrap_Vec2f_getRotatedRad},
    { "rotate", _wrap_Vec2f_rotate},
    { "rotateRad", _wrap_Vec2f_rotateRad},
    { "getMapped", _wrap_Vec2f_getMapped},
    { "map", _wrap_Vec2f_map},
    { "distance", _wrap_Vec2f_distance},
    { "squareDistance", _wrap_Vec2f_squareDistance},
    { "getInterpolated", _wrap_Vec2f_getInterpolated},
    { "interpolate", _wrap_Vec2f_interpolate},
    { "getMiddle", _wrap_Vec2f_getMiddle},
    { "middle", _wrap_Vec2f_middle},
    { "average", _wrap_Vec2f_average},
    { "getNormalized", _wrap_Vec2f_getNormalized},
    { "normalize", _wrap_Vec2f_normalize},
    { "getLimited", _wrap_Vec2f_getLimited},
    { "limit", _wrap_Vec2f_limit},
    { "length", _wrap_Vec2f_length},
    { "lengthSquared", _wrap_Vec2f_lengthSquared},
    { "angle", _wrap_Vec2f_angle},
    { "angleRad", _wrap_Vec2f_angleRad},
    { "getPerpendicular", _wrap_Vec2f_getPerpendicular},
    { "perpendicular", _wrap_Vec2f_perpendicular},
    { "dot", _wrap_Vec2f_dot},
    { "__tostring", _wrap_Vec2f___tostring},
    {0,0}
};
static swig_lua_method swig_Vec2f_meta[] = {
    { "__eq", _wrap_Vec2f___eq},
    { "__add", _wrap_Vec2f___add},
    { "__sub", _wrap_Vec2f___sub},
    { "__unm", _wrap_Vec2f___unm},
    { "__mul", _wrap_Vec2f___mul},
    { "__div", _wrap_Vec2f___div},
    { "__tostring", _wrap_Vec2f___tostring},
    {0,0}
};

static swig_lua_attribute swig_Vec2f_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_Vec2f_Sf_SwigStatic_constants[]= {
    {SWIG_LUA_CONSTTAB_INT("DIM", ofVec2f::DIM)},
    {0,0,0,0,0,0}
};
static swig_lua_method swig_Vec2f_Sf_SwigStatic_methods[]= {
    { "zero", _wrap_Vec2f_zero},
    { "one", _wrap_Vec2f_one},
    {0,0}
};
static swig_lua_class* swig_Vec2f_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_Vec2f_Sf_SwigStatic = {
    "Vec2f",
    swig_Vec2f_Sf_SwigStatic_methods,
    swig_Vec2f_Sf_SwigStatic_attributes,
    swig_Vec2f_Sf_SwigStatic_constants,
    swig_Vec2f_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_Vec2f_bases[] = {0};
static const char *swig_Vec2f_base_names[] = {0};
static swig_lua_class _wrap_class_Vec2f = { "Vec2f", "Vec2f", &SWIGTYPE_p_ofVec2f,_proxy__wrap_new_Vec2f, swig_delete_Vec2f, swig_Vec2f_methods, swig_Vec2f_attributes, &swig_Vec2f_Sf_SwigStatic, swig_Vec2f_meta, swig_Vec2f_bases, swig_Vec2f_base_names };

static int _wrap_Vec3f_x_set(lua_State* L) { int SWIG_arg = 0; ofVec3f *arg1 = (ofVec3f *) 0 ; float arg2 ;
  SWIG_check_num_args("ofVec3f::x",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec3f::x",1,"ofVec3f *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVec3f::x",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec3f,0))){ SWIG_fail_ptr("Vec3f_x_set",1,SWIGTYPE_p_ofVec3f); }
   arg2 = (float)lua_tonumber(L, 2); if (arg1) (arg1)->x = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Vec3f_x_get(lua_State* L) { int SWIG_arg = 0; ofVec3f *arg1 = (ofVec3f *) 0 ; float result;
  SWIG_check_num_args("ofVec3f::x",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec3f::x",1,"ofVec3f *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec3f,0))){ SWIG_fail_ptr("Vec3f_x_get",1,SWIGTYPE_p_ofVec3f); }
   result = (float) ((arg1)->x); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vec3f_y_set(lua_State* L) { int SWIG_arg = 0; ofVec3f *arg1 = (ofVec3f *) 0 ; float arg2 ;
  SWIG_check_num_args("ofVec3f::y",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec3f::y",1,"ofVec3f *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVec3f::y",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec3f,0))){ SWIG_fail_ptr("Vec3f_y_set",1,SWIGTYPE_p_ofVec3f); }
   arg2 = (float)lua_tonumber(L, 2); if (arg1) (arg1)->y = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Vec3f_y_get(lua_State* L) { int SWIG_arg = 0; ofVec3f *arg1 = (ofVec3f *) 0 ; float result;
  SWIG_check_num_args("ofVec3f::y",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec3f::y",1,"ofVec3f *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec3f,0))){ SWIG_fail_ptr("Vec3f_y_get",1,SWIGTYPE_p_ofVec3f); }
   result = (float) ((arg1)->y); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vec3f_z_set(lua_State* L) { int SWIG_arg = 0; ofVec3f *arg1 = (ofVec3f *) 0 ; float arg2 ;
  SWIG_check_num_args("ofVec3f::z",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec3f::z",1,"ofVec3f *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVec3f::z",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec3f,0))){ SWIG_fail_ptr("Vec3f_z_set",1,SWIGTYPE_p_ofVec3f); }
   arg2 = (float)lua_tonumber(L, 2); if (arg1) (arg1)->z = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Vec3f_z_get(lua_State* L) { int SWIG_arg = 0; ofVec3f *arg1 = (ofVec3f *) 0 ; float result;
  SWIG_check_num_args("ofVec3f::z",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec3f::z",1,"ofVec3f *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec3f,0))){ SWIG_fail_ptr("Vec3f_z_get",1,SWIGTYPE_p_ofVec3f); }
   result = (float) ((arg1)->z); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_Vec3f__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofVec3f *result = 0 ;
  SWIG_check_num_args("ofVec3f::ofVec3f",0,0) result = (ofVec3f *)new ofVec3f();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofVec3f,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_Vec3f__SWIG_1(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ;
  ofVec3f *result = 0 ; SWIG_check_num_args("ofVec3f::ofVec3f",3,3)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofVec3f::ofVec3f",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVec3f::ofVec3f",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVec3f::ofVec3f",3,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); result = (ofVec3f *)new ofVec3f(arg1,arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofVec3f,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_Vec3f__SWIG_2(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; ofVec3f *result = 0 ;
  SWIG_check_num_args("ofVec3f::ofVec3f",2,2) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofVec3f::ofVec3f",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVec3f::ofVec3f",2,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); result = (ofVec3f *)new ofVec3f(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofVec3f,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_Vec3f__SWIG_3(lua_State* L) { int SWIG_arg = 0; float arg1 ; ofVec3f *result = 0 ;
  SWIG_check_num_args("ofVec3f::ofVec3f",1,1) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofVec3f::ofVec3f",1,"float");
  arg1 = (float)lua_tonumber(L, 1); result = (ofVec3f *)new ofVec3f(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofVec3f,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_Vec3f__SWIG_4(lua_State* L) { int SWIG_arg = 0; ofVec2f *arg1 = 0 ; ofVec3f *result = 0 ;
  SWIG_check_num_args("ofVec3f::ofVec3f",1,1) if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofVec3f::ofVec3f",1,"ofVec2f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec2f,0))){ SWIG_fail_ptr("new_Vec3f",1,SWIGTYPE_p_ofVec2f); } 
  result = (ofVec3f *)new ofVec3f((ofVec2f const &)*arg1); SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofVec3f,1); SWIG_arg++; 
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_new_Vec3f__SWIG_5(lua_State* L) { int SWIG_arg = 0; ofVec4f *arg1 = 0 ; ofVec3f *result = 0 ;
  SWIG_check_num_args("ofVec3f::ofVec3f",1,1) if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofVec3f::ofVec3f",1,"ofVec4f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec4f,0))){ SWIG_fail_ptr("new_Vec3f",1,SWIGTYPE_p_ofVec4f); } 
  result = (ofVec3f *)new ofVec3f((ofVec4f const &)*arg1); SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofVec3f,1); SWIG_arg++; 
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_new_Vec3f__SWIG_6(lua_State* L) { int SWIG_arg = 0; glm::vec2 *arg1 = 0 ; ofVec3f *result = 0 ;
  SWIG_check_num_args("ofVec3f::ofVec3f",1,1) if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofVec3f::ofVec3f",1,"glm::vec2 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glm__vec2,0))){
    SWIG_fail_ptr("new_Vec3f",1,SWIGTYPE_p_glm__vec2); }  result = (ofVec3f *)new ofVec3f((glm::vec2 const &)*arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofVec3f,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_Vec3f__SWIG_7(lua_State* L) { int SWIG_arg = 0; glm::vec3 *arg1 = 0 ; ofVec3f *result = 0 ;
  SWIG_check_num_args("ofVec3f::ofVec3f",1,1) if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofVec3f::ofVec3f",1,"glm::vec3 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("new_Vec3f",1,SWIGTYPE_p_glm__vec3); }  result = (ofVec3f *)new ofVec3f((glm::vec3 const &)*arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofVec3f,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_Vec3f__SWIG_8(lua_State* L) { int SWIG_arg = 0; glm::vec4 *arg1 = 0 ; ofVec3f *result = 0 ;
  SWIG_check_num_args("ofVec3f::ofVec3f",1,1) if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofVec3f::ofVec3f",1,"glm::vec4 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glm__vec4,0))){
    SWIG_fail_ptr("new_Vec3f",1,SWIGTYPE_p_glm__vec4); }  result = (ofVec3f *)new ofVec3f((glm::vec4 const &)*arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofVec3f,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_Vec3f(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 0) {
    return _wrap_new_Vec3f__SWIG_0(L);}  if (argc == 1) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec2f, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { return _wrap_new_Vec3f__SWIG_4(L);}  }  if (argc == 1) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec4f, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { return _wrap_new_Vec3f__SWIG_5(L);}  }  if (argc == 1) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_glm__vec2, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { return _wrap_new_Vec3f__SWIG_6(L);}  }  if (argc == 1) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { return _wrap_new_Vec3f__SWIG_7(L);}  }  if (argc == 1) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_glm__vec4, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { return _wrap_new_Vec3f__SWIG_8(L);}  }  if (argc == 1) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { return _wrap_new_Vec3f__SWIG_3(L);}  }  if (argc == 2) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { return _wrap_new_Vec3f__SWIG_2(L);}
       }  }  if (argc == 3) { int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        { _v = lua_isnumber(L,argv[2]); }  if (_v) { return _wrap_new_Vec3f__SWIG_1(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_Vec3f'\n" "  Possible C/C++ prototypes are:\n"
  "    ofVec3f::ofVec3f()\n" "    ofVec3f::ofVec3f(float,float,float)\n" "    ofVec3f::ofVec3f(float,float)\n"
  "    ofVec3f::ofVec3f(float)\n" "    ofVec3f::ofVec3f(ofVec2f const &)\n" "    ofVec3f::ofVec3f(ofVec4f const &)\n"
  "    ofVec3f::ofVec3f(glm::vec2 const &)\n" "    ofVec3f::ofVec3f(glm::vec3 const &)\n"
  "    ofVec3f::ofVec3f(glm::vec4 const &)\n"); lua_error(L);return 0; }
static int _wrap_Vec3f_getPtr__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofVec3f *arg1 = (ofVec3f *) 0 ; float *result = 0 ;
  SWIG_check_num_args("ofVec3f::getPtr",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec3f::getPtr",1,"ofVec3f *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec3f,0))){ SWIG_fail_ptr("Vec3f_getPtr",1,SWIGTYPE_p_ofVec3f); }
   result = (float *)(arg1)->getPtr(); SWIG_NewPointerObj(L,result,SWIGTYPE_p_float,0); SWIG_arg++;  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vec3f_getPtr__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofVec3f *arg1 = (ofVec3f *) 0 ; float *result = 0 ;
  SWIG_check_num_args("ofVec3f::getPtr",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec3f::getPtr",1,"ofVec3f const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec3f,0))){ SWIG_fail_ptr("Vec3f_getPtr",1,SWIGTYPE_p_ofVec3f); }
   result = (float *)((ofVec3f const *)arg1)->getPtr(); SWIG_NewPointerObj(L,result,SWIGTYPE_p_float,0); SWIG_arg++; 
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vec3f_getPtr(lua_State* L) { int argc; int argv[2]={ 1,2} ; argc = lua_gettop(L); if (argc == 1) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Vec3f_getPtr__SWIG_0(L);}  }  if (argc == 1) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Vec3f_getPtr__SWIG_1(L);}  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Vec3f_getPtr'\n" "  Possible C/C++ prototypes are:\n"
  "    ofVec3f::getPtr()\n" "    ofVec3f::getPtr() const\n"); lua_error(L);return 0; }
static int _wrap_Vec3f_set__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofVec3f *arg1 = (ofVec3f *) 0 ; float arg2 ; float arg3 ;
  float arg4 ; SWIG_check_num_args("ofVec3f::set",4,4) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec3f::set",1,"ofVec3f *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVec3f::set",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVec3f::set",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofVec3f::set",4,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec3f,0))){ SWIG_fail_ptr("Vec3f_set",1,SWIGTYPE_p_ofVec3f); } 
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  (arg1)->set(arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vec3f_set__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofVec3f *arg1 = (ofVec3f *) 0 ; float arg2 ; float arg3 ;
  SWIG_check_num_args("ofVec3f::set",3,3) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec3f::set",1,"ofVec3f *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVec3f::set",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVec3f::set",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec3f,0))){ SWIG_fail_ptr("Vec3f_set",1,SWIGTYPE_p_ofVec3f); } 
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); (arg1)->set(arg2,arg3); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vec3f_set__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofVec3f *arg1 = (ofVec3f *) 0 ; ofVec3f *arg2 = 0 ;
  SWIG_check_num_args("ofVec3f::set",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec3f::set",1,"ofVec3f *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVec3f::set",2,"ofVec3f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec3f,0))){ SWIG_fail_ptr("Vec3f_set",1,SWIGTYPE_p_ofVec3f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec3f,0))){ SWIG_fail_ptr("Vec3f_set",2,SWIGTYPE_p_ofVec3f); } 
  (arg1)->set((ofVec3f const &)*arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vec3f_set__SWIG_3(lua_State* L) { int SWIG_arg = 0; ofVec3f *arg1 = (ofVec3f *) 0 ; float arg2 ;
  SWIG_check_num_args("ofVec3f::set",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec3f::set",1,"ofVec3f *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVec3f::set",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec3f,0))){ SWIG_fail_ptr("Vec3f_set",1,SWIGTYPE_p_ofVec3f); } 
  arg2 = (float)lua_tonumber(L, 2); (arg1)->set(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vec3f_set(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L); if (argc == 2) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Vec3f_set__SWIG_2(L);}  }  }  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { return _wrap_Vec3f_set__SWIG_3(L);}  }  } 
  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_Vec3f_set__SWIG_1(L);}  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { {
            _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_Vec3f_set__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Vec3f_set'\n" "  Possible C/C++ prototypes are:\n"
  "    ofVec3f::set(float,float,float)\n" "    ofVec3f::set(float,float)\n" "    ofVec3f::set(ofVec3f const &)\n"
  "    ofVec3f::set(float)\n"); lua_error(L);return 0; }
static int _wrap_Vec3f___eq(lua_State* L) { int SWIG_arg = 0; ofVec3f *arg1 = (ofVec3f *) 0 ; ofVec3f *arg2 = 0 ; bool result;
  SWIG_check_num_args("ofVec3f::operator ==",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec3f::operator ==",1,"ofVec3f const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVec3f::operator ==",2,"ofVec3f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec3f,0))){ SWIG_fail_ptr("Vec3f___eq",1,SWIGTYPE_p_ofVec3f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec3f,0))){ SWIG_fail_ptr("Vec3f___eq",2,SWIGTYPE_p_ofVec3f); } 
  result = (bool)((ofVec3f const *)arg1)->operator ==((ofVec3f const &)*arg2); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vec3f_match__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofVec3f *arg1 = (ofVec3f *) 0 ; ofVec3f *arg2 = 0 ;
  float arg3 ; bool result; SWIG_check_num_args("ofVec3f::match",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec3f::match",1,"ofVec3f const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVec3f::match",2,"ofVec3f const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVec3f::match",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec3f,0))){ SWIG_fail_ptr("Vec3f_match",1,SWIGTYPE_p_ofVec3f); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec3f,0))){ SWIG_fail_ptr("Vec3f_match",2,SWIGTYPE_p_ofVec3f); }
   arg3 = (float)lua_tonumber(L, 3); result = (bool)((ofVec3f const *)arg1)->match((ofVec3f const &)*arg2,arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vec3f_match__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofVec3f *arg1 = (ofVec3f *) 0 ; ofVec3f *arg2 = 0 ;
  bool result; SWIG_check_num_args("ofVec3f::match",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec3f::match",1,"ofVec3f const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVec3f::match",2,"ofVec3f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec3f,0))){ SWIG_fail_ptr("Vec3f_match",1,SWIGTYPE_p_ofVec3f); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec3f,0))){ SWIG_fail_ptr("Vec3f_match",2,SWIGTYPE_p_ofVec3f); }
   result = (bool)((ofVec3f const *)arg1)->match((ofVec3f const &)*arg2); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vec3f_match(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 2) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Vec3f_match__SWIG_1(L);}  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { return _wrap_Vec3f_match__SWIG_0(L);}  }  }
     }  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Vec3f_match'\n" "  Possible C/C++ prototypes are:\n"
  "    ofVec3f::match(ofVec3f const &,float) const\n" "    ofVec3f::match(ofVec3f const &) const\n"); lua_error(L);return 0; }
static int _wrap_Vec3f_isAligned__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofVec3f *arg1 = (ofVec3f *) 0 ; ofVec3f *arg2 = 0 ;
  float arg3 ; bool result; SWIG_check_num_args("ofVec3f::isAligned",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec3f::isAligned",1,"ofVec3f const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVec3f::isAligned",2,"ofVec3f const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVec3f::isAligned",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Vec3f_isAligned",1,SWIGTYPE_p_ofVec3f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Vec3f_isAligned",2,SWIGTYPE_p_ofVec3f); }  arg3 = (float)lua_tonumber(L, 3);
  result = (bool)((ofVec3f const *)arg1)->isAligned((ofVec3f const &)*arg2,arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vec3f_isAligned__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofVec3f *arg1 = (ofVec3f *) 0 ; ofVec3f *arg2 = 0 ;
  bool result; SWIG_check_num_args("ofVec3f::isAligned",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec3f::isAligned",1,"ofVec3f const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVec3f::isAligned",2,"ofVec3f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Vec3f_isAligned",1,SWIGTYPE_p_ofVec3f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Vec3f_isAligned",2,SWIGTYPE_p_ofVec3f); } 
  result = (bool)((ofVec3f const *)arg1)->isAligned((ofVec3f const &)*arg2); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vec3f_isAligned(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Vec3f_isAligned__SWIG_1(L);}  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { return _wrap_Vec3f_isAligned__SWIG_0(L);}  }
       }  }  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Vec3f_isAligned'\n"
  "  Possible C/C++ prototypes are:\n" "    ofVec3f::isAligned(ofVec3f const &,float) const\n"
  "    ofVec3f::isAligned(ofVec3f const &) const\n"); lua_error(L);return 0; }
static int _wrap_Vec3f_isAlignedRad__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofVec3f *arg1 = (ofVec3f *) 0 ;
  ofVec3f *arg2 = 0 ; float arg3 ; bool result; SWIG_check_num_args("ofVec3f::isAlignedRad",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec3f::isAlignedRad",1,"ofVec3f const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVec3f::isAlignedRad",2,"ofVec3f const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVec3f::isAlignedRad",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Vec3f_isAlignedRad",1,SWIGTYPE_p_ofVec3f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Vec3f_isAlignedRad",2,SWIGTYPE_p_ofVec3f); }  arg3 = (float)lua_tonumber(L, 3);
  result = (bool)((ofVec3f const *)arg1)->isAlignedRad((ofVec3f const &)*arg2,arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vec3f_isAlignedRad__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofVec3f *arg1 = (ofVec3f *) 0 ;
  ofVec3f *arg2 = 0 ; bool result; SWIG_check_num_args("ofVec3f::isAlignedRad",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec3f::isAlignedRad",1,"ofVec3f const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVec3f::isAlignedRad",2,"ofVec3f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Vec3f_isAlignedRad",1,SWIGTYPE_p_ofVec3f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Vec3f_isAlignedRad",2,SWIGTYPE_p_ofVec3f); } 
  result = (bool)((ofVec3f const *)arg1)->isAlignedRad((ofVec3f const &)*arg2); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vec3f_isAlignedRad(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Vec3f_isAlignedRad__SWIG_1(L);}  }  }  if (argc == 3) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { return _wrap_Vec3f_isAlignedRad__SWIG_0(L);}
         }  }  }  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Vec3f_isAlignedRad'\n"
  "  Possible C/C++ prototypes are:\n" "    ofVec3f::isAlignedRad(ofVec3f const &,float) const\n"
  "    ofVec3f::isAlignedRad(ofVec3f const &) const\n"); lua_error(L);return 0; }
static int _wrap_Vec3f_align__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofVec3f *arg1 = (ofVec3f *) 0 ; ofVec3f *arg2 = 0 ;
  float arg3 ; bool result; SWIG_check_num_args("ofVec3f::align",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec3f::align",1,"ofVec3f const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVec3f::align",2,"ofVec3f const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVec3f::align",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec3f,0))){ SWIG_fail_ptr("Vec3f_align",1,SWIGTYPE_p_ofVec3f); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec3f,0))){ SWIG_fail_ptr("Vec3f_align",2,SWIGTYPE_p_ofVec3f); }
   arg3 = (float)lua_tonumber(L, 3); result = (bool)((ofVec3f const *)arg1)->align((ofVec3f const &)*arg2,arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vec3f_align__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofVec3f *arg1 = (ofVec3f *) 0 ; ofVec3f *arg2 = 0 ;
  bool result; SWIG_check_num_args("ofVec3f::align",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec3f::align",1,"ofVec3f const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVec3f::align",2,"ofVec3f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec3f,0))){ SWIG_fail_ptr("Vec3f_align",1,SWIGTYPE_p_ofVec3f); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec3f,0))){ SWIG_fail_ptr("Vec3f_align",2,SWIGTYPE_p_ofVec3f); }
   result = (bool)((ofVec3f const *)arg1)->align((ofVec3f const &)*arg2); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vec3f_align(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 2) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Vec3f_align__SWIG_1(L);}  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { return _wrap_Vec3f_align__SWIG_0(L);}  }  }
     }  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Vec3f_align'\n" "  Possible C/C++ prototypes are:\n"
  "    ofVec3f::align(ofVec3f const &,float) const\n" "    ofVec3f::align(ofVec3f const &) const\n"); lua_error(L);return 0; }
static int _wrap_Vec3f_alignRad__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofVec3f *arg1 = (ofVec3f *) 0 ; ofVec3f *arg2 = 0 ;
  float arg3 ; bool result; SWIG_check_num_args("ofVec3f::alignRad",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec3f::alignRad",1,"ofVec3f const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVec3f::alignRad",2,"ofVec3f const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVec3f::alignRad",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Vec3f_alignRad",1,SWIGTYPE_p_ofVec3f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Vec3f_alignRad",2,SWIGTYPE_p_ofVec3f); }  arg3 = (float)lua_tonumber(L, 3);
  result = (bool)((ofVec3f const *)arg1)->alignRad((ofVec3f const &)*arg2,arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vec3f_alignRad__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofVec3f *arg1 = (ofVec3f *) 0 ; ofVec3f *arg2 = 0 ;
  bool result; SWIG_check_num_args("ofVec3f::alignRad",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec3f::alignRad",1,"ofVec3f const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVec3f::alignRad",2,"ofVec3f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Vec3f_alignRad",1,SWIGTYPE_p_ofVec3f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Vec3f_alignRad",2,SWIGTYPE_p_ofVec3f); } 
  result = (bool)((ofVec3f const *)arg1)->alignRad((ofVec3f const &)*arg2); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vec3f_alignRad(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Vec3f_alignRad__SWIG_1(L);}  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { return _wrap_Vec3f_alignRad__SWIG_0(L);}  }
       }  }  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Vec3f_alignRad'\n"
  "  Possible C/C++ prototypes are:\n" "    ofVec3f::alignRad(ofVec3f const &,float) const\n"
  "    ofVec3f::alignRad(ofVec3f const &) const\n"); lua_error(L);return 0; }
static int _wrap_Vec3f___add__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofVec3f *arg1 = (ofVec3f *) 0 ; ofVec3f *arg2 = 0 ;
  ofVec3f result; SWIG_check_num_args("ofVec3f::operator +",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec3f::operator +",1,"ofVec3f const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVec3f::operator +",2,"ofVec3f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec3f,0))){ SWIG_fail_ptr("Vec3f___add",1,SWIGTYPE_p_ofVec3f); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec3f,0))){ SWIG_fail_ptr("Vec3f___add",2,SWIGTYPE_p_ofVec3f); }
   result = ((ofVec3f const *)arg1)->operator +((ofVec3f const &)*arg2); {
    ofVec3f * resultptr = new ofVec3f((const ofVec3f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec3f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vec3f___add__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofVec3f *arg1 = (ofVec3f *) 0 ; float arg2 ;
  ofVec3f result; SWIG_check_num_args("ofVec3f::operator +",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec3f::operator +",1,"ofVec3f const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVec3f::operator +",2,"float const");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec3f,0))){ SWIG_fail_ptr("Vec3f___add",1,SWIGTYPE_p_ofVec3f); }
   arg2 = (float const)lua_tonumber(L, 2); result = ((ofVec3f const *)arg1)->operator +(arg2); {
    ofVec3f * resultptr = new ofVec3f((const ofVec3f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec3f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vec3f___add(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 2) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Vec3f___add__SWIG_0(L);}  }  }  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { return _wrap_Vec3f___add__SWIG_1(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Vec3f___add'\n" "  Possible C/C++ prototypes are:\n"
  "    ofVec3f::operator +(ofVec3f const &) const\n" "    ofVec3f::operator +(float const) const\n"); lua_error(L);return 0; }
static int _wrap_Vec3f___sub__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofVec3f *arg1 = (ofVec3f *) 0 ; ofVec3f *arg2 = 0 ;
  ofVec3f result; SWIG_check_num_args("ofVec3f::operator -",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec3f::operator -",1,"ofVec3f const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVec3f::operator -",2,"ofVec3f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec3f,0))){ SWIG_fail_ptr("Vec3f___sub",1,SWIGTYPE_p_ofVec3f); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec3f,0))){ SWIG_fail_ptr("Vec3f___sub",2,SWIGTYPE_p_ofVec3f); }
   result = ((ofVec3f const *)arg1)->operator -((ofVec3f const &)*arg2); {
    ofVec3f * resultptr = new ofVec3f((const ofVec3f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec3f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vec3f___sub__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofVec3f *arg1 = (ofVec3f *) 0 ; float arg2 ;
  ofVec3f result; SWIG_check_num_args("ofVec3f::operator -",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec3f::operator -",1,"ofVec3f const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVec3f::operator -",2,"float const");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec3f,0))){ SWIG_fail_ptr("Vec3f___sub",1,SWIGTYPE_p_ofVec3f); }
   arg2 = (float const)lua_tonumber(L, 2); result = ((ofVec3f const *)arg1)->operator -(arg2); {
    ofVec3f * resultptr = new ofVec3f((const ofVec3f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec3f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vec3f___sub(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 2) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Vec3f___sub__SWIG_0(L);}  }  }  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { return _wrap_Vec3f___sub__SWIG_1(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Vec3f___sub'\n" "  Possible C/C++ prototypes are:\n"
  "    ofVec3f::operator -(ofVec3f const &) const\n" "    ofVec3f::operator -(float const) const\n"); lua_error(L);return 0; }
static int _wrap_Vec3f___unm(lua_State* L) { int SWIG_arg = 0; ofVec3f *arg1 = (ofVec3f *) 0 ; ofVec3f result;
  SWIG_check_num_args("ofVec3f::operator -",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec3f::operator -",1,"ofVec3f const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec3f,0))){ SWIG_fail_ptr("Vec3f___unm",1,SWIGTYPE_p_ofVec3f); }
   result = ((ofVec3f const *)arg1)->operator -(); { ofVec3f * resultptr = new ofVec3f((const ofVec3f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec3f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vec3f___mul__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofVec3f *arg1 = (ofVec3f *) 0 ; ofVec3f *arg2 = 0 ;
  ofVec3f result; SWIG_check_num_args("ofVec3f::operator *",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec3f::operator *",1,"ofVec3f const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVec3f::operator *",2,"ofVec3f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec3f,0))){ SWIG_fail_ptr("Vec3f___mul",1,SWIGTYPE_p_ofVec3f); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec3f,0))){ SWIG_fail_ptr("Vec3f___mul",2,SWIGTYPE_p_ofVec3f); }
   result = ((ofVec3f const *)arg1)->operator *((ofVec3f const &)*arg2); {
    ofVec3f * resultptr = new ofVec3f((const ofVec3f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec3f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vec3f___mul__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofVec3f *arg1 = (ofVec3f *) 0 ; float arg2 ;
  ofVec3f result; SWIG_check_num_args("ofVec3f::operator *",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec3f::operator *",1,"ofVec3f const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVec3f::operator *",2,"float const");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec3f,0))){ SWIG_fail_ptr("Vec3f___mul",1,SWIGTYPE_p_ofVec3f); }
   arg2 = (float const)lua_tonumber(L, 2); result = ((ofVec3f const *)arg1)->operator *(arg2); {
    ofVec3f * resultptr = new ofVec3f((const ofVec3f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec3f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vec3f___mul(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 2) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Vec3f___mul__SWIG_0(L);}  }  }  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { return _wrap_Vec3f___mul__SWIG_1(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Vec3f___mul'\n" "  Possible C/C++ prototypes are:\n"
  "    ofVec3f::operator *(ofVec3f const &) const\n" "    ofVec3f::operator *(float const) const\n"); lua_error(L);return 0; }
static int _wrap_Vec3f___div__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofVec3f *arg1 = (ofVec3f *) 0 ; ofVec3f *arg2 = 0 ;
  ofVec3f result; SWIG_check_num_args("ofVec3f::operator /",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec3f::operator /",1,"ofVec3f const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVec3f::operator /",2,"ofVec3f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec3f,0))){ SWIG_fail_ptr("Vec3f___div",1,SWIGTYPE_p_ofVec3f); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec3f,0))){ SWIG_fail_ptr("Vec3f___div",2,SWIGTYPE_p_ofVec3f); }
   result = ((ofVec3f const *)arg1)->operator /((ofVec3f const &)*arg2); {
    ofVec3f * resultptr = new ofVec3f((const ofVec3f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec3f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vec3f___div__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofVec3f *arg1 = (ofVec3f *) 0 ; float arg2 ;
  ofVec3f result; SWIG_check_num_args("ofVec3f::operator /",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec3f::operator /",1,"ofVec3f const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVec3f::operator /",2,"float const");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec3f,0))){ SWIG_fail_ptr("Vec3f___div",1,SWIGTYPE_p_ofVec3f); }
   arg2 = (float const)lua_tonumber(L, 2); result = ((ofVec3f const *)arg1)->operator /(arg2); {
    ofVec3f * resultptr = new ofVec3f((const ofVec3f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec3f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vec3f___div(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 2) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Vec3f___div__SWIG_0(L);}  }  }  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { return _wrap_Vec3f___div__SWIG_1(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Vec3f___div'\n" "  Possible C/C++ prototypes are:\n"
  "    ofVec3f::operator /(ofVec3f const &) const\n" "    ofVec3f::operator /(float const) const\n"); lua_error(L);return 0; }
static int _wrap_Vec3f_getScaled(lua_State* L) { int SWIG_arg = 0; ofVec3f *arg1 = (ofVec3f *) 0 ; float arg2 ; ofVec3f result;
  SWIG_check_num_args("ofVec3f::getScaled",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec3f::getScaled",1,"ofVec3f const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVec3f::getScaled",2,"float const");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Vec3f_getScaled",1,SWIGTYPE_p_ofVec3f); }  arg2 = (float const)lua_tonumber(L, 2);
  result = ((ofVec3f const *)arg1)->getScaled(arg2); { ofVec3f * resultptr = new ofVec3f((const ofVec3f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec3f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vec3f_scale(lua_State* L) { int SWIG_arg = 0; ofVec3f *arg1 = (ofVec3f *) 0 ; float arg2 ;
  ofVec3f *result = 0 ; SWIG_check_num_args("ofVec3f::scale",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec3f::scale",1,"ofVec3f *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVec3f::scale",2,"float const");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec3f,0))){ SWIG_fail_ptr("Vec3f_scale",1,SWIGTYPE_p_ofVec3f); }
   arg2 = (float const)lua_tonumber(L, 2); result = (ofVec3f *) &(arg1)->scale(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofVec3f,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Vec3f_getRotated__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofVec3f *arg1 = (ofVec3f *) 0 ; float arg2 ;
  ofVec3f *arg3 = 0 ; ofVec3f result; SWIG_check_num_args("ofVec3f::getRotated",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec3f::getRotated",1,"ofVec3f const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVec3f::getRotated",2,"float");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofVec3f::getRotated",3,"ofVec3f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Vec3f_getRotated",1,SWIGTYPE_p_ofVec3f); }  arg2 = (float)lua_tonumber(L, 2);
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Vec3f_getRotated",3,SWIGTYPE_p_ofVec3f); } 
  result = ((ofVec3f const *)arg1)->getRotated(arg2,(ofVec3f const &)*arg3); {
    ofVec3f * resultptr = new ofVec3f((const ofVec3f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec3f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vec3f_getRotated__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofVec3f *arg1 = (ofVec3f *) 0 ; float arg2 ;
  float arg3 ; float arg4 ; ofVec3f result; SWIG_check_num_args("ofVec3f::getRotated",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec3f::getRotated",1,"ofVec3f const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVec3f::getRotated",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVec3f::getRotated",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofVec3f::getRotated",4,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Vec3f_getRotated",1,SWIGTYPE_p_ofVec3f); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  result = ((ofVec3f const *)arg1)->getRotated(arg2,arg3,arg4); { ofVec3f * resultptr = new ofVec3f((const ofVec3f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec3f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vec3f_getRotated__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofVec3f *arg1 = (ofVec3f *) 0 ; float arg2 ;
  ofVec3f *arg3 = 0 ; ofVec3f *arg4 = 0 ; ofVec3f result; SWIG_check_num_args("ofVec3f::getRotated",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec3f::getRotated",1,"ofVec3f const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVec3f::getRotated",2,"float");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofVec3f::getRotated",3,"ofVec3f const &");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("ofVec3f::getRotated",4,"ofVec3f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Vec3f_getRotated",1,SWIGTYPE_p_ofVec3f); }  arg2 = (float)lua_tonumber(L, 2);
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Vec3f_getRotated",3,SWIGTYPE_p_ofVec3f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Vec3f_getRotated",4,SWIGTYPE_p_ofVec3f); } 
  result = ((ofVec3f const *)arg1)->getRotated(arg2,(ofVec3f const &)*arg3,(ofVec3f const &)*arg4); {
    ofVec3f * resultptr = new ofVec3f((const ofVec3f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec3f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vec3f_getRotated(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L); if (argc == 3) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }
           else { _v = 1; }  }  if (_v) { return _wrap_Vec3f_getRotated__SWIG_0(L);}  }  }  }  if (argc == 4) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }
           else { _v = 1; }  }  if (_v) { { void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }
             else { _v = 1; }  }  if (_v) { return _wrap_Vec3f_getRotated__SWIG_2(L);}  }  }  }  }  if (argc == 4) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_Vec3f_getRotated__SWIG_1(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Vec3f_getRotated'\n" "  Possible C/C++ prototypes are:\n"
  "    ofVec3f::getRotated(float,ofVec3f const &) const\n" "    ofVec3f::getRotated(float,float,float) const\n"
  "    ofVec3f::getRotated(float,ofVec3f const &,ofVec3f const &) const\n"); lua_error(L);return 0; }
static int _wrap_Vec3f_getRotatedRad__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofVec3f *arg1 = (ofVec3f *) 0 ; float arg2 ;
  ofVec3f *arg3 = 0 ; ofVec3f result; SWIG_check_num_args("ofVec3f::getRotatedRad",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec3f::getRotatedRad",1,"ofVec3f const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVec3f::getRotatedRad",2,"float");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofVec3f::getRotatedRad",3,"ofVec3f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Vec3f_getRotatedRad",1,SWIGTYPE_p_ofVec3f); }  arg2 = (float)lua_tonumber(L, 2);
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Vec3f_getRotatedRad",3,SWIGTYPE_p_ofVec3f); } 
  result = ((ofVec3f const *)arg1)->getRotatedRad(arg2,(ofVec3f const &)*arg3); {
    ofVec3f * resultptr = new ofVec3f((const ofVec3f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec3f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vec3f_getRotatedRad__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofVec3f *arg1 = (ofVec3f *) 0 ; float arg2 ;
  float arg3 ; float arg4 ; ofVec3f result; SWIG_check_num_args("ofVec3f::getRotatedRad",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec3f::getRotatedRad",1,"ofVec3f const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVec3f::getRotatedRad",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVec3f::getRotatedRad",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofVec3f::getRotatedRad",4,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Vec3f_getRotatedRad",1,SWIGTYPE_p_ofVec3f); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  result = ((ofVec3f const *)arg1)->getRotatedRad(arg2,arg3,arg4); {
    ofVec3f * resultptr = new ofVec3f((const ofVec3f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec3f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vec3f_getRotatedRad__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofVec3f *arg1 = (ofVec3f *) 0 ; float arg2 ;
  ofVec3f *arg3 = 0 ; ofVec3f *arg4 = 0 ; ofVec3f result; SWIG_check_num_args("ofVec3f::getRotatedRad",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec3f::getRotatedRad",1,"ofVec3f const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVec3f::getRotatedRad",2,"float");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofVec3f::getRotatedRad",3,"ofVec3f const &");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("ofVec3f::getRotatedRad",4,"ofVec3f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Vec3f_getRotatedRad",1,SWIGTYPE_p_ofVec3f); }  arg2 = (float)lua_tonumber(L, 2);
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Vec3f_getRotatedRad",3,SWIGTYPE_p_ofVec3f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Vec3f_getRotatedRad",4,SWIGTYPE_p_ofVec3f); } 
  result = ((ofVec3f const *)arg1)->getRotatedRad(arg2,(ofVec3f const &)*arg3,(ofVec3f const &)*arg4); {
    ofVec3f * resultptr = new ofVec3f((const ofVec3f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec3f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vec3f_getRotatedRad(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L); if (argc == 3) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }
           else { _v = 1; }  }  if (_v) { return _wrap_Vec3f_getRotatedRad__SWIG_0(L);}  }  }  }  if (argc == 4) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }
           else { _v = 1; }  }  if (_v) { { void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }
             else { _v = 1; }  }  if (_v) { return _wrap_Vec3f_getRotatedRad__SWIG_2(L);}  }  }  }  }  if (argc == 4) { int _v;
    { void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_Vec3f_getRotatedRad__SWIG_1(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Vec3f_getRotatedRad'\n"
  "  Possible C/C++ prototypes are:\n" "    ofVec3f::getRotatedRad(float,ofVec3f const &) const\n"
  "    ofVec3f::getRotatedRad(float,float,float) const\n"
  "    ofVec3f::getRotatedRad(float,ofVec3f const &,ofVec3f const &) const\n"); lua_error(L);return 0; }
static int _wrap_Vec3f_rotate__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofVec3f *arg1 = (ofVec3f *) 0 ; float arg2 ;
  ofVec3f *arg3 = 0 ; ofVec3f *result = 0 ; SWIG_check_num_args("ofVec3f::rotate",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec3f::rotate",1,"ofVec3f *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVec3f::rotate",2,"float");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofVec3f::rotate",3,"ofVec3f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec3f,0))){ SWIG_fail_ptr("Vec3f_rotate",1,SWIGTYPE_p_ofVec3f); }
   arg2 = (float)lua_tonumber(L, 2); if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Vec3f_rotate",3,SWIGTYPE_p_ofVec3f); }  result = (ofVec3f *) &(arg1)->rotate(arg2,(ofVec3f const &)*arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofVec3f,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Vec3f_rotate__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofVec3f *arg1 = (ofVec3f *) 0 ; float arg2 ;
  float arg3 ; float arg4 ; ofVec3f *result = 0 ; SWIG_check_num_args("ofVec3f::rotate",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec3f::rotate",1,"ofVec3f *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVec3f::rotate",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVec3f::rotate",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofVec3f::rotate",4,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec3f,0))){ SWIG_fail_ptr("Vec3f_rotate",1,SWIGTYPE_p_ofVec3f); }
   arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  result = (ofVec3f *) &(arg1)->rotate(arg2,arg3,arg4); SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofVec3f,0); SWIG_arg++; 
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vec3f_rotate__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofVec3f *arg1 = (ofVec3f *) 0 ; float arg2 ;
  ofVec3f *arg3 = 0 ; ofVec3f *arg4 = 0 ; ofVec3f *result = 0 ; SWIG_check_num_args("ofVec3f::rotate",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec3f::rotate",1,"ofVec3f *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVec3f::rotate",2,"float");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofVec3f::rotate",3,"ofVec3f const &");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("ofVec3f::rotate",4,"ofVec3f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec3f,0))){ SWIG_fail_ptr("Vec3f_rotate",1,SWIGTYPE_p_ofVec3f); }
   arg2 = (float)lua_tonumber(L, 2); if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Vec3f_rotate",3,SWIGTYPE_p_ofVec3f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_ofVec3f,0))){ SWIG_fail_ptr("Vec3f_rotate",4,SWIGTYPE_p_ofVec3f); }
   result = (ofVec3f *) &(arg1)->rotate(arg2,(ofVec3f const &)*arg3,(ofVec3f const &)*arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofVec3f,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Vec3f_rotate(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L); if (argc == 3) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }
           else { _v = 1; }  }  if (_v) { return _wrap_Vec3f_rotate__SWIG_0(L);}  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }
           else { _v = 1; }  }  if (_v) { { void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }
             else { _v = 1; }  }  if (_v) { return _wrap_Vec3f_rotate__SWIG_2(L);}  }  }  }  }  if (argc == 4) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_Vec3f_rotate__SWIG_1(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Vec3f_rotate'\n" "  Possible C/C++ prototypes are:\n"
  "    ofVec3f::rotate(float,ofVec3f const &)\n" "    ofVec3f::rotate(float,float,float)\n"
  "    ofVec3f::rotate(float,ofVec3f const &,ofVec3f const &)\n"); lua_error(L);return 0; }
static int _wrap_Vec3f_rotateRad__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofVec3f *arg1 = (ofVec3f *) 0 ; float arg2 ;
  ofVec3f *arg3 = 0 ; ofVec3f *result = 0 ; SWIG_check_num_args("ofVec3f::rotateRad",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec3f::rotateRad",1,"ofVec3f *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVec3f::rotateRad",2,"float");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofVec3f::rotateRad",3,"ofVec3f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Vec3f_rotateRad",1,SWIGTYPE_p_ofVec3f); }  arg2 = (float)lua_tonumber(L, 2);
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Vec3f_rotateRad",3,SWIGTYPE_p_ofVec3f); } 
  result = (ofVec3f *) &(arg1)->rotateRad(arg2,(ofVec3f const &)*arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofVec3f,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Vec3f_rotateRad__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofVec3f *arg1 = (ofVec3f *) 0 ; float arg2 ;
  float arg3 ; float arg4 ; ofVec3f *result = 0 ; SWIG_check_num_args("ofVec3f::rotateRad",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec3f::rotateRad",1,"ofVec3f *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVec3f::rotateRad",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVec3f::rotateRad",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofVec3f::rotateRad",4,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Vec3f_rotateRad",1,SWIGTYPE_p_ofVec3f); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); result = (ofVec3f *) &(arg1)->rotateRad(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofVec3f,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Vec3f_rotateRad__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofVec3f *arg1 = (ofVec3f *) 0 ; float arg2 ;
  ofVec3f *arg3 = 0 ; ofVec3f *arg4 = 0 ; ofVec3f *result = 0 ; SWIG_check_num_args("ofVec3f::rotateRad",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec3f::rotateRad",1,"ofVec3f *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVec3f::rotateRad",2,"float");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofVec3f::rotateRad",3,"ofVec3f const &");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("ofVec3f::rotateRad",4,"ofVec3f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Vec3f_rotateRad",1,SWIGTYPE_p_ofVec3f); }  arg2 = (float)lua_tonumber(L, 2);
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Vec3f_rotateRad",3,SWIGTYPE_p_ofVec3f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Vec3f_rotateRad",4,SWIGTYPE_p_ofVec3f); } 
  result = (ofVec3f *) &(arg1)->rotateRad(arg2,(ofVec3f const &)*arg3,(ofVec3f const &)*arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofVec3f,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Vec3f_rotateRad(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L); if (argc == 3) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }
           else { _v = 1; }  }  if (_v) { return _wrap_Vec3f_rotateRad__SWIG_0(L);}  }  }  }  if (argc == 4) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }
           else { _v = 1; }  }  if (_v) { { void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }
             else { _v = 1; }  }  if (_v) { return _wrap_Vec3f_rotateRad__SWIG_2(L);}  }  }  }  }  if (argc == 4) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_Vec3f_rotateRad__SWIG_1(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Vec3f_rotateRad'\n" "  Possible C/C++ prototypes are:\n"
  "    ofVec3f::rotateRad(float,ofVec3f const &)\n" "    ofVec3f::rotateRad(float,float,float)\n"
  "    ofVec3f::rotateRad(float,ofVec3f const &,ofVec3f const &)\n"); lua_error(L);return 0; }
static int _wrap_Vec3f_getMapped(lua_State* L) { int SWIG_arg = 0; ofVec3f *arg1 = (ofVec3f *) 0 ; ofVec3f *arg2 = 0 ;
  ofVec3f *arg3 = 0 ; ofVec3f *arg4 = 0 ; ofVec3f *arg5 = 0 ; ofVec3f result; SWIG_check_num_args("ofVec3f::getMapped",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec3f::getMapped",1,"ofVec3f const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVec3f::getMapped",2,"ofVec3f const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofVec3f::getMapped",3,"ofVec3f const &");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("ofVec3f::getMapped",4,"ofVec3f const &");
  if(!lua_isuserdata(L,5)) SWIG_fail_arg("ofVec3f::getMapped",5,"ofVec3f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Vec3f_getMapped",1,SWIGTYPE_p_ofVec3f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Vec3f_getMapped",2,SWIGTYPE_p_ofVec3f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Vec3f_getMapped",3,SWIGTYPE_p_ofVec3f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Vec3f_getMapped",4,SWIGTYPE_p_ofVec3f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&arg5,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Vec3f_getMapped",5,SWIGTYPE_p_ofVec3f); } 
  result = ((ofVec3f const *)arg1)->getMapped((ofVec3f const &)*arg2,(ofVec3f const &)*arg3,(ofVec3f const &)*arg4,(ofVec3f const &)*arg5);
  { ofVec3f * resultptr = new ofVec3f((const ofVec3f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec3f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vec3f_map(lua_State* L) { int SWIG_arg = 0; ofVec3f *arg1 = (ofVec3f *) 0 ; ofVec3f *arg2 = 0 ;
  ofVec3f *arg3 = 0 ; ofVec3f *arg4 = 0 ; ofVec3f *arg5 = 0 ; ofVec3f *result = 0 ; SWIG_check_num_args("ofVec3f::map",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec3f::map",1,"ofVec3f *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVec3f::map",2,"ofVec3f const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofVec3f::map",3,"ofVec3f const &");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("ofVec3f::map",4,"ofVec3f const &");
  if(!lua_isuserdata(L,5)) SWIG_fail_arg("ofVec3f::map",5,"ofVec3f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec3f,0))){ SWIG_fail_ptr("Vec3f_map",1,SWIGTYPE_p_ofVec3f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec3f,0))){ SWIG_fail_ptr("Vec3f_map",2,SWIGTYPE_p_ofVec3f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_ofVec3f,0))){ SWIG_fail_ptr("Vec3f_map",3,SWIGTYPE_p_ofVec3f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_ofVec3f,0))){ SWIG_fail_ptr("Vec3f_map",4,SWIGTYPE_p_ofVec3f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&arg5,SWIGTYPE_p_ofVec3f,0))){ SWIG_fail_ptr("Vec3f_map",5,SWIGTYPE_p_ofVec3f); } 
  result = (ofVec3f *) &(arg1)->map((ofVec3f const &)*arg2,(ofVec3f const &)*arg3,(ofVec3f const &)*arg4,(ofVec3f const &)*arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofVec3f,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Vec3f_distance(lua_State* L) { int SWIG_arg = 0; ofVec3f *arg1 = (ofVec3f *) 0 ; ofVec3f *arg2 = 0 ;
  float result; SWIG_check_num_args("ofVec3f::distance",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec3f::distance",1,"ofVec3f const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVec3f::distance",2,"ofVec3f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Vec3f_distance",1,SWIGTYPE_p_ofVec3f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Vec3f_distance",2,SWIGTYPE_p_ofVec3f); } 
  result = (float)((ofVec3f const *)arg1)->distance((ofVec3f const &)*arg2); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vec3f_squareDistance(lua_State* L) { int SWIG_arg = 0; ofVec3f *arg1 = (ofVec3f *) 0 ; ofVec3f *arg2 = 0 ;
  float result; SWIG_check_num_args("ofVec3f::squareDistance",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec3f::squareDistance",1,"ofVec3f const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVec3f::squareDistance",2,"ofVec3f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Vec3f_squareDistance",1,SWIGTYPE_p_ofVec3f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Vec3f_squareDistance",2,SWIGTYPE_p_ofVec3f); } 
  result = (float)((ofVec3f const *)arg1)->squareDistance((ofVec3f const &)*arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vec3f_getInterpolated(lua_State* L) { int SWIG_arg = 0; ofVec3f *arg1 = (ofVec3f *) 0 ; ofVec3f *arg2 = 0 ;
  float arg3 ; ofVec3f result; SWIG_check_num_args("ofVec3f::getInterpolated",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec3f::getInterpolated",1,"ofVec3f const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVec3f::getInterpolated",2,"ofVec3f const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVec3f::getInterpolated",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Vec3f_getInterpolated",1,SWIGTYPE_p_ofVec3f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Vec3f_getInterpolated",2,SWIGTYPE_p_ofVec3f); }  arg3 = (float)lua_tonumber(L, 3);
  result = ((ofVec3f const *)arg1)->getInterpolated((ofVec3f const &)*arg2,arg3); {
    ofVec3f * resultptr = new ofVec3f((const ofVec3f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec3f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vec3f_interpolate(lua_State* L) { int SWIG_arg = 0; ofVec3f *arg1 = (ofVec3f *) 0 ; ofVec3f *arg2 = 0 ;
  float arg3 ; ofVec3f *result = 0 ; SWIG_check_num_args("ofVec3f::interpolate",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec3f::interpolate",1,"ofVec3f *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVec3f::interpolate",2,"ofVec3f const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVec3f::interpolate",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Vec3f_interpolate",1,SWIGTYPE_p_ofVec3f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Vec3f_interpolate",2,SWIGTYPE_p_ofVec3f); }  arg3 = (float)lua_tonumber(L, 3);
  result = (ofVec3f *) &(arg1)->interpolate((ofVec3f const &)*arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofVec3f,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Vec3f_getMiddle(lua_State* L) { int SWIG_arg = 0; ofVec3f *arg1 = (ofVec3f *) 0 ; ofVec3f *arg2 = 0 ;
  ofVec3f result; SWIG_check_num_args("ofVec3f::getMiddle",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec3f::getMiddle",1,"ofVec3f const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVec3f::getMiddle",2,"ofVec3f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Vec3f_getMiddle",1,SWIGTYPE_p_ofVec3f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Vec3f_getMiddle",2,SWIGTYPE_p_ofVec3f); } 
  result = ((ofVec3f const *)arg1)->getMiddle((ofVec3f const &)*arg2); {
    ofVec3f * resultptr = new ofVec3f((const ofVec3f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec3f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vec3f_middle(lua_State* L) { int SWIG_arg = 0; ofVec3f *arg1 = (ofVec3f *) 0 ; ofVec3f *arg2 = 0 ;
  ofVec3f *result = 0 ; SWIG_check_num_args("ofVec3f::middle",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec3f::middle",1,"ofVec3f *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVec3f::middle",2,"ofVec3f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec3f,0))){ SWIG_fail_ptr("Vec3f_middle",1,SWIGTYPE_p_ofVec3f); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Vec3f_middle",2,SWIGTYPE_p_ofVec3f); }  result = (ofVec3f *) &(arg1)->middle((ofVec3f const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofVec3f,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Vec3f_average(lua_State* L) { int SWIG_arg = 0; ofVec3f *arg1 = (ofVec3f *) 0 ; ofVec3f *arg2 = (ofVec3f *) 0 ;
  int arg3 ; ofVec3f *result = 0 ; SWIG_check_num_args("ofVec3f::average",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec3f::average",1,"ofVec3f *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofVec3f::average",2,"ofVec3f const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVec3f::average",3,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Vec3f_average",1,SWIGTYPE_p_ofVec3f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Vec3f_average",2,SWIGTYPE_p_ofVec3f); }  arg3 = (int)lua_tonumber(L, 3);
  result = (ofVec3f *) &(arg1)->average((ofVec3f const *)arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofVec3f,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Vec3f_getNormalized(lua_State* L) { int SWIG_arg = 0; ofVec3f *arg1 = (ofVec3f *) 0 ; ofVec3f result;
  SWIG_check_num_args("ofVec3f::getNormalized",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec3f::getNormalized",1,"ofVec3f const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Vec3f_getNormalized",1,SWIGTYPE_p_ofVec3f); }  result = ((ofVec3f const *)arg1)->getNormalized(); {
    ofVec3f * resultptr = new ofVec3f((const ofVec3f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec3f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vec3f_normalize(lua_State* L) { int SWIG_arg = 0; ofVec3f *arg1 = (ofVec3f *) 0 ; ofVec3f *result = 0 ;
  SWIG_check_num_args("ofVec3f::normalize",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec3f::normalize",1,"ofVec3f *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Vec3f_normalize",1,SWIGTYPE_p_ofVec3f); }  result = (ofVec3f *) &(arg1)->normalize();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofVec3f,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Vec3f_getLimited(lua_State* L) { int SWIG_arg = 0; ofVec3f *arg1 = (ofVec3f *) 0 ; float arg2 ; ofVec3f result;
  SWIG_check_num_args("ofVec3f::getLimited",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec3f::getLimited",1,"ofVec3f const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVec3f::getLimited",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Vec3f_getLimited",1,SWIGTYPE_p_ofVec3f); }  arg2 = (float)lua_tonumber(L, 2);
  result = ((ofVec3f const *)arg1)->getLimited(arg2); { ofVec3f * resultptr = new ofVec3f((const ofVec3f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec3f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vec3f_limit(lua_State* L) { int SWIG_arg = 0; ofVec3f *arg1 = (ofVec3f *) 0 ; float arg2 ;
  ofVec3f *result = 0 ; SWIG_check_num_args("ofVec3f::limit",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec3f::limit",1,"ofVec3f *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVec3f::limit",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec3f,0))){ SWIG_fail_ptr("Vec3f_limit",1,SWIGTYPE_p_ofVec3f); }
   arg2 = (float)lua_tonumber(L, 2); result = (ofVec3f *) &(arg1)->limit(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofVec3f,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Vec3f_length(lua_State* L) { int SWIG_arg = 0; ofVec3f *arg1 = (ofVec3f *) 0 ; float result;
  SWIG_check_num_args("ofVec3f::length",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec3f::length",1,"ofVec3f const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec3f,0))){ SWIG_fail_ptr("Vec3f_length",1,SWIGTYPE_p_ofVec3f); }
   result = (float)((ofVec3f const *)arg1)->length(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vec3f_lengthSquared(lua_State* L) { int SWIG_arg = 0; ofVec3f *arg1 = (ofVec3f *) 0 ; float result;
  SWIG_check_num_args("ofVec3f::lengthSquared",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec3f::lengthSquared",1,"ofVec3f const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Vec3f_lengthSquared",1,SWIGTYPE_p_ofVec3f); }  result = (float)((ofVec3f const *)arg1)->lengthSquared();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vec3f_angle(lua_State* L) { int SWIG_arg = 0; ofVec3f *arg1 = (ofVec3f *) 0 ; ofVec3f *arg2 = 0 ; float result;
  SWIG_check_num_args("ofVec3f::angle",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec3f::angle",1,"ofVec3f const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVec3f::angle",2,"ofVec3f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec3f,0))){ SWIG_fail_ptr("Vec3f_angle",1,SWIGTYPE_p_ofVec3f); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec3f,0))){ SWIG_fail_ptr("Vec3f_angle",2,SWIGTYPE_p_ofVec3f); }
   result = (float)((ofVec3f const *)arg1)->angle((ofVec3f const &)*arg2); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vec3f_angleRad(lua_State* L) { int SWIG_arg = 0; ofVec3f *arg1 = (ofVec3f *) 0 ; ofVec3f *arg2 = 0 ;
  float result; SWIG_check_num_args("ofVec3f::angleRad",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec3f::angleRad",1,"ofVec3f const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVec3f::angleRad",2,"ofVec3f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Vec3f_angleRad",1,SWIGTYPE_p_ofVec3f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Vec3f_angleRad",2,SWIGTYPE_p_ofVec3f); } 
  result = (float)((ofVec3f const *)arg1)->angleRad((ofVec3f const &)*arg2); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vec3f_getPerpendicular(lua_State* L) { int SWIG_arg = 0; ofVec3f *arg1 = (ofVec3f *) 0 ; ofVec3f *arg2 = 0 ;
  ofVec3f result; SWIG_check_num_args("ofVec3f::getPerpendicular",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec3f::getPerpendicular",1,"ofVec3f const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVec3f::getPerpendicular",2,"ofVec3f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Vec3f_getPerpendicular",1,SWIGTYPE_p_ofVec3f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Vec3f_getPerpendicular",2,SWIGTYPE_p_ofVec3f); } 
  result = ((ofVec3f const *)arg1)->getPerpendicular((ofVec3f const &)*arg2); {
    ofVec3f * resultptr = new ofVec3f((const ofVec3f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec3f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vec3f_perpendicular(lua_State* L) { int SWIG_arg = 0; ofVec3f *arg1 = (ofVec3f *) 0 ; ofVec3f *arg2 = 0 ;
  ofVec3f *result = 0 ; SWIG_check_num_args("ofVec3f::perpendicular",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec3f::perpendicular",1,"ofVec3f *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVec3f::perpendicular",2,"ofVec3f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Vec3f_perpendicular",1,SWIGTYPE_p_ofVec3f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Vec3f_perpendicular",2,SWIGTYPE_p_ofVec3f); } 
  result = (ofVec3f *) &(arg1)->perpendicular((ofVec3f const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofVec3f,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Vec3f_getCrossed(lua_State* L) { int SWIG_arg = 0; ofVec3f *arg1 = (ofVec3f *) 0 ; ofVec3f *arg2 = 0 ;
  ofVec3f result; SWIG_check_num_args("ofVec3f::getCrossed",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec3f::getCrossed",1,"ofVec3f const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVec3f::getCrossed",2,"ofVec3f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Vec3f_getCrossed",1,SWIGTYPE_p_ofVec3f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Vec3f_getCrossed",2,SWIGTYPE_p_ofVec3f); } 
  result = ((ofVec3f const *)arg1)->getCrossed((ofVec3f const &)*arg2); {
    ofVec3f * resultptr = new ofVec3f((const ofVec3f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec3f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vec3f_cross(lua_State* L) { int SWIG_arg = 0; ofVec3f *arg1 = (ofVec3f *) 0 ; ofVec3f *arg2 = 0 ;
  ofVec3f *result = 0 ; SWIG_check_num_args("ofVec3f::cross",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec3f::cross",1,"ofVec3f *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVec3f::cross",2,"ofVec3f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec3f,0))){ SWIG_fail_ptr("Vec3f_cross",1,SWIGTYPE_p_ofVec3f); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec3f,0))){ SWIG_fail_ptr("Vec3f_cross",2,SWIGTYPE_p_ofVec3f); }
   result = (ofVec3f *) &(arg1)->cross((ofVec3f const &)*arg2); SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofVec3f,0); SWIG_arg++; 
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vec3f_dot(lua_State* L) { int SWIG_arg = 0; ofVec3f *arg1 = (ofVec3f *) 0 ; ofVec3f *arg2 = 0 ; float result;
  SWIG_check_num_args("ofVec3f::dot",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec3f::dot",1,"ofVec3f const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVec3f::dot",2,"ofVec3f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec3f,0))){ SWIG_fail_ptr("Vec3f_dot",1,SWIGTYPE_p_ofVec3f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec3f,0))){ SWIG_fail_ptr("Vec3f_dot",2,SWIGTYPE_p_ofVec3f); } 
  result = (float)((ofVec3f const *)arg1)->dot((ofVec3f const &)*arg2); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vec3f_zero(lua_State* L) { int SWIG_arg = 0; ofVec3f result; SWIG_check_num_args("ofVec3f::zero",0,0)
  result = ofVec3f::zero(); { ofVec3f * resultptr = new ofVec3f((const ofVec3f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec3f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vec3f_one(lua_State* L) { int SWIG_arg = 0; ofVec3f result; SWIG_check_num_args("ofVec3f::one",0,0)
  result = ofVec3f::one(); { ofVec3f * resultptr = new ofVec3f((const ofVec3f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec3f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vec3f___tostring(lua_State* L) { int SWIG_arg = 0; ofVec3f *arg1 = (ofVec3f *) 0 ; char *result = 0 ;
  SWIG_check_num_args("ofVec3f::__str__",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec3f::__str__",1,"ofVec3f *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Vec3f___tostring",1,SWIGTYPE_p_ofVec3f); }  result = (char *)ofVec3f___str__(arg1);
  lua_pushstring(L,(const char *)result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static void swig_delete_Vec3f(void *obj) {
ofVec3f *arg1 = (ofVec3f *) obj;
delete arg1;
}
static int _proxy__wrap_new_Vec3f(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_Vec3f);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_Vec3f_attributes[] = {
    { "x", _wrap_Vec3f_x_get, _wrap_Vec3f_x_set },
    { "y", _wrap_Vec3f_y_get, _wrap_Vec3f_y_set },
    { "z", _wrap_Vec3f_z_get, _wrap_Vec3f_z_set },
    {0,0,0}
};
static swig_lua_method swig_Vec3f_methods[]= {
    { "getPtr", _wrap_Vec3f_getPtr},
    { "set", _wrap_Vec3f_set},
    { "__eq", _wrap_Vec3f___eq},
    { "match", _wrap_Vec3f_match},
    { "isAligned", _wrap_Vec3f_isAligned},
    { "isAlignedRad", _wrap_Vec3f_isAlignedRad},
    { "align", _wrap_Vec3f_align},
    { "alignRad", _wrap_Vec3f_alignRad},
    { "__add", _wrap_Vec3f___add},
    { "__sub", _wrap_Vec3f___sub},
    { "__unm", _wrap_Vec3f___unm},
    { "__mul", _wrap_Vec3f___mul},
    { "__div", _wrap_Vec3f___div},
    { "getScaled", _wrap_Vec3f_getScaled},
    { "scale", _wrap_Vec3f_scale},
    { "getRotated", _wrap_Vec3f_getRotated},
    { "getRotatedRad", _wrap_Vec3f_getRotatedRad},
    { "rotate", _wrap_Vec3f_rotate},
    { "rotateRad", _wrap_Vec3f_rotateRad},
    { "getMapped", _wrap_Vec3f_getMapped},
    { "map", _wrap_Vec3f_map},
    { "distance", _wrap_Vec3f_distance},
    { "squareDistance", _wrap_Vec3f_squareDistance},
    { "getInterpolated", _wrap_Vec3f_getInterpolated},
    { "interpolate", _wrap_Vec3f_interpolate},
    { "getMiddle", _wrap_Vec3f_getMiddle},
    { "middle", _wrap_Vec3f_middle},
    { "average", _wrap_Vec3f_average},
    { "getNormalized", _wrap_Vec3f_getNormalized},
    { "normalize", _wrap_Vec3f_normalize},
    { "getLimited", _wrap_Vec3f_getLimited},
    { "limit", _wrap_Vec3f_limit},
    { "length", _wrap_Vec3f_length},
    { "lengthSquared", _wrap_Vec3f_lengthSquared},
    { "angle", _wrap_Vec3f_angle},
    { "angleRad", _wrap_Vec3f_angleRad},
    { "getPerpendicular", _wrap_Vec3f_getPerpendicular},
    { "perpendicular", _wrap_Vec3f_perpendicular},
    { "getCrossed", _wrap_Vec3f_getCrossed},
    { "cross", _wrap_Vec3f_cross},
    { "dot", _wrap_Vec3f_dot},
    { "__tostring", _wrap_Vec3f___tostring},
    {0,0}
};
static swig_lua_method swig_Vec3f_meta[] = {
    { "__eq", _wrap_Vec3f___eq},
    { "__add", _wrap_Vec3f___add},
    { "__sub", _wrap_Vec3f___sub},
    { "__unm", _wrap_Vec3f___unm},
    { "__mul", _wrap_Vec3f___mul},
    { "__div", _wrap_Vec3f___div},
    { "__tostring", _wrap_Vec3f___tostring},
    {0,0}
};

static swig_lua_attribute swig_Vec3f_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_Vec3f_Sf_SwigStatic_constants[]= {
    {SWIG_LUA_CONSTTAB_INT("DIM", ofVec3f::DIM)},
    {0,0,0,0,0,0}
};
static swig_lua_method swig_Vec3f_Sf_SwigStatic_methods[]= {
    { "zero", _wrap_Vec3f_zero},
    { "one", _wrap_Vec3f_one},
    {0,0}
};
static swig_lua_class* swig_Vec3f_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_Vec3f_Sf_SwigStatic = {
    "Vec3f",
    swig_Vec3f_Sf_SwigStatic_methods,
    swig_Vec3f_Sf_SwigStatic_attributes,
    swig_Vec3f_Sf_SwigStatic_constants,
    swig_Vec3f_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_Vec3f_bases[] = {0};
static const char *swig_Vec3f_base_names[] = {0};
static swig_lua_class _wrap_class_Vec3f = { "Vec3f", "Vec3f", &SWIGTYPE_p_ofVec3f,_proxy__wrap_new_Vec3f, swig_delete_Vec3f, swig_Vec3f_methods, swig_Vec3f_attributes, &swig_Vec3f_Sf_SwigStatic, swig_Vec3f_meta, swig_Vec3f_bases, swig_Vec3f_base_names };

static int _wrap_Vec4f_x_set(lua_State* L) { int SWIG_arg = 0; ofVec4f *arg1 = (ofVec4f *) 0 ; float arg2 ;
  SWIG_check_num_args("ofVec4f::x",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec4f::x",1,"ofVec4f *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVec4f::x",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec4f,0))){ SWIG_fail_ptr("Vec4f_x_set",1,SWIGTYPE_p_ofVec4f); }
   arg2 = (float)lua_tonumber(L, 2); if (arg1) (arg1)->x = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Vec4f_x_get(lua_State* L) { int SWIG_arg = 0; ofVec4f *arg1 = (ofVec4f *) 0 ; float result;
  SWIG_check_num_args("ofVec4f::x",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec4f::x",1,"ofVec4f *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec4f,0))){ SWIG_fail_ptr("Vec4f_x_get",1,SWIGTYPE_p_ofVec4f); }
   result = (float) ((arg1)->x); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vec4f_y_set(lua_State* L) { int SWIG_arg = 0; ofVec4f *arg1 = (ofVec4f *) 0 ; float arg2 ;
  SWIG_check_num_args("ofVec4f::y",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec4f::y",1,"ofVec4f *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVec4f::y",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec4f,0))){ SWIG_fail_ptr("Vec4f_y_set",1,SWIGTYPE_p_ofVec4f); }
   arg2 = (float)lua_tonumber(L, 2); if (arg1) (arg1)->y = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Vec4f_y_get(lua_State* L) { int SWIG_arg = 0; ofVec4f *arg1 = (ofVec4f *) 0 ; float result;
  SWIG_check_num_args("ofVec4f::y",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec4f::y",1,"ofVec4f *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec4f,0))){ SWIG_fail_ptr("Vec4f_y_get",1,SWIGTYPE_p_ofVec4f); }
   result = (float) ((arg1)->y); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vec4f_z_set(lua_State* L) { int SWIG_arg = 0; ofVec4f *arg1 = (ofVec4f *) 0 ; float arg2 ;
  SWIG_check_num_args("ofVec4f::z",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec4f::z",1,"ofVec4f *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVec4f::z",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec4f,0))){ SWIG_fail_ptr("Vec4f_z_set",1,SWIGTYPE_p_ofVec4f); }
   arg2 = (float)lua_tonumber(L, 2); if (arg1) (arg1)->z = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Vec4f_z_get(lua_State* L) { int SWIG_arg = 0; ofVec4f *arg1 = (ofVec4f *) 0 ; float result;
  SWIG_check_num_args("ofVec4f::z",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec4f::z",1,"ofVec4f *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec4f,0))){ SWIG_fail_ptr("Vec4f_z_get",1,SWIGTYPE_p_ofVec4f); }
   result = (float) ((arg1)->z); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vec4f_w_set(lua_State* L) { int SWIG_arg = 0; ofVec4f *arg1 = (ofVec4f *) 0 ; float arg2 ;
  SWIG_check_num_args("ofVec4f::w",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec4f::w",1,"ofVec4f *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVec4f::w",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec4f,0))){ SWIG_fail_ptr("Vec4f_w_set",1,SWIGTYPE_p_ofVec4f); }
   arg2 = (float)lua_tonumber(L, 2); if (arg1) (arg1)->w = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Vec4f_w_get(lua_State* L) { int SWIG_arg = 0; ofVec4f *arg1 = (ofVec4f *) 0 ; float result;
  SWIG_check_num_args("ofVec4f::w",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec4f::w",1,"ofVec4f *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec4f,0))){ SWIG_fail_ptr("Vec4f_w_get",1,SWIGTYPE_p_ofVec4f); }
   result = (float) ((arg1)->w); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_Vec4f__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofVec4f *result = 0 ;
  SWIG_check_num_args("ofVec4f::ofVec4f",0,0) result = (ofVec4f *)new ofVec4f();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofVec4f,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_Vec4f__SWIG_1(lua_State* L) { int SWIG_arg = 0; float arg1 ; ofVec4f *result = 0 ;
  SWIG_check_num_args("ofVec4f::ofVec4f",1,1) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofVec4f::ofVec4f",1,"float");
  arg1 = (float)lua_tonumber(L, 1); result = (ofVec4f *)new ofVec4f(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofVec4f,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_Vec4f__SWIG_2(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ; float arg4 ;
  ofVec4f *result = 0 ; SWIG_check_num_args("ofVec4f::ofVec4f",4,4)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofVec4f::ofVec4f",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVec4f::ofVec4f",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVec4f::ofVec4f",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofVec4f::ofVec4f",4,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  result = (ofVec4f *)new ofVec4f(arg1,arg2,arg3,arg4); SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofVec4f,1); SWIG_arg++; 
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_new_Vec4f__SWIG_3(lua_State* L) { int SWIG_arg = 0; ofVec2f *arg1 = 0 ; ofVec4f *result = 0 ;
  SWIG_check_num_args("ofVec4f::ofVec4f",1,1) if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofVec4f::ofVec4f",1,"ofVec2f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec2f,0))){ SWIG_fail_ptr("new_Vec4f",1,SWIGTYPE_p_ofVec2f); } 
  result = (ofVec4f *)new ofVec4f((ofVec2f const &)*arg1); SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofVec4f,1); SWIG_arg++; 
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_new_Vec4f__SWIG_4(lua_State* L) { int SWIG_arg = 0; ofVec3f *arg1 = 0 ; ofVec4f *result = 0 ;
  SWIG_check_num_args("ofVec4f::ofVec4f",1,1) if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofVec4f::ofVec4f",1,"ofVec3f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec3f,0))){ SWIG_fail_ptr("new_Vec4f",1,SWIGTYPE_p_ofVec3f); } 
  result = (ofVec4f *)new ofVec4f((ofVec3f const &)*arg1); SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofVec4f,1); SWIG_arg++; 
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_new_Vec4f__SWIG_5(lua_State* L) { int SWIG_arg = 0; glm::vec2 *arg1 = 0 ; ofVec4f *result = 0 ;
  SWIG_check_num_args("ofVec4f::ofVec4f",1,1) if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofVec4f::ofVec4f",1,"glm::vec2 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glm__vec2,0))){
    SWIG_fail_ptr("new_Vec4f",1,SWIGTYPE_p_glm__vec2); }  result = (ofVec4f *)new ofVec4f((glm::vec2 const &)*arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofVec4f,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_Vec4f__SWIG_6(lua_State* L) { int SWIG_arg = 0; glm::vec3 *arg1 = 0 ; ofVec4f *result = 0 ;
  SWIG_check_num_args("ofVec4f::ofVec4f",1,1) if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofVec4f::ofVec4f",1,"glm::vec3 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("new_Vec4f",1,SWIGTYPE_p_glm__vec3); }  result = (ofVec4f *)new ofVec4f((glm::vec3 const &)*arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofVec4f,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_Vec4f__SWIG_7(lua_State* L) { int SWIG_arg = 0; glm::vec4 *arg1 = 0 ; ofVec4f *result = 0 ;
  SWIG_check_num_args("ofVec4f::ofVec4f",1,1) if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofVec4f::ofVec4f",1,"glm::vec4 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glm__vec4,0))){
    SWIG_fail_ptr("new_Vec4f",1,SWIGTYPE_p_glm__vec4); }  result = (ofVec4f *)new ofVec4f((glm::vec4 const &)*arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofVec4f,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_Vec4f(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L); if (argc == 0) {
    return _wrap_new_Vec4f__SWIG_0(L);}  if (argc == 1) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec2f, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { return _wrap_new_Vec4f__SWIG_3(L);}  }  if (argc == 1) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { return _wrap_new_Vec4f__SWIG_4(L);}  }  if (argc == 1) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_glm__vec2, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { return _wrap_new_Vec4f__SWIG_5(L);}  }  if (argc == 1) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { return _wrap_new_Vec4f__SWIG_6(L);}  }  if (argc == 1) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_glm__vec4, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { return _wrap_new_Vec4f__SWIG_7(L);}  }  if (argc == 1) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { return _wrap_new_Vec4f__SWIG_1(L);}  }  if (argc == 4) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); } 
        if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_new_Vec4f__SWIG_2(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_Vec4f'\n" "  Possible C/C++ prototypes are:\n"
  "    ofVec4f::ofVec4f()\n" "    ofVec4f::ofVec4f(float)\n" "    ofVec4f::ofVec4f(float,float,float,float)\n"
  "    ofVec4f::ofVec4f(ofVec2f const &)\n" "    ofVec4f::ofVec4f(ofVec3f const &)\n"
  "    ofVec4f::ofVec4f(glm::vec2 const &)\n" "    ofVec4f::ofVec4f(glm::vec3 const &)\n"
  "    ofVec4f::ofVec4f(glm::vec4 const &)\n"); lua_error(L);return 0; }
static int _wrap_Vec4f_getPtr__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofVec4f *arg1 = (ofVec4f *) 0 ; float *result = 0 ;
  SWIG_check_num_args("ofVec4f::getPtr",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec4f::getPtr",1,"ofVec4f *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec4f,0))){ SWIG_fail_ptr("Vec4f_getPtr",1,SWIGTYPE_p_ofVec4f); }
   result = (float *)(arg1)->getPtr(); SWIG_NewPointerObj(L,result,SWIGTYPE_p_float,0); SWIG_arg++;  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vec4f_getPtr__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofVec4f *arg1 = (ofVec4f *) 0 ; float *result = 0 ;
  SWIG_check_num_args("ofVec4f::getPtr",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec4f::getPtr",1,"ofVec4f const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec4f,0))){ SWIG_fail_ptr("Vec4f_getPtr",1,SWIGTYPE_p_ofVec4f); }
   result = (float *)((ofVec4f const *)arg1)->getPtr(); SWIG_NewPointerObj(L,result,SWIGTYPE_p_float,0); SWIG_arg++; 
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vec4f_getPtr(lua_State* L) { int argc; int argv[2]={ 1,2} ; argc = lua_gettop(L); if (argc == 1) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec4f, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Vec4f_getPtr__SWIG_0(L);}  }  if (argc == 1) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec4f, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Vec4f_getPtr__SWIG_1(L);}  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Vec4f_getPtr'\n" "  Possible C/C++ prototypes are:\n"
  "    ofVec4f::getPtr()\n" "    ofVec4f::getPtr() const\n"); lua_error(L);return 0; }
static int _wrap_Vec4f_set__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofVec4f *arg1 = (ofVec4f *) 0 ; float arg2 ;
  SWIG_check_num_args("ofVec4f::set",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec4f::set",1,"ofVec4f *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVec4f::set",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec4f,0))){ SWIG_fail_ptr("Vec4f_set",1,SWIGTYPE_p_ofVec4f); } 
  arg2 = (float)lua_tonumber(L, 2); (arg1)->set(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vec4f_set__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofVec4f *arg1 = (ofVec4f *) 0 ; float arg2 ; float arg3 ;
  float arg4 ; float arg5 ; SWIG_check_num_args("ofVec4f::set",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec4f::set",1,"ofVec4f *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVec4f::set",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVec4f::set",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofVec4f::set",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofVec4f::set",5,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec4f,0))){ SWIG_fail_ptr("Vec4f_set",1,SWIGTYPE_p_ofVec4f); } 
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  arg5 = (float)lua_tonumber(L, 5); (arg1)->set(arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Vec4f_set__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofVec4f *arg1 = (ofVec4f *) 0 ; ofVec4f *arg2 = 0 ;
  SWIG_check_num_args("ofVec4f::set",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec4f::set",1,"ofVec4f *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVec4f::set",2,"ofVec4f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec4f,0))){ SWIG_fail_ptr("Vec4f_set",1,SWIGTYPE_p_ofVec4f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec4f,0))){ SWIG_fail_ptr("Vec4f_set",2,SWIGTYPE_p_ofVec4f); } 
  (arg1)->set((ofVec4f const &)*arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vec4f_set(lua_State* L) { int argc; int argv[6]={ 1,2,3,4,5,6} ; argc = lua_gettop(L); if (argc == 2) { int _v;
    { void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec4f, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofVec4f, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Vec4f_set__SWIG_2(L);}  }  }  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec4f, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { return _wrap_Vec4f_set__SWIG_0(L);}  }  } 
  if (argc == 5) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec4f, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { {
            _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) {
              return _wrap_Vec4f_set__SWIG_1(L);}  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Vec4f_set'\n" "  Possible C/C++ prototypes are:\n"
  "    ofVec4f::set(float)\n" "    ofVec4f::set(float,float,float,float)\n" "    ofVec4f::set(ofVec4f const &)\n");
  lua_error(L);return 0; }
static int _wrap_Vec4f___eq(lua_State* L) { int SWIG_arg = 0; ofVec4f *arg1 = (ofVec4f *) 0 ; ofVec4f *arg2 = 0 ; bool result;
  SWIG_check_num_args("ofVec4f::operator ==",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec4f::operator ==",1,"ofVec4f const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVec4f::operator ==",2,"ofVec4f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec4f,0))){ SWIG_fail_ptr("Vec4f___eq",1,SWIGTYPE_p_ofVec4f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec4f,0))){ SWIG_fail_ptr("Vec4f___eq",2,SWIGTYPE_p_ofVec4f); } 
  result = (bool)((ofVec4f const *)arg1)->operator ==((ofVec4f const &)*arg2); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vec4f_match__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofVec4f *arg1 = (ofVec4f *) 0 ; ofVec4f *arg2 = 0 ;
  float arg3 ; bool result; SWIG_check_num_args("ofVec4f::match",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec4f::match",1,"ofVec4f const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVec4f::match",2,"ofVec4f const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVec4f::match",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec4f,0))){ SWIG_fail_ptr("Vec4f_match",1,SWIGTYPE_p_ofVec4f); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec4f,0))){ SWIG_fail_ptr("Vec4f_match",2,SWIGTYPE_p_ofVec4f); }
   arg3 = (float)lua_tonumber(L, 3); result = (bool)((ofVec4f const *)arg1)->match((ofVec4f const &)*arg2,arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vec4f_match__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofVec4f *arg1 = (ofVec4f *) 0 ; ofVec4f *arg2 = 0 ;
  bool result; SWIG_check_num_args("ofVec4f::match",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec4f::match",1,"ofVec4f const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVec4f::match",2,"ofVec4f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec4f,0))){ SWIG_fail_ptr("Vec4f_match",1,SWIGTYPE_p_ofVec4f); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec4f,0))){ SWIG_fail_ptr("Vec4f_match",2,SWIGTYPE_p_ofVec4f); }
   result = (bool)((ofVec4f const *)arg1)->match((ofVec4f const &)*arg2); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vec4f_match(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 2) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec4f, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofVec4f, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Vec4f_match__SWIG_1(L);}  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec4f, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofVec4f, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { return _wrap_Vec4f_match__SWIG_0(L);}  }  }
     }  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Vec4f_match'\n" "  Possible C/C++ prototypes are:\n"
  "    ofVec4f::match(ofVec4f const &,float) const\n" "    ofVec4f::match(ofVec4f const &) const\n"); lua_error(L);return 0; }
static int _wrap_Vec4f___add__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofVec4f *arg1 = (ofVec4f *) 0 ; ofVec4f *arg2 = 0 ;
  ofVec4f result; SWIG_check_num_args("ofVec4f::operator +",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec4f::operator +",1,"ofVec4f const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVec4f::operator +",2,"ofVec4f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec4f,0))){ SWIG_fail_ptr("Vec4f___add",1,SWIGTYPE_p_ofVec4f); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec4f,0))){ SWIG_fail_ptr("Vec4f___add",2,SWIGTYPE_p_ofVec4f); }
   result = ((ofVec4f const *)arg1)->operator +((ofVec4f const &)*arg2); {
    ofVec4f * resultptr = new ofVec4f((const ofVec4f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec4f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vec4f___add__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofVec4f *arg1 = (ofVec4f *) 0 ; float arg2 ;
  ofVec4f result; SWIG_check_num_args("ofVec4f::operator +",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec4f::operator +",1,"ofVec4f const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVec4f::operator +",2,"float const");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec4f,0))){ SWIG_fail_ptr("Vec4f___add",1,SWIGTYPE_p_ofVec4f); }
   arg2 = (float const)lua_tonumber(L, 2); result = ((ofVec4f const *)arg1)->operator +(arg2); {
    ofVec4f * resultptr = new ofVec4f((const ofVec4f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec4f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vec4f___add(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 2) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec4f, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofVec4f, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Vec4f___add__SWIG_0(L);}  }  }  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec4f, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { return _wrap_Vec4f___add__SWIG_1(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Vec4f___add'\n" "  Possible C/C++ prototypes are:\n"
  "    ofVec4f::operator +(ofVec4f const &) const\n" "    ofVec4f::operator +(float const) const\n"); lua_error(L);return 0; }
static int _wrap_Vec4f___sub__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofVec4f *arg1 = (ofVec4f *) 0 ; float arg2 ;
  ofVec4f result; SWIG_check_num_args("ofVec4f::operator -",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec4f::operator -",1,"ofVec4f const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVec4f::operator -",2,"float const");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec4f,0))){ SWIG_fail_ptr("Vec4f___sub",1,SWIGTYPE_p_ofVec4f); }
   arg2 = (float const)lua_tonumber(L, 2); result = ((ofVec4f const *)arg1)->operator -(arg2); {
    ofVec4f * resultptr = new ofVec4f((const ofVec4f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec4f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vec4f___sub__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofVec4f *arg1 = (ofVec4f *) 0 ; ofVec4f *arg2 = 0 ;
  ofVec4f result; SWIG_check_num_args("ofVec4f::operator -",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec4f::operator -",1,"ofVec4f const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVec4f::operator -",2,"ofVec4f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec4f,0))){ SWIG_fail_ptr("Vec4f___sub",1,SWIGTYPE_p_ofVec4f); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec4f,0))){ SWIG_fail_ptr("Vec4f___sub",2,SWIGTYPE_p_ofVec4f); }
   result = ((ofVec4f const *)arg1)->operator -((ofVec4f const &)*arg2); {
    ofVec4f * resultptr = new ofVec4f((const ofVec4f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec4f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vec4f___sub(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 2) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec4f, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofVec4f, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Vec4f___sub__SWIG_1(L);}  }  }  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec4f, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { return _wrap_Vec4f___sub__SWIG_0(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Vec4f___sub'\n" "  Possible C/C++ prototypes are:\n"
  "    ofVec4f::operator -(float const) const\n" "    ofVec4f::operator -(ofVec4f const &) const\n"); lua_error(L);return 0; }
static int _wrap_Vec4f___unm(lua_State* L) { int SWIG_arg = 0; ofVec4f *arg1 = (ofVec4f *) 0 ; ofVec4f result;
  SWIG_check_num_args("ofVec4f::operator -",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec4f::operator -",1,"ofVec4f const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec4f,0))){ SWIG_fail_ptr("Vec4f___unm",1,SWIGTYPE_p_ofVec4f); }
   result = ((ofVec4f const *)arg1)->operator -(); { ofVec4f * resultptr = new ofVec4f((const ofVec4f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec4f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vec4f___mul__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofVec4f *arg1 = (ofVec4f *) 0 ; ofVec4f *arg2 = 0 ;
  ofVec4f result; SWIG_check_num_args("ofVec4f::operator *",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec4f::operator *",1,"ofVec4f const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVec4f::operator *",2,"ofVec4f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec4f,0))){ SWIG_fail_ptr("Vec4f___mul",1,SWIGTYPE_p_ofVec4f); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec4f,0))){ SWIG_fail_ptr("Vec4f___mul",2,SWIGTYPE_p_ofVec4f); }
   result = ((ofVec4f const *)arg1)->operator *((ofVec4f const &)*arg2); {
    ofVec4f * resultptr = new ofVec4f((const ofVec4f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec4f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vec4f___mul__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofVec4f *arg1 = (ofVec4f *) 0 ; float arg2 ;
  ofVec4f result; SWIG_check_num_args("ofVec4f::operator *",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec4f::operator *",1,"ofVec4f const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVec4f::operator *",2,"float const");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec4f,0))){ SWIG_fail_ptr("Vec4f___mul",1,SWIGTYPE_p_ofVec4f); }
   arg2 = (float const)lua_tonumber(L, 2); result = ((ofVec4f const *)arg1)->operator *(arg2); {
    ofVec4f * resultptr = new ofVec4f((const ofVec4f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec4f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vec4f___mul(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 2) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec4f, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofVec4f, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Vec4f___mul__SWIG_0(L);}  }  }  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec4f, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { return _wrap_Vec4f___mul__SWIG_1(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Vec4f___mul'\n" "  Possible C/C++ prototypes are:\n"
  "    ofVec4f::operator *(ofVec4f const &) const\n" "    ofVec4f::operator *(float const) const\n"); lua_error(L);return 0; }
static int _wrap_Vec4f___div__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofVec4f *arg1 = (ofVec4f *) 0 ; ofVec4f *arg2 = 0 ;
  ofVec4f result; SWIG_check_num_args("ofVec4f::operator /",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec4f::operator /",1,"ofVec4f const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVec4f::operator /",2,"ofVec4f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec4f,0))){ SWIG_fail_ptr("Vec4f___div",1,SWIGTYPE_p_ofVec4f); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec4f,0))){ SWIG_fail_ptr("Vec4f___div",2,SWIGTYPE_p_ofVec4f); }
   result = ((ofVec4f const *)arg1)->operator /((ofVec4f const &)*arg2); {
    ofVec4f * resultptr = new ofVec4f((const ofVec4f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec4f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vec4f___div__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofVec4f *arg1 = (ofVec4f *) 0 ; float arg2 ;
  ofVec4f result; SWIG_check_num_args("ofVec4f::operator /",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec4f::operator /",1,"ofVec4f const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVec4f::operator /",2,"float const");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec4f,0))){ SWIG_fail_ptr("Vec4f___div",1,SWIGTYPE_p_ofVec4f); }
   arg2 = (float const)lua_tonumber(L, 2); result = ((ofVec4f const *)arg1)->operator /(arg2); {
    ofVec4f * resultptr = new ofVec4f((const ofVec4f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec4f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vec4f___div(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 2) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec4f, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofVec4f, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Vec4f___div__SWIG_0(L);}  }  }  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVec4f, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { return _wrap_Vec4f___div__SWIG_1(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Vec4f___div'\n" "  Possible C/C++ prototypes are:\n"
  "    ofVec4f::operator /(ofVec4f const &) const\n" "    ofVec4f::operator /(float const) const\n"); lua_error(L);return 0; }
static int _wrap_Vec4f_getScaled(lua_State* L) { int SWIG_arg = 0; ofVec4f *arg1 = (ofVec4f *) 0 ; float arg2 ; ofVec4f result;
  SWIG_check_num_args("ofVec4f::getScaled",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec4f::getScaled",1,"ofVec4f const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVec4f::getScaled",2,"float const");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec4f,0))){
    SWIG_fail_ptr("Vec4f_getScaled",1,SWIGTYPE_p_ofVec4f); }  arg2 = (float const)lua_tonumber(L, 2);
  result = ((ofVec4f const *)arg1)->getScaled(arg2); { ofVec4f * resultptr = new ofVec4f((const ofVec4f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec4f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vec4f_scale(lua_State* L) { int SWIG_arg = 0; ofVec4f *arg1 = (ofVec4f *) 0 ; float arg2 ;
  ofVec4f *result = 0 ; SWIG_check_num_args("ofVec4f::scale",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec4f::scale",1,"ofVec4f *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVec4f::scale",2,"float const");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec4f,0))){ SWIG_fail_ptr("Vec4f_scale",1,SWIGTYPE_p_ofVec4f); }
   arg2 = (float const)lua_tonumber(L, 2); result = (ofVec4f *) &(arg1)->scale(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofVec4f,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Vec4f_distance(lua_State* L) { int SWIG_arg = 0; ofVec4f *arg1 = (ofVec4f *) 0 ; ofVec4f *arg2 = 0 ;
  float result; SWIG_check_num_args("ofVec4f::distance",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec4f::distance",1,"ofVec4f const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVec4f::distance",2,"ofVec4f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec4f,0))){
    SWIG_fail_ptr("Vec4f_distance",1,SWIGTYPE_p_ofVec4f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec4f,0))){
    SWIG_fail_ptr("Vec4f_distance",2,SWIGTYPE_p_ofVec4f); } 
  result = (float)((ofVec4f const *)arg1)->distance((ofVec4f const &)*arg2); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vec4f_squareDistance(lua_State* L) { int SWIG_arg = 0; ofVec4f *arg1 = (ofVec4f *) 0 ; ofVec4f *arg2 = 0 ;
  float result; SWIG_check_num_args("ofVec4f::squareDistance",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec4f::squareDistance",1,"ofVec4f const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVec4f::squareDistance",2,"ofVec4f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec4f,0))){
    SWIG_fail_ptr("Vec4f_squareDistance",1,SWIGTYPE_p_ofVec4f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec4f,0))){
    SWIG_fail_ptr("Vec4f_squareDistance",2,SWIGTYPE_p_ofVec4f); } 
  result = (float)((ofVec4f const *)arg1)->squareDistance((ofVec4f const &)*arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vec4f_getInterpolated(lua_State* L) { int SWIG_arg = 0; ofVec4f *arg1 = (ofVec4f *) 0 ; ofVec4f *arg2 = 0 ;
  float arg3 ; ofVec4f result; SWIG_check_num_args("ofVec4f::getInterpolated",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec4f::getInterpolated",1,"ofVec4f const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVec4f::getInterpolated",2,"ofVec4f const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVec4f::getInterpolated",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec4f,0))){
    SWIG_fail_ptr("Vec4f_getInterpolated",1,SWIGTYPE_p_ofVec4f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec4f,0))){
    SWIG_fail_ptr("Vec4f_getInterpolated",2,SWIGTYPE_p_ofVec4f); }  arg3 = (float)lua_tonumber(L, 3);
  result = ((ofVec4f const *)arg1)->getInterpolated((ofVec4f const &)*arg2,arg3); {
    ofVec4f * resultptr = new ofVec4f((const ofVec4f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec4f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vec4f_interpolate(lua_State* L) { int SWIG_arg = 0; ofVec4f *arg1 = (ofVec4f *) 0 ; ofVec4f *arg2 = 0 ;
  float arg3 ; ofVec4f *result = 0 ; SWIG_check_num_args("ofVec4f::interpolate",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec4f::interpolate",1,"ofVec4f *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVec4f::interpolate",2,"ofVec4f const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVec4f::interpolate",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec4f,0))){
    SWIG_fail_ptr("Vec4f_interpolate",1,SWIGTYPE_p_ofVec4f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec4f,0))){
    SWIG_fail_ptr("Vec4f_interpolate",2,SWIGTYPE_p_ofVec4f); }  arg3 = (float)lua_tonumber(L, 3);
  result = (ofVec4f *) &(arg1)->interpolate((ofVec4f const &)*arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofVec4f,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Vec4f_getMiddle(lua_State* L) { int SWIG_arg = 0; ofVec4f *arg1 = (ofVec4f *) 0 ; ofVec4f *arg2 = 0 ;
  ofVec4f result; SWIG_check_num_args("ofVec4f::getMiddle",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec4f::getMiddle",1,"ofVec4f const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVec4f::getMiddle",2,"ofVec4f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec4f,0))){
    SWIG_fail_ptr("Vec4f_getMiddle",1,SWIGTYPE_p_ofVec4f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec4f,0))){
    SWIG_fail_ptr("Vec4f_getMiddle",2,SWIGTYPE_p_ofVec4f); } 
  result = ((ofVec4f const *)arg1)->getMiddle((ofVec4f const &)*arg2); {
    ofVec4f * resultptr = new ofVec4f((const ofVec4f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec4f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vec4f_middle(lua_State* L) { int SWIG_arg = 0; ofVec4f *arg1 = (ofVec4f *) 0 ; ofVec4f *arg2 = 0 ;
  ofVec4f *result = 0 ; SWIG_check_num_args("ofVec4f::middle",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec4f::middle",1,"ofVec4f *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVec4f::middle",2,"ofVec4f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec4f,0))){ SWIG_fail_ptr("Vec4f_middle",1,SWIGTYPE_p_ofVec4f); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec4f,0))){
    SWIG_fail_ptr("Vec4f_middle",2,SWIGTYPE_p_ofVec4f); }  result = (ofVec4f *) &(arg1)->middle((ofVec4f const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofVec4f,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Vec4f_average(lua_State* L) { int SWIG_arg = 0; ofVec4f *arg1 = (ofVec4f *) 0 ; ofVec4f *arg2 = (ofVec4f *) 0 ;
  int arg3 ; ofVec4f *result = 0 ; SWIG_check_num_args("ofVec4f::average",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec4f::average",1,"ofVec4f *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofVec4f::average",2,"ofVec4f const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVec4f::average",3,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec4f,0))){
    SWIG_fail_ptr("Vec4f_average",1,SWIGTYPE_p_ofVec4f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec4f,0))){
    SWIG_fail_ptr("Vec4f_average",2,SWIGTYPE_p_ofVec4f); }  arg3 = (int)lua_tonumber(L, 3);
  result = (ofVec4f *) &(arg1)->average((ofVec4f const *)arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofVec4f,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Vec4f_getNormalized(lua_State* L) { int SWIG_arg = 0; ofVec4f *arg1 = (ofVec4f *) 0 ; ofVec4f result;
  SWIG_check_num_args("ofVec4f::getNormalized",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec4f::getNormalized",1,"ofVec4f const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec4f,0))){
    SWIG_fail_ptr("Vec4f_getNormalized",1,SWIGTYPE_p_ofVec4f); }  result = ((ofVec4f const *)arg1)->getNormalized(); {
    ofVec4f * resultptr = new ofVec4f((const ofVec4f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec4f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vec4f_normalize(lua_State* L) { int SWIG_arg = 0; ofVec4f *arg1 = (ofVec4f *) 0 ; ofVec4f *result = 0 ;
  SWIG_check_num_args("ofVec4f::normalize",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec4f::normalize",1,"ofVec4f *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec4f,0))){
    SWIG_fail_ptr("Vec4f_normalize",1,SWIGTYPE_p_ofVec4f); }  result = (ofVec4f *) &(arg1)->normalize();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofVec4f,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Vec4f_getLimited(lua_State* L) { int SWIG_arg = 0; ofVec4f *arg1 = (ofVec4f *) 0 ; float arg2 ; ofVec4f result;
  SWIG_check_num_args("ofVec4f::getLimited",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec4f::getLimited",1,"ofVec4f const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVec4f::getLimited",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec4f,0))){
    SWIG_fail_ptr("Vec4f_getLimited",1,SWIGTYPE_p_ofVec4f); }  arg2 = (float)lua_tonumber(L, 2);
  result = ((ofVec4f const *)arg1)->getLimited(arg2); { ofVec4f * resultptr = new ofVec4f((const ofVec4f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec4f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vec4f_limit(lua_State* L) { int SWIG_arg = 0; ofVec4f *arg1 = (ofVec4f *) 0 ; float arg2 ;
  ofVec4f *result = 0 ; SWIG_check_num_args("ofVec4f::limit",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec4f::limit",1,"ofVec4f *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVec4f::limit",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec4f,0))){ SWIG_fail_ptr("Vec4f_limit",1,SWIGTYPE_p_ofVec4f); }
   arg2 = (float)lua_tonumber(L, 2); result = (ofVec4f *) &(arg1)->limit(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofVec4f,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Vec4f_length(lua_State* L) { int SWIG_arg = 0; ofVec4f *arg1 = (ofVec4f *) 0 ; float result;
  SWIG_check_num_args("ofVec4f::length",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec4f::length",1,"ofVec4f const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec4f,0))){ SWIG_fail_ptr("Vec4f_length",1,SWIGTYPE_p_ofVec4f); }
   result = (float)((ofVec4f const *)arg1)->length(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vec4f_lengthSquared(lua_State* L) { int SWIG_arg = 0; ofVec4f *arg1 = (ofVec4f *) 0 ; float result;
  SWIG_check_num_args("ofVec4f::lengthSquared",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec4f::lengthSquared",1,"ofVec4f const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec4f,0))){
    SWIG_fail_ptr("Vec4f_lengthSquared",1,SWIGTYPE_p_ofVec4f); }  result = (float)((ofVec4f const *)arg1)->lengthSquared();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vec4f_dot(lua_State* L) { int SWIG_arg = 0; ofVec4f *arg1 = (ofVec4f *) 0 ; ofVec4f *arg2 = 0 ; float result;
  SWIG_check_num_args("ofVec4f::dot",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec4f::dot",1,"ofVec4f const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVec4f::dot",2,"ofVec4f const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec4f,0))){ SWIG_fail_ptr("Vec4f_dot",1,SWIGTYPE_p_ofVec4f); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec4f,0))){ SWIG_fail_ptr("Vec4f_dot",2,SWIGTYPE_p_ofVec4f); } 
  result = (float)((ofVec4f const *)arg1)->dot((ofVec4f const &)*arg2); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vec4f_zero(lua_State* L) { int SWIG_arg = 0; ofVec4f result; SWIG_check_num_args("ofVec4f::zero",0,0)
  result = ofVec4f::zero(); { ofVec4f * resultptr = new ofVec4f((const ofVec4f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec4f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vec4f_one(lua_State* L) { int SWIG_arg = 0; ofVec4f result; SWIG_check_num_args("ofVec4f::one",0,0)
  result = ofVec4f::one(); { ofVec4f * resultptr = new ofVec4f((const ofVec4f &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofVec4f,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vec4f___tostring(lua_State* L) { int SWIG_arg = 0; ofVec4f *arg1 = (ofVec4f *) 0 ; char *result = 0 ;
  SWIG_check_num_args("ofVec4f::__str__",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVec4f::__str__",1,"ofVec4f *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVec4f,0))){
    SWIG_fail_ptr("Vec4f___tostring",1,SWIGTYPE_p_ofVec4f); }  result = (char *)ofVec4f___str__(arg1);
  lua_pushstring(L,(const char *)result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static void swig_delete_Vec4f(void *obj) {
ofVec4f *arg1 = (ofVec4f *) obj;
delete arg1;
}
static int _proxy__wrap_new_Vec4f(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_Vec4f);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_Vec4f_attributes[] = {
    { "x", _wrap_Vec4f_x_get, _wrap_Vec4f_x_set },
    { "y", _wrap_Vec4f_y_get, _wrap_Vec4f_y_set },
    { "z", _wrap_Vec4f_z_get, _wrap_Vec4f_z_set },
    { "w", _wrap_Vec4f_w_get, _wrap_Vec4f_w_set },
    {0,0,0}
};
static swig_lua_method swig_Vec4f_methods[]= {
    { "getPtr", _wrap_Vec4f_getPtr},
    { "set", _wrap_Vec4f_set},
    { "__eq", _wrap_Vec4f___eq},
    { "match", _wrap_Vec4f_match},
    { "__add", _wrap_Vec4f___add},
    { "__sub", _wrap_Vec4f___sub},
    { "__unm", _wrap_Vec4f___unm},
    { "__mul", _wrap_Vec4f___mul},
    { "__div", _wrap_Vec4f___div},
    { "getScaled", _wrap_Vec4f_getScaled},
    { "scale", _wrap_Vec4f_scale},
    { "distance", _wrap_Vec4f_distance},
    { "squareDistance", _wrap_Vec4f_squareDistance},
    { "getInterpolated", _wrap_Vec4f_getInterpolated},
    { "interpolate", _wrap_Vec4f_interpolate},
    { "getMiddle", _wrap_Vec4f_getMiddle},
    { "middle", _wrap_Vec4f_middle},
    { "average", _wrap_Vec4f_average},
    { "getNormalized", _wrap_Vec4f_getNormalized},
    { "normalize", _wrap_Vec4f_normalize},
    { "getLimited", _wrap_Vec4f_getLimited},
    { "limit", _wrap_Vec4f_limit},
    { "length", _wrap_Vec4f_length},
    { "lengthSquared", _wrap_Vec4f_lengthSquared},
    { "dot", _wrap_Vec4f_dot},
    { "__tostring", _wrap_Vec4f___tostring},
    {0,0}
};
static swig_lua_method swig_Vec4f_meta[] = {
    { "__eq", _wrap_Vec4f___eq},
    { "__add", _wrap_Vec4f___add},
    { "__sub", _wrap_Vec4f___sub},
    { "__unm", _wrap_Vec4f___unm},
    { "__mul", _wrap_Vec4f___mul},
    { "__div", _wrap_Vec4f___div},
    { "__tostring", _wrap_Vec4f___tostring},
    {0,0}
};

static swig_lua_attribute swig_Vec4f_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_Vec4f_Sf_SwigStatic_constants[]= {
    {SWIG_LUA_CONSTTAB_INT("DIM", ofVec4f::DIM)},
    {0,0,0,0,0,0}
};
static swig_lua_method swig_Vec4f_Sf_SwigStatic_methods[]= {
    { "zero", _wrap_Vec4f_zero},
    { "one", _wrap_Vec4f_one},
    {0,0}
};
static swig_lua_class* swig_Vec4f_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_Vec4f_Sf_SwigStatic = {
    "Vec4f",
    swig_Vec4f_Sf_SwigStatic_methods,
    swig_Vec4f_Sf_SwigStatic_attributes,
    swig_Vec4f_Sf_SwigStatic_constants,
    swig_Vec4f_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_Vec4f_bases[] = {0};
static const char *swig_Vec4f_base_names[] = {0};
static swig_lua_class _wrap_class_Vec4f = { "Vec4f", "Vec4f", &SWIGTYPE_p_ofVec4f,_proxy__wrap_new_Vec4f, swig_delete_Vec4f, swig_Vec4f_methods, swig_Vec4f_attributes, &swig_Vec4f_Sf_SwigStatic, swig_Vec4f_meta, swig_Vec4f_bases, swig_Vec4f_base_names };

static int _wrap_new_vec2(lua_State* L) { int SWIG_arg = 0; glm::vec2 *result = 0 ; SWIG_check_num_args("glm::vec2::vec2",0,0)
  result = (glm::vec2 *)new glm::vec2(); SWIG_NewPointerObj(L,result,SWIGTYPE_p_glm__vec2,1); SWIG_arg++;  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static void swig_delete_vec2(void *obj) {
glm::vec2 *arg1 = (glm::vec2 *) obj;
delete arg1;
}
static int _proxy__wrap_new_vec2(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_vec2);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_vec2_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_vec2_methods[]= {
    {0,0}
};
static swig_lua_method swig_vec2_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_vec2_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_vec2_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_vec2_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_vec2_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_vec2_Sf_SwigStatic = {
    "vec2",
    swig_vec2_Sf_SwigStatic_methods,
    swig_vec2_Sf_SwigStatic_attributes,
    swig_vec2_Sf_SwigStatic_constants,
    swig_vec2_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_vec2_bases[] = {0};
static const char *swig_vec2_base_names[] = {0};
static swig_lua_class _wrap_class_vec2 = { "vec2", "vec2", &SWIGTYPE_p_glm__vec2,_proxy__wrap_new_vec2, swig_delete_vec2, swig_vec2_methods, swig_vec2_attributes, &swig_vec2_Sf_SwigStatic, swig_vec2_meta, swig_vec2_bases, swig_vec2_base_names };

static int _wrap_getMousePressed__SWIG_0(lua_State* L) { int SWIG_arg = 0; int arg1 ; bool result;
  SWIG_check_num_args("ofGetMousePressed",1,1) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofGetMousePressed",1,"int");
  arg1 = (int)lua_tonumber(L, 1); result = (bool)ofGetMousePressed(arg1); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_getMousePressed__SWIG_1(lua_State* L) { int SWIG_arg = 0; bool result;
  SWIG_check_num_args("ofGetMousePressed",0,0) result = (bool)ofGetMousePressed();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_getMousePressed(lua_State* L) { int argc; int argv[2]={ 1,2} ; argc = lua_gettop(L); if (argc == 0) {
    return _wrap_getMousePressed__SWIG_1(L);}  if (argc == 1) { int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) {
      return _wrap_getMousePressed__SWIG_0(L);}  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'getMousePressed'\n" "  Possible C/C++ prototypes are:\n"
  "    ofGetMousePressed(int)\n" "    ofGetMousePressed()\n"); lua_error(L);return 0; }
static int _wrap_getKeyPressed__SWIG_0(lua_State* L) { int SWIG_arg = 0; int arg1 ; bool result;
  SWIG_check_num_args("ofGetKeyPressed",1,1) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofGetKeyPressed",1,"int");
  arg1 = (int)lua_tonumber(L, 1); result = (bool)ofGetKeyPressed(arg1); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_getKeyPressed__SWIG_1(lua_State* L) { int SWIG_arg = 0; bool result; SWIG_check_num_args("ofGetKeyPressed",0,0)
  result = (bool)ofGetKeyPressed(); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_getKeyPressed(lua_State* L) { int argc; int argv[2]={ 1,2} ; argc = lua_gettop(L); if (argc == 0) {
    return _wrap_getKeyPressed__SWIG_1(L);}  if (argc == 1) { int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) {
      return _wrap_getKeyPressed__SWIG_0(L);}  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'getKeyPressed'\n" "  Possible C/C++ prototypes are:\n"
  "    ofGetKeyPressed(int)\n" "    ofGetKeyPressed()\n"); lua_error(L);return 0; }
static int _wrap_getMouseX(lua_State* L) { int SWIG_arg = 0; int result; SWIG_check_num_args("ofGetMouseX",0,0)
  result = (int)ofGetMouseX(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_getMouseY(lua_State* L) { int SWIG_arg = 0; int result; SWIG_check_num_args("ofGetMouseY",0,0)
  result = (int)ofGetMouseY(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_getPreviousMouseX(lua_State* L) { int SWIG_arg = 0; int result; SWIG_check_num_args("ofGetPreviousMouseX",0,0)
  result = (int)ofGetPreviousMouseX(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_getPreviousMouseY(lua_State* L) { int SWIG_arg = 0; int result; SWIG_check_num_args("ofGetPreviousMouseY",0,0)
  result = (int)ofGetPreviousMouseY(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_DragInfo_files_set(lua_State* L) { int SWIG_arg = 0; ofDragInfo *arg1 = (ofDragInfo *) 0 ;
  std::vector< std::string > *arg2 = (std::vector< std::string > *) 0 ; SWIG_check_num_args("ofDragInfo::files",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofDragInfo::files",1,"ofDragInfo *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofDragInfo::files",2,"std::vector< std::string > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofDragInfo,0))){
    SWIG_fail_ptr("DragInfo_files_set",1,SWIGTYPE_p_ofDragInfo); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_std__vectorT_std__string_t,0))){
    SWIG_fail_ptr("DragInfo_files_set",2,SWIGTYPE_p_std__vectorT_std__string_t); }  if (arg1) (arg1)->files = *arg2;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_DragInfo_files_get(lua_State* L) { int SWIG_arg = 0; ofDragInfo *arg1 = (ofDragInfo *) 0 ;
  std::vector< std::string > *result = 0 ; SWIG_check_num_args("ofDragInfo::files",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofDragInfo::files",1,"ofDragInfo *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofDragInfo,0))){
    SWIG_fail_ptr("DragInfo_files_get",1,SWIGTYPE_p_ofDragInfo); }  result = (std::vector< std::string > *)& ((arg1)->files);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorT_std__string_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_DragInfo_position_set(lua_State* L) { int SWIG_arg = 0; ofDragInfo *arg1 = (ofDragInfo *) 0 ;
  glm::vec2 *arg2 = (glm::vec2 *) 0 ; SWIG_check_num_args("ofDragInfo::position",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofDragInfo::position",1,"ofDragInfo *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofDragInfo::position",2,"glm::vec2 *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofDragInfo,0))){
    SWIG_fail_ptr("DragInfo_position_set",1,SWIGTYPE_p_ofDragInfo); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec2,0))){
    SWIG_fail_ptr("DragInfo_position_set",2,SWIGTYPE_p_glm__vec2); }  if (arg1) (arg1)->position = *arg2; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_DragInfo_position_get(lua_State* L) { int SWIG_arg = 0; ofDragInfo *arg1 = (ofDragInfo *) 0 ;
  glm::vec2 *result = 0 ; SWIG_check_num_args("ofDragInfo::position",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofDragInfo::position",1,"ofDragInfo *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofDragInfo,0))){
    SWIG_fail_ptr("DragInfo_position_get",1,SWIGTYPE_p_ofDragInfo); }  result = (glm::vec2 *)& ((arg1)->position);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_glm__vec2,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_DragInfo(lua_State* L) { int SWIG_arg = 0; ofDragInfo *result = 0 ;
  SWIG_check_num_args("ofDragInfo::ofDragInfo",0,0) result = (ofDragInfo *)new ofDragInfo();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofDragInfo,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static void swig_delete_DragInfo(void *obj) {
ofDragInfo *arg1 = (ofDragInfo *) obj;
delete arg1;
}
static int _proxy__wrap_new_DragInfo(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_DragInfo);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_DragInfo_attributes[] = {
    { "files", _wrap_DragInfo_files_get, _wrap_DragInfo_files_set },
    { "position", _wrap_DragInfo_position_get, _wrap_DragInfo_position_set },
    {0,0,0}
};
static swig_lua_method swig_DragInfo_methods[]= {
    {0,0}
};
static swig_lua_method swig_DragInfo_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_DragInfo_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_DragInfo_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_DragInfo_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_DragInfo_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_DragInfo_Sf_SwigStatic = {
    "DragInfo",
    swig_DragInfo_Sf_SwigStatic_methods,
    swig_DragInfo_Sf_SwigStatic_attributes,
    swig_DragInfo_Sf_SwigStatic_constants,
    swig_DragInfo_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_DragInfo_bases[] = {0};
static const char *swig_DragInfo_base_names[] = {0};
static swig_lua_class _wrap_class_DragInfo = { "DragInfo", "DragInfo", &SWIGTYPE_p_ofDragInfo,_proxy__wrap_new_DragInfo, swig_delete_DragInfo, swig_DragInfo_methods, swig_DragInfo_attributes, &swig_DragInfo_Sf_SwigStatic, swig_DragInfo_meta, swig_DragInfo_bases, swig_DragInfo_base_names };

static int _wrap_new_TouchEventArgs__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofTouchEventArgs *result = 0 ;
  SWIG_check_num_args("ofTouchEventArgs::ofTouchEventArgs",0,0) result = (ofTouchEventArgs *)new ofTouchEventArgs();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofTouchEventArgs,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_TouchEventArgs__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofTouchEventArgs::Type arg1 ; float arg2 ;
  float arg3 ; int arg4 ; ofTouchEventArgs *result = 0 ; SWIG_check_num_args("ofTouchEventArgs::ofTouchEventArgs",4,4)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofTouchEventArgs::ofTouchEventArgs",1,"ofTouchEventArgs::Type");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofTouchEventArgs::ofTouchEventArgs",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofTouchEventArgs::ofTouchEventArgs",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofTouchEventArgs::ofTouchEventArgs",4,"int");
  arg1 = (ofTouchEventArgs::Type)(int)lua_tonumber(L, 1); arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4); result = (ofTouchEventArgs *)new ofTouchEventArgs(arg1,arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofTouchEventArgs,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_TouchEventArgs(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L); if (argc == 0) {
    return _wrap_new_TouchEventArgs__SWIG_0(L);}  if (argc == 4) { int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { {
        _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); }
           if (_v) { return _wrap_new_TouchEventArgs__SWIG_1(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_TouchEventArgs'\n" "  Possible C/C++ prototypes are:\n"
  "    ofTouchEventArgs::ofTouchEventArgs()\n"
  "    ofTouchEventArgs::ofTouchEventArgs(ofTouchEventArgs::Type,float,float,int)\n"); lua_error(L);return 0; }
static int _wrap_TouchEventArgs_type_set(lua_State* L) { int SWIG_arg = 0; ofTouchEventArgs *arg1 = (ofTouchEventArgs *) 0 ;
  ofTouchEventArgs::Type arg2 ; SWIG_check_num_args("ofTouchEventArgs::type",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTouchEventArgs::type",1,"ofTouchEventArgs *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofTouchEventArgs::type",2,"ofTouchEventArgs::Type");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTouchEventArgs,0))){
    SWIG_fail_ptr("TouchEventArgs_type_set",1,SWIGTYPE_p_ofTouchEventArgs); } 
  arg2 = (ofTouchEventArgs::Type)(int)lua_tonumber(L, 2); if (arg1) (arg1)->type = arg2; return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_TouchEventArgs_type_get(lua_State* L) { int SWIG_arg = 0; ofTouchEventArgs *arg1 = (ofTouchEventArgs *) 0 ;
  ofTouchEventArgs::Type result; SWIG_check_num_args("ofTouchEventArgs::type",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTouchEventArgs::type",1,"ofTouchEventArgs *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTouchEventArgs,0))){
    SWIG_fail_ptr("TouchEventArgs_type_get",1,SWIGTYPE_p_ofTouchEventArgs); }  result = (ofTouchEventArgs::Type) ((arg1)->type);
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_TouchEventArgs_id_set(lua_State* L) { int SWIG_arg = 0; ofTouchEventArgs *arg1 = (ofTouchEventArgs *) 0 ;
  int arg2 ; SWIG_check_num_args("ofTouchEventArgs::id",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTouchEventArgs::id",1,"ofTouchEventArgs *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofTouchEventArgs::id",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTouchEventArgs,0))){
    SWIG_fail_ptr("TouchEventArgs_id_set",1,SWIGTYPE_p_ofTouchEventArgs); }  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->id = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TouchEventArgs_id_get(lua_State* L) { int SWIG_arg = 0; ofTouchEventArgs *arg1 = (ofTouchEventArgs *) 0 ;
  int result; SWIG_check_num_args("ofTouchEventArgs::id",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTouchEventArgs::id",1,"ofTouchEventArgs *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTouchEventArgs,0))){
    SWIG_fail_ptr("TouchEventArgs_id_get",1,SWIGTYPE_p_ofTouchEventArgs); }  result = (int) ((arg1)->id);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TouchEventArgs_time_set(lua_State* L) { int SWIG_arg = 0; ofTouchEventArgs *arg1 = (ofTouchEventArgs *) 0 ;
  int arg2 ; SWIG_check_num_args("ofTouchEventArgs::time",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTouchEventArgs::time",1,"ofTouchEventArgs *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofTouchEventArgs::time",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTouchEventArgs,0))){
    SWIG_fail_ptr("TouchEventArgs_time_set",1,SWIGTYPE_p_ofTouchEventArgs); }  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->time = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TouchEventArgs_time_get(lua_State* L) { int SWIG_arg = 0; ofTouchEventArgs *arg1 = (ofTouchEventArgs *) 0 ;
  int result; SWIG_check_num_args("ofTouchEventArgs::time",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTouchEventArgs::time",1,"ofTouchEventArgs *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTouchEventArgs,0))){
    SWIG_fail_ptr("TouchEventArgs_time_get",1,SWIGTYPE_p_ofTouchEventArgs); }  result = (int) ((arg1)->time);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TouchEventArgs_numTouches_set(lua_State* L) { int SWIG_arg = 0;
  ofTouchEventArgs *arg1 = (ofTouchEventArgs *) 0 ; int arg2 ; SWIG_check_num_args("ofTouchEventArgs::numTouches",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTouchEventArgs::numTouches",1,"ofTouchEventArgs *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofTouchEventArgs::numTouches",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTouchEventArgs,0))){
    SWIG_fail_ptr("TouchEventArgs_numTouches_set",1,SWIGTYPE_p_ofTouchEventArgs); }  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->numTouches = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TouchEventArgs_numTouches_get(lua_State* L) { int SWIG_arg = 0;
  ofTouchEventArgs *arg1 = (ofTouchEventArgs *) 0 ; int result; SWIG_check_num_args("ofTouchEventArgs::numTouches",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTouchEventArgs::numTouches",1,"ofTouchEventArgs *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTouchEventArgs,0))){
    SWIG_fail_ptr("TouchEventArgs_numTouches_get",1,SWIGTYPE_p_ofTouchEventArgs); }  result = (int) ((arg1)->numTouches);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TouchEventArgs_width_set(lua_State* L) { int SWIG_arg = 0; ofTouchEventArgs *arg1 = (ofTouchEventArgs *) 0 ;
  float arg2 ; SWIG_check_num_args("ofTouchEventArgs::width",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTouchEventArgs::width",1,"ofTouchEventArgs *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofTouchEventArgs::width",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTouchEventArgs,0))){
    SWIG_fail_ptr("TouchEventArgs_width_set",1,SWIGTYPE_p_ofTouchEventArgs); }  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->width = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TouchEventArgs_width_get(lua_State* L) { int SWIG_arg = 0; ofTouchEventArgs *arg1 = (ofTouchEventArgs *) 0 ;
  float result; SWIG_check_num_args("ofTouchEventArgs::width",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTouchEventArgs::width",1,"ofTouchEventArgs *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTouchEventArgs,0))){
    SWIG_fail_ptr("TouchEventArgs_width_get",1,SWIGTYPE_p_ofTouchEventArgs); }  result = (float) ((arg1)->width);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TouchEventArgs_height_set(lua_State* L) { int SWIG_arg = 0; ofTouchEventArgs *arg1 = (ofTouchEventArgs *) 0 ;
  float arg2 ; SWIG_check_num_args("ofTouchEventArgs::height",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTouchEventArgs::height",1,"ofTouchEventArgs *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofTouchEventArgs::height",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTouchEventArgs,0))){
    SWIG_fail_ptr("TouchEventArgs_height_set",1,SWIGTYPE_p_ofTouchEventArgs); }  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->height = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TouchEventArgs_height_get(lua_State* L) { int SWIG_arg = 0; ofTouchEventArgs *arg1 = (ofTouchEventArgs *) 0 ;
  float result; SWIG_check_num_args("ofTouchEventArgs::height",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTouchEventArgs::height",1,"ofTouchEventArgs *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTouchEventArgs,0))){
    SWIG_fail_ptr("TouchEventArgs_height_get",1,SWIGTYPE_p_ofTouchEventArgs); }  result = (float) ((arg1)->height);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TouchEventArgs_angle_set(lua_State* L) { int SWIG_arg = 0; ofTouchEventArgs *arg1 = (ofTouchEventArgs *) 0 ;
  float arg2 ; SWIG_check_num_args("ofTouchEventArgs::angle",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTouchEventArgs::angle",1,"ofTouchEventArgs *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofTouchEventArgs::angle",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTouchEventArgs,0))){
    SWIG_fail_ptr("TouchEventArgs_angle_set",1,SWIGTYPE_p_ofTouchEventArgs); }  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->angle = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TouchEventArgs_angle_get(lua_State* L) { int SWIG_arg = 0; ofTouchEventArgs *arg1 = (ofTouchEventArgs *) 0 ;
  float result; SWIG_check_num_args("ofTouchEventArgs::angle",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTouchEventArgs::angle",1,"ofTouchEventArgs *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTouchEventArgs,0))){
    SWIG_fail_ptr("TouchEventArgs_angle_get",1,SWIGTYPE_p_ofTouchEventArgs); }  result = (float) ((arg1)->angle);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TouchEventArgs_minoraxis_set(lua_State* L) { int SWIG_arg = 0;
  ofTouchEventArgs *arg1 = (ofTouchEventArgs *) 0 ; float arg2 ; SWIG_check_num_args("ofTouchEventArgs::minoraxis",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTouchEventArgs::minoraxis",1,"ofTouchEventArgs *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofTouchEventArgs::minoraxis",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTouchEventArgs,0))){
    SWIG_fail_ptr("TouchEventArgs_minoraxis_set",1,SWIGTYPE_p_ofTouchEventArgs); }  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->minoraxis = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TouchEventArgs_minoraxis_get(lua_State* L) { int SWIG_arg = 0;
  ofTouchEventArgs *arg1 = (ofTouchEventArgs *) 0 ; float result; SWIG_check_num_args("ofTouchEventArgs::minoraxis",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTouchEventArgs::minoraxis",1,"ofTouchEventArgs *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTouchEventArgs,0))){
    SWIG_fail_ptr("TouchEventArgs_minoraxis_get",1,SWIGTYPE_p_ofTouchEventArgs); }  result = (float) ((arg1)->minoraxis);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TouchEventArgs_majoraxis_set(lua_State* L) { int SWIG_arg = 0;
  ofTouchEventArgs *arg1 = (ofTouchEventArgs *) 0 ; float arg2 ; SWIG_check_num_args("ofTouchEventArgs::majoraxis",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTouchEventArgs::majoraxis",1,"ofTouchEventArgs *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofTouchEventArgs::majoraxis",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTouchEventArgs,0))){
    SWIG_fail_ptr("TouchEventArgs_majoraxis_set",1,SWIGTYPE_p_ofTouchEventArgs); }  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->majoraxis = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TouchEventArgs_majoraxis_get(lua_State* L) { int SWIG_arg = 0;
  ofTouchEventArgs *arg1 = (ofTouchEventArgs *) 0 ; float result; SWIG_check_num_args("ofTouchEventArgs::majoraxis",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTouchEventArgs::majoraxis",1,"ofTouchEventArgs *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTouchEventArgs,0))){
    SWIG_fail_ptr("TouchEventArgs_majoraxis_get",1,SWIGTYPE_p_ofTouchEventArgs); }  result = (float) ((arg1)->majoraxis);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TouchEventArgs_pressure_set(lua_State* L) { int SWIG_arg = 0; ofTouchEventArgs *arg1 = (ofTouchEventArgs *) 0 ;
  float arg2 ; SWIG_check_num_args("ofTouchEventArgs::pressure",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTouchEventArgs::pressure",1,"ofTouchEventArgs *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofTouchEventArgs::pressure",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTouchEventArgs,0))){
    SWIG_fail_ptr("TouchEventArgs_pressure_set",1,SWIGTYPE_p_ofTouchEventArgs); }  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->pressure = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TouchEventArgs_pressure_get(lua_State* L) { int SWIG_arg = 0; ofTouchEventArgs *arg1 = (ofTouchEventArgs *) 0 ;
  float result; SWIG_check_num_args("ofTouchEventArgs::pressure",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTouchEventArgs::pressure",1,"ofTouchEventArgs *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTouchEventArgs,0))){
    SWIG_fail_ptr("TouchEventArgs_pressure_get",1,SWIGTYPE_p_ofTouchEventArgs); }  result = (float) ((arg1)->pressure);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TouchEventArgs_xspeed_set(lua_State* L) { int SWIG_arg = 0; ofTouchEventArgs *arg1 = (ofTouchEventArgs *) 0 ;
  float arg2 ; SWIG_check_num_args("ofTouchEventArgs::xspeed",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTouchEventArgs::xspeed",1,"ofTouchEventArgs *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofTouchEventArgs::xspeed",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTouchEventArgs,0))){
    SWIG_fail_ptr("TouchEventArgs_xspeed_set",1,SWIGTYPE_p_ofTouchEventArgs); }  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->xspeed = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TouchEventArgs_xspeed_get(lua_State* L) { int SWIG_arg = 0; ofTouchEventArgs *arg1 = (ofTouchEventArgs *) 0 ;
  float result; SWIG_check_num_args("ofTouchEventArgs::xspeed",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTouchEventArgs::xspeed",1,"ofTouchEventArgs *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTouchEventArgs,0))){
    SWIG_fail_ptr("TouchEventArgs_xspeed_get",1,SWIGTYPE_p_ofTouchEventArgs); }  result = (float) ((arg1)->xspeed);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TouchEventArgs_yspeed_set(lua_State* L) { int SWIG_arg = 0; ofTouchEventArgs *arg1 = (ofTouchEventArgs *) 0 ;
  float arg2 ; SWIG_check_num_args("ofTouchEventArgs::yspeed",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTouchEventArgs::yspeed",1,"ofTouchEventArgs *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofTouchEventArgs::yspeed",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTouchEventArgs,0))){
    SWIG_fail_ptr("TouchEventArgs_yspeed_set",1,SWIGTYPE_p_ofTouchEventArgs); }  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->yspeed = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TouchEventArgs_yspeed_get(lua_State* L) { int SWIG_arg = 0; ofTouchEventArgs *arg1 = (ofTouchEventArgs *) 0 ;
  float result; SWIG_check_num_args("ofTouchEventArgs::yspeed",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTouchEventArgs::yspeed",1,"ofTouchEventArgs *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTouchEventArgs,0))){
    SWIG_fail_ptr("TouchEventArgs_yspeed_get",1,SWIGTYPE_p_ofTouchEventArgs); }  result = (float) ((arg1)->yspeed);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TouchEventArgs_xaccel_set(lua_State* L) { int SWIG_arg = 0; ofTouchEventArgs *arg1 = (ofTouchEventArgs *) 0 ;
  float arg2 ; SWIG_check_num_args("ofTouchEventArgs::xaccel",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTouchEventArgs::xaccel",1,"ofTouchEventArgs *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofTouchEventArgs::xaccel",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTouchEventArgs,0))){
    SWIG_fail_ptr("TouchEventArgs_xaccel_set",1,SWIGTYPE_p_ofTouchEventArgs); }  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->xaccel = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TouchEventArgs_xaccel_get(lua_State* L) { int SWIG_arg = 0; ofTouchEventArgs *arg1 = (ofTouchEventArgs *) 0 ;
  float result; SWIG_check_num_args("ofTouchEventArgs::xaccel",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTouchEventArgs::xaccel",1,"ofTouchEventArgs *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTouchEventArgs,0))){
    SWIG_fail_ptr("TouchEventArgs_xaccel_get",1,SWIGTYPE_p_ofTouchEventArgs); }  result = (float) ((arg1)->xaccel);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TouchEventArgs_yaccel_set(lua_State* L) { int SWIG_arg = 0; ofTouchEventArgs *arg1 = (ofTouchEventArgs *) 0 ;
  float arg2 ; SWIG_check_num_args("ofTouchEventArgs::yaccel",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTouchEventArgs::yaccel",1,"ofTouchEventArgs *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofTouchEventArgs::yaccel",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTouchEventArgs,0))){
    SWIG_fail_ptr("TouchEventArgs_yaccel_set",1,SWIGTYPE_p_ofTouchEventArgs); }  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->yaccel = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TouchEventArgs_yaccel_get(lua_State* L) { int SWIG_arg = 0; ofTouchEventArgs *arg1 = (ofTouchEventArgs *) 0 ;
  float result; SWIG_check_num_args("ofTouchEventArgs::yaccel",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTouchEventArgs::yaccel",1,"ofTouchEventArgs *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTouchEventArgs,0))){
    SWIG_fail_ptr("TouchEventArgs_yaccel_get",1,SWIGTYPE_p_ofTouchEventArgs); }  result = (float) ((arg1)->yaccel);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static void swig_delete_TouchEventArgs(void *obj) {
ofTouchEventArgs *arg1 = (ofTouchEventArgs *) obj;
delete arg1;
}
static int _proxy__wrap_new_TouchEventArgs(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_TouchEventArgs);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_TouchEventArgs_attributes[] = {
    { "type", _wrap_TouchEventArgs_type_get, _wrap_TouchEventArgs_type_set },
    { "id", _wrap_TouchEventArgs_id_get, _wrap_TouchEventArgs_id_set },
    { "time", _wrap_TouchEventArgs_time_get, _wrap_TouchEventArgs_time_set },
    { "numTouches", _wrap_TouchEventArgs_numTouches_get, _wrap_TouchEventArgs_numTouches_set },
    { "width", _wrap_TouchEventArgs_width_get, _wrap_TouchEventArgs_width_set },
    { "height", _wrap_TouchEventArgs_height_get, _wrap_TouchEventArgs_height_set },
    { "angle", _wrap_TouchEventArgs_angle_get, _wrap_TouchEventArgs_angle_set },
    { "minoraxis", _wrap_TouchEventArgs_minoraxis_get, _wrap_TouchEventArgs_minoraxis_set },
    { "majoraxis", _wrap_TouchEventArgs_majoraxis_get, _wrap_TouchEventArgs_majoraxis_set },
    { "pressure", _wrap_TouchEventArgs_pressure_get, _wrap_TouchEventArgs_pressure_set },
    { "xspeed", _wrap_TouchEventArgs_xspeed_get, _wrap_TouchEventArgs_xspeed_set },
    { "yspeed", _wrap_TouchEventArgs_yspeed_get, _wrap_TouchEventArgs_yspeed_set },
    { "xaccel", _wrap_TouchEventArgs_xaccel_get, _wrap_TouchEventArgs_xaccel_set },
    { "yaccel", _wrap_TouchEventArgs_yaccel_get, _wrap_TouchEventArgs_yaccel_set },
    {0,0,0}
};
static swig_lua_method swig_TouchEventArgs_methods[]= {
    {0,0}
};
static swig_lua_method swig_TouchEventArgs_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_TouchEventArgs_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_TouchEventArgs_Sf_SwigStatic_constants[]= {
    {SWIG_LUA_CONSTTAB_INT("down", ofTouchEventArgs::down)},
    {SWIG_LUA_CONSTTAB_INT("up", ofTouchEventArgs::up)},
    {SWIG_LUA_CONSTTAB_INT("move", ofTouchEventArgs::move)},
    {SWIG_LUA_CONSTTAB_INT("doubleTap", ofTouchEventArgs::doubleTap)},
    {SWIG_LUA_CONSTTAB_INT("cancel", ofTouchEventArgs::cancel)},
    {0,0,0,0,0,0}
};
static swig_lua_method swig_TouchEventArgs_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_TouchEventArgs_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_TouchEventArgs_Sf_SwigStatic = {
    "TouchEventArgs",
    swig_TouchEventArgs_Sf_SwigStatic_methods,
    swig_TouchEventArgs_Sf_SwigStatic_attributes,
    swig_TouchEventArgs_Sf_SwigStatic_constants,
    swig_TouchEventArgs_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_TouchEventArgs_bases[] = {0,0};
static const char *swig_TouchEventArgs_base_names[] = {"glm::vec2 *",0};
static swig_lua_class _wrap_class_TouchEventArgs = { "TouchEventArgs", "TouchEventArgs", &SWIGTYPE_p_ofTouchEventArgs,_proxy__wrap_new_TouchEventArgs, swig_delete_TouchEventArgs, swig_TouchEventArgs_methods, swig_TouchEventArgs_attributes, &swig_TouchEventArgs_Sf_SwigStatic, swig_TouchEventArgs_meta, swig_TouchEventArgs_bases, swig_TouchEventArgs_base_names };

static int _wrap_sendMessage(lua_State* L) { int SWIG_arg = 0; std::string arg1 ; bool result;
  SWIG_check_num_args("ofSendMessage",1,1) if(!lua_isstring(L,1)) SWIG_fail_arg("ofSendMessage",1,"std::string");
  (&arg1)->assign(lua_tostring(L,1),lua_rawlen(L,1)); result = (bool)ofSendMessage(arg1);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_new_BufferObject(lua_State* L) { int SWIG_arg = 0; ofBufferObject *result = 0 ;
  SWIG_check_num_args("ofBufferObject::ofBufferObject",0,0) result = (ofBufferObject *)new ofBufferObject();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofBufferObject,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_BufferObject_allocate__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofBufferObject *arg1 = (ofBufferObject *) 0 ;
  SWIG_check_num_args("ofBufferObject::allocate",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBufferObject::allocate",1,"ofBufferObject *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBufferObject,0))){
    SWIG_fail_ptr("BufferObject_allocate",1,SWIGTYPE_p_ofBufferObject); }  (arg1)->allocate(); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_BufferObject_allocate__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofBufferObject *arg1 = (ofBufferObject *) 0 ;
  GLsizeiptr arg2 ; GLenum arg3 ; GLsizeiptr *argp2 ; SWIG_check_num_args("ofBufferObject::allocate",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBufferObject::allocate",1,"ofBufferObject *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofBufferObject::allocate",2,"GLsizeiptr");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofBufferObject::allocate",3,"GLenum");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBufferObject,0))){
    SWIG_fail_ptr("BufferObject_allocate",1,SWIGTYPE_p_ofBufferObject); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_GLsizeiptr,0))){
    SWIG_fail_ptr("BufferObject_allocate",2,SWIGTYPE_p_GLsizeiptr); }  arg2 = *argp2;
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (GLenum)lua_tonumber(L, 3);
  (arg1)->allocate(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_BufferObject_allocate__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofBufferObject *arg1 = (ofBufferObject *) 0 ;
  GLsizeiptr arg2 ; void *arg3 = (void *) 0 ; GLenum arg4 ; GLsizeiptr *argp2 ;
  SWIG_check_num_args("ofBufferObject::allocate",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBufferObject::allocate",1,"ofBufferObject *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofBufferObject::allocate",2,"GLsizeiptr");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("ofBufferObject::allocate",3,"void const *");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofBufferObject::allocate",4,"GLenum");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBufferObject,0))){
    SWIG_fail_ptr("BufferObject_allocate",1,SWIGTYPE_p_ofBufferObject); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_GLsizeiptr,0))){
    SWIG_fail_ptr("BufferObject_allocate",2,SWIGTYPE_p_GLsizeiptr); }  arg2 = *argp2;
  arg3=(void *)SWIG_MustGetPtr(L,3,0,0,3,"BufferObject_allocate");
  SWIG_contract_assert((lua_tonumber(L,4)>=0),"number must not be negative") arg4 = (GLenum)lua_tonumber(L, 4);
  (arg1)->allocate(arg2,(void const *)arg3,arg4); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_BufferObject_allocate(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L);
  if (argc == 1) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofBufferObject, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { return _wrap_BufferObject_allocate__SWIG_0(L);}  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofBufferObject, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_GLsizeiptr, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_BufferObject_allocate__SWIG_1(L);}  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofBufferObject, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_GLsizeiptr, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { void *ptr;
          if (SWIG_isptrtype(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, 0, 0)) { _v = 0; }  else { _v = 1; }  }
         if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_BufferObject_allocate__SWIG_2(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'BufferObject_allocate'\n"
  "  Possible C/C++ prototypes are:\n" "    ofBufferObject::allocate()\n" "    ofBufferObject::allocate(GLsizeiptr,GLenum)\n"
  "    ofBufferObject::allocate(GLsizeiptr,void const *,GLenum)\n"); lua_error(L);return 0; }
static int _wrap_BufferObject_isAllocated(lua_State* L) { int SWIG_arg = 0; ofBufferObject *arg1 = (ofBufferObject *) 0 ;
  bool result; SWIG_check_num_args("ofBufferObject::isAllocated",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBufferObject::isAllocated",1,"ofBufferObject const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBufferObject,0))){
    SWIG_fail_ptr("BufferObject_isAllocated",1,SWIGTYPE_p_ofBufferObject); } 
  result = (bool)((ofBufferObject const *)arg1)->isAllocated(); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_BufferObject_bind(lua_State* L) { int SWIG_arg = 0; ofBufferObject *arg1 = (ofBufferObject *) 0 ; GLenum arg2 ;
  SWIG_check_num_args("ofBufferObject::bind",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBufferObject::bind",1,"ofBufferObject const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofBufferObject::bind",2,"GLenum");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBufferObject,0))){
    SWIG_fail_ptr("BufferObject_bind",1,SWIGTYPE_p_ofBufferObject); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (GLenum)lua_tonumber(L, 2);
  ((ofBufferObject const *)arg1)->bind(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_BufferObject_unbind(lua_State* L) { int SWIG_arg = 0; ofBufferObject *arg1 = (ofBufferObject *) 0 ;
  GLenum arg2 ; SWIG_check_num_args("ofBufferObject::unbind",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBufferObject::unbind",1,"ofBufferObject const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofBufferObject::unbind",2,"GLenum");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBufferObject,0))){
    SWIG_fail_ptr("BufferObject_unbind",1,SWIGTYPE_p_ofBufferObject); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (GLenum)lua_tonumber(L, 2);
  ((ofBufferObject const *)arg1)->unbind(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_BufferObject_bindBase(lua_State* L) { int SWIG_arg = 0; ofBufferObject *arg1 = (ofBufferObject *) 0 ;
  GLenum arg2 ; GLuint arg3 ; SWIG_check_num_args("ofBufferObject::bindBase",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBufferObject::bindBase",1,"ofBufferObject const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofBufferObject::bindBase",2,"GLenum");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofBufferObject::bindBase",3,"GLuint");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBufferObject,0))){
    SWIG_fail_ptr("BufferObject_bindBase",1,SWIGTYPE_p_ofBufferObject); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (GLenum)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (GLuint)lua_tonumber(L, 3);
  ((ofBufferObject const *)arg1)->bindBase(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_BufferObject_unbindBase(lua_State* L) { int SWIG_arg = 0; ofBufferObject *arg1 = (ofBufferObject *) 0 ;
  GLenum arg2 ; GLuint arg3 ; SWIG_check_num_args("ofBufferObject::unbindBase",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBufferObject::unbindBase",1,"ofBufferObject const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofBufferObject::unbindBase",2,"GLenum");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofBufferObject::unbindBase",3,"GLuint");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBufferObject,0))){
    SWIG_fail_ptr("BufferObject_unbindBase",1,SWIGTYPE_p_ofBufferObject); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (GLenum)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (GLuint)lua_tonumber(L, 3);
  ((ofBufferObject const *)arg1)->unbindBase(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_BufferObject_bindRange(lua_State* L) { int SWIG_arg = 0; ofBufferObject *arg1 = (ofBufferObject *) 0 ;
  GLenum arg2 ; GLuint arg3 ; GLintptr arg4 ; GLsizeiptr arg5 ; GLintptr *argp4 ; GLsizeiptr *argp5 ;
  SWIG_check_num_args("ofBufferObject::bindRange",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBufferObject::bindRange",1,"ofBufferObject const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofBufferObject::bindRange",2,"GLenum");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofBufferObject::bindRange",3,"GLuint");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("ofBufferObject::bindRange",4,"GLintptr");
  if(!lua_isuserdata(L,5)) SWIG_fail_arg("ofBufferObject::bindRange",5,"GLsizeiptr");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBufferObject,0))){
    SWIG_fail_ptr("BufferObject_bindRange",1,SWIGTYPE_p_ofBufferObject); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (GLenum)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (GLuint)lua_tonumber(L, 3);
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&argp4,SWIGTYPE_p_GLintptr,0))){
    SWIG_fail_ptr("BufferObject_bindRange",4,SWIGTYPE_p_GLintptr); }  arg4 = *argp4;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&argp5,SWIGTYPE_p_GLsizeiptr,0))){
    SWIG_fail_ptr("BufferObject_bindRange",5,SWIGTYPE_p_GLsizeiptr); }  arg5 = *argp5;
  ((ofBufferObject const *)arg1)->bindRange(arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_BufferObject_unbindRange(lua_State* L) { int SWIG_arg = 0; ofBufferObject *arg1 = (ofBufferObject *) 0 ;
  GLenum arg2 ; GLuint arg3 ; SWIG_check_num_args("ofBufferObject::unbindRange",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBufferObject::unbindRange",1,"ofBufferObject const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofBufferObject::unbindRange",2,"GLenum");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofBufferObject::unbindRange",3,"GLuint");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBufferObject,0))){
    SWIG_fail_ptr("BufferObject_unbindRange",1,SWIGTYPE_p_ofBufferObject); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (GLenum)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (GLuint)lua_tonumber(L, 3);
  ((ofBufferObject const *)arg1)->unbindRange(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_BufferObject_getId(lua_State* L) { int SWIG_arg = 0; ofBufferObject *arg1 = (ofBufferObject *) 0 ;
  GLuint result; SWIG_check_num_args("ofBufferObject::getId",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBufferObject::getId",1,"ofBufferObject const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBufferObject,0))){
    SWIG_fail_ptr("BufferObject_getId",1,SWIGTYPE_p_ofBufferObject); } 
  result = (GLuint)((ofBufferObject const *)arg1)->getId(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_BufferObject_setData(lua_State* L) { int SWIG_arg = 0; ofBufferObject *arg1 = (ofBufferObject *) 0 ;
  GLsizeiptr arg2 ; void *arg3 = (void *) 0 ; GLenum arg4 ; GLsizeiptr *argp2 ;
  SWIG_check_num_args("ofBufferObject::setData",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBufferObject::setData",1,"ofBufferObject *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofBufferObject::setData",2,"GLsizeiptr");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("ofBufferObject::setData",3,"void const *");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofBufferObject::setData",4,"GLenum");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBufferObject,0))){
    SWIG_fail_ptr("BufferObject_setData",1,SWIGTYPE_p_ofBufferObject); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_GLsizeiptr,0))){
    SWIG_fail_ptr("BufferObject_setData",2,SWIGTYPE_p_GLsizeiptr); }  arg2 = *argp2;
  arg3=(void *)SWIG_MustGetPtr(L,3,0,0,3,"BufferObject_setData");
  SWIG_contract_assert((lua_tonumber(L,4)>=0),"number must not be negative") arg4 = (GLenum)lua_tonumber(L, 4);
  (arg1)->setData(arg2,(void const *)arg3,arg4); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_BufferObject_updateData__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofBufferObject *arg1 = (ofBufferObject *) 0 ;
  GLintptr arg2 ; GLsizeiptr arg3 ; void *arg4 = (void *) 0 ; GLintptr *argp2 ; GLsizeiptr *argp3 ;
  SWIG_check_num_args("ofBufferObject::updateData",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBufferObject::updateData",1,"ofBufferObject *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofBufferObject::updateData",2,"GLintptr");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofBufferObject::updateData",3,"GLsizeiptr");
  if(!SWIG_isptrtype(L,4)) SWIG_fail_arg("ofBufferObject::updateData",4,"void const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBufferObject,0))){
    SWIG_fail_ptr("BufferObject_updateData",1,SWIGTYPE_p_ofBufferObject); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_GLintptr,0))){
    SWIG_fail_ptr("BufferObject_updateData",2,SWIGTYPE_p_GLintptr); }  arg2 = *argp2;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_GLsizeiptr,0))){
    SWIG_fail_ptr("BufferObject_updateData",3,SWIGTYPE_p_GLsizeiptr); }  arg3 = *argp3;
  arg4=(void *)SWIG_MustGetPtr(L,4,0,0,4,"BufferObject_updateData"); (arg1)->updateData(arg2,arg3,(void const *)arg4);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_BufferObject_updateData__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofBufferObject *arg1 = (ofBufferObject *) 0 ;
  GLsizeiptr arg2 ; void *arg3 = (void *) 0 ; GLsizeiptr *argp2 ; SWIG_check_num_args("ofBufferObject::updateData",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBufferObject::updateData",1,"ofBufferObject *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofBufferObject::updateData",2,"GLsizeiptr");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("ofBufferObject::updateData",3,"void const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBufferObject,0))){
    SWIG_fail_ptr("BufferObject_updateData",1,SWIGTYPE_p_ofBufferObject); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_GLsizeiptr,0))){
    SWIG_fail_ptr("BufferObject_updateData",2,SWIGTYPE_p_GLsizeiptr); }  arg2 = *argp2;
  arg3=(void *)SWIG_MustGetPtr(L,3,0,0,3,"BufferObject_updateData"); (arg1)->updateData(arg2,(void const *)arg3);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_BufferObject_updateData(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L);
  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofBufferObject, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_GLsizeiptr, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { void *ptr;
          if (SWIG_isptrtype(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, 0, 0)) { _v = 0; }  else { _v = 1; }  }
         if (_v) { return _wrap_BufferObject_updateData__SWIG_1(L);}  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofBufferObject, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_GLintptr, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_GLsizeiptr, 0)) { _v = 0; }
           else { _v = 1; }  }  if (_v) { { void *ptr;
            if (SWIG_isptrtype(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, 0, 0)) { _v = 0; }  else { _v = 1; }
             }  if (_v) { return _wrap_BufferObject_updateData__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'BufferObject_updateData'\n"
  "  Possible C/C++ prototypes are:\n" "    ofBufferObject::updateData(GLintptr,GLsizeiptr,void const *)\n"
  "    ofBufferObject::updateData(GLsizeiptr,void const *)\n"); lua_error(L);return 0; }
static int _wrap_BufferObject_map(lua_State* L) { int SWIG_arg = 0; ofBufferObject *arg1 = (ofBufferObject *) 0 ; GLenum arg2 ;
  void *result = 0 ; SWIG_check_num_args("ofBufferObject::map",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBufferObject::map",1,"ofBufferObject *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofBufferObject::map",2,"GLenum");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBufferObject,0))){
    SWIG_fail_ptr("BufferObject_map",1,SWIGTYPE_p_ofBufferObject); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (GLenum)lua_tonumber(L, 2);
  result = (void *)(arg1)->map(arg2); SWIG_NewPointerObj(L,result,SWIGTYPE_p_void,0); SWIG_arg++;  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_BufferObject_unmap(lua_State* L) { int SWIG_arg = 0; ofBufferObject *arg1 = (ofBufferObject *) 0 ;
  SWIG_check_num_args("ofBufferObject::unmap",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBufferObject::unmap",1,"ofBufferObject *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBufferObject,0))){
    SWIG_fail_ptr("BufferObject_unmap",1,SWIGTYPE_p_ofBufferObject); }  (arg1)->unmap(); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_BufferObject_mapRange(lua_State* L) { int SWIG_arg = 0; ofBufferObject *arg1 = (ofBufferObject *) 0 ;
  GLintptr arg2 ; GLsizeiptr arg3 ; GLenum arg4 ; GLintptr *argp2 ; GLsizeiptr *argp3 ; void *result = 0 ;
  SWIG_check_num_args("ofBufferObject::mapRange",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBufferObject::mapRange",1,"ofBufferObject *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofBufferObject::mapRange",2,"GLintptr");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofBufferObject::mapRange",3,"GLsizeiptr");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofBufferObject::mapRange",4,"GLenum");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBufferObject,0))){
    SWIG_fail_ptr("BufferObject_mapRange",1,SWIGTYPE_p_ofBufferObject); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_GLintptr,0))){
    SWIG_fail_ptr("BufferObject_mapRange",2,SWIGTYPE_p_GLintptr); }  arg2 = *argp2;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_GLsizeiptr,0))){
    SWIG_fail_ptr("BufferObject_mapRange",3,SWIGTYPE_p_GLsizeiptr); }  arg3 = *argp3;
  SWIG_contract_assert((lua_tonumber(L,4)>=0),"number must not be negative") arg4 = (GLenum)lua_tonumber(L, 4);
  result = (void *)(arg1)->mapRange(arg2,arg3,arg4); SWIG_NewPointerObj(L,result,SWIGTYPE_p_void,0); SWIG_arg++; 
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_BufferObject_unmapRange(lua_State* L) { int SWIG_arg = 0; ofBufferObject *arg1 = (ofBufferObject *) 0 ;
  SWIG_check_num_args("ofBufferObject::unmapRange",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBufferObject::unmapRange",1,"ofBufferObject *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBufferObject,0))){
    SWIG_fail_ptr("BufferObject_unmapRange",1,SWIGTYPE_p_ofBufferObject); }  (arg1)->unmapRange(); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_BufferObject_copyTo__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofBufferObject *arg1 = (ofBufferObject *) 0 ;
  ofBufferObject *arg2 = 0 ; SWIG_check_num_args("ofBufferObject::copyTo",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBufferObject::copyTo",1,"ofBufferObject const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofBufferObject::copyTo",2,"ofBufferObject &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBufferObject,0))){
    SWIG_fail_ptr("BufferObject_copyTo",1,SWIGTYPE_p_ofBufferObject); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofBufferObject,0))){
    SWIG_fail_ptr("BufferObject_copyTo",2,SWIGTYPE_p_ofBufferObject); }  ((ofBufferObject const *)arg1)->copyTo(*arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_BufferObject_copyTo__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofBufferObject *arg1 = (ofBufferObject *) 0 ;
  ofBufferObject *arg2 = 0 ; int arg3 ; int arg4 ; size_t arg5 ; SWIG_check_num_args("ofBufferObject::copyTo",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBufferObject::copyTo",1,"ofBufferObject const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofBufferObject::copyTo",2,"ofBufferObject &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofBufferObject::copyTo",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofBufferObject::copyTo",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofBufferObject::copyTo",5,"size_t");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBufferObject,0))){
    SWIG_fail_ptr("BufferObject_copyTo",1,SWIGTYPE_p_ofBufferObject); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofBufferObject,0))){
    SWIG_fail_ptr("BufferObject_copyTo",2,SWIGTYPE_p_ofBufferObject); }  arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4); SWIG_contract_assert((lua_tonumber(L,5)>=0),"number must not be negative")
  arg5 = (size_t)lua_tonumber(L, 5); ((ofBufferObject const *)arg1)->copyTo(*arg2,arg3,arg4,arg5); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_BufferObject_copyTo(lua_State* L) { int argc; int argv[6]={ 1,2,3,4,5,6} ; argc = lua_gettop(L);
  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofBufferObject, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofBufferObject, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_BufferObject_copyTo__SWIG_0(L);}  }  }  if (argc == 5) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofBufferObject, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofBufferObject, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); } 
          if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) { return _wrap_BufferObject_copyTo__SWIG_1(L);}  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'BufferObject_copyTo'\n"
  "  Possible C/C++ prototypes are:\n" "    ofBufferObject::copyTo(ofBufferObject &) const\n"
  "    ofBufferObject::copyTo(ofBufferObject &,int,int,size_t) const\n"); lua_error(L);return 0; }
static int _wrap_BufferObject_invalidate(lua_State* L) { int SWIG_arg = 0; ofBufferObject *arg1 = (ofBufferObject *) 0 ;
  SWIG_check_num_args("ofBufferObject::invalidate",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBufferObject::invalidate",1,"ofBufferObject *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBufferObject,0))){
    SWIG_fail_ptr("BufferObject_invalidate",1,SWIGTYPE_p_ofBufferObject); }  (arg1)->invalidate(); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_BufferObject_size(lua_State* L) { int SWIG_arg = 0; ofBufferObject *arg1 = (ofBufferObject *) 0 ;
  GLsizeiptr result; SWIG_check_num_args("ofBufferObject::size",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBufferObject::size",1,"ofBufferObject const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBufferObject,0))){
    SWIG_fail_ptr("BufferObject_size",1,SWIGTYPE_p_ofBufferObject); }  result = ((ofBufferObject const *)arg1)->size(); {
    GLsizeiptr * resultptr = new GLsizeiptr((const GLsizeiptr &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_GLsizeiptr,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static void swig_delete_BufferObject(void *obj) {
ofBufferObject *arg1 = (ofBufferObject *) obj;
delete arg1;
}
static int _proxy__wrap_new_BufferObject(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_BufferObject);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_BufferObject_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_BufferObject_methods[]= {
    { "allocate", _wrap_BufferObject_allocate},
    { "isAllocated", _wrap_BufferObject_isAllocated},
    { "bind", _wrap_BufferObject_bind},
    { "unbind", _wrap_BufferObject_unbind},
    { "bindBase", _wrap_BufferObject_bindBase},
    { "unbindBase", _wrap_BufferObject_unbindBase},
    { "bindRange", _wrap_BufferObject_bindRange},
    { "unbindRange", _wrap_BufferObject_unbindRange},
    { "getId", _wrap_BufferObject_getId},
    { "setData", _wrap_BufferObject_setData},
    { "updateData", _wrap_BufferObject_updateData},
    { "map", _wrap_BufferObject_map},
    { "unmap", _wrap_BufferObject_unmap},
    { "mapRange", _wrap_BufferObject_mapRange},
    { "unmapRange", _wrap_BufferObject_unmapRange},
    { "copyTo", _wrap_BufferObject_copyTo},
    { "invalidate", _wrap_BufferObject_invalidate},
    { "size", _wrap_BufferObject_size},
    {0,0}
};
static swig_lua_method swig_BufferObject_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_BufferObject_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_BufferObject_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_BufferObject_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_BufferObject_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_BufferObject_Sf_SwigStatic = {
    "BufferObject",
    swig_BufferObject_Sf_SwigStatic_methods,
    swig_BufferObject_Sf_SwigStatic_attributes,
    swig_BufferObject_Sf_SwigStatic_constants,
    swig_BufferObject_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_BufferObject_bases[] = {0};
static const char *swig_BufferObject_base_names[] = {0};
static swig_lua_class _wrap_class_BufferObject = { "BufferObject", "BufferObject", &SWIGTYPE_p_ofBufferObject,_proxy__wrap_new_BufferObject, swig_delete_BufferObject, swig_BufferObject_methods, swig_BufferObject_attributes, &swig_BufferObject_Sf_SwigStatic, swig_BufferObject_meta, swig_BufferObject_bases, swig_BufferObject_base_names };

static int _wrap_getGLInternalFormat__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofPixels *arg1 = 0 ; int result;
  SWIG_check_num_args("ofGetGLInternalFormat",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofGetGLInternalFormat",1,"ofPixels const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0))){
    SWIG_fail_ptr("getGLInternalFormat",1,SWIGTYPE_p_ofPixels_T_unsigned_char_t); } 
  result = (int)ofGetGLInternalFormat((ofPixels_< unsigned char > const &)*arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_getGLInternalFormat__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofShortPixels *arg1 = 0 ; int result;
  SWIG_check_num_args("ofGetGLInternalFormat",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofGetGLInternalFormat",1,"ofShortPixels const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_short_t,0))){
    SWIG_fail_ptr("getGLInternalFormat",1,SWIGTYPE_p_ofPixels_T_unsigned_short_t); } 
  result = (int)ofGetGLInternalFormat((ofPixels_< unsigned short > const &)*arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_getGLInternalFormat__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofFloatPixels *arg1 = 0 ; int result;
  SWIG_check_num_args("ofGetGLInternalFormat",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofGetGLInternalFormat",1,"ofFloatPixels const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_float_t,0))){
    SWIG_fail_ptr("getGLInternalFormat",1,SWIGTYPE_p_ofPixels_T_float_t); } 
  result = (int)ofGetGLInternalFormat((ofPixels_< float > const &)*arg1); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_getGLInternalFormat(lua_State* L) { int argc; int argv[2]={ 1,2} ; argc = lua_gettop(L); if (argc == 1) {
    int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofPixels_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_getGLInternalFormat__SWIG_0(L);}  }  if (argc == 1) { int _v; {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofPixels_T_unsigned_short_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_getGLInternalFormat__SWIG_1(L);}  }  if (argc == 1) { int _v; {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofPixels_T_float_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_getGLInternalFormat__SWIG_2(L);}  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'getGLInternalFormat'\n"
  "  Possible C/C++ prototypes are:\n" "    ofGetGLInternalFormat(ofPixels const &)\n"
  "    ofGetGLInternalFormat(ofShortPixels const &)\n" "    ofGetGLInternalFormat(ofFloatPixels const &)\n");
  lua_error(L);return 0; }
static int _wrap_getGLInternalFormatName(lua_State* L) { int SWIG_arg = 0; int arg1 ; std::string result;
  SWIG_check_num_args("ofGetGLInternalFormatName",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofGetGLInternalFormatName",1,"int"); arg1 = (int)lua_tonumber(L, 1);
  result = ofGetGLInternalFormatName(arg1); lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_getGLFormatFromInternal(lua_State* L) { int SWIG_arg = 0; int arg1 ; int result;
  SWIG_check_num_args("ofGetGLFormatFromInternal",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofGetGLFormatFromInternal",1,"int"); arg1 = (int)lua_tonumber(L, 1);
  result = (int)ofGetGLFormatFromInternal(arg1); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_getGLTypeFromInternal(lua_State* L) { int SWIG_arg = 0; int arg1 ; int result;
  SWIG_check_num_args("ofGetGLTypeFromInternal",1,1) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofGetGLTypeFromInternal",1,"int");
  arg1 = (int)lua_tonumber(L, 1); result = (int)ofGetGLTypeFromInternal(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_getGLType__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofPixels *arg1 = 0 ; int result;
  SWIG_check_num_args("ofGetGLType",1,1) if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofGetGLType",1,"ofPixels const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0))){
    SWIG_fail_ptr("getGLType",1,SWIGTYPE_p_ofPixels_T_unsigned_char_t); } 
  result = (int)ofGetGLType((ofPixels_< unsigned char > const &)*arg1); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_getGLType__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofShortPixels *arg1 = 0 ; int result;
  SWIG_check_num_args("ofGetGLType",1,1) if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofGetGLType",1,"ofShortPixels const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_short_t,0))){
    SWIG_fail_ptr("getGLType",1,SWIGTYPE_p_ofPixels_T_unsigned_short_t); } 
  result = (int)ofGetGLType((ofPixels_< unsigned short > const &)*arg1); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_getGLType__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofFloatPixels *arg1 = 0 ; int result;
  SWIG_check_num_args("ofGetGLType",1,1) if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofGetGLType",1,"ofFloatPixels const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_float_t,0))){
    SWIG_fail_ptr("getGLType",1,SWIGTYPE_p_ofPixels_T_float_t); }  result = (int)ofGetGLType((ofPixels_< float > const &)*arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_getGLType(lua_State* L) { int argc; int argv[2]={ 1,2} ; argc = lua_gettop(L); if (argc == 1) { int _v; {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofPixels_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_getGLType__SWIG_0(L);}  }  if (argc == 1) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofPixels_T_unsigned_short_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_getGLType__SWIG_1(L);}  }  if (argc == 1) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofPixels_T_float_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_getGLType__SWIG_2(L);}  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'getGLType'\n" "  Possible C/C++ prototypes are:\n"
  "    ofGetGLType(ofPixels const &)\n" "    ofGetGLType(ofShortPixels const &)\n" "    ofGetGLType(ofFloatPixels const &)\n");
  lua_error(L);return 0; }
static int _wrap_getImageTypeFromGLType(lua_State* L) { int SWIG_arg = 0; int arg1 ; ofImageType result;
  SWIG_check_num_args("ofGetImageTypeFromGLType",1,1) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofGetImageTypeFromGLType",1,"int");
  arg1 = (int)lua_tonumber(L, 1); result = (ofImageType)ofGetImageTypeFromGLType(arg1);
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_getGLPolyMode(lua_State* L) { int SWIG_arg = 0; ofPolyRenderMode arg1 ; GLuint result;
  SWIG_check_num_args("ofGetGLPolyMode",1,1) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofGetGLPolyMode",1,"ofPolyRenderMode");
  arg1 = (ofPolyRenderMode)(int)lua_tonumber(L, 1); result = (GLuint)ofGetGLPolyMode(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_getOFPolyMode(lua_State* L) { int SWIG_arg = 0; GLuint arg1 ; ofPolyRenderMode result;
  SWIG_check_num_args("ofGetOFPolyMode",1,1) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofGetOFPolyMode",1,"GLuint");
  SWIG_contract_assert((lua_tonumber(L,1)>=0),"number must not be negative") arg1 = (GLuint)lua_tonumber(L, 1);
  result = (ofPolyRenderMode)ofGetOFPolyMode(arg1); lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_getGLPrimitiveMode(lua_State* L) { int SWIG_arg = 0; ofPrimitiveMode arg1 ; GLuint result;
  SWIG_check_num_args("ofGetGLPrimitiveMode",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofGetGLPrimitiveMode",1,"ofPrimitiveMode");
  arg1 = (ofPrimitiveMode)(int)lua_tonumber(L, 1); result = (GLuint)ofGetGLPrimitiveMode(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_getOFPrimitiveMode(lua_State* L) { int SWIG_arg = 0; GLuint arg1 ; ofPrimitiveMode result;
  SWIG_check_num_args("ofGetOFPrimitiveMode",1,1) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofGetOFPrimitiveMode",1,"GLuint");
  SWIG_contract_assert((lua_tonumber(L,1)>=0),"number must not be negative") arg1 = (GLuint)lua_tonumber(L, 1);
  result = (ofPrimitiveMode)ofGetOFPrimitiveMode(arg1); lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_getGLInternalFormatFromPixelFormat(lua_State* L) { int SWIG_arg = 0; ofPixelFormat arg1 ; int result;
  SWIG_check_num_args("ofGetGLInternalFormatFromPixelFormat",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofGetGLInternalFormatFromPixelFormat",1,"ofPixelFormat");
  arg1 = (ofPixelFormat)(int)lua_tonumber(L, 1); result = (int)ofGetGLInternalFormatFromPixelFormat(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_getGLFormatFromPixelFormat(lua_State* L) { int SWIG_arg = 0; ofPixelFormat arg1 ; int result;
  SWIG_check_num_args("ofGetGLFormatFromPixelFormat",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofGetGLFormatFromPixelFormat",1,"ofPixelFormat");
  arg1 = (ofPixelFormat)(int)lua_tonumber(L, 1); result = (int)ofGetGLFormatFromPixelFormat(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_getBytesPerChannelFromGLType(lua_State* L) { int SWIG_arg = 0; int arg1 ; int result;
  SWIG_check_num_args("ofGetBytesPerChannelFromGLType",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofGetBytesPerChannelFromGLType",1,"int"); arg1 = (int)lua_tonumber(L, 1);
  result = (int)ofGetBytesPerChannelFromGLType(arg1); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_getNumChannelsFromGLFormat(lua_State* L) { int SWIG_arg = 0; int arg1 ; int result;
  SWIG_check_num_args("ofGetNumChannelsFromGLFormat",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofGetNumChannelsFromGLFormat",1,"int"); arg1 = (int)lua_tonumber(L, 1);
  result = (int)ofGetNumChannelsFromGLFormat(arg1); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_setPixelStoreiAlignment__SWIG_0(lua_State* L) { int SWIG_arg = 0; GLenum arg1 ; int arg2 ; int arg3 ;
  int arg4 ; SWIG_check_num_args("ofSetPixelStoreiAlignment",4,4)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofSetPixelStoreiAlignment",1,"GLenum");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofSetPixelStoreiAlignment",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofSetPixelStoreiAlignment",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofSetPixelStoreiAlignment",4,"int");
  SWIG_contract_assert((lua_tonumber(L,1)>=0),"number must not be negative") arg1 = (GLenum)lua_tonumber(L, 1);
  arg2 = (int)lua_tonumber(L, 2); arg3 = (int)lua_tonumber(L, 3); arg4 = (int)lua_tonumber(L, 4);
  ofSetPixelStoreiAlignment(arg1,arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_setPixelStoreiAlignment__SWIG_1(lua_State* L) { int SWIG_arg = 0; GLenum arg1 ; int arg2 ;
  SWIG_check_num_args("ofSetPixelStoreiAlignment",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofSetPixelStoreiAlignment",1,"GLenum");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofSetPixelStoreiAlignment",2,"int");
  SWIG_contract_assert((lua_tonumber(L,1)>=0),"number must not be negative") arg1 = (GLenum)lua_tonumber(L, 1);
  arg2 = (int)lua_tonumber(L, 2); ofSetPixelStoreiAlignment(arg1,arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_setPixelStoreiAlignment(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L);
  if (argc == 2) { int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_setPixelStoreiAlignment__SWIG_1(L);}  }  }  if (argc == 4) { int _v; { _v = lua_isnumber(L,argv[0]); } 
    if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { {
            _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_setPixelStoreiAlignment__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'setPixelStoreiAlignment'\n"
  "  Possible C/C++ prototypes are:\n" "    ofSetPixelStoreiAlignment(GLenum,int,int,int)\n"
  "    ofSetPixelStoreiAlignment(GLenum,int)\n"); lua_error(L);return 0; }
static int _wrap_GLSupportedExtensions(lua_State* L) { int SWIG_arg = 0; std::vector< std::string > result;
  SWIG_check_num_args("ofGLSupportedExtensions",0,0) result = ofGLSupportedExtensions(); {
    std::vector< std::string > * resultptr = new std::vector< std::string >((const std::vector< std::string > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_std__vectorT_std__string_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_GLCheckExtension(lua_State* L) { int SWIG_arg = 0; std::string arg1 ; bool result;
  SWIG_check_num_args("ofGLCheckExtension",1,1) if(!lua_isstring(L,1)) SWIG_fail_arg("ofGLCheckExtension",1,"std::string");
  (&arg1)->assign(lua_tostring(L,1),lua_rawlen(L,1)); result = (bool)ofGLCheckExtension(arg1);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_GLSupportsNPOTTextures(lua_State* L) { int SWIG_arg = 0; bool result;
  SWIG_check_num_args("ofGLSupportsNPOTTextures",0,0) result = (bool)ofGLSupportsNPOTTextures();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_isGLProgrammableRenderer(lua_State* L) { int SWIG_arg = 0; bool result;
  SWIG_check_num_args("ofIsGLProgrammableRenderer",0,0) result = (bool)ofIsGLProgrammableRenderer();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_GLSLVersionFromGL(lua_State* L) { int SWIG_arg = 0; int arg1 ; int arg2 ; std::string result;
  SWIG_check_num_args("ofGLSLVersionFromGL",2,2) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofGLSLVersionFromGL",1,"int");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofGLSLVersionFromGL",2,"int"); arg1 = (int)lua_tonumber(L, 1);
  arg2 = (int)lua_tonumber(L, 2); result = ofGLSLVersionFromGL(arg1,arg2);
  lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_enableGLDebugLog(lua_State* L) { int SWIG_arg = 0; SWIG_check_num_args("ofEnableGLDebugLog",0,0)
  ofEnableGLDebugLog(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_disableGLDebugLog(lua_State* L) { int SWIG_arg = 0; SWIG_check_num_args("ofDisableGLDebugLog",0,0)
  ofDisableGLDebugLog(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_enableLighting(lua_State* L) { int SWIG_arg = 0; SWIG_check_num_args("ofEnableLighting",0,0)
  ofEnableLighting(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_disableLighting(lua_State* L) { int SWIG_arg = 0; SWIG_check_num_args("ofDisableLighting",0,0)
  ofDisableLighting(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_enableSeparateSpecularLight(lua_State* L) { int SWIG_arg = 0;
  SWIG_check_num_args("ofEnableSeparateSpecularLight",0,0) ofEnableSeparateSpecularLight(); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_disableSeparateSpecularLight(lua_State* L) { int SWIG_arg = 0;
  SWIG_check_num_args("ofDisableSeparateSpecularLight",0,0) ofDisableSeparateSpecularLight(); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_getLightingEnabled(lua_State* L) { int SWIG_arg = 0; bool result;
  SWIG_check_num_args("ofGetLightingEnabled",0,0) result = (bool)ofGetLightingEnabled();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_setSmoothLighting(lua_State* L) { int SWIG_arg = 0; bool arg1 ; SWIG_check_num_args("ofSetSmoothLighting",1,1)
  if(!lua_isboolean(L,1)) SWIG_fail_arg("ofSetSmoothLighting",1,"bool"); arg1 = (lua_toboolean(L, 1)!=0);
  ofSetSmoothLighting(arg1); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_setGlobalAmbientColor(lua_State* L) { int SWIG_arg = 0; ofFloatColor *arg1 = 0 ;
  SWIG_check_num_args("ofSetGlobalAmbientColor",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofSetGlobalAmbientColor",1,"ofFloatColor const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("setGlobalAmbientColor",1,SWIGTYPE_p_ofColor_T_float_t); } 
  ofSetGlobalAmbientColor((ofColor_< float > const &)*arg1); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_getGlobalAmbientColor(lua_State* L) { int SWIG_arg = 0; ofFloatColor *result = 0 ;
  SWIG_check_num_args("ofGetGlobalAmbientColor",0,0) result = (ofFloatColor *) &ofGetGlobalAmbientColor();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_Light(lua_State* L) { int SWIG_arg = 0; ofLight *result = 0 ; SWIG_check_num_args("ofLight::ofLight",0,0)
  result = (ofLight *)new ofLight(); SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofLight,1); SWIG_arg++;  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Light_setup(lua_State* L) { int SWIG_arg = 0; ofLight *arg1 = (ofLight *) 0 ;
  SWIG_check_num_args("ofLight::setup",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofLight::setup",1,"ofLight *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofLight,0))){ SWIG_fail_ptr("Light_setup",1,SWIGTYPE_p_ofLight); }
   (arg1)->setup(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Light_enable(lua_State* L) { int SWIG_arg = 0; ofLight *arg1 = (ofLight *) 0 ;
  SWIG_check_num_args("ofLight::enable",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofLight::enable",1,"ofLight *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofLight,0))){ SWIG_fail_ptr("Light_enable",1,SWIGTYPE_p_ofLight); }
   (arg1)->enable(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Light_disable(lua_State* L) { int SWIG_arg = 0; ofLight *arg1 = (ofLight *) 0 ;
  SWIG_check_num_args("ofLight::disable",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofLight::disable",1,"ofLight *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofLight,0))){
    SWIG_fail_ptr("Light_disable",1,SWIGTYPE_p_ofLight); }  (arg1)->disable(); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Light_getIsEnabled(lua_State* L) { int SWIG_arg = 0; ofLight *arg1 = (ofLight *) 0 ; bool result;
  SWIG_check_num_args("ofLight::getIsEnabled",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofLight::getIsEnabled",1,"ofLight const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofLight,0))){
    SWIG_fail_ptr("Light_getIsEnabled",1,SWIGTYPE_p_ofLight); }  result = (bool)((ofLight const *)arg1)->getIsEnabled();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Light_setDirectional(lua_State* L) { int SWIG_arg = 0; ofLight *arg1 = (ofLight *) 0 ;
  SWIG_check_num_args("ofLight::setDirectional",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofLight::setDirectional",1,"ofLight *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofLight,0))){
    SWIG_fail_ptr("Light_setDirectional",1,SWIGTYPE_p_ofLight); }  (arg1)->setDirectional(); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Light_getIsDirectional(lua_State* L) { int SWIG_arg = 0; ofLight *arg1 = (ofLight *) 0 ; bool result;
  SWIG_check_num_args("ofLight::getIsDirectional",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofLight::getIsDirectional",1,"ofLight const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofLight,0))){
    SWIG_fail_ptr("Light_getIsDirectional",1,SWIGTYPE_p_ofLight); }  result = (bool)((ofLight const *)arg1)->getIsDirectional();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Light_setSpotlight__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofLight *arg1 = (ofLight *) 0 ; float arg2 ;
  float arg3 ; SWIG_check_num_args("ofLight::setSpotlight",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofLight::setSpotlight",1,"ofLight *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofLight::setSpotlight",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofLight::setSpotlight",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofLight,0))){
    SWIG_fail_ptr("Light_setSpotlight",1,SWIGTYPE_p_ofLight); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); (arg1)->setSpotlight(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Light_setSpotlight__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofLight *arg1 = (ofLight *) 0 ; float arg2 ;
  SWIG_check_num_args("ofLight::setSpotlight",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofLight::setSpotlight",1,"ofLight *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofLight::setSpotlight",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofLight,0))){
    SWIG_fail_ptr("Light_setSpotlight",1,SWIGTYPE_p_ofLight); }  arg2 = (float)lua_tonumber(L, 2); (arg1)->setSpotlight(arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Light_setSpotlight__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofLight *arg1 = (ofLight *) 0 ;
  SWIG_check_num_args("ofLight::setSpotlight",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofLight::setSpotlight",1,"ofLight *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofLight,0))){
    SWIG_fail_ptr("Light_setSpotlight",1,SWIGTYPE_p_ofLight); }  (arg1)->setSpotlight(); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Light_setSpotlight(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 1) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofLight, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { return _wrap_Light_setSpotlight__SWIG_2(L);}  }  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofLight, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { return _wrap_Light_setSpotlight__SWIG_1(L);}  }  } 
  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofLight, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_Light_setSpotlight__SWIG_0(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Light_setSpotlight'\n" "  Possible C/C++ prototypes are:\n"
  "    ofLight::setSpotlight(float,float)\n" "    ofLight::setSpotlight(float)\n" "    ofLight::setSpotlight()\n");
  lua_error(L);return 0; }
static int _wrap_Light_getIsSpotlight(lua_State* L) { int SWIG_arg = 0; ofLight *arg1 = (ofLight *) 0 ; bool result;
  SWIG_check_num_args("ofLight::getIsSpotlight",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofLight::getIsSpotlight",1,"ofLight const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofLight,0))){
    SWIG_fail_ptr("Light_getIsSpotlight",1,SWIGTYPE_p_ofLight); }  result = (bool)((ofLight const *)arg1)->getIsSpotlight();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Light_setSpotlightCutOff(lua_State* L) { int SWIG_arg = 0; ofLight *arg1 = (ofLight *) 0 ; float arg2 ;
  SWIG_check_num_args("ofLight::setSpotlightCutOff",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofLight::setSpotlightCutOff",1,"ofLight *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofLight::setSpotlightCutOff",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofLight,0))){
    SWIG_fail_ptr("Light_setSpotlightCutOff",1,SWIGTYPE_p_ofLight); }  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setSpotlightCutOff(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Light_getSpotlightCutOff(lua_State* L) { int SWIG_arg = 0; ofLight *arg1 = (ofLight *) 0 ; float result;
  SWIG_check_num_args("ofLight::getSpotlightCutOff",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofLight::getSpotlightCutOff",1,"ofLight const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofLight,0))){
    SWIG_fail_ptr("Light_getSpotlightCutOff",1,SWIGTYPE_p_ofLight); } 
  result = (float)((ofLight const *)arg1)->getSpotlightCutOff(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Light_setSpotConcentration(lua_State* L) { int SWIG_arg = 0; ofLight *arg1 = (ofLight *) 0 ; float arg2 ;
  SWIG_check_num_args("ofLight::setSpotConcentration",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofLight::setSpotConcentration",1,"ofLight *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofLight::setSpotConcentration",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofLight,0))){
    SWIG_fail_ptr("Light_setSpotConcentration",1,SWIGTYPE_p_ofLight); }  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setSpotConcentration(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Light_getSpotConcentration(lua_State* L) { int SWIG_arg = 0; ofLight *arg1 = (ofLight *) 0 ; float result;
  SWIG_check_num_args("ofLight::getSpotConcentration",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofLight::getSpotConcentration",1,"ofLight const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofLight,0))){
    SWIG_fail_ptr("Light_getSpotConcentration",1,SWIGTYPE_p_ofLight); } 
  result = (float)((ofLight const *)arg1)->getSpotConcentration(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Light_setPointLight(lua_State* L) { int SWIG_arg = 0; ofLight *arg1 = (ofLight *) 0 ;
  SWIG_check_num_args("ofLight::setPointLight",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofLight::setPointLight",1,"ofLight *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofLight,0))){
    SWIG_fail_ptr("Light_setPointLight",1,SWIGTYPE_p_ofLight); }  (arg1)->setPointLight(); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Light_getIsPointLight(lua_State* L) { int SWIG_arg = 0; ofLight *arg1 = (ofLight *) 0 ; bool result;
  SWIG_check_num_args("ofLight::getIsPointLight",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofLight::getIsPointLight",1,"ofLight const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofLight,0))){
    SWIG_fail_ptr("Light_getIsPointLight",1,SWIGTYPE_p_ofLight); }  result = (bool)((ofLight const *)arg1)->getIsPointLight();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Light_setAttenuation__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofLight *arg1 = (ofLight *) 0 ; float arg2 ;
  float arg3 ; float arg4 ; SWIG_check_num_args("ofLight::setAttenuation",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofLight::setAttenuation",1,"ofLight *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofLight::setAttenuation",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofLight::setAttenuation",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofLight::setAttenuation",4,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofLight,0))){
    SWIG_fail_ptr("Light_setAttenuation",1,SWIGTYPE_p_ofLight); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); (arg1)->setAttenuation(arg2,arg3,arg4); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Light_setAttenuation__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofLight *arg1 = (ofLight *) 0 ; float arg2 ;
  float arg3 ; SWIG_check_num_args("ofLight::setAttenuation",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofLight::setAttenuation",1,"ofLight *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofLight::setAttenuation",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofLight::setAttenuation",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofLight,0))){
    SWIG_fail_ptr("Light_setAttenuation",1,SWIGTYPE_p_ofLight); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); (arg1)->setAttenuation(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Light_setAttenuation__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofLight *arg1 = (ofLight *) 0 ; float arg2 ;
  SWIG_check_num_args("ofLight::setAttenuation",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofLight::setAttenuation",1,"ofLight *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofLight::setAttenuation",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofLight,0))){
    SWIG_fail_ptr("Light_setAttenuation",1,SWIGTYPE_p_ofLight); }  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setAttenuation(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Light_setAttenuation__SWIG_3(lua_State* L) { int SWIG_arg = 0; ofLight *arg1 = (ofLight *) 0 ;
  SWIG_check_num_args("ofLight::setAttenuation",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofLight::setAttenuation",1,"ofLight *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofLight,0))){
    SWIG_fail_ptr("Light_setAttenuation",1,SWIGTYPE_p_ofLight); }  (arg1)->setAttenuation(); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Light_setAttenuation(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L);
  if (argc == 1) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofLight, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { return _wrap_Light_setAttenuation__SWIG_3(L);}  }  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofLight, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { return _wrap_Light_setAttenuation__SWIG_2(L);}  }  }
   if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofLight, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_Light_setAttenuation__SWIG_1(L);}  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofLight, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { {
            _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_Light_setAttenuation__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Light_setAttenuation'\n"
  "  Possible C/C++ prototypes are:\n" "    ofLight::setAttenuation(float,float,float)\n"
  "    ofLight::setAttenuation(float,float)\n" "    ofLight::setAttenuation(float)\n" "    ofLight::setAttenuation()\n");
  lua_error(L);return 0; }
static int _wrap_Light_getAttenuationConstant(lua_State* L) { int SWIG_arg = 0; ofLight *arg1 = (ofLight *) 0 ; float result;
  SWIG_check_num_args("ofLight::getAttenuationConstant",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofLight::getAttenuationConstant",1,"ofLight const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofLight,0))){
    SWIG_fail_ptr("Light_getAttenuationConstant",1,SWIGTYPE_p_ofLight); } 
  result = (float)((ofLight const *)arg1)->getAttenuationConstant(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Light_getAttenuationLinear(lua_State* L) { int SWIG_arg = 0; ofLight *arg1 = (ofLight *) 0 ; float result;
  SWIG_check_num_args("ofLight::getAttenuationLinear",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofLight::getAttenuationLinear",1,"ofLight const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofLight,0))){
    SWIG_fail_ptr("Light_getAttenuationLinear",1,SWIGTYPE_p_ofLight); } 
  result = (float)((ofLight const *)arg1)->getAttenuationLinear(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Light_getAttenuationQuadratic(lua_State* L) { int SWIG_arg = 0; ofLight *arg1 = (ofLight *) 0 ; float result;
  SWIG_check_num_args("ofLight::getAttenuationQuadratic",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofLight::getAttenuationQuadratic",1,"ofLight const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofLight,0))){
    SWIG_fail_ptr("Light_getAttenuationQuadratic",1,SWIGTYPE_p_ofLight); } 
  result = (float)((ofLight const *)arg1)->getAttenuationQuadratic(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Light_setAreaLight(lua_State* L) { int SWIG_arg = 0; ofLight *arg1 = (ofLight *) 0 ; float arg2 ; float arg3 ;
  SWIG_check_num_args("ofLight::setAreaLight",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofLight::setAreaLight",1,"ofLight *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofLight::setAreaLight",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofLight::setAreaLight",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofLight,0))){
    SWIG_fail_ptr("Light_setAreaLight",1,SWIGTYPE_p_ofLight); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); (arg1)->setAreaLight(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Light_getIsAreaLight(lua_State* L) { int SWIG_arg = 0; ofLight *arg1 = (ofLight *) 0 ; bool result;
  SWIG_check_num_args("ofLight::getIsAreaLight",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofLight::getIsAreaLight",1,"ofLight const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofLight,0))){
    SWIG_fail_ptr("Light_getIsAreaLight",1,SWIGTYPE_p_ofLight); }  result = (bool)((ofLight const *)arg1)->getIsAreaLight();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Light_getType(lua_State* L) { int SWIG_arg = 0; ofLight *arg1 = (ofLight *) 0 ; int result;
  SWIG_check_num_args("ofLight::getType",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofLight::getType",1,"ofLight const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofLight,0))){
    SWIG_fail_ptr("Light_getType",1,SWIGTYPE_p_ofLight); }  result = (int)((ofLight const *)arg1)->getType();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Light_setAmbientColor(lua_State* L) { int SWIG_arg = 0; ofLight *arg1 = (ofLight *) 0 ;
  ofFloatColor *arg2 = 0 ; SWIG_check_num_args("ofLight::setAmbientColor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofLight::setAmbientColor",1,"ofLight *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofLight::setAmbientColor",2,"ofFloatColor const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofLight,0))){
    SWIG_fail_ptr("Light_setAmbientColor",1,SWIGTYPE_p_ofLight); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("Light_setAmbientColor",2,SWIGTYPE_p_ofColor_T_float_t); } 
  (arg1)->setAmbientColor((ofFloatColor const &)*arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Light_setDiffuseColor(lua_State* L) { int SWIG_arg = 0; ofLight *arg1 = (ofLight *) 0 ;
  ofFloatColor *arg2 = 0 ; SWIG_check_num_args("ofLight::setDiffuseColor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofLight::setDiffuseColor",1,"ofLight *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofLight::setDiffuseColor",2,"ofFloatColor const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofLight,0))){
    SWIG_fail_ptr("Light_setDiffuseColor",1,SWIGTYPE_p_ofLight); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("Light_setDiffuseColor",2,SWIGTYPE_p_ofColor_T_float_t); } 
  (arg1)->setDiffuseColor((ofFloatColor const &)*arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Light_setSpecularColor(lua_State* L) { int SWIG_arg = 0; ofLight *arg1 = (ofLight *) 0 ;
  ofFloatColor *arg2 = 0 ; SWIG_check_num_args("ofLight::setSpecularColor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofLight::setSpecularColor",1,"ofLight *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofLight::setSpecularColor",2,"ofFloatColor const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofLight,0))){
    SWIG_fail_ptr("Light_setSpecularColor",1,SWIGTYPE_p_ofLight); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("Light_setSpecularColor",2,SWIGTYPE_p_ofColor_T_float_t); } 
  (arg1)->setSpecularColor((ofFloatColor const &)*arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Light_getAmbientColor(lua_State* L) { int SWIG_arg = 0; ofLight *arg1 = (ofLight *) 0 ; ofFloatColor result;
  SWIG_check_num_args("ofLight::getAmbientColor",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofLight::getAmbientColor",1,"ofLight const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofLight,0))){
    SWIG_fail_ptr("Light_getAmbientColor",1,SWIGTYPE_p_ofLight); }  result = ((ofLight const *)arg1)->getAmbientColor(); {
    ofFloatColor * resultptr = new ofFloatColor((const ofFloatColor &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofColor_T_float_t,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Light_getDiffuseColor(lua_State* L) { int SWIG_arg = 0; ofLight *arg1 = (ofLight *) 0 ; ofFloatColor result;
  SWIG_check_num_args("ofLight::getDiffuseColor",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofLight::getDiffuseColor",1,"ofLight const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofLight,0))){
    SWIG_fail_ptr("Light_getDiffuseColor",1,SWIGTYPE_p_ofLight); }  result = ((ofLight const *)arg1)->getDiffuseColor(); {
    ofFloatColor * resultptr = new ofFloatColor((const ofFloatColor &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofColor_T_float_t,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Light_getSpecularColor(lua_State* L) { int SWIG_arg = 0; ofLight *arg1 = (ofLight *) 0 ; ofFloatColor result;
  SWIG_check_num_args("ofLight::getSpecularColor",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofLight::getSpecularColor",1,"ofLight const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofLight,0))){
    SWIG_fail_ptr("Light_getSpecularColor",1,SWIGTYPE_p_ofLight); }  result = ((ofLight const *)arg1)->getSpecularColor(); {
    ofFloatColor * resultptr = new ofFloatColor((const ofFloatColor &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofColor_T_float_t,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Light_getLightID(lua_State* L) { int SWIG_arg = 0; ofLight *arg1 = (ofLight *) 0 ; int result;
  SWIG_check_num_args("ofLight::getLightID",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofLight::getLightID",1,"ofLight const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofLight,0))){
    SWIG_fail_ptr("Light_getLightID",1,SWIGTYPE_p_ofLight); }  result = (int)((ofLight const *)arg1)->getLightID();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static void swig_delete_Light(void *obj) {
ofLight *arg1 = (ofLight *) obj;
delete arg1;
}
static int _proxy__wrap_new_Light(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_Light);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_Light_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_Light_methods[]= {
    { "setup", _wrap_Light_setup},
    { "enable", _wrap_Light_enable},
    { "disable", _wrap_Light_disable},
    { "getIsEnabled", _wrap_Light_getIsEnabled},
    { "setDirectional", _wrap_Light_setDirectional},
    { "getIsDirectional", _wrap_Light_getIsDirectional},
    { "setSpotlight", _wrap_Light_setSpotlight},
    { "getIsSpotlight", _wrap_Light_getIsSpotlight},
    { "setSpotlightCutOff", _wrap_Light_setSpotlightCutOff},
    { "getSpotlightCutOff", _wrap_Light_getSpotlightCutOff},
    { "setSpotConcentration", _wrap_Light_setSpotConcentration},
    { "getSpotConcentration", _wrap_Light_getSpotConcentration},
    { "setPointLight", _wrap_Light_setPointLight},
    { "getIsPointLight", _wrap_Light_getIsPointLight},
    { "setAttenuation", _wrap_Light_setAttenuation},
    { "getAttenuationConstant", _wrap_Light_getAttenuationConstant},
    { "getAttenuationLinear", _wrap_Light_getAttenuationLinear},
    { "getAttenuationQuadratic", _wrap_Light_getAttenuationQuadratic},
    { "setAreaLight", _wrap_Light_setAreaLight},
    { "getIsAreaLight", _wrap_Light_getIsAreaLight},
    { "getType", _wrap_Light_getType},
    { "setAmbientColor", _wrap_Light_setAmbientColor},
    { "setDiffuseColor", _wrap_Light_setDiffuseColor},
    { "setSpecularColor", _wrap_Light_setSpecularColor},
    { "getAmbientColor", _wrap_Light_getAmbientColor},
    { "getDiffuseColor", _wrap_Light_getDiffuseColor},
    { "getSpecularColor", _wrap_Light_getSpecularColor},
    { "getLightID", _wrap_Light_getLightID},
    {0,0}
};
static swig_lua_method swig_Light_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_Light_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_Light_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_Light_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_Light_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_Light_Sf_SwigStatic = {
    "Light",
    swig_Light_Sf_SwigStatic_methods,
    swig_Light_Sf_SwigStatic_attributes,
    swig_Light_Sf_SwigStatic_constants,
    swig_Light_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_Light_bases[] = {0,0};
static const char *swig_Light_base_names[] = {"ofNode *",0};
static swig_lua_class _wrap_class_Light = { "Light", "Light", &SWIGTYPE_p_ofLight,_proxy__wrap_new_Light, swig_delete_Light, swig_Light_methods, swig_Light_attributes, &swig_Light_Sf_SwigStatic, swig_Light_meta, swig_Light_bases, swig_Light_base_names };

static int _wrap_new_Material(lua_State* L) { int SWIG_arg = 0; ofMaterial *result = 0 ;
  SWIG_check_num_args("ofMaterial::ofMaterial",0,0) result = (ofMaterial *)new ofMaterial();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofMaterial,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Material_setup(lua_State* L) { int SWIG_arg = 0; ofMaterial *arg1 = (ofMaterial *) 0 ;
  ofMaterialSettings *arg2 = 0 ; SWIG_check_num_args("ofMaterial::setup",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMaterial::setup",1,"ofMaterial *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMaterial::setup",2,"ofMaterialSettings const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMaterial,0))){
    SWIG_fail_ptr("Material_setup",1,SWIGTYPE_p_ofMaterial); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofMaterialSettings,0))){
    SWIG_fail_ptr("Material_setup",2,SWIGTYPE_p_ofMaterialSettings); }  (arg1)->setup((ofMaterialSettings const &)*arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Material_setColors(lua_State* L) { int SWIG_arg = 0; ofMaterial *arg1 = (ofMaterial *) 0 ; ofFloatColor arg2 ;
  ofFloatColor arg3 ; ofFloatColor arg4 ; ofFloatColor arg5 ; ofFloatColor *argp2 ; ofFloatColor *argp3 ; ofFloatColor *argp4 ;
  ofFloatColor *argp5 ; SWIG_check_num_args("ofMaterial::setColors",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMaterial::setColors",1,"ofMaterial *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMaterial::setColors",2,"ofFloatColor");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofMaterial::setColors",3,"ofFloatColor");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("ofMaterial::setColors",4,"ofFloatColor");
  if(!lua_isuserdata(L,5)) SWIG_fail_arg("ofMaterial::setColors",5,"ofFloatColor");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMaterial,0))){
    SWIG_fail_ptr("Material_setColors",1,SWIGTYPE_p_ofMaterial); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("Material_setColors",2,SWIGTYPE_p_ofColor_T_float_t); }  arg2 = *argp2;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("Material_setColors",3,SWIGTYPE_p_ofColor_T_float_t); }  arg3 = *argp3;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&argp4,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("Material_setColors",4,SWIGTYPE_p_ofColor_T_float_t); }  arg4 = *argp4;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&argp5,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("Material_setColors",5,SWIGTYPE_p_ofColor_T_float_t); }  arg5 = *argp5;
  (arg1)->setColors(arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Material_setDiffuseColor(lua_State* L) { int SWIG_arg = 0; ofMaterial *arg1 = (ofMaterial *) 0 ;
  ofFloatColor arg2 ; ofFloatColor *argp2 ; SWIG_check_num_args("ofMaterial::setDiffuseColor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMaterial::setDiffuseColor",1,"ofMaterial *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMaterial::setDiffuseColor",2,"ofFloatColor");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMaterial,0))){
    SWIG_fail_ptr("Material_setDiffuseColor",1,SWIGTYPE_p_ofMaterial); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("Material_setDiffuseColor",2,SWIGTYPE_p_ofColor_T_float_t); }  arg2 = *argp2; (arg1)->setDiffuseColor(arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Material_setAmbientColor(lua_State* L) { int SWIG_arg = 0; ofMaterial *arg1 = (ofMaterial *) 0 ;
  ofFloatColor arg2 ; ofFloatColor *argp2 ; SWIG_check_num_args("ofMaterial::setAmbientColor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMaterial::setAmbientColor",1,"ofMaterial *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMaterial::setAmbientColor",2,"ofFloatColor");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMaterial,0))){
    SWIG_fail_ptr("Material_setAmbientColor",1,SWIGTYPE_p_ofMaterial); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("Material_setAmbientColor",2,SWIGTYPE_p_ofColor_T_float_t); }  arg2 = *argp2; (arg1)->setAmbientColor(arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Material_setSpecularColor(lua_State* L) { int SWIG_arg = 0; ofMaterial *arg1 = (ofMaterial *) 0 ;
  ofFloatColor arg2 ; ofFloatColor *argp2 ; SWIG_check_num_args("ofMaterial::setSpecularColor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMaterial::setSpecularColor",1,"ofMaterial *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMaterial::setSpecularColor",2,"ofFloatColor");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMaterial,0))){
    SWIG_fail_ptr("Material_setSpecularColor",1,SWIGTYPE_p_ofMaterial); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("Material_setSpecularColor",2,SWIGTYPE_p_ofColor_T_float_t); }  arg2 = *argp2; (arg1)->setSpecularColor(arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Material_setEmissiveColor(lua_State* L) { int SWIG_arg = 0; ofMaterial *arg1 = (ofMaterial *) 0 ;
  ofFloatColor arg2 ; ofFloatColor *argp2 ; SWIG_check_num_args("ofMaterial::setEmissiveColor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMaterial::setEmissiveColor",1,"ofMaterial *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMaterial::setEmissiveColor",2,"ofFloatColor");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMaterial,0))){
    SWIG_fail_ptr("Material_setEmissiveColor",1,SWIGTYPE_p_ofMaterial); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("Material_setEmissiveColor",2,SWIGTYPE_p_ofColor_T_float_t); }  arg2 = *argp2; (arg1)->setEmissiveColor(arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Material_setShininess(lua_State* L) { int SWIG_arg = 0; ofMaterial *arg1 = (ofMaterial *) 0 ; float arg2 ;
  SWIG_check_num_args("ofMaterial::setShininess",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMaterial::setShininess",1,"ofMaterial *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMaterial::setShininess",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMaterial,0))){
    SWIG_fail_ptr("Material_setShininess",1,SWIGTYPE_p_ofMaterial); }  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setShininess(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Material_getDiffuseColor(lua_State* L) { int SWIG_arg = 0; ofMaterial *arg1 = (ofMaterial *) 0 ;
  ofFloatColor result; SWIG_check_num_args("ofMaterial::getDiffuseColor",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMaterial::getDiffuseColor",1,"ofMaterial const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMaterial,0))){
    SWIG_fail_ptr("Material_getDiffuseColor",1,SWIGTYPE_p_ofMaterial); } 
  result = ((ofMaterial const *)arg1)->getDiffuseColor(); {
    ofFloatColor * resultptr = new ofFloatColor((const ofFloatColor &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofColor_T_float_t,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Material_getAmbientColor(lua_State* L) { int SWIG_arg = 0; ofMaterial *arg1 = (ofMaterial *) 0 ;
  ofFloatColor result; SWIG_check_num_args("ofMaterial::getAmbientColor",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMaterial::getAmbientColor",1,"ofMaterial const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMaterial,0))){
    SWIG_fail_ptr("Material_getAmbientColor",1,SWIGTYPE_p_ofMaterial); } 
  result = ((ofMaterial const *)arg1)->getAmbientColor(); {
    ofFloatColor * resultptr = new ofFloatColor((const ofFloatColor &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofColor_T_float_t,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Material_getSpecularColor(lua_State* L) { int SWIG_arg = 0; ofMaterial *arg1 = (ofMaterial *) 0 ;
  ofFloatColor result; SWIG_check_num_args("ofMaterial::getSpecularColor",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMaterial::getSpecularColor",1,"ofMaterial const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMaterial,0))){
    SWIG_fail_ptr("Material_getSpecularColor",1,SWIGTYPE_p_ofMaterial); } 
  result = ((ofMaterial const *)arg1)->getSpecularColor(); {
    ofFloatColor * resultptr = new ofFloatColor((const ofFloatColor &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofColor_T_float_t,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Material_getEmissiveColor(lua_State* L) { int SWIG_arg = 0; ofMaterial *arg1 = (ofMaterial *) 0 ;
  ofFloatColor result; SWIG_check_num_args("ofMaterial::getEmissiveColor",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMaterial::getEmissiveColor",1,"ofMaterial const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMaterial,0))){
    SWIG_fail_ptr("Material_getEmissiveColor",1,SWIGTYPE_p_ofMaterial); } 
  result = ((ofMaterial const *)arg1)->getEmissiveColor(); {
    ofFloatColor * resultptr = new ofFloatColor((const ofFloatColor &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofColor_T_float_t,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Material_getShininess(lua_State* L) { int SWIG_arg = 0; ofMaterial *arg1 = (ofMaterial *) 0 ; float result;
  SWIG_check_num_args("ofMaterial::getShininess",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMaterial::getShininess",1,"ofMaterial const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMaterial,0))){
    SWIG_fail_ptr("Material_getShininess",1,SWIGTYPE_p_ofMaterial); } 
  result = (float)((ofMaterial const *)arg1)->getShininess(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Material_getSettings(lua_State* L) { int SWIG_arg = 0; ofMaterial *arg1 = (ofMaterial *) 0 ;
  ofMaterialSettings result; SWIG_check_num_args("ofMaterial::getSettings",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMaterial::getSettings",1,"ofMaterial const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMaterial,0))){
    SWIG_fail_ptr("Material_getSettings",1,SWIGTYPE_p_ofMaterial); }  result = ((ofMaterial const *)arg1)->getSettings(); {
    ofMaterialSettings * resultptr = new ofMaterialSettings((const ofMaterialSettings &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofMaterialSettings,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Material_beginMaterial(lua_State* L) { int SWIG_arg = 0; ofMaterial *arg1 = (ofMaterial *) 0 ;
  SWIG_check_num_args("ofMaterial::begin",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMaterial::begin",1,"ofMaterial const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMaterial,0))){
    SWIG_fail_ptr("Material_beginMaterial",1,SWIGTYPE_p_ofMaterial); }  ((ofMaterial const *)arg1)->begin(); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Material_endMaterial(lua_State* L) { int SWIG_arg = 0; ofMaterial *arg1 = (ofMaterial *) 0 ;
  SWIG_check_num_args("ofMaterial::end",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMaterial::end",1,"ofMaterial const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMaterial,0))){
    SWIG_fail_ptr("Material_endMaterial",1,SWIGTYPE_p_ofMaterial); }  ((ofMaterial const *)arg1)->end(); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Material_setCustomUniform1f(lua_State* L) { int SWIG_arg = 0; ofMaterial *arg1 = (ofMaterial *) 0 ;
  std::string *arg2 = 0 ; float arg3 ; std::string temp2 ; SWIG_check_num_args("ofMaterial::setCustomUniform1f",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMaterial::setCustomUniform1f",1,"ofMaterial *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofMaterial::setCustomUniform1f",2,"std::string const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofMaterial::setCustomUniform1f",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMaterial,0))){
    SWIG_fail_ptr("Material_setCustomUniform1f",1,SWIGTYPE_p_ofMaterial); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2; arg3 = (float)lua_tonumber(L, 3);
  (arg1)->setCustomUniform1f((std::string const &)*arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Material_setCustomUniform2f(lua_State* L) { int SWIG_arg = 0; ofMaterial *arg1 = (ofMaterial *) 0 ;
  std::string *arg2 = 0 ; glm::vec2 arg3 ; std::string temp2 ; glm::vec2 *argp3 ;
  SWIG_check_num_args("ofMaterial::setCustomUniform2f",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMaterial::setCustomUniform2f",1,"ofMaterial *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofMaterial::setCustomUniform2f",2,"std::string const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofMaterial::setCustomUniform2f",3,"glm::vec2");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMaterial,0))){
    SWIG_fail_ptr("Material_setCustomUniform2f",1,SWIGTYPE_p_ofMaterial); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_glm__vec2,0))){
    SWIG_fail_ptr("Material_setCustomUniform2f",3,SWIGTYPE_p_glm__vec2); }  arg3 = *argp3;
  (arg1)->setCustomUniform2f((std::string const &)*arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Material_setCustomUniform3f(lua_State* L) { int SWIG_arg = 0; ofMaterial *arg1 = (ofMaterial *) 0 ;
  std::string *arg2 = 0 ; glm::vec3 arg3 ; std::string temp2 ; glm::vec3 *argp3 ;
  SWIG_check_num_args("ofMaterial::setCustomUniform3f",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMaterial::setCustomUniform3f",1,"ofMaterial *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofMaterial::setCustomUniform3f",2,"std::string const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofMaterial::setCustomUniform3f",3,"glm::vec3");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMaterial,0))){
    SWIG_fail_ptr("Material_setCustomUniform3f",1,SWIGTYPE_p_ofMaterial); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("Material_setCustomUniform3f",3,SWIGTYPE_p_glm__vec3); }  arg3 = *argp3;
  (arg1)->setCustomUniform3f((std::string const &)*arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Material_setCustomUniform4f(lua_State* L) { int SWIG_arg = 0; ofMaterial *arg1 = (ofMaterial *) 0 ;
  std::string *arg2 = 0 ; glm::vec4 arg3 ; std::string temp2 ; glm::vec4 *argp3 ;
  SWIG_check_num_args("ofMaterial::setCustomUniform4f",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMaterial::setCustomUniform4f",1,"ofMaterial *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofMaterial::setCustomUniform4f",2,"std::string const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofMaterial::setCustomUniform4f",3,"glm::vec4");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMaterial,0))){
    SWIG_fail_ptr("Material_setCustomUniform4f",1,SWIGTYPE_p_ofMaterial); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_glm__vec4,0))){
    SWIG_fail_ptr("Material_setCustomUniform4f",3,SWIGTYPE_p_glm__vec4); }  arg3 = *argp3;
  (arg1)->setCustomUniform4f((std::string const &)*arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Material_setCustomUniformMatrix4f(lua_State* L) { int SWIG_arg = 0; ofMaterial *arg1 = (ofMaterial *) 0 ;
  std::string *arg2 = 0 ; glm::mat4 arg3 ; std::string temp2 ; glm::mat4 *argp3 ;
  SWIG_check_num_args("ofMaterial::setCustomUniformMatrix4f",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMaterial::setCustomUniformMatrix4f",1,"ofMaterial *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofMaterial::setCustomUniformMatrix4f",2,"std::string const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofMaterial::setCustomUniformMatrix4f",3,"glm::mat4");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMaterial,0))){
    SWIG_fail_ptr("Material_setCustomUniformMatrix4f",1,SWIGTYPE_p_ofMaterial); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_glm__mat4,0))){
    SWIG_fail_ptr("Material_setCustomUniformMatrix4f",3,SWIGTYPE_p_glm__mat4); }  arg3 = *argp3;
  (arg1)->setCustomUniformMatrix4f((std::string const &)*arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Material_setCustomUniformMatrix3f(lua_State* L) { int SWIG_arg = 0; ofMaterial *arg1 = (ofMaterial *) 0 ;
  std::string *arg2 = 0 ; glm::mat3 arg3 ; std::string temp2 ; glm::mat3 *argp3 ;
  SWIG_check_num_args("ofMaterial::setCustomUniformMatrix3f",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMaterial::setCustomUniformMatrix3f",1,"ofMaterial *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofMaterial::setCustomUniformMatrix3f",2,"std::string const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofMaterial::setCustomUniformMatrix3f",3,"glm::mat3");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMaterial,0))){
    SWIG_fail_ptr("Material_setCustomUniformMatrix3f",1,SWIGTYPE_p_ofMaterial); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_glm__mat3,0))){
    SWIG_fail_ptr("Material_setCustomUniformMatrix3f",3,SWIGTYPE_p_glm__mat3); }  arg3 = *argp3;
  (arg1)->setCustomUniformMatrix3f((std::string const &)*arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Material_setCustomUniform1i(lua_State* L) { int SWIG_arg = 0; ofMaterial *arg1 = (ofMaterial *) 0 ;
  std::string *arg2 = 0 ; int arg3 ; std::string temp2 ; SWIG_check_num_args("ofMaterial::setCustomUniform1i",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMaterial::setCustomUniform1i",1,"ofMaterial *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofMaterial::setCustomUniform1i",2,"std::string const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofMaterial::setCustomUniform1i",3,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMaterial,0))){
    SWIG_fail_ptr("Material_setCustomUniform1i",1,SWIGTYPE_p_ofMaterial); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2; arg3 = (int)lua_tonumber(L, 3);
  (arg1)->setCustomUniform1i((std::string const &)*arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Material_setCustomUniform2i(lua_State* L) { int SWIG_arg = 0; ofMaterial *arg1 = (ofMaterial *) 0 ;
  std::string *arg2 = 0 ; glm::tvec2< int,glm::precision::defaultp > arg3 ; std::string temp2 ;
  glm::tvec2< int,glm::precision::defaultp > *argp3 ; SWIG_check_num_args("ofMaterial::setCustomUniform2i",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMaterial::setCustomUniform2i",1,"ofMaterial *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofMaterial::setCustomUniform2i",2,"std::string const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofMaterial::setCustomUniform2i",3,"glm::tvec2< int,glm::precision::defaultp >");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMaterial,0))){
    SWIG_fail_ptr("Material_setCustomUniform2i",1,SWIGTYPE_p_ofMaterial); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_glm__tvec2T_int_glm__precision__defaultp_t,0))){
    SWIG_fail_ptr("Material_setCustomUniform2i",3,SWIGTYPE_p_glm__tvec2T_int_glm__precision__defaultp_t); }  arg3 = *argp3;
  (arg1)->setCustomUniform2i((std::string const &)*arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Material_setCustomUniform3i(lua_State* L) { int SWIG_arg = 0; ofMaterial *arg1 = (ofMaterial *) 0 ;
  std::string *arg2 = 0 ; glm::tvec3< int,glm::precision::defaultp > arg3 ; std::string temp2 ;
  glm::tvec3< int,glm::precision::defaultp > *argp3 ; SWIG_check_num_args("ofMaterial::setCustomUniform3i",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMaterial::setCustomUniform3i",1,"ofMaterial *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofMaterial::setCustomUniform3i",2,"std::string const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofMaterial::setCustomUniform3i",3,"glm::tvec3< int,glm::precision::defaultp >");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMaterial,0))){
    SWIG_fail_ptr("Material_setCustomUniform3i",1,SWIGTYPE_p_ofMaterial); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_glm__tvec3T_int_glm__precision__defaultp_t,0))){
    SWIG_fail_ptr("Material_setCustomUniform3i",3,SWIGTYPE_p_glm__tvec3T_int_glm__precision__defaultp_t); }  arg3 = *argp3;
  (arg1)->setCustomUniform3i((std::string const &)*arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Material_setCustomUniform4i(lua_State* L) { int SWIG_arg = 0; ofMaterial *arg1 = (ofMaterial *) 0 ;
  std::string *arg2 = 0 ; glm::tvec4< int,glm::precision::defaultp > arg3 ; std::string temp2 ;
  glm::tvec4< int,glm::precision::defaultp > *argp3 ; SWIG_check_num_args("ofMaterial::setCustomUniform4i",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMaterial::setCustomUniform4i",1,"ofMaterial *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofMaterial::setCustomUniform4i",2,"std::string const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofMaterial::setCustomUniform4i",3,"glm::tvec4< int,glm::precision::defaultp >");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMaterial,0))){
    SWIG_fail_ptr("Material_setCustomUniform4i",1,SWIGTYPE_p_ofMaterial); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_glm__tvec4T_int_glm__precision__defaultp_t,0))){
    SWIG_fail_ptr("Material_setCustomUniform4i",3,SWIGTYPE_p_glm__tvec4T_int_glm__precision__defaultp_t); }  arg3 = *argp3;
  (arg1)->setCustomUniform4i((std::string const &)*arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Material_setCustomUniformTexture__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofMaterial *arg1 = (ofMaterial *) 0 ; std::string *arg2 = 0 ; ofTexture *arg3 = 0 ; int arg4 ; std::string temp2 ;
  SWIG_check_num_args("ofMaterial::setCustomUniformTexture",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMaterial::setCustomUniformTexture",1,"ofMaterial *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofMaterial::setCustomUniformTexture",2,"std::string const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofMaterial::setCustomUniformTexture",3,"ofTexture const &");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofMaterial::setCustomUniformTexture",4,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMaterial,0))){
    SWIG_fail_ptr("Material_setCustomUniformTexture",1,SWIGTYPE_p_ofMaterial); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Material_setCustomUniformTexture",3,SWIGTYPE_p_ofTexture); }  arg4 = (int)lua_tonumber(L, 4);
  (arg1)->setCustomUniformTexture((std::string const &)*arg2,(ofTexture const &)*arg3,arg4); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Material_setCustomUniformTexture__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofMaterial *arg1 = (ofMaterial *) 0 ; std::string *arg2 = 0 ; int arg3 ; GLint arg4 ; int arg5 ; std::string temp2 ;
  SWIG_check_num_args("ofMaterial::setCustomUniformTexture",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMaterial::setCustomUniformTexture",1,"ofMaterial *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofMaterial::setCustomUniformTexture",2,"std::string const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofMaterial::setCustomUniformTexture",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofMaterial::setCustomUniformTexture",4,"GLint");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofMaterial::setCustomUniformTexture",5,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMaterial,0))){
    SWIG_fail_ptr("Material_setCustomUniformTexture",1,SWIGTYPE_p_ofMaterial); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2; arg3 = (int)lua_tonumber(L, 3);
  arg4 = (GLint)lua_tonumber(L, 4); arg5 = (int)lua_tonumber(L, 5);
  (arg1)->setCustomUniformTexture((std::string const &)*arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Material_setCustomUniformTexture(lua_State* L) { int argc; int argv[6]={ 1,2,3,4,5,6} ; argc = lua_gettop(L);
  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMaterial, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L,argv[1]); }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_ofTexture, 0)) { _v = 0; }
           else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) {
            return _wrap_Material_setCustomUniformTexture__SWIG_0(L);}  }  }  }  }  if (argc == 5) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMaterial, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) {
              return _wrap_Material_setCustomUniformTexture__SWIG_1(L);}  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Material_setCustomUniformTexture'\n"
  "  Possible C/C++ prototypes are:\n" "    ofMaterial::setCustomUniformTexture(std::string const &,ofTexture const &,int)\n"
  "    ofMaterial::setCustomUniformTexture(std::string const &,int,GLint,int)\n"); lua_error(L);return 0; }
static void swig_delete_Material(void *obj) {
ofMaterial *arg1 = (ofMaterial *) obj;
delete arg1;
}
static int _proxy__wrap_new_Material(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_Material);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_Material_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_Material_methods[]= {
    { "setup", _wrap_Material_setup},
    { "setColors", _wrap_Material_setColors},
    { "setDiffuseColor", _wrap_Material_setDiffuseColor},
    { "setAmbientColor", _wrap_Material_setAmbientColor},
    { "setSpecularColor", _wrap_Material_setSpecularColor},
    { "setEmissiveColor", _wrap_Material_setEmissiveColor},
    { "setShininess", _wrap_Material_setShininess},
    { "getDiffuseColor", _wrap_Material_getDiffuseColor},
    { "getAmbientColor", _wrap_Material_getAmbientColor},
    { "getSpecularColor", _wrap_Material_getSpecularColor},
    { "getEmissiveColor", _wrap_Material_getEmissiveColor},
    { "getShininess", _wrap_Material_getShininess},
    { "getSettings", _wrap_Material_getSettings},
    { "beginMaterial", _wrap_Material_beginMaterial},
    { "endMaterial", _wrap_Material_endMaterial},
    { "setCustomUniform1f", _wrap_Material_setCustomUniform1f},
    { "setCustomUniform2f", _wrap_Material_setCustomUniform2f},
    { "setCustomUniform3f", _wrap_Material_setCustomUniform3f},
    { "setCustomUniform4f", _wrap_Material_setCustomUniform4f},
    { "setCustomUniformMatrix4f", _wrap_Material_setCustomUniformMatrix4f},
    { "setCustomUniformMatrix3f", _wrap_Material_setCustomUniformMatrix3f},
    { "setCustomUniform1i", _wrap_Material_setCustomUniform1i},
    { "setCustomUniform2i", _wrap_Material_setCustomUniform2i},
    { "setCustomUniform3i", _wrap_Material_setCustomUniform3i},
    { "setCustomUniform4i", _wrap_Material_setCustomUniform4i},
    { "setCustomUniformTexture", _wrap_Material_setCustomUniformTexture},
    {0,0}
};
static swig_lua_method swig_Material_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_Material_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_Material_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_Material_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_Material_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_Material_Sf_SwigStatic = {
    "Material",
    swig_Material_Sf_SwigStatic_methods,
    swig_Material_Sf_SwigStatic_attributes,
    swig_Material_Sf_SwigStatic_constants,
    swig_Material_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_Material_bases[] = {0};
static const char *swig_Material_base_names[] = {0};
static swig_lua_class _wrap_class_Material = { "Material", "Material", &SWIGTYPE_p_ofMaterial,_proxy__wrap_new_Material, swig_delete_Material, swig_Material_methods, swig_Material_attributes, &swig_Material_Sf_SwigStatic, swig_Material_meta, swig_Material_bases, swig_Material_base_names };

static int _wrap_new_Shader__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofShader *result = 0 ;
  SWIG_check_num_args("ofShader::ofShader",0,0) result = (ofShader *)new ofShader();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofShader,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_Shader__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = 0 ; ofShader *result = 0 ;
  SWIG_check_num_args("ofShader::ofShader",1,1) if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofShader::ofShader",1,"ofShader &&");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){ SWIG_fail_ptr("new_Shader",1,SWIGTYPE_p_ofShader); }
   result = (ofShader *)new ofShader((ofShader &&)*arg1); SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofShader,1); SWIG_arg++; 
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_new_Shader(lua_State* L) { int argc; int argv[2]={ 1,2} ; argc = lua_gettop(L); if (argc == 0) {
    return _wrap_new_Shader__SWIG_0(L);}  if (argc == 1) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofShader, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { return _wrap_new_Shader__SWIG_1(L);}  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_Shader'\n" "  Possible C/C++ prototypes are:\n"
  "    ofShader::ofShader()\n" "    ofShader::ofShader(ofShader &&)\n"); lua_error(L);return 0; }
static int _wrap_Shader_load__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ;
  std::filesystem::path *arg2 = 0 ; std::filesystem::path temp2 ; bool result; SWIG_check_num_args("ofShader::load",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::load",1,"ofShader *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofShader::load",2,"std::filesystem::path const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_load",1,SWIGTYPE_p_ofShader); }  { size_t len = lua_rawlen(L, 2); temp2 = lua_tolstring(L, 2, &len);
    arg2 = &temp2; }  result = (bool)(arg1)->load((std::filesystem::path const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Shader_load__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ;
  std::filesystem::path *arg2 = 0 ; std::filesystem::path *arg3 = 0 ; std::filesystem::path *arg4 = 0 ;
  std::filesystem::path temp2 ; std::filesystem::path temp3 ; std::filesystem::path temp4 ; bool result;
  SWIG_check_num_args("ofShader::load",4,4) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::load",1,"ofShader *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofShader::load",2,"std::filesystem::path const &");
  if(!lua_isstring(L,3)) SWIG_fail_arg("ofShader::load",3,"std::filesystem::path const &");
  if(!lua_isstring(L,4)) SWIG_fail_arg("ofShader::load",4,"std::filesystem::path const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_load",1,SWIGTYPE_p_ofShader); }  { size_t len = lua_rawlen(L, 2); temp2 = lua_tolstring(L, 2, &len);
    arg2 = &temp2; }  { size_t len = lua_rawlen(L, 3); temp3 = lua_tolstring(L, 3, &len); arg3 = &temp3; }  {
    size_t len = lua_rawlen(L, 4); temp4 = lua_tolstring(L, 4, &len); arg4 = &temp4; } 
  result = (bool)(arg1)->load((std::filesystem::path const &)*arg2,(std::filesystem::path const &)*arg3,(std::filesystem::path const &)*arg4);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Shader_load__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ;
  std::filesystem::path *arg2 = 0 ; std::filesystem::path *arg3 = 0 ; std::filesystem::path temp2 ;
  std::filesystem::path temp3 ; bool result; SWIG_check_num_args("ofShader::load",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::load",1,"ofShader *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofShader::load",2,"std::filesystem::path const &");
  if(!lua_isstring(L,3)) SWIG_fail_arg("ofShader::load",3,"std::filesystem::path const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_load",1,SWIGTYPE_p_ofShader); }  { size_t len = lua_rawlen(L, 2); temp2 = lua_tolstring(L, 2, &len);
    arg2 = &temp2; }  { size_t len = lua_rawlen(L, 3); temp3 = lua_tolstring(L, 3, &len); arg3 = &temp3; } 
  result = (bool)(arg1)->load((std::filesystem::path const &)*arg2,(std::filesystem::path const &)*arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Shader_load(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L); if (argc == 2) { int _v;
    { void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofShader, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L, argv[1]); }  if (_v) {
        return _wrap_Shader_load__SWIG_0(L);}  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofShader, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L, argv[1]); }  if (_v) { { _v = lua_isstring(L, argv[2]); } 
        if (_v) { return _wrap_Shader_load__SWIG_2(L);}  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofShader, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L, argv[1]); }  if (_v) { { _v = lua_isstring(L, argv[2]); } 
        if (_v) { { _v = lua_isstring(L, argv[3]); }  if (_v) { return _wrap_Shader_load__SWIG_1(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Shader_load'\n" "  Possible C/C++ prototypes are:\n"
  "    ofShader::load(std::filesystem::path const &)\n"
  "    ofShader::load(std::filesystem::path const &,std::filesystem::path const &,std::filesystem::path const &)\n"
  "    ofShader::load(std::filesystem::path const &,std::filesystem::path const &)\n"); lua_error(L);return 0; }
static int _wrap_Shader_setup__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ;
  ofShaderSettings *arg2 = 0 ; bool result; SWIG_check_num_args("ofShader::setup",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::setup",1,"ofShader *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofShader::setup",2,"ofShaderSettings const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_setup",1,SWIGTYPE_p_ofShader); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofShaderSettings,0))){
    SWIG_fail_ptr("Shader_setup",2,SWIGTYPE_p_ofShaderSettings); } 
  result = (bool)(arg1)->setup((ofShaderSettings const &)*arg2); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Shader_setup__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ;
  ofShader::TransformFeedbackSettings *arg2 = 0 ; bool result; SWIG_check_num_args("ofShader::setup",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::setup",1,"ofShader *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofShader::setup",2,"ofShader::TransformFeedbackSettings const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_setup",1,SWIGTYPE_p_ofShader); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofShader__TransformFeedbackSettings,0))){
    SWIG_fail_ptr("Shader_setup",2,SWIGTYPE_p_ofShader__TransformFeedbackSettings); } 
  result = (bool)(arg1)->setup((ofShader::TransformFeedbackSettings const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Shader_setup(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 2) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofShader, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofShaderSettings, 0)) {
          _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Shader_setup__SWIG_0(L);}  }  }  if (argc == 2) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofShader, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofShader__TransformFeedbackSettings, 0)) {
          _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Shader_setup__SWIG_1(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Shader_setup'\n" "  Possible C/C++ prototypes are:\n"
  "    ofShader::setup(ofShaderSettings const &)\n" "    ofShader::setup(ofShader::TransformFeedbackSettings const &)\n");
  lua_error(L);return 0; }
static int _wrap_Shader_setGeometryInputType(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ; GLenum arg2 ;
  SWIG_check_num_args("ofShader::setGeometryInputType",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::setGeometryInputType",1,"ofShader *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofShader::setGeometryInputType",2,"GLenum");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_setGeometryInputType",1,SWIGTYPE_p_ofShader); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (GLenum)lua_tonumber(L, 2);
  (arg1)->setGeometryInputType(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Shader_setGeometryOutputType(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ; GLenum arg2 ;
  SWIG_check_num_args("ofShader::setGeometryOutputType",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::setGeometryOutputType",1,"ofShader *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofShader::setGeometryOutputType",2,"GLenum");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_setGeometryOutputType",1,SWIGTYPE_p_ofShader); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (GLenum)lua_tonumber(L, 2);
  (arg1)->setGeometryOutputType(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Shader_setGeometryOutputCount(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ; int arg2 ;
  SWIG_check_num_args("ofShader::setGeometryOutputCount",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::setGeometryOutputCount",1,"ofShader *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofShader::setGeometryOutputCount",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_setGeometryOutputCount",1,SWIGTYPE_p_ofShader); }  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setGeometryOutputCount(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Shader_getGeometryMaxOutputCount(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ;
  int result; SWIG_check_num_args("ofShader::getGeometryMaxOutputCount",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::getGeometryMaxOutputCount",1,"ofShader const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_getGeometryMaxOutputCount",1,SWIGTYPE_p_ofShader); } 
  result = (int)((ofShader const *)arg1)->getGeometryMaxOutputCount(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Shader_unload(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ;
  SWIG_check_num_args("ofShader::unload",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::unload",1,"ofShader *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_unload",1,SWIGTYPE_p_ofShader); }  (arg1)->unload(); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Shader_isLoaded(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ; bool result;
  SWIG_check_num_args("ofShader::isLoaded",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::isLoaded",1,"ofShader const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_isLoaded",1,SWIGTYPE_p_ofShader); }  result = (bool)((ofShader const *)arg1)->isLoaded();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Shader_beginShader(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ;
  SWIG_check_num_args("ofShader::begin",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::begin",1,"ofShader const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_beginShader",1,SWIGTYPE_p_ofShader); }  ((ofShader const *)arg1)->begin(); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Shader_endShader(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ;
  SWIG_check_num_args("ofShader::end",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::end",1,"ofShader const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_endShader",1,SWIGTYPE_p_ofShader); }  ((ofShader const *)arg1)->end(); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Shader_setUniformTexture__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ;
  std::string *arg2 = 0 ; ofBaseHasTexture *arg3 = 0 ; int arg4 ; std::string temp2 ;
  SWIG_check_num_args("ofShader::setUniformTexture",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::setUniformTexture",1,"ofShader const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofShader::setUniformTexture",2,"std::string const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofShader::setUniformTexture",3,"ofBaseHasTexture const &");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofShader::setUniformTexture",4,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_setUniformTexture",1,SWIGTYPE_p_ofShader); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_ofBaseHasTexture,0))){
    SWIG_fail_ptr("Shader_setUniformTexture",3,SWIGTYPE_p_ofBaseHasTexture); }  arg4 = (int)lua_tonumber(L, 4);
  ((ofShader const *)arg1)->setUniformTexture((std::string const &)*arg2,(ofBaseHasTexture const &)*arg3,arg4); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Shader_setUniformTexture__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ;
  std::string *arg2 = 0 ; ofTexture *arg3 = 0 ; int arg4 ; std::string temp2 ;
  SWIG_check_num_args("ofShader::setUniformTexture",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::setUniformTexture",1,"ofShader const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofShader::setUniformTexture",2,"std::string const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofShader::setUniformTexture",3,"ofTexture const &");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofShader::setUniformTexture",4,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_setUniformTexture",1,SWIGTYPE_p_ofShader); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_ofTexture,0))){
    SWIG_fail_ptr("Shader_setUniformTexture",3,SWIGTYPE_p_ofTexture); }  arg4 = (int)lua_tonumber(L, 4);
  ((ofShader const *)arg1)->setUniformTexture((std::string const &)*arg2,(ofTexture const &)*arg3,arg4); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Shader_setUniformTexture__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ;
  std::string *arg2 = 0 ; int arg3 ; GLint arg4 ; int arg5 ; std::string temp2 ;
  SWIG_check_num_args("ofShader::setUniformTexture",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::setUniformTexture",1,"ofShader const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofShader::setUniformTexture",2,"std::string const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofShader::setUniformTexture",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofShader::setUniformTexture",4,"GLint");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofShader::setUniformTexture",5,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_setUniformTexture",1,SWIGTYPE_p_ofShader); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2; arg3 = (int)lua_tonumber(L, 3);
  arg4 = (GLint)lua_tonumber(L, 4); arg5 = (int)lua_tonumber(L, 5);
  ((ofShader const *)arg1)->setUniformTexture((std::string const &)*arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Shader_setUniformTexture(lua_State* L) { int argc; int argv[6]={ 1,2,3,4,5,6} ; argc = lua_gettop(L);
  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofShader, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L,argv[1]); }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_ofBaseHasTexture, 0)) {
            _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) {
            return _wrap_Shader_setUniformTexture__SWIG_0(L);}  }  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofShader, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L,argv[1]); }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_ofTexture, 0)) { _v = 0; }
           else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) {
            return _wrap_Shader_setUniformTexture__SWIG_1(L);}  }  }  }  }  if (argc == 5) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofShader, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) {
              return _wrap_Shader_setUniformTexture__SWIG_2(L);}  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Shader_setUniformTexture'\n"
  "  Possible C/C++ prototypes are:\n"
  "    ofShader::setUniformTexture(std::string const &,ofBaseHasTexture const &,int) const\n"
  "    ofShader::setUniformTexture(std::string const &,ofTexture const &,int) const\n"
  "    ofShader::setUniformTexture(std::string const &,int,GLint,int) const\n"); lua_error(L);return 0; }
static int _wrap_Shader_setUniform1i(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ; std::string *arg2 = 0 ;
  int arg3 ; std::string temp2 ; SWIG_check_num_args("ofShader::setUniform1i",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::setUniform1i",1,"ofShader const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofShader::setUniform1i",2,"std::string const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofShader::setUniform1i",3,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_setUniform1i",1,SWIGTYPE_p_ofShader); }  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  arg3 = (int)lua_tonumber(L, 3); ((ofShader const *)arg1)->setUniform1i((std::string const &)*arg2,arg3); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Shader_setUniform2i(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ; std::string *arg2 = 0 ;
  int arg3 ; int arg4 ; std::string temp2 ; SWIG_check_num_args("ofShader::setUniform2i",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::setUniform2i",1,"ofShader const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofShader::setUniform2i",2,"std::string const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofShader::setUniform2i",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofShader::setUniform2i",4,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_setUniform2i",1,SWIGTYPE_p_ofShader); }  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  arg3 = (int)lua_tonumber(L, 3); arg4 = (int)lua_tonumber(L, 4);
  ((ofShader const *)arg1)->setUniform2i((std::string const &)*arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Shader_setUniform3i(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ; std::string *arg2 = 0 ;
  int arg3 ; int arg4 ; int arg5 ; std::string temp2 ; SWIG_check_num_args("ofShader::setUniform3i",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::setUniform3i",1,"ofShader const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofShader::setUniform3i",2,"std::string const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofShader::setUniform3i",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofShader::setUniform3i",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofShader::setUniform3i",5,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_setUniform3i",1,SWIGTYPE_p_ofShader); }  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  arg3 = (int)lua_tonumber(L, 3); arg4 = (int)lua_tonumber(L, 4); arg5 = (int)lua_tonumber(L, 5);
  ((ofShader const *)arg1)->setUniform3i((std::string const &)*arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Shader_setUniform4i(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ; std::string *arg2 = 0 ;
  int arg3 ; int arg4 ; int arg5 ; int arg6 ; std::string temp2 ; SWIG_check_num_args("ofShader::setUniform4i",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::setUniform4i",1,"ofShader const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofShader::setUniform4i",2,"std::string const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofShader::setUniform4i",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofShader::setUniform4i",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofShader::setUniform4i",5,"int");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofShader::setUniform4i",6,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_setUniform4i",1,SWIGTYPE_p_ofShader); }  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  arg3 = (int)lua_tonumber(L, 3); arg4 = (int)lua_tonumber(L, 4); arg5 = (int)lua_tonumber(L, 5);
  arg6 = (int)lua_tonumber(L, 6); ((ofShader const *)arg1)->setUniform4i((std::string const &)*arg2,arg3,arg4,arg5,arg6);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Shader_setUniform1f(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ; std::string *arg2 = 0 ;
  float arg3 ; std::string temp2 ; SWIG_check_num_args("ofShader::setUniform1f",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::setUniform1f",1,"ofShader const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofShader::setUniform1f",2,"std::string const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofShader::setUniform1f",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_setUniform1f",1,SWIGTYPE_p_ofShader); }  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  arg3 = (float)lua_tonumber(L, 3); ((ofShader const *)arg1)->setUniform1f((std::string const &)*arg2,arg3); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Shader_setUniform2f__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ;
  std::string *arg2 = 0 ; float arg3 ; float arg4 ; std::string temp2 ; SWIG_check_num_args("ofShader::setUniform2f",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::setUniform2f",1,"ofShader const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofShader::setUniform2f",2,"std::string const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofShader::setUniform2f",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofShader::setUniform2f",4,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_setUniform2f",1,SWIGTYPE_p_ofShader); }  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  ((ofShader const *)arg1)->setUniform2f((std::string const &)*arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Shader_setUniform3f__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ;
  std::string *arg2 = 0 ; float arg3 ; float arg4 ; float arg5 ; std::string temp2 ;
  SWIG_check_num_args("ofShader::setUniform3f",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::setUniform3f",1,"ofShader const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofShader::setUniform3f",2,"std::string const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofShader::setUniform3f",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofShader::setUniform3f",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofShader::setUniform3f",5,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_setUniform3f",1,SWIGTYPE_p_ofShader); }  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); arg5 = (float)lua_tonumber(L, 5);
  ((ofShader const *)arg1)->setUniform3f((std::string const &)*arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Shader_setUniform4f__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ;
  std::string *arg2 = 0 ; float arg3 ; float arg4 ; float arg5 ; float arg6 ; std::string temp2 ;
  SWIG_check_num_args("ofShader::setUniform4f",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::setUniform4f",1,"ofShader const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofShader::setUniform4f",2,"std::string const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofShader::setUniform4f",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofShader::setUniform4f",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofShader::setUniform4f",5,"float");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofShader::setUniform4f",6,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_setUniform4f",1,SWIGTYPE_p_ofShader); }  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); arg5 = (float)lua_tonumber(L, 5);
  arg6 = (float)lua_tonumber(L, 6); ((ofShader const *)arg1)->setUniform4f((std::string const &)*arg2,arg3,arg4,arg5,arg6);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Shader_setUniform2f__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ;
  std::string *arg2 = 0 ; glm::vec2 *arg3 = 0 ; std::string temp2 ; SWIG_check_num_args("ofShader::setUniform2f",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::setUniform2f",1,"ofShader const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofShader::setUniform2f",2,"std::string const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofShader::setUniform2f",3,"glm::vec2 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_setUniform2f",1,SWIGTYPE_p_ofShader); }  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_glm__vec2,0))){
    SWIG_fail_ptr("Shader_setUniform2f",3,SWIGTYPE_p_glm__vec2); } 
  ((ofShader const *)arg1)->setUniform2f((std::string const &)*arg2,(glm::vec2 const &)*arg3); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Shader_setUniform2f(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L); if (argc == 3) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofShader, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L,argv[1]); }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_glm__vec2, 0)) { _v = 0; }
           else { _v = 1; }  }  if (_v) { return _wrap_Shader_setUniform2f__SWIG_1(L);}  }  }  }  if (argc == 4) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofShader, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_Shader_setUniform2f__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Shader_setUniform2f'\n"
  "  Possible C/C++ prototypes are:\n" "    ofShader::setUniform2f(std::string const &,float,float) const\n"
  "    ofShader::setUniform2f(std::string const &,glm::vec2 const &) const\n"); lua_error(L);return 0; }
static int _wrap_Shader_setUniform3f__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ;
  std::string *arg2 = 0 ; glm::vec3 *arg3 = 0 ; std::string temp2 ; SWIG_check_num_args("ofShader::setUniform3f",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::setUniform3f",1,"ofShader const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofShader::setUniform3f",2,"std::string const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofShader::setUniform3f",3,"glm::vec3 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_setUniform3f",1,SWIGTYPE_p_ofShader); }  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("Shader_setUniform3f",3,SWIGTYPE_p_glm__vec3); } 
  ((ofShader const *)arg1)->setUniform3f((std::string const &)*arg2,(glm::vec3 const &)*arg3); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Shader_setUniform3f(lua_State* L) { int argc; int argv[6]={ 1,2,3,4,5,6} ; argc = lua_gettop(L);
  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofShader, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L,argv[1]); }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
           else { _v = 1; }  }  if (_v) { return _wrap_Shader_setUniform3f__SWIG_1(L);}  }  }  }  if (argc == 5) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofShader, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) {
              return _wrap_Shader_setUniform3f__SWIG_0(L);}  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Shader_setUniform3f'\n"
  "  Possible C/C++ prototypes are:\n" "    ofShader::setUniform3f(std::string const &,float,float,float) const\n"
  "    ofShader::setUniform3f(std::string const &,glm::vec3 const &) const\n"); lua_error(L);return 0; }
static int _wrap_Shader_setUniform4f__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ;
  std::string *arg2 = 0 ; glm::vec4 *arg3 = 0 ; std::string temp2 ; SWIG_check_num_args("ofShader::setUniform4f",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::setUniform4f",1,"ofShader const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofShader::setUniform4f",2,"std::string const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofShader::setUniform4f",3,"glm::vec4 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_setUniform4f",1,SWIGTYPE_p_ofShader); }  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_glm__vec4,0))){
    SWIG_fail_ptr("Shader_setUniform4f",3,SWIGTYPE_p_glm__vec4); } 
  ((ofShader const *)arg1)->setUniform4f((std::string const &)*arg2,(glm::vec4 const &)*arg3); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Shader_setUniform4f__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ;
  std::string *arg2 = 0 ; ofFloatColor *arg3 = 0 ; std::string temp2 ; SWIG_check_num_args("ofShader::setUniform4f",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::setUniform4f",1,"ofShader const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofShader::setUniform4f",2,"std::string const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofShader::setUniform4f",3,"ofFloatColor const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_setUniform4f",1,SWIGTYPE_p_ofShader); }  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("Shader_setUniform4f",3,SWIGTYPE_p_ofColor_T_float_t); } 
  ((ofShader const *)arg1)->setUniform4f((std::string const &)*arg2,(ofFloatColor const &)*arg3); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Shader_setUniform4f(lua_State* L) { int argc; int argv[7]={ 1,2,3,4,5,6,7} ; argc = lua_gettop(L);
  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofShader, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L,argv[1]); }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_glm__vec4, 0)) { _v = 0; }
           else { _v = 1; }  }  if (_v) { return _wrap_Shader_setUniform4f__SWIG_1(L);}  }  }  }  if (argc == 3) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofShader, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L,argv[1]); }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_ofColor_T_float_t, 0)) {
            _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Shader_setUniform4f__SWIG_2(L);}  }  }  }  if (argc == 6) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofShader, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) { {
                _v = lua_isnumber(L,argv[5]); }  if (_v) { return _wrap_Shader_setUniform4f__SWIG_0(L);}  }  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Shader_setUniform4f'\n"
  "  Possible C/C++ prototypes are:\n" "    ofShader::setUniform4f(std::string const &,float,float,float,float) const\n"
  "    ofShader::setUniform4f(std::string const &,glm::vec4 const &) const\n"
  "    ofShader::setUniform4f(std::string const &,ofFloatColor const &) const\n"); lua_error(L);return 0; }
static int _wrap_Shader_setUniform1iv__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ;
  std::string *arg2 = 0 ; int *arg3 = (int *) 0 ; int arg4 ; std::string temp2 ;
  SWIG_check_num_args("ofShader::setUniform1iv",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::setUniform1iv",1,"ofShader const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofShader::setUniform1iv",2,"std::string const &");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("ofShader::setUniform1iv",3,"int const *");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofShader::setUniform1iv",4,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_setUniform1iv",1,SWIGTYPE_p_ofShader); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_int,0))){ SWIG_fail_ptr("Shader_setUniform1iv",3,SWIGTYPE_p_int); }
   arg4 = (int)lua_tonumber(L, 4); ((ofShader const *)arg1)->setUniform1iv((std::string const &)*arg2,(int const *)arg3,arg4);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Shader_setUniform1iv__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ;
  std::string *arg2 = 0 ; int *arg3 = (int *) 0 ; std::string temp2 ; SWIG_check_num_args("ofShader::setUniform1iv",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::setUniform1iv",1,"ofShader const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofShader::setUniform1iv",2,"std::string const &");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("ofShader::setUniform1iv",3,"int const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_setUniform1iv",1,SWIGTYPE_p_ofShader); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_int,0))){ SWIG_fail_ptr("Shader_setUniform1iv",3,SWIGTYPE_p_int); }
   ((ofShader const *)arg1)->setUniform1iv((std::string const &)*arg2,(int const *)arg3); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Shader_setUniform1iv(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L);
  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofShader, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L,argv[1]); }  if (_v) { { void *ptr;
          if (SWIG_isptrtype(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_int, 0)) { _v = 0; }  else {
            _v = 1; }  }  if (_v) { return _wrap_Shader_setUniform1iv__SWIG_1(L);}  }  }  }  if (argc == 4) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofShader, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L,argv[1]); }  if (_v) { { void *ptr;
          if (SWIG_isptrtype(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_int, 0)) { _v = 0; }  else {
            _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_Shader_setUniform1iv__SWIG_0(L);}
           }  }  }  }  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Shader_setUniform1iv'\n"
  "  Possible C/C++ prototypes are:\n" "    ofShader::setUniform1iv(std::string const &,int const *,int) const\n"
  "    ofShader::setUniform1iv(std::string const &,int const *) const\n"); lua_error(L);return 0; }
static int _wrap_Shader_setUniform2iv__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ;
  std::string *arg2 = 0 ; int *arg3 = (int *) 0 ; int arg4 ; std::string temp2 ;
  SWIG_check_num_args("ofShader::setUniform2iv",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::setUniform2iv",1,"ofShader const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofShader::setUniform2iv",2,"std::string const &");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("ofShader::setUniform2iv",3,"int const *");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofShader::setUniform2iv",4,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_setUniform2iv",1,SWIGTYPE_p_ofShader); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_int,0))){ SWIG_fail_ptr("Shader_setUniform2iv",3,SWIGTYPE_p_int); }
   arg4 = (int)lua_tonumber(L, 4); ((ofShader const *)arg1)->setUniform2iv((std::string const &)*arg2,(int const *)arg3,arg4);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Shader_setUniform2iv__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ;
  std::string *arg2 = 0 ; int *arg3 = (int *) 0 ; std::string temp2 ; SWIG_check_num_args("ofShader::setUniform2iv",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::setUniform2iv",1,"ofShader const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofShader::setUniform2iv",2,"std::string const &");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("ofShader::setUniform2iv",3,"int const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_setUniform2iv",1,SWIGTYPE_p_ofShader); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_int,0))){ SWIG_fail_ptr("Shader_setUniform2iv",3,SWIGTYPE_p_int); }
   ((ofShader const *)arg1)->setUniform2iv((std::string const &)*arg2,(int const *)arg3); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Shader_setUniform2iv(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L);
  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofShader, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L,argv[1]); }  if (_v) { { void *ptr;
          if (SWIG_isptrtype(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_int, 0)) { _v = 0; }  else {
            _v = 1; }  }  if (_v) { return _wrap_Shader_setUniform2iv__SWIG_1(L);}  }  }  }  if (argc == 4) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofShader, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L,argv[1]); }  if (_v) { { void *ptr;
          if (SWIG_isptrtype(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_int, 0)) { _v = 0; }  else {
            _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_Shader_setUniform2iv__SWIG_0(L);}
           }  }  }  }  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Shader_setUniform2iv'\n"
  "  Possible C/C++ prototypes are:\n" "    ofShader::setUniform2iv(std::string const &,int const *,int) const\n"
  "    ofShader::setUniform2iv(std::string const &,int const *) const\n"); lua_error(L);return 0; }
static int _wrap_Shader_setUniform3iv__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ;
  std::string *arg2 = 0 ; int *arg3 = (int *) 0 ; int arg4 ; std::string temp2 ;
  SWIG_check_num_args("ofShader::setUniform3iv",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::setUniform3iv",1,"ofShader const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofShader::setUniform3iv",2,"std::string const &");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("ofShader::setUniform3iv",3,"int const *");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofShader::setUniform3iv",4,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_setUniform3iv",1,SWIGTYPE_p_ofShader); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_int,0))){ SWIG_fail_ptr("Shader_setUniform3iv",3,SWIGTYPE_p_int); }
   arg4 = (int)lua_tonumber(L, 4); ((ofShader const *)arg1)->setUniform3iv((std::string const &)*arg2,(int const *)arg3,arg4);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Shader_setUniform3iv__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ;
  std::string *arg2 = 0 ; int *arg3 = (int *) 0 ; std::string temp2 ; SWIG_check_num_args("ofShader::setUniform3iv",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::setUniform3iv",1,"ofShader const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofShader::setUniform3iv",2,"std::string const &");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("ofShader::setUniform3iv",3,"int const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_setUniform3iv",1,SWIGTYPE_p_ofShader); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_int,0))){ SWIG_fail_ptr("Shader_setUniform3iv",3,SWIGTYPE_p_int); }
   ((ofShader const *)arg1)->setUniform3iv((std::string const &)*arg2,(int const *)arg3); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Shader_setUniform3iv(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L);
  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofShader, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L,argv[1]); }  if (_v) { { void *ptr;
          if (SWIG_isptrtype(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_int, 0)) { _v = 0; }  else {
            _v = 1; }  }  if (_v) { return _wrap_Shader_setUniform3iv__SWIG_1(L);}  }  }  }  if (argc == 4) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofShader, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L,argv[1]); }  if (_v) { { void *ptr;
          if (SWIG_isptrtype(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_int, 0)) { _v = 0; }  else {
            _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_Shader_setUniform3iv__SWIG_0(L);}
           }  }  }  }  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Shader_setUniform3iv'\n"
  "  Possible C/C++ prototypes are:\n" "    ofShader::setUniform3iv(std::string const &,int const *,int) const\n"
  "    ofShader::setUniform3iv(std::string const &,int const *) const\n"); lua_error(L);return 0; }
static int _wrap_Shader_setUniform4iv__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ;
  std::string *arg2 = 0 ; int *arg3 = (int *) 0 ; int arg4 ; std::string temp2 ;
  SWIG_check_num_args("ofShader::setUniform4iv",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::setUniform4iv",1,"ofShader const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofShader::setUniform4iv",2,"std::string const &");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("ofShader::setUniform4iv",3,"int const *");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofShader::setUniform4iv",4,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_setUniform4iv",1,SWIGTYPE_p_ofShader); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_int,0))){ SWIG_fail_ptr("Shader_setUniform4iv",3,SWIGTYPE_p_int); }
   arg4 = (int)lua_tonumber(L, 4); ((ofShader const *)arg1)->setUniform4iv((std::string const &)*arg2,(int const *)arg3,arg4);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Shader_setUniform4iv__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ;
  std::string *arg2 = 0 ; int *arg3 = (int *) 0 ; std::string temp2 ; SWIG_check_num_args("ofShader::setUniform4iv",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::setUniform4iv",1,"ofShader const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofShader::setUniform4iv",2,"std::string const &");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("ofShader::setUniform4iv",3,"int const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_setUniform4iv",1,SWIGTYPE_p_ofShader); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_int,0))){ SWIG_fail_ptr("Shader_setUniform4iv",3,SWIGTYPE_p_int); }
   ((ofShader const *)arg1)->setUniform4iv((std::string const &)*arg2,(int const *)arg3); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Shader_setUniform4iv(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L);
  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofShader, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L,argv[1]); }  if (_v) { { void *ptr;
          if (SWIG_isptrtype(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_int, 0)) { _v = 0; }  else {
            _v = 1; }  }  if (_v) { return _wrap_Shader_setUniform4iv__SWIG_1(L);}  }  }  }  if (argc == 4) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofShader, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L,argv[1]); }  if (_v) { { void *ptr;
          if (SWIG_isptrtype(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_int, 0)) { _v = 0; }  else {
            _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_Shader_setUniform4iv__SWIG_0(L);}
           }  }  }  }  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Shader_setUniform4iv'\n"
  "  Possible C/C++ prototypes are:\n" "    ofShader::setUniform4iv(std::string const &,int const *,int) const\n"
  "    ofShader::setUniform4iv(std::string const &,int const *) const\n"); lua_error(L);return 0; }
static int _wrap_Shader_setUniform1fv__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ;
  std::string *arg2 = 0 ; float *arg3 = (float *) 0 ; int arg4 ; std::string temp2 ;
  SWIG_check_num_args("ofShader::setUniform1fv",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::setUniform1fv",1,"ofShader const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofShader::setUniform1fv",2,"std::string const &");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("ofShader::setUniform1fv",3,"float const *");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofShader::setUniform1fv",4,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_setUniform1fv",1,SWIGTYPE_p_ofShader); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("Shader_setUniform1fv",3,SWIGTYPE_p_float); }  arg4 = (int)lua_tonumber(L, 4);
  ((ofShader const *)arg1)->setUniform1fv((std::string const &)*arg2,(float const *)arg3,arg4); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Shader_setUniform1fv__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ;
  std::string *arg2 = 0 ; float *arg3 = (float *) 0 ; std::string temp2 ; SWIG_check_num_args("ofShader::setUniform1fv",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::setUniform1fv",1,"ofShader const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofShader::setUniform1fv",2,"std::string const &");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("ofShader::setUniform1fv",3,"float const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_setUniform1fv",1,SWIGTYPE_p_ofShader); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("Shader_setUniform1fv",3,SWIGTYPE_p_float); } 
  ((ofShader const *)arg1)->setUniform1fv((std::string const &)*arg2,(float const *)arg3); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Shader_setUniform1fv(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L);
  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofShader, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L,argv[1]); }  if (_v) { { void *ptr;
          if (SWIG_isptrtype(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_float, 0)) { _v = 0; }
           else { _v = 1; }  }  if (_v) { return _wrap_Shader_setUniform1fv__SWIG_1(L);}  }  }  }  if (argc == 4) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofShader, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L,argv[1]); }  if (_v) { { void *ptr;
          if (SWIG_isptrtype(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_float, 0)) { _v = 0; }
           else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) {
            return _wrap_Shader_setUniform1fv__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Shader_setUniform1fv'\n"
  "  Possible C/C++ prototypes are:\n" "    ofShader::setUniform1fv(std::string const &,float const *,int) const\n"
  "    ofShader::setUniform1fv(std::string const &,float const *) const\n"); lua_error(L);return 0; }
static int _wrap_Shader_setUniform2fv__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ;
  std::string *arg2 = 0 ; float *arg3 = (float *) 0 ; int arg4 ; std::string temp2 ;
  SWIG_check_num_args("ofShader::setUniform2fv",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::setUniform2fv",1,"ofShader const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofShader::setUniform2fv",2,"std::string const &");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("ofShader::setUniform2fv",3,"float const *");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofShader::setUniform2fv",4,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_setUniform2fv",1,SWIGTYPE_p_ofShader); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("Shader_setUniform2fv",3,SWIGTYPE_p_float); }  arg4 = (int)lua_tonumber(L, 4);
  ((ofShader const *)arg1)->setUniform2fv((std::string const &)*arg2,(float const *)arg3,arg4); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Shader_setUniform2fv__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ;
  std::string *arg2 = 0 ; float *arg3 = (float *) 0 ; std::string temp2 ; SWIG_check_num_args("ofShader::setUniform2fv",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::setUniform2fv",1,"ofShader const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofShader::setUniform2fv",2,"std::string const &");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("ofShader::setUniform2fv",3,"float const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_setUniform2fv",1,SWIGTYPE_p_ofShader); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("Shader_setUniform2fv",3,SWIGTYPE_p_float); } 
  ((ofShader const *)arg1)->setUniform2fv((std::string const &)*arg2,(float const *)arg3); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Shader_setUniform2fv(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L);
  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofShader, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L,argv[1]); }  if (_v) { { void *ptr;
          if (SWIG_isptrtype(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_float, 0)) { _v = 0; }
           else { _v = 1; }  }  if (_v) { return _wrap_Shader_setUniform2fv__SWIG_1(L);}  }  }  }  if (argc == 4) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofShader, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L,argv[1]); }  if (_v) { { void *ptr;
          if (SWIG_isptrtype(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_float, 0)) { _v = 0; }
           else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) {
            return _wrap_Shader_setUniform2fv__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Shader_setUniform2fv'\n"
  "  Possible C/C++ prototypes are:\n" "    ofShader::setUniform2fv(std::string const &,float const *,int) const\n"
  "    ofShader::setUniform2fv(std::string const &,float const *) const\n"); lua_error(L);return 0; }
static int _wrap_Shader_setUniform3fv__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ;
  std::string *arg2 = 0 ; float *arg3 = (float *) 0 ; int arg4 ; std::string temp2 ;
  SWIG_check_num_args("ofShader::setUniform3fv",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::setUniform3fv",1,"ofShader const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofShader::setUniform3fv",2,"std::string const &");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("ofShader::setUniform3fv",3,"float const *");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofShader::setUniform3fv",4,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_setUniform3fv",1,SWIGTYPE_p_ofShader); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("Shader_setUniform3fv",3,SWIGTYPE_p_float); }  arg4 = (int)lua_tonumber(L, 4);
  ((ofShader const *)arg1)->setUniform3fv((std::string const &)*arg2,(float const *)arg3,arg4); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Shader_setUniform3fv__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ;
  std::string *arg2 = 0 ; float *arg3 = (float *) 0 ; std::string temp2 ; SWIG_check_num_args("ofShader::setUniform3fv",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::setUniform3fv",1,"ofShader const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofShader::setUniform3fv",2,"std::string const &");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("ofShader::setUniform3fv",3,"float const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_setUniform3fv",1,SWIGTYPE_p_ofShader); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("Shader_setUniform3fv",3,SWIGTYPE_p_float); } 
  ((ofShader const *)arg1)->setUniform3fv((std::string const &)*arg2,(float const *)arg3); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Shader_setUniform3fv(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L);
  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofShader, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L,argv[1]); }  if (_v) { { void *ptr;
          if (SWIG_isptrtype(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_float, 0)) { _v = 0; }
           else { _v = 1; }  }  if (_v) { return _wrap_Shader_setUniform3fv__SWIG_1(L);}  }  }  }  if (argc == 4) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofShader, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L,argv[1]); }  if (_v) { { void *ptr;
          if (SWIG_isptrtype(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_float, 0)) { _v = 0; }
           else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) {
            return _wrap_Shader_setUniform3fv__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Shader_setUniform3fv'\n"
  "  Possible C/C++ prototypes are:\n" "    ofShader::setUniform3fv(std::string const &,float const *,int) const\n"
  "    ofShader::setUniform3fv(std::string const &,float const *) const\n"); lua_error(L);return 0; }
static int _wrap_Shader_setUniform4fv__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ;
  std::string *arg2 = 0 ; float *arg3 = (float *) 0 ; int arg4 ; std::string temp2 ;
  SWIG_check_num_args("ofShader::setUniform4fv",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::setUniform4fv",1,"ofShader const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofShader::setUniform4fv",2,"std::string const &");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("ofShader::setUniform4fv",3,"float const *");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofShader::setUniform4fv",4,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_setUniform4fv",1,SWIGTYPE_p_ofShader); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("Shader_setUniform4fv",3,SWIGTYPE_p_float); }  arg4 = (int)lua_tonumber(L, 4);
  ((ofShader const *)arg1)->setUniform4fv((std::string const &)*arg2,(float const *)arg3,arg4); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Shader_setUniform4fv__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ;
  std::string *arg2 = 0 ; float *arg3 = (float *) 0 ; std::string temp2 ; SWIG_check_num_args("ofShader::setUniform4fv",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::setUniform4fv",1,"ofShader const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofShader::setUniform4fv",2,"std::string const &");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("ofShader::setUniform4fv",3,"float const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_setUniform4fv",1,SWIGTYPE_p_ofShader); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("Shader_setUniform4fv",3,SWIGTYPE_p_float); } 
  ((ofShader const *)arg1)->setUniform4fv((std::string const &)*arg2,(float const *)arg3); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Shader_setUniform4fv(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L);
  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofShader, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L,argv[1]); }  if (_v) { { void *ptr;
          if (SWIG_isptrtype(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_float, 0)) { _v = 0; }
           else { _v = 1; }  }  if (_v) { return _wrap_Shader_setUniform4fv__SWIG_1(L);}  }  }  }  if (argc == 4) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofShader, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L,argv[1]); }  if (_v) { { void *ptr;
          if (SWIG_isptrtype(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_float, 0)) { _v = 0; }
           else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) {
            return _wrap_Shader_setUniform4fv__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Shader_setUniform4fv'\n"
  "  Possible C/C++ prototypes are:\n" "    ofShader::setUniform4fv(std::string const &,float const *,int) const\n"
  "    ofShader::setUniform4fv(std::string const &,float const *) const\n"); lua_error(L);return 0; }
static int _wrap_Shader_setUniforms(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ;
  ofParameterGroup *arg2 = 0 ; SWIG_check_num_args("ofShader::setUniforms",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::setUniforms",1,"ofShader const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofShader::setUniforms",2,"ofParameterGroup const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_setUniforms",1,SWIGTYPE_p_ofShader); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofParameterGroup,0))){
    SWIG_fail_ptr("Shader_setUniforms",2,SWIGTYPE_p_ofParameterGroup); } 
  ((ofShader const *)arg1)->setUniforms((ofParameterGroup const &)*arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Shader_setUniformMatrix3f__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ;
  std::string *arg2 = 0 ; glm::mat3 *arg3 = 0 ; int arg4 ; std::string temp2 ;
  SWIG_check_num_args("ofShader::setUniformMatrix3f",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::setUniformMatrix3f",1,"ofShader const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofShader::setUniformMatrix3f",2,"std::string const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofShader::setUniformMatrix3f",3,"glm::mat3 const &");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofShader::setUniformMatrix3f",4,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_setUniformMatrix3f",1,SWIGTYPE_p_ofShader); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_glm__mat3,0))){
    SWIG_fail_ptr("Shader_setUniformMatrix3f",3,SWIGTYPE_p_glm__mat3); }  arg4 = (int)lua_tonumber(L, 4);
  ((ofShader const *)arg1)->setUniformMatrix3f((std::string const &)*arg2,(glm::mat3 const &)*arg3,arg4); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Shader_setUniformMatrix3f__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ;
  std::string *arg2 = 0 ; glm::mat3 *arg3 = 0 ; std::string temp2 ; SWIG_check_num_args("ofShader::setUniformMatrix3f",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::setUniformMatrix3f",1,"ofShader const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofShader::setUniformMatrix3f",2,"std::string const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofShader::setUniformMatrix3f",3,"glm::mat3 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_setUniformMatrix3f",1,SWIGTYPE_p_ofShader); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_glm__mat3,0))){
    SWIG_fail_ptr("Shader_setUniformMatrix3f",3,SWIGTYPE_p_glm__mat3); } 
  ((ofShader const *)arg1)->setUniformMatrix3f((std::string const &)*arg2,(glm::mat3 const &)*arg3); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Shader_setUniformMatrix3f(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L);
  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofShader, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L,argv[1]); }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_glm__mat3, 0)) { _v = 0; }
           else { _v = 1; }  }  if (_v) { return _wrap_Shader_setUniformMatrix3f__SWIG_1(L);}  }  }  }  if (argc == 4) { int _v;
    { void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofShader, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L,argv[1]); }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_glm__mat3, 0)) { _v = 0; }
           else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) {
            return _wrap_Shader_setUniformMatrix3f__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Shader_setUniformMatrix3f'\n"
  "  Possible C/C++ prototypes are:\n" "    ofShader::setUniformMatrix3f(std::string const &,glm::mat3 const &,int) const\n"
  "    ofShader::setUniformMatrix3f(std::string const &,glm::mat3 const &) const\n"); lua_error(L);return 0; }
static int _wrap_Shader_setUniformMatrix4f__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ;
  std::string *arg2 = 0 ; glm::mat4 *arg3 = 0 ; int arg4 ; std::string temp2 ;
  SWIG_check_num_args("ofShader::setUniformMatrix4f",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::setUniformMatrix4f",1,"ofShader const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofShader::setUniformMatrix4f",2,"std::string const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofShader::setUniformMatrix4f",3,"glm::mat4 const &");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofShader::setUniformMatrix4f",4,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_setUniformMatrix4f",1,SWIGTYPE_p_ofShader); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_glm__mat4,0))){
    SWIG_fail_ptr("Shader_setUniformMatrix4f",3,SWIGTYPE_p_glm__mat4); }  arg4 = (int)lua_tonumber(L, 4);
  ((ofShader const *)arg1)->setUniformMatrix4f((std::string const &)*arg2,(glm::mat4 const &)*arg3,arg4); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Shader_setUniformMatrix4f__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ;
  std::string *arg2 = 0 ; glm::mat4 *arg3 = 0 ; std::string temp2 ; SWIG_check_num_args("ofShader::setUniformMatrix4f",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::setUniformMatrix4f",1,"ofShader const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofShader::setUniformMatrix4f",2,"std::string const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofShader::setUniformMatrix4f",3,"glm::mat4 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_setUniformMatrix4f",1,SWIGTYPE_p_ofShader); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_glm__mat4,0))){
    SWIG_fail_ptr("Shader_setUniformMatrix4f",3,SWIGTYPE_p_glm__mat4); } 
  ((ofShader const *)arg1)->setUniformMatrix4f((std::string const &)*arg2,(glm::mat4 const &)*arg3); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Shader_setUniformMatrix4f(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L);
  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofShader, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L,argv[1]); }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_glm__mat4, 0)) { _v = 0; }
           else { _v = 1; }  }  if (_v) { return _wrap_Shader_setUniformMatrix4f__SWIG_1(L);}  }  }  }  if (argc == 4) { int _v;
    { void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofShader, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L,argv[1]); }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_glm__mat4, 0)) { _v = 0; }
           else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) {
            return _wrap_Shader_setUniformMatrix4f__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Shader_setUniformMatrix4f'\n"
  "  Possible C/C++ prototypes are:\n" "    ofShader::setUniformMatrix4f(std::string const &,glm::mat4 const &,int) const\n"
  "    ofShader::setUniformMatrix4f(std::string const &,glm::mat4 const &) const\n"); lua_error(L);return 0; }
static int _wrap_Shader_getUniformLocation(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ;
  std::string *arg2 = 0 ; std::string temp2 ; GLint result; SWIG_check_num_args("ofShader::getUniformLocation",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::getUniformLocation",1,"ofShader const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofShader::getUniformLocation",2,"std::string const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_getUniformLocation",1,SWIGTYPE_p_ofShader); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  result = (GLint)((ofShader const *)arg1)->getUniformLocation((std::string const &)*arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Shader_getAttributeLocation(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ;
  std::string *arg2 = 0 ; std::string temp2 ; GLint result; SWIG_check_num_args("ofShader::getAttributeLocation",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::getAttributeLocation",1,"ofShader const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofShader::getAttributeLocation",2,"std::string const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_getAttributeLocation",1,SWIGTYPE_p_ofShader); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  result = (GLint)((ofShader const *)arg1)->getAttributeLocation((std::string const &)*arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Shader_setAttribute1s(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ; GLint arg2 ;
  short arg3 ; SWIG_check_num_args("ofShader::setAttribute1s",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::setAttribute1s",1,"ofShader const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofShader::setAttribute1s",2,"GLint");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofShader::setAttribute1s",3,"short");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_setAttribute1s",1,SWIGTYPE_p_ofShader); }  arg2 = (GLint)lua_tonumber(L, 2);
  arg3 = (short)lua_tonumber(L, 3); ((ofShader const *)arg1)->setAttribute1s(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Shader_setAttribute2s(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ; GLint arg2 ;
  short arg3 ; short arg4 ; SWIG_check_num_args("ofShader::setAttribute2s",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::setAttribute2s",1,"ofShader const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofShader::setAttribute2s",2,"GLint");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofShader::setAttribute2s",3,"short");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofShader::setAttribute2s",4,"short");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_setAttribute2s",1,SWIGTYPE_p_ofShader); }  arg2 = (GLint)lua_tonumber(L, 2);
  arg3 = (short)lua_tonumber(L, 3); arg4 = (short)lua_tonumber(L, 4); ((ofShader const *)arg1)->setAttribute2s(arg2,arg3,arg4);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Shader_setAttribute3s(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ; GLint arg2 ;
  short arg3 ; short arg4 ; short arg5 ; SWIG_check_num_args("ofShader::setAttribute3s",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::setAttribute3s",1,"ofShader const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofShader::setAttribute3s",2,"GLint");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofShader::setAttribute3s",3,"short");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofShader::setAttribute3s",4,"short");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofShader::setAttribute3s",5,"short");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_setAttribute3s",1,SWIGTYPE_p_ofShader); }  arg2 = (GLint)lua_tonumber(L, 2);
  arg3 = (short)lua_tonumber(L, 3); arg4 = (short)lua_tonumber(L, 4); arg5 = (short)lua_tonumber(L, 5);
  ((ofShader const *)arg1)->setAttribute3s(arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Shader_setAttribute4s(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ; GLint arg2 ;
  short arg3 ; short arg4 ; short arg5 ; short arg6 ; SWIG_check_num_args("ofShader::setAttribute4s",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::setAttribute4s",1,"ofShader const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofShader::setAttribute4s",2,"GLint");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofShader::setAttribute4s",3,"short");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofShader::setAttribute4s",4,"short");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofShader::setAttribute4s",5,"short");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofShader::setAttribute4s",6,"short");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_setAttribute4s",1,SWIGTYPE_p_ofShader); }  arg2 = (GLint)lua_tonumber(L, 2);
  arg3 = (short)lua_tonumber(L, 3); arg4 = (short)lua_tonumber(L, 4); arg5 = (short)lua_tonumber(L, 5);
  arg6 = (short)lua_tonumber(L, 6); ((ofShader const *)arg1)->setAttribute4s(arg2,arg3,arg4,arg5,arg6); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Shader_setAttribute1f(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ; GLint arg2 ;
  float arg3 ; SWIG_check_num_args("ofShader::setAttribute1f",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::setAttribute1f",1,"ofShader const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofShader::setAttribute1f",2,"GLint");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofShader::setAttribute1f",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_setAttribute1f",1,SWIGTYPE_p_ofShader); }  arg2 = (GLint)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); ((ofShader const *)arg1)->setAttribute1f(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Shader_setAttribute2f(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ; GLint arg2 ;
  float arg3 ; float arg4 ; SWIG_check_num_args("ofShader::setAttribute2f",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::setAttribute2f",1,"ofShader const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofShader::setAttribute2f",2,"GLint");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofShader::setAttribute2f",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofShader::setAttribute2f",4,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_setAttribute2f",1,SWIGTYPE_p_ofShader); }  arg2 = (GLint)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); ((ofShader const *)arg1)->setAttribute2f(arg2,arg3,arg4);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Shader_setAttribute3f(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ; GLint arg2 ;
  float arg3 ; float arg4 ; float arg5 ; SWIG_check_num_args("ofShader::setAttribute3f",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::setAttribute3f",1,"ofShader const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofShader::setAttribute3f",2,"GLint");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofShader::setAttribute3f",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofShader::setAttribute3f",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofShader::setAttribute3f",5,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_setAttribute3f",1,SWIGTYPE_p_ofShader); }  arg2 = (GLint)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); arg5 = (float)lua_tonumber(L, 5);
  ((ofShader const *)arg1)->setAttribute3f(arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Shader_setAttribute4f(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ; GLint arg2 ;
  float arg3 ; float arg4 ; float arg5 ; float arg6 ; SWIG_check_num_args("ofShader::setAttribute4f",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::setAttribute4f",1,"ofShader const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofShader::setAttribute4f",2,"GLint");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofShader::setAttribute4f",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofShader::setAttribute4f",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofShader::setAttribute4f",5,"float");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofShader::setAttribute4f",6,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_setAttribute4f",1,SWIGTYPE_p_ofShader); }  arg2 = (GLint)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); arg5 = (float)lua_tonumber(L, 5);
  arg6 = (float)lua_tonumber(L, 6); ((ofShader const *)arg1)->setAttribute4f(arg2,arg3,arg4,arg5,arg6); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Shader_setAttribute1d(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ; GLint arg2 ;
  double arg3 ; SWIG_check_num_args("ofShader::setAttribute1d",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::setAttribute1d",1,"ofShader const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofShader::setAttribute1d",2,"GLint");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofShader::setAttribute1d",3,"double");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_setAttribute1d",1,SWIGTYPE_p_ofShader); }  arg2 = (GLint)lua_tonumber(L, 2);
  arg3 = (double)lua_tonumber(L, 3); ((ofShader const *)arg1)->setAttribute1d(arg2,arg3); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Shader_setAttribute2d(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ; GLint arg2 ;
  double arg3 ; double arg4 ; SWIG_check_num_args("ofShader::setAttribute2d",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::setAttribute2d",1,"ofShader const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofShader::setAttribute2d",2,"GLint");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofShader::setAttribute2d",3,"double");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofShader::setAttribute2d",4,"double");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_setAttribute2d",1,SWIGTYPE_p_ofShader); }  arg2 = (GLint)lua_tonumber(L, 2);
  arg3 = (double)lua_tonumber(L, 3); arg4 = (double)lua_tonumber(L, 4);
  ((ofShader const *)arg1)->setAttribute2d(arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Shader_setAttribute3d(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ; GLint arg2 ;
  double arg3 ; double arg4 ; double arg5 ; SWIG_check_num_args("ofShader::setAttribute3d",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::setAttribute3d",1,"ofShader const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofShader::setAttribute3d",2,"GLint");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofShader::setAttribute3d",3,"double");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofShader::setAttribute3d",4,"double");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofShader::setAttribute3d",5,"double");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_setAttribute3d",1,SWIGTYPE_p_ofShader); }  arg2 = (GLint)lua_tonumber(L, 2);
  arg3 = (double)lua_tonumber(L, 3); arg4 = (double)lua_tonumber(L, 4); arg5 = (double)lua_tonumber(L, 5);
  ((ofShader const *)arg1)->setAttribute3d(arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Shader_setAttribute4d(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ; GLint arg2 ;
  double arg3 ; double arg4 ; double arg5 ; double arg6 ; SWIG_check_num_args("ofShader::setAttribute4d",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::setAttribute4d",1,"ofShader const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofShader::setAttribute4d",2,"GLint");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofShader::setAttribute4d",3,"double");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofShader::setAttribute4d",4,"double");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofShader::setAttribute4d",5,"double");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofShader::setAttribute4d",6,"double");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_setAttribute4d",1,SWIGTYPE_p_ofShader); }  arg2 = (GLint)lua_tonumber(L, 2);
  arg3 = (double)lua_tonumber(L, 3); arg4 = (double)lua_tonumber(L, 4); arg5 = (double)lua_tonumber(L, 5);
  arg6 = (double)lua_tonumber(L, 6); ((ofShader const *)arg1)->setAttribute4d(arg2,arg3,arg4,arg5,arg6); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Shader_setAttribute1fv__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ;
  std::string *arg2 = 0 ; float *arg3 = (float *) 0 ; GLsizei arg4 ; std::string temp2 ; GLsizei *argp4 ;
  SWIG_check_num_args("ofShader::setAttribute1fv",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::setAttribute1fv",1,"ofShader const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofShader::setAttribute1fv",2,"std::string const &");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("ofShader::setAttribute1fv",3,"float const *");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("ofShader::setAttribute1fv",4,"GLsizei");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_setAttribute1fv",1,SWIGTYPE_p_ofShader); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("Shader_setAttribute1fv",3,SWIGTYPE_p_float); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&argp4,SWIGTYPE_p_GLsizei,0))){
    SWIG_fail_ptr("Shader_setAttribute1fv",4,SWIGTYPE_p_GLsizei); }  arg4 = *argp4;
  ((ofShader const *)arg1)->setAttribute1fv((std::string const &)*arg2,(float const *)arg3,arg4); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Shader_setAttribute1fv__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ;
  std::string *arg2 = 0 ; float *arg3 = (float *) 0 ; std::string temp2 ; SWIG_check_num_args("ofShader::setAttribute1fv",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::setAttribute1fv",1,"ofShader const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofShader::setAttribute1fv",2,"std::string const &");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("ofShader::setAttribute1fv",3,"float const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_setAttribute1fv",1,SWIGTYPE_p_ofShader); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("Shader_setAttribute1fv",3,SWIGTYPE_p_float); } 
  ((ofShader const *)arg1)->setAttribute1fv((std::string const &)*arg2,(float const *)arg3); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Shader_setAttribute1fv(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L);
  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofShader, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L,argv[1]); }  if (_v) { { void *ptr;
          if (SWIG_isptrtype(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_float, 0)) { _v = 0; }
           else { _v = 1; }  }  if (_v) { return _wrap_Shader_setAttribute1fv__SWIG_1(L);}  }  }  }  if (argc == 4) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofShader, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L,argv[1]); }  if (_v) { { void *ptr;
          if (SWIG_isptrtype(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_float, 0)) { _v = 0; }
           else { _v = 1; }  }  if (_v) { { void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_GLsizei, 0)) { _v = 0; }
             else { _v = 1; }  }  if (_v) { return _wrap_Shader_setAttribute1fv__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Shader_setAttribute1fv'\n"
  "  Possible C/C++ prototypes are:\n" "    ofShader::setAttribute1fv(std::string const &,float const *,GLsizei) const\n"
  "    ofShader::setAttribute1fv(std::string const &,float const *) const\n"); lua_error(L);return 0; }
static int _wrap_Shader_setAttribute2fv__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ;
  std::string *arg2 = 0 ; float *arg3 = (float *) 0 ; GLsizei arg4 ; std::string temp2 ; GLsizei *argp4 ;
  SWIG_check_num_args("ofShader::setAttribute2fv",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::setAttribute2fv",1,"ofShader const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofShader::setAttribute2fv",2,"std::string const &");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("ofShader::setAttribute2fv",3,"float const *");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("ofShader::setAttribute2fv",4,"GLsizei");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_setAttribute2fv",1,SWIGTYPE_p_ofShader); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("Shader_setAttribute2fv",3,SWIGTYPE_p_float); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&argp4,SWIGTYPE_p_GLsizei,0))){
    SWIG_fail_ptr("Shader_setAttribute2fv",4,SWIGTYPE_p_GLsizei); }  arg4 = *argp4;
  ((ofShader const *)arg1)->setAttribute2fv((std::string const &)*arg2,(float const *)arg3,arg4); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Shader_setAttribute2fv__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ;
  std::string *arg2 = 0 ; float *arg3 = (float *) 0 ; std::string temp2 ; SWIG_check_num_args("ofShader::setAttribute2fv",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::setAttribute2fv",1,"ofShader const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofShader::setAttribute2fv",2,"std::string const &");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("ofShader::setAttribute2fv",3,"float const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_setAttribute2fv",1,SWIGTYPE_p_ofShader); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("Shader_setAttribute2fv",3,SWIGTYPE_p_float); } 
  ((ofShader const *)arg1)->setAttribute2fv((std::string const &)*arg2,(float const *)arg3); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Shader_setAttribute2fv(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L);
  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofShader, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L,argv[1]); }  if (_v) { { void *ptr;
          if (SWIG_isptrtype(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_float, 0)) { _v = 0; }
           else { _v = 1; }  }  if (_v) { return _wrap_Shader_setAttribute2fv__SWIG_1(L);}  }  }  }  if (argc == 4) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofShader, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L,argv[1]); }  if (_v) { { void *ptr;
          if (SWIG_isptrtype(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_float, 0)) { _v = 0; }
           else { _v = 1; }  }  if (_v) { { void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_GLsizei, 0)) { _v = 0; }
             else { _v = 1; }  }  if (_v) { return _wrap_Shader_setAttribute2fv__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Shader_setAttribute2fv'\n"
  "  Possible C/C++ prototypes are:\n" "    ofShader::setAttribute2fv(std::string const &,float const *,GLsizei) const\n"
  "    ofShader::setAttribute2fv(std::string const &,float const *) const\n"); lua_error(L);return 0; }
static int _wrap_Shader_setAttribute3fv__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ;
  std::string *arg2 = 0 ; float *arg3 = (float *) 0 ; GLsizei arg4 ; std::string temp2 ; GLsizei *argp4 ;
  SWIG_check_num_args("ofShader::setAttribute3fv",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::setAttribute3fv",1,"ofShader const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofShader::setAttribute3fv",2,"std::string const &");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("ofShader::setAttribute3fv",3,"float const *");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("ofShader::setAttribute3fv",4,"GLsizei");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_setAttribute3fv",1,SWIGTYPE_p_ofShader); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("Shader_setAttribute3fv",3,SWIGTYPE_p_float); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&argp4,SWIGTYPE_p_GLsizei,0))){
    SWIG_fail_ptr("Shader_setAttribute3fv",4,SWIGTYPE_p_GLsizei); }  arg4 = *argp4;
  ((ofShader const *)arg1)->setAttribute3fv((std::string const &)*arg2,(float const *)arg3,arg4); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Shader_setAttribute3fv__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ;
  std::string *arg2 = 0 ; float *arg3 = (float *) 0 ; std::string temp2 ; SWIG_check_num_args("ofShader::setAttribute3fv",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::setAttribute3fv",1,"ofShader const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofShader::setAttribute3fv",2,"std::string const &");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("ofShader::setAttribute3fv",3,"float const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_setAttribute3fv",1,SWIGTYPE_p_ofShader); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("Shader_setAttribute3fv",3,SWIGTYPE_p_float); } 
  ((ofShader const *)arg1)->setAttribute3fv((std::string const &)*arg2,(float const *)arg3); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Shader_setAttribute3fv(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L);
  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofShader, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L,argv[1]); }  if (_v) { { void *ptr;
          if (SWIG_isptrtype(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_float, 0)) { _v = 0; }
           else { _v = 1; }  }  if (_v) { return _wrap_Shader_setAttribute3fv__SWIG_1(L);}  }  }  }  if (argc == 4) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofShader, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L,argv[1]); }  if (_v) { { void *ptr;
          if (SWIG_isptrtype(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_float, 0)) { _v = 0; }
           else { _v = 1; }  }  if (_v) { { void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_GLsizei, 0)) { _v = 0; }
             else { _v = 1; }  }  if (_v) { return _wrap_Shader_setAttribute3fv__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Shader_setAttribute3fv'\n"
  "  Possible C/C++ prototypes are:\n" "    ofShader::setAttribute3fv(std::string const &,float const *,GLsizei) const\n"
  "    ofShader::setAttribute3fv(std::string const &,float const *) const\n"); lua_error(L);return 0; }
static int _wrap_Shader_setAttribute4fv__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ;
  std::string *arg2 = 0 ; float *arg3 = (float *) 0 ; GLsizei arg4 ; std::string temp2 ; GLsizei *argp4 ;
  SWIG_check_num_args("ofShader::setAttribute4fv",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::setAttribute4fv",1,"ofShader const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofShader::setAttribute4fv",2,"std::string const &");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("ofShader::setAttribute4fv",3,"float const *");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("ofShader::setAttribute4fv",4,"GLsizei");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_setAttribute4fv",1,SWIGTYPE_p_ofShader); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("Shader_setAttribute4fv",3,SWIGTYPE_p_float); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&argp4,SWIGTYPE_p_GLsizei,0))){
    SWIG_fail_ptr("Shader_setAttribute4fv",4,SWIGTYPE_p_GLsizei); }  arg4 = *argp4;
  ((ofShader const *)arg1)->setAttribute4fv((std::string const &)*arg2,(float const *)arg3,arg4); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Shader_setAttribute4fv__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ;
  std::string *arg2 = 0 ; float *arg3 = (float *) 0 ; std::string temp2 ; SWIG_check_num_args("ofShader::setAttribute4fv",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::setAttribute4fv",1,"ofShader const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofShader::setAttribute4fv",2,"std::string const &");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("ofShader::setAttribute4fv",3,"float const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_setAttribute4fv",1,SWIGTYPE_p_ofShader); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("Shader_setAttribute4fv",3,SWIGTYPE_p_float); } 
  ((ofShader const *)arg1)->setAttribute4fv((std::string const &)*arg2,(float const *)arg3); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Shader_setAttribute4fv(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L);
  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofShader, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L,argv[1]); }  if (_v) { { void *ptr;
          if (SWIG_isptrtype(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_float, 0)) { _v = 0; }
           else { _v = 1; }  }  if (_v) { return _wrap_Shader_setAttribute4fv__SWIG_1(L);}  }  }  }  if (argc == 4) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofShader, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L,argv[1]); }  if (_v) { { void *ptr;
          if (SWIG_isptrtype(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_float, 0)) { _v = 0; }
           else { _v = 1; }  }  if (_v) { { void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_GLsizei, 0)) { _v = 0; }
             else { _v = 1; }  }  if (_v) { return _wrap_Shader_setAttribute4fv__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Shader_setAttribute4fv'\n"
  "  Possible C/C++ prototypes are:\n" "    ofShader::setAttribute4fv(std::string const &,float const *,GLsizei) const\n"
  "    ofShader::setAttribute4fv(std::string const &,float const *) const\n"); lua_error(L);return 0; }
static int _wrap_Shader_bindAttribute(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ; GLuint arg2 ;
  std::string *arg3 = 0 ; std::string temp3 ; SWIG_check_num_args("ofShader::bindAttribute",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::bindAttribute",1,"ofShader const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofShader::bindAttribute",2,"GLuint");
  if(!lua_isstring(L,3)) SWIG_fail_arg("ofShader::bindAttribute",3,"std::string const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_bindAttribute",1,SWIGTYPE_p_ofShader); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (GLuint)lua_tonumber(L, 2);
  temp3.assign(lua_tostring(L,3),lua_rawlen(L,3)); arg3=&temp3;
  ((ofShader const *)arg1)->bindAttribute(arg2,(std::string const &)*arg3); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Shader_printActiveUniforms(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ;
  SWIG_check_num_args("ofShader::printActiveUniforms",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::printActiveUniforms",1,"ofShader const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_printActiveUniforms",1,SWIGTYPE_p_ofShader); }  ((ofShader const *)arg1)->printActiveUniforms();
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Shader_printActiveAttributes(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ;
  SWIG_check_num_args("ofShader::printActiveAttributes",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::printActiveAttributes",1,"ofShader const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_printActiveAttributes",1,SWIGTYPE_p_ofShader); }  ((ofShader const *)arg1)->printActiveAttributes();
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Shader_setupShaderFromSource__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ;
  GLenum arg2 ; std::string arg3 ; std::string arg4 ; bool result; SWIG_check_num_args("ofShader::setupShaderFromSource",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::setupShaderFromSource",1,"ofShader *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofShader::setupShaderFromSource",2,"GLenum");
  if(!lua_isstring(L,3)) SWIG_fail_arg("ofShader::setupShaderFromSource",3,"std::string");
  if(!lua_isstring(L,4)) SWIG_fail_arg("ofShader::setupShaderFromSource",4,"std::string");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_setupShaderFromSource",1,SWIGTYPE_p_ofShader); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (GLenum)lua_tonumber(L, 2);
  (&arg3)->assign(lua_tostring(L,3),lua_rawlen(L,3)); (&arg4)->assign(lua_tostring(L,4),lua_rawlen(L,4));
  result = (bool)(arg1)->setupShaderFromSource(arg2,arg3,arg4); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Shader_setupShaderFromSource__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ;
  GLenum arg2 ; std::string arg3 ; bool result; SWIG_check_num_args("ofShader::setupShaderFromSource",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::setupShaderFromSource",1,"ofShader *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofShader::setupShaderFromSource",2,"GLenum");
  if(!lua_isstring(L,3)) SWIG_fail_arg("ofShader::setupShaderFromSource",3,"std::string");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_setupShaderFromSource",1,SWIGTYPE_p_ofShader); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (GLenum)lua_tonumber(L, 2);
  (&arg3)->assign(lua_tostring(L,3),lua_rawlen(L,3)); result = (bool)(arg1)->setupShaderFromSource(arg2,arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Shader_setupShaderFromSource(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L);
  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofShader, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isstring(L,argv[2]); }  if (_v) {
          return _wrap_Shader_setupShaderFromSource__SWIG_1(L);}  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofShader, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isstring(L,argv[2]); }  if (_v) {
          { _v = lua_isstring(L,argv[3]); }  if (_v) { return _wrap_Shader_setupShaderFromSource__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Shader_setupShaderFromSource'\n"
  "  Possible C/C++ prototypes are:\n" "    ofShader::setupShaderFromSource(GLenum,std::string,std::string)\n"
  "    ofShader::setupShaderFromSource(GLenum,std::string)\n"); lua_error(L);return 0; }
static int _wrap_Shader_setupShaderFromFile(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ; GLenum arg2 ;
  std::filesystem::path *arg3 = 0 ; std::filesystem::path temp3 ; bool result;
  SWIG_check_num_args("ofShader::setupShaderFromFile",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::setupShaderFromFile",1,"ofShader *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofShader::setupShaderFromFile",2,"GLenum");
  if(!lua_isstring(L,3)) SWIG_fail_arg("ofShader::setupShaderFromFile",3,"std::filesystem::path const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_setupShaderFromFile",1,SWIGTYPE_p_ofShader); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (GLenum)lua_tonumber(L, 2); {
    size_t len = lua_rawlen(L, 3); temp3 = lua_tolstring(L, 3, &len); arg3 = &temp3; } 
  result = (bool)(arg1)->setupShaderFromFile(arg2,(std::filesystem::path const &)*arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Shader_linkProgram(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ; bool result;
  SWIG_check_num_args("ofShader::linkProgram",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::linkProgram",1,"ofShader *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_linkProgram",1,SWIGTYPE_p_ofShader); }  result = (bool)(arg1)->linkProgram();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Shader_bindDefaults(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ; bool result;
  SWIG_check_num_args("ofShader::bindDefaults",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::bindDefaults",1,"ofShader *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_bindDefaults",1,SWIGTYPE_p_ofShader); }  result = (bool)(arg1)->bindDefaults();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Shader_getProgram(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ; GLuint result;
  SWIG_check_num_args("ofShader::getProgram",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::getProgram",1,"ofShader const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_getProgram",1,SWIGTYPE_p_ofShader); }  result = (GLuint)((ofShader const *)arg1)->getProgram();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Shader_getShader(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ; GLenum arg2 ;
  GLuint result; SWIG_check_num_args("ofShader::getShader",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::getShader",1,"ofShader const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofShader::getShader",2,"GLenum");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_getShader",1,SWIGTYPE_p_ofShader); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (GLenum)lua_tonumber(L, 2);
  result = (GLuint)((ofShader const *)arg1)->getShader(arg2); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Shader___eq(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ; ofShader *arg2 = 0 ;
  bool result; SWIG_check_num_args("ofShader::operator ==",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::operator ==",1,"ofShader const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofShader::operator ==",2,"ofShader const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader___eq",1,SWIGTYPE_p_ofShader); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader___eq",2,SWIGTYPE_p_ofShader); } 
  result = (bool)((ofShader const *)arg1)->operator ==((ofShader const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Shader_getShaderSource(lua_State* L) { int SWIG_arg = 0; ofShader *arg1 = (ofShader *) 0 ; GLenum arg2 ;
  std::string result; SWIG_check_num_args("ofShader::getShaderSource",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofShader::getShaderSource",1,"ofShader const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofShader::getShaderSource",2,"GLenum");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofShader,0))){
    SWIG_fail_ptr("Shader_getShaderSource",1,SWIGTYPE_p_ofShader); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (GLenum)lua_tonumber(L, 2);
  result = ((ofShader const *)arg1)->getShaderSource(arg2); lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static void swig_delete_Shader(void *obj) {
ofShader *arg1 = (ofShader *) obj;
delete arg1;
}
static int _proxy__wrap_new_Shader(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_Shader);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_Shader_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_Shader_methods[]= {
    { "load", _wrap_Shader_load},
    { "setup", _wrap_Shader_setup},
    { "setGeometryInputType", _wrap_Shader_setGeometryInputType},
    { "setGeometryOutputType", _wrap_Shader_setGeometryOutputType},
    { "setGeometryOutputCount", _wrap_Shader_setGeometryOutputCount},
    { "getGeometryMaxOutputCount", _wrap_Shader_getGeometryMaxOutputCount},
    { "unload", _wrap_Shader_unload},
    { "isLoaded", _wrap_Shader_isLoaded},
    { "beginShader", _wrap_Shader_beginShader},
    { "endShader", _wrap_Shader_endShader},
    { "setUniformTexture", _wrap_Shader_setUniformTexture},
    { "setUniform1i", _wrap_Shader_setUniform1i},
    { "setUniform2i", _wrap_Shader_setUniform2i},
    { "setUniform3i", _wrap_Shader_setUniform3i},
    { "setUniform4i", _wrap_Shader_setUniform4i},
    { "setUniform1f", _wrap_Shader_setUniform1f},
    { "setUniform2f", _wrap_Shader_setUniform2f},
    { "setUniform3f", _wrap_Shader_setUniform3f},
    { "setUniform4f", _wrap_Shader_setUniform4f},
    { "setUniform1iv", _wrap_Shader_setUniform1iv},
    { "setUniform2iv", _wrap_Shader_setUniform2iv},
    { "setUniform3iv", _wrap_Shader_setUniform3iv},
    { "setUniform4iv", _wrap_Shader_setUniform4iv},
    { "setUniform1fv", _wrap_Shader_setUniform1fv},
    { "setUniform2fv", _wrap_Shader_setUniform2fv},
    { "setUniform3fv", _wrap_Shader_setUniform3fv},
    { "setUniform4fv", _wrap_Shader_setUniform4fv},
    { "setUniforms", _wrap_Shader_setUniforms},
    { "setUniformMatrix3f", _wrap_Shader_setUniformMatrix3f},
    { "setUniformMatrix4f", _wrap_Shader_setUniformMatrix4f},
    { "getUniformLocation", _wrap_Shader_getUniformLocation},
    { "getAttributeLocation", _wrap_Shader_getAttributeLocation},
    { "setAttribute1s", _wrap_Shader_setAttribute1s},
    { "setAttribute2s", _wrap_Shader_setAttribute2s},
    { "setAttribute3s", _wrap_Shader_setAttribute3s},
    { "setAttribute4s", _wrap_Shader_setAttribute4s},
    { "setAttribute1f", _wrap_Shader_setAttribute1f},
    { "setAttribute2f", _wrap_Shader_setAttribute2f},
    { "setAttribute3f", _wrap_Shader_setAttribute3f},
    { "setAttribute4f", _wrap_Shader_setAttribute4f},
    { "setAttribute1d", _wrap_Shader_setAttribute1d},
    { "setAttribute2d", _wrap_Shader_setAttribute2d},
    { "setAttribute3d", _wrap_Shader_setAttribute3d},
    { "setAttribute4d", _wrap_Shader_setAttribute4d},
    { "setAttribute1fv", _wrap_Shader_setAttribute1fv},
    { "setAttribute2fv", _wrap_Shader_setAttribute2fv},
    { "setAttribute3fv", _wrap_Shader_setAttribute3fv},
    { "setAttribute4fv", _wrap_Shader_setAttribute4fv},
    { "bindAttribute", _wrap_Shader_bindAttribute},
    { "printActiveUniforms", _wrap_Shader_printActiveUniforms},
    { "printActiveAttributes", _wrap_Shader_printActiveAttributes},
    { "setupShaderFromSource", _wrap_Shader_setupShaderFromSource},
    { "setupShaderFromFile", _wrap_Shader_setupShaderFromFile},
    { "linkProgram", _wrap_Shader_linkProgram},
    { "bindDefaults", _wrap_Shader_bindDefaults},
    { "getProgram", _wrap_Shader_getProgram},
    { "getShader", _wrap_Shader_getShader},
    { "__eq", _wrap_Shader___eq},
    { "getShaderSource", _wrap_Shader_getShaderSource},
    {0,0}
};
static swig_lua_method swig_Shader_meta[] = {
    { "__eq", _wrap_Shader___eq},
    {0,0}
};

static swig_lua_attribute swig_Shader_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_Shader_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_Shader_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_Shader_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_Shader_Sf_SwigStatic = {
    "Shader",
    swig_Shader_Sf_SwigStatic_methods,
    swig_Shader_Sf_SwigStatic_attributes,
    swig_Shader_Sf_SwigStatic_constants,
    swig_Shader_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_Shader_bases[] = {0};
static const char *swig_Shader_base_names[] = {0};
static swig_lua_class _wrap_class_Shader = { "Shader", "Shader", &SWIGTYPE_p_ofShader,_proxy__wrap_new_Shader, swig_delete_Shader, swig_Shader_methods, swig_Shader_attributes, &swig_Shader_Sf_SwigStatic, swig_Shader_meta, swig_Shader_bases, swig_Shader_base_names };

static int _wrap_new_Vbo__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofVbo *result = 0 ; SWIG_check_num_args("ofVbo::ofVbo",0,0)
  result = (ofVbo *)new ofVbo(); SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofVbo,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_new_Vbo__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = 0 ; ofVbo *result = 0 ;
  SWIG_check_num_args("ofVbo::ofVbo",1,1) if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofVbo::ofVbo",1,"ofVbo const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){ SWIG_fail_ptr("new_Vbo",1,SWIGTYPE_p_ofVbo); } 
  result = (ofVbo *)new ofVbo((ofVbo const &)*arg1); SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofVbo,1); SWIG_arg++; 
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_new_Vbo(lua_State* L) { int argc; int argv[2]={ 1,2} ; argc = lua_gettop(L); if (argc == 0) {
    return _wrap_new_Vbo__SWIG_0(L);}  if (argc == 1) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVbo, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { return _wrap_new_Vbo__SWIG_1(L);}  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_Vbo'\n" "  Possible C/C++ prototypes are:\n"
  "    ofVbo::ofVbo()\n" "    ofVbo::ofVbo(ofVbo const &)\n"); lua_error(L);return 0; }
static int _wrap_Vbo_setMesh__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ; ofMesh *arg2 = 0 ; int arg3 ;
  SWIG_check_num_args("ofVbo::setMesh",3,3) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::setMesh",1,"ofVbo *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVbo::setMesh",2,"ofMesh const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVbo::setMesh",3,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){ SWIG_fail_ptr("Vbo_setMesh",1,SWIGTYPE_p_ofVbo); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Vbo_setMesh",2,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   arg3 = (int)lua_tonumber(L, 3); (arg1)->setMesh((ofMesh const &)*arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vbo_setMesh__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ; ofMesh *arg2 = 0 ; int arg3 ;
  bool arg4 ; bool arg5 ; bool arg6 ; SWIG_check_num_args("ofVbo::setMesh",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::setMesh",1,"ofVbo *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVbo::setMesh",2,"ofMesh const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVbo::setMesh",3,"int");
  if(!lua_isboolean(L,4)) SWIG_fail_arg("ofVbo::setMesh",4,"bool");
  if(!lua_isboolean(L,5)) SWIG_fail_arg("ofVbo::setMesh",5,"bool");
  if(!lua_isboolean(L,6)) SWIG_fail_arg("ofVbo::setMesh",6,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){ SWIG_fail_ptr("Vbo_setMesh",1,SWIGTYPE_p_ofVbo); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Vbo_setMesh",2,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   arg3 = (int)lua_tonumber(L, 3); arg4 = (lua_toboolean(L, 4)!=0); arg5 = (lua_toboolean(L, 5)!=0);
  arg6 = (lua_toboolean(L, 6)!=0); (arg1)->setMesh((ofMesh const &)*arg2,arg3,arg4,arg5,arg6); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vbo_setMesh(lua_State* L) { int argc; int argv[7]={ 1,2,3,4,5,6,7} ; argc = lua_gettop(L); if (argc == 3) {
    int _v; { void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVbo, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t, 0)) {
          _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_Vbo_setMesh__SWIG_0(L);}  }  }  }  if (argc == 6) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVbo, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t, 0)) {
          _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { {
            _v = lua_isboolean(L,argv[3]); }  if (_v) { { _v = lua_isboolean(L,argv[4]); }  if (_v) { {
                _v = lua_isboolean(L,argv[5]); }  if (_v) { return _wrap_Vbo_setMesh__SWIG_1(L);}  }  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Vbo_setMesh'\n" "  Possible C/C++ prototypes are:\n"
  "    ofVbo::setMesh(ofMesh const &,int)\n" "    ofVbo::setMesh(ofMesh const &,int,bool,bool,bool)\n"); lua_error(L);return 0; }
static int _wrap_Vbo_setVertexData__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ;
  glm::vec3 *arg2 = (glm::vec3 *) 0 ; int arg3 ; int arg4 ; SWIG_check_num_args("ofVbo::setVertexData",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::setVertexData",1,"ofVbo *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofVbo::setVertexData",2,"glm::vec3 const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVbo::setVertexData",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofVbo::setVertexData",4,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_setVertexData",1,SWIGTYPE_p_ofVbo); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("Vbo_setVertexData",2,SWIGTYPE_p_glm__vec3); }  arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4); (arg1)->setVertexData((glm::vec3 const *)arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vbo_setVertexData__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ;
  glm::vec2 *arg2 = (glm::vec2 *) 0 ; int arg3 ; int arg4 ; SWIG_check_num_args("ofVbo::setVertexData",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::setVertexData",1,"ofVbo *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofVbo::setVertexData",2,"glm::vec2 const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVbo::setVertexData",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofVbo::setVertexData",4,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_setVertexData",1,SWIGTYPE_p_ofVbo); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec2,0))){
    SWIG_fail_ptr("Vbo_setVertexData",2,SWIGTYPE_p_glm__vec2); }  arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4); (arg1)->setVertexData((glm::vec2 const *)arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vbo_setVertexData__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ;
  ofVec3f *arg2 = (ofVec3f *) 0 ; int arg3 ; int arg4 ; SWIG_check_num_args("ofVbo::setVertexData",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::setVertexData",1,"ofVbo *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofVbo::setVertexData",2,"ofVec3f const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVbo::setVertexData",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofVbo::setVertexData",4,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_setVertexData",1,SWIGTYPE_p_ofVbo); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Vbo_setVertexData",2,SWIGTYPE_p_ofVec3f); }  arg3 = (int)lua_tonumber(L, 3); arg4 = (int)lua_tonumber(L, 4);
  (arg1)->setVertexData((ofVec3f const *)arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Vbo_setVertexData__SWIG_3(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ;
  ofVec2f *arg2 = (ofVec2f *) 0 ; int arg3 ; int arg4 ; SWIG_check_num_args("ofVbo::setVertexData",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::setVertexData",1,"ofVbo *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofVbo::setVertexData",2,"ofVec2f const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVbo::setVertexData",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofVbo::setVertexData",4,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_setVertexData",1,SWIGTYPE_p_ofVbo); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec2f,0))){
    SWIG_fail_ptr("Vbo_setVertexData",2,SWIGTYPE_p_ofVec2f); }  arg3 = (int)lua_tonumber(L, 3); arg4 = (int)lua_tonumber(L, 4);
  (arg1)->setVertexData((ofVec2f const *)arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Vbo_setColorData__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ;
  ofFloatColor *arg2 = (ofFloatColor *) 0 ; int arg3 ; int arg4 ; SWIG_check_num_args("ofVbo::setColorData",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::setColorData",1,"ofVbo *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofVbo::setColorData",2,"ofFloatColor const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVbo::setColorData",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofVbo::setColorData",4,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){ SWIG_fail_ptr("Vbo_setColorData",1,SWIGTYPE_p_ofVbo); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("Vbo_setColorData",2,SWIGTYPE_p_ofColor_T_float_t); }  arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4); (arg1)->setColorData((ofFloatColor const *)arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vbo_setNormalData__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ;
  glm::vec3 *arg2 = (glm::vec3 *) 0 ; int arg3 ; int arg4 ; SWIG_check_num_args("ofVbo::setNormalData",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::setNormalData",1,"ofVbo *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofVbo::setNormalData",2,"glm::vec3 const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVbo::setNormalData",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofVbo::setNormalData",4,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_setNormalData",1,SWIGTYPE_p_ofVbo); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("Vbo_setNormalData",2,SWIGTYPE_p_glm__vec3); }  arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4); (arg1)->setNormalData((glm::vec3 const *)arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vbo_setNormalData__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ;
  ofVec3f *arg2 = (ofVec3f *) 0 ; int arg3 ; int arg4 ; SWIG_check_num_args("ofVbo::setNormalData",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::setNormalData",1,"ofVbo *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofVbo::setNormalData",2,"ofVec3f const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVbo::setNormalData",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofVbo::setNormalData",4,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_setNormalData",1,SWIGTYPE_p_ofVbo); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Vbo_setNormalData",2,SWIGTYPE_p_ofVec3f); }  arg3 = (int)lua_tonumber(L, 3); arg4 = (int)lua_tonumber(L, 4);
  (arg1)->setNormalData((ofVec3f const *)arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Vbo_setTexCoordData__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ;
  glm::vec2 *arg2 = (glm::vec2 *) 0 ; int arg3 ; int arg4 ; SWIG_check_num_args("ofVbo::setTexCoordData",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::setTexCoordData",1,"ofVbo *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofVbo::setTexCoordData",2,"glm::vec2 const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVbo::setTexCoordData",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofVbo::setTexCoordData",4,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_setTexCoordData",1,SWIGTYPE_p_ofVbo); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec2,0))){
    SWIG_fail_ptr("Vbo_setTexCoordData",2,SWIGTYPE_p_glm__vec2); }  arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4); (arg1)->setTexCoordData((glm::vec2 const *)arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vbo_setTexCoordData__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ;
  ofVec2f *arg2 = (ofVec2f *) 0 ; int arg3 ; int arg4 ; SWIG_check_num_args("ofVbo::setTexCoordData",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::setTexCoordData",1,"ofVbo *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofVbo::setTexCoordData",2,"ofVec2f const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVbo::setTexCoordData",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofVbo::setTexCoordData",4,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_setTexCoordData",1,SWIGTYPE_p_ofVbo); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec2f,0))){
    SWIG_fail_ptr("Vbo_setTexCoordData",2,SWIGTYPE_p_ofVec2f); }  arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4); (arg1)->setTexCoordData((ofVec2f const *)arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vbo_setIndexData(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ;
  ofIndexType *arg2 = (ofIndexType *) 0 ; int arg3 ; int arg4 ; SWIG_check_num_args("ofVbo::setIndexData",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::setIndexData",1,"ofVbo *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofVbo::setIndexData",2,"ofIndexType const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVbo::setIndexData",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofVbo::setIndexData",4,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){ SWIG_fail_ptr("Vbo_setIndexData",1,SWIGTYPE_p_ofVbo); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_TESSindex,0))){
    SWIG_fail_ptr("Vbo_setIndexData",2,SWIGTYPE_p_TESSindex); }  arg3 = (int)lua_tonumber(L, 3); arg4 = (int)lua_tonumber(L, 4);
  (arg1)->setIndexData((ofIndexType const *)arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Vbo_setVertexData__SWIG_4(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ;
  float *arg2 = (float *) 0 ; int arg3 ; int arg4 ; int arg5 ; int arg6 ; SWIG_check_num_args("ofVbo::setVertexData",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::setVertexData",1,"ofVbo *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofVbo::setVertexData",2,"float const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVbo::setVertexData",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofVbo::setVertexData",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofVbo::setVertexData",5,"int");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofVbo::setVertexData",6,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_setVertexData",1,SWIGTYPE_p_ofVbo); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("Vbo_setVertexData",2,SWIGTYPE_p_float); }  arg3 = (int)lua_tonumber(L, 3); arg4 = (int)lua_tonumber(L, 4);
  arg5 = (int)lua_tonumber(L, 5); arg6 = (int)lua_tonumber(L, 6);
  (arg1)->setVertexData((float const *)arg2,arg3,arg4,arg5,arg6); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Vbo_setVertexData__SWIG_5(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ;
  float *arg2 = (float *) 0 ; int arg3 ; int arg4 ; int arg5 ; SWIG_check_num_args("ofVbo::setVertexData",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::setVertexData",1,"ofVbo *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofVbo::setVertexData",2,"float const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVbo::setVertexData",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofVbo::setVertexData",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofVbo::setVertexData",5,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_setVertexData",1,SWIGTYPE_p_ofVbo); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("Vbo_setVertexData",2,SWIGTYPE_p_float); }  arg3 = (int)lua_tonumber(L, 3); arg4 = (int)lua_tonumber(L, 4);
  arg5 = (int)lua_tonumber(L, 5); (arg1)->setVertexData((float const *)arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vbo_setVertexData(lua_State* L) { int argc; int argv[7]={ 1,2,3,4,5,6,7} ; argc = lua_gettop(L);
  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVbo, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); } 
          if (_v) { return _wrap_Vbo_setVertexData__SWIG_0(L);}  }  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVbo, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec2, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); } 
          if (_v) { return _wrap_Vbo_setVertexData__SWIG_1(L);}  }  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVbo, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); } 
          if (_v) { return _wrap_Vbo_setVertexData__SWIG_2(L);}  }  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVbo, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofVec2f, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); } 
          if (_v) { return _wrap_Vbo_setVertexData__SWIG_3(L);}  }  }  }  }  if (argc == 5) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVbo, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_float, 0)) { _v = 0; }  else {
          _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { {
              _v = lua_isnumber(L,argv[4]); }  if (_v) { return _wrap_Vbo_setVertexData__SWIG_5(L);}  }  }  }  }  } 
  if (argc == 6) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVbo, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_float, 0)) { _v = 0; }  else {
          _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { {
              _v = lua_isnumber(L,argv[4]); }  if (_v) { { _v = lua_isnumber(L,argv[5]); }  if (_v) {
                return _wrap_Vbo_setVertexData__SWIG_4(L);}  }  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Vbo_setVertexData'\n" "  Possible C/C++ prototypes are:\n"
  "    ofVbo::setVertexData(glm::vec3 const *,int,int)\n" "    ofVbo::setVertexData(glm::vec2 const *,int,int)\n"
  "    ofVbo::setVertexData(ofVec3f const *,int,int)\n" "    ofVbo::setVertexData(ofVec2f const *,int,int)\n"
  "    ofVbo::setVertexData(float const *,int,int,int,int)\n" "    ofVbo::setVertexData(float const *,int,int,int)\n");
  lua_error(L);return 0; }
static int _wrap_Vbo_setColorData__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ;
  float *arg2 = (float *) 0 ; int arg3 ; int arg4 ; int arg5 ; SWIG_check_num_args("ofVbo::setColorData",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::setColorData",1,"ofVbo *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofVbo::setColorData",2,"float const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVbo::setColorData",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofVbo::setColorData",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofVbo::setColorData",5,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){ SWIG_fail_ptr("Vbo_setColorData",1,SWIGTYPE_p_ofVbo); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("Vbo_setColorData",2,SWIGTYPE_p_float); }  arg3 = (int)lua_tonumber(L, 3); arg4 = (int)lua_tonumber(L, 4);
  arg5 = (int)lua_tonumber(L, 5); (arg1)->setColorData((float const *)arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vbo_setColorData__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ;
  float *arg2 = (float *) 0 ; int arg3 ; int arg4 ; SWIG_check_num_args("ofVbo::setColorData",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::setColorData",1,"ofVbo *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofVbo::setColorData",2,"float const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVbo::setColorData",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofVbo::setColorData",4,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){ SWIG_fail_ptr("Vbo_setColorData",1,SWIGTYPE_p_ofVbo); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("Vbo_setColorData",2,SWIGTYPE_p_float); }  arg3 = (int)lua_tonumber(L, 3); arg4 = (int)lua_tonumber(L, 4);
  (arg1)->setColorData((float const *)arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vbo_setColorData(lua_State* L) { int argc; int argv[6]={ 1,2,3,4,5,6} ; argc = lua_gettop(L); if (argc == 4) {
    int _v; { void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVbo, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofColor_T_float_t, 0)) {
          _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { {
            _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_Vbo_setColorData__SWIG_0(L);}  }  }  }  }  if (argc == 4) {
    int _v; { void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVbo, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_float, 0)) { _v = 0; }  else {
          _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) {
            return _wrap_Vbo_setColorData__SWIG_2(L);}  }  }  }  }  if (argc == 5) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVbo, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_float, 0)) { _v = 0; }  else {
          _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { {
              _v = lua_isnumber(L,argv[4]); }  if (_v) { return _wrap_Vbo_setColorData__SWIG_1(L);}  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Vbo_setColorData'\n" "  Possible C/C++ prototypes are:\n"
  "    ofVbo::setColorData(ofFloatColor const *,int,int)\n" "    ofVbo::setColorData(float const *,int,int,int)\n"
  "    ofVbo::setColorData(float const *,int,int)\n"); lua_error(L);return 0; }
static int _wrap_Vbo_setNormalData__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ;
  float *arg2 = (float *) 0 ; int arg3 ; int arg4 ; int arg5 ; SWIG_check_num_args("ofVbo::setNormalData",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::setNormalData",1,"ofVbo *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofVbo::setNormalData",2,"float const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVbo::setNormalData",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofVbo::setNormalData",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofVbo::setNormalData",5,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_setNormalData",1,SWIGTYPE_p_ofVbo); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("Vbo_setNormalData",2,SWIGTYPE_p_float); }  arg3 = (int)lua_tonumber(L, 3); arg4 = (int)lua_tonumber(L, 4);
  arg5 = (int)lua_tonumber(L, 5); (arg1)->setNormalData((float const *)arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vbo_setNormalData__SWIG_3(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ;
  float *arg2 = (float *) 0 ; int arg3 ; int arg4 ; SWIG_check_num_args("ofVbo::setNormalData",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::setNormalData",1,"ofVbo *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofVbo::setNormalData",2,"float const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVbo::setNormalData",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofVbo::setNormalData",4,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_setNormalData",1,SWIGTYPE_p_ofVbo); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("Vbo_setNormalData",2,SWIGTYPE_p_float); }  arg3 = (int)lua_tonumber(L, 3); arg4 = (int)lua_tonumber(L, 4);
  (arg1)->setNormalData((float const *)arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vbo_setNormalData(lua_State* L) { int argc; int argv[6]={ 1,2,3,4,5,6} ; argc = lua_gettop(L); if (argc == 4) {
    int _v; { void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVbo, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); } 
          if (_v) { return _wrap_Vbo_setNormalData__SWIG_0(L);}  }  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVbo, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); } 
          if (_v) { return _wrap_Vbo_setNormalData__SWIG_1(L);}  }  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVbo, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_float, 0)) { _v = 0; }  else {
          _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) {
            return _wrap_Vbo_setNormalData__SWIG_3(L);}  }  }  }  }  if (argc == 5) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVbo, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_float, 0)) { _v = 0; }  else {
          _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { {
              _v = lua_isnumber(L,argv[4]); }  if (_v) { return _wrap_Vbo_setNormalData__SWIG_2(L);}  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Vbo_setNormalData'\n" "  Possible C/C++ prototypes are:\n"
  "    ofVbo::setNormalData(glm::vec3 const *,int,int)\n" "    ofVbo::setNormalData(ofVec3f const *,int,int)\n"
  "    ofVbo::setNormalData(float const *,int,int,int)\n" "    ofVbo::setNormalData(float const *,int,int)\n");
  lua_error(L);return 0; }
static int _wrap_Vbo_setTexCoordData__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ;
  float *arg2 = (float *) 0 ; int arg3 ; int arg4 ; int arg5 ; SWIG_check_num_args("ofVbo::setTexCoordData",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::setTexCoordData",1,"ofVbo *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofVbo::setTexCoordData",2,"float const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVbo::setTexCoordData",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofVbo::setTexCoordData",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofVbo::setTexCoordData",5,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_setTexCoordData",1,SWIGTYPE_p_ofVbo); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("Vbo_setTexCoordData",2,SWIGTYPE_p_float); }  arg3 = (int)lua_tonumber(L, 3); arg4 = (int)lua_tonumber(L, 4);
  arg5 = (int)lua_tonumber(L, 5); (arg1)->setTexCoordData((float const *)arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vbo_setTexCoordData__SWIG_3(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ;
  float *arg2 = (float *) 0 ; int arg3 ; int arg4 ; SWIG_check_num_args("ofVbo::setTexCoordData",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::setTexCoordData",1,"ofVbo *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofVbo::setTexCoordData",2,"float const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVbo::setTexCoordData",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofVbo::setTexCoordData",4,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_setTexCoordData",1,SWIGTYPE_p_ofVbo); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("Vbo_setTexCoordData",2,SWIGTYPE_p_float); }  arg3 = (int)lua_tonumber(L, 3); arg4 = (int)lua_tonumber(L, 4);
  (arg1)->setTexCoordData((float const *)arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Vbo_setTexCoordData(lua_State* L) { int argc; int argv[6]={ 1,2,3,4,5,6} ; argc = lua_gettop(L);
  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVbo, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec2, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); } 
          if (_v) { return _wrap_Vbo_setTexCoordData__SWIG_0(L);}  }  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVbo, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofVec2f, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); } 
          if (_v) { return _wrap_Vbo_setTexCoordData__SWIG_1(L);}  }  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVbo, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_float, 0)) { _v = 0; }  else {
          _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) {
            return _wrap_Vbo_setTexCoordData__SWIG_3(L);}  }  }  }  }  if (argc == 5) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVbo, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_float, 0)) { _v = 0; }  else {
          _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { {
              _v = lua_isnumber(L,argv[4]); }  if (_v) { return _wrap_Vbo_setTexCoordData__SWIG_2(L);}  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Vbo_setTexCoordData'\n"
  "  Possible C/C++ prototypes are:\n" "    ofVbo::setTexCoordData(glm::vec2 const *,int,int)\n"
  "    ofVbo::setTexCoordData(ofVec2f const *,int,int)\n" "    ofVbo::setTexCoordData(float const *,int,int,int)\n"
  "    ofVbo::setTexCoordData(float const *,int,int)\n"); lua_error(L);return 0; }
static int _wrap_Vbo_setAttributeData__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ; int arg2 ;
  float *arg3 = (float *) 0 ; int arg4 ; int arg5 ; int arg6 ; int arg7 ; SWIG_check_num_args("ofVbo::setAttributeData",7,7)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::setAttributeData",1,"ofVbo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVbo::setAttributeData",2,"int");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("ofVbo::setAttributeData",3,"float const *");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofVbo::setAttributeData",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofVbo::setAttributeData",5,"int");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofVbo::setAttributeData",6,"int");
  if(!lua_isnumber(L,7)) SWIG_fail_arg("ofVbo::setAttributeData",7,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_setAttributeData",1,SWIGTYPE_p_ofVbo); }  arg2 = (int)lua_tonumber(L, 2);
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("Vbo_setAttributeData",3,SWIGTYPE_p_float); }  arg4 = (int)lua_tonumber(L, 4); arg5 = (int)lua_tonumber(L, 5);
  arg6 = (int)lua_tonumber(L, 6); arg7 = (int)lua_tonumber(L, 7);
  (arg1)->setAttributeData(arg2,(float const *)arg3,arg4,arg5,arg6,arg7); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Vbo_setAttributeData__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ; int arg2 ;
  float *arg3 = (float *) 0 ; int arg4 ; int arg5 ; int arg6 ; SWIG_check_num_args("ofVbo::setAttributeData",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::setAttributeData",1,"ofVbo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVbo::setAttributeData",2,"int");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("ofVbo::setAttributeData",3,"float const *");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofVbo::setAttributeData",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofVbo::setAttributeData",5,"int");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofVbo::setAttributeData",6,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_setAttributeData",1,SWIGTYPE_p_ofVbo); }  arg2 = (int)lua_tonumber(L, 2);
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("Vbo_setAttributeData",3,SWIGTYPE_p_float); }  arg4 = (int)lua_tonumber(L, 4); arg5 = (int)lua_tonumber(L, 5);
  arg6 = (int)lua_tonumber(L, 6); (arg1)->setAttributeData(arg2,(float const *)arg3,arg4,arg5,arg6); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vbo_setAttributeData(lua_State* L) { int argc; int argv[8]={ 1,2,3,4,5,6,7,8} ; argc = lua_gettop(L);
  if (argc == 6) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVbo, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { void *ptr;
          if (SWIG_isptrtype(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_float, 0)) { _v = 0; }
           else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); } 
            if (_v) { { _v = lua_isnumber(L,argv[5]); }  if (_v) { return _wrap_Vbo_setAttributeData__SWIG_1(L);}  }  }  }  }  }
     }  if (argc == 7) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVbo, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { void *ptr;
          if (SWIG_isptrtype(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_float, 0)) { _v = 0; }
           else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); } 
            if (_v) { { _v = lua_isnumber(L,argv[5]); }  if (_v) { { _v = lua_isnumber(L,argv[6]); }  if (_v) {
                  return _wrap_Vbo_setAttributeData__SWIG_0(L);}  }  }  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Vbo_setAttributeData'\n"
  "  Possible C/C++ prototypes are:\n" "    ofVbo::setAttributeData(int,float const *,int,int,int,int)\n"
  "    ofVbo::setAttributeData(int,float const *,int,int,int)\n"); lua_error(L);return 0; }
static int _wrap_Vbo_setAttributeDivisor(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ; int arg2 ; int arg3 ;
  SWIG_check_num_args("ofVbo::setAttributeDivisor",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::setAttributeDivisor",1,"ofVbo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVbo::setAttributeDivisor",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVbo::setAttributeDivisor",3,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_setAttributeDivisor",1,SWIGTYPE_p_ofVbo); }  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3); (arg1)->setAttributeDivisor(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Vbo_setVertexBuffer__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ;
  ofBufferObject *arg2 = 0 ; int arg3 ; int arg4 ; int arg5 ; SWIG_check_num_args("ofVbo::setVertexBuffer",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::setVertexBuffer",1,"ofVbo *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVbo::setVertexBuffer",2,"ofBufferObject &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVbo::setVertexBuffer",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofVbo::setVertexBuffer",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofVbo::setVertexBuffer",5,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_setVertexBuffer",1,SWIGTYPE_p_ofVbo); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofBufferObject,0))){
    SWIG_fail_ptr("Vbo_setVertexBuffer",2,SWIGTYPE_p_ofBufferObject); }  arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4); arg5 = (int)lua_tonumber(L, 5); (arg1)->setVertexBuffer(*arg2,arg3,arg4,arg5);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vbo_setVertexBuffer__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ;
  ofBufferObject *arg2 = 0 ; int arg3 ; int arg4 ; SWIG_check_num_args("ofVbo::setVertexBuffer",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::setVertexBuffer",1,"ofVbo *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVbo::setVertexBuffer",2,"ofBufferObject &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVbo::setVertexBuffer",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofVbo::setVertexBuffer",4,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_setVertexBuffer",1,SWIGTYPE_p_ofVbo); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofBufferObject,0))){
    SWIG_fail_ptr("Vbo_setVertexBuffer",2,SWIGTYPE_p_ofBufferObject); }  arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4); (arg1)->setVertexBuffer(*arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vbo_setVertexBuffer(lua_State* L) { int argc; int argv[6]={ 1,2,3,4,5,6} ; argc = lua_gettop(L);
  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVbo, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofBufferObject, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); } 
          if (_v) { return _wrap_Vbo_setVertexBuffer__SWIG_1(L);}  }  }  }  }  if (argc == 5) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVbo, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofBufferObject, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); } 
          if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) { return _wrap_Vbo_setVertexBuffer__SWIG_0(L);}  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Vbo_setVertexBuffer'\n"
  "  Possible C/C++ prototypes are:\n" "    ofVbo::setVertexBuffer(ofBufferObject &,int,int,int)\n"
  "    ofVbo::setVertexBuffer(ofBufferObject &,int,int)\n"); lua_error(L);return 0; }
static int _wrap_Vbo_setColorBuffer__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ;
  ofBufferObject *arg2 = 0 ; int arg3 ; int arg4 ; SWIG_check_num_args("ofVbo::setColorBuffer",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::setColorBuffer",1,"ofVbo *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVbo::setColorBuffer",2,"ofBufferObject &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVbo::setColorBuffer",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofVbo::setColorBuffer",4,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_setColorBuffer",1,SWIGTYPE_p_ofVbo); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofBufferObject,0))){
    SWIG_fail_ptr("Vbo_setColorBuffer",2,SWIGTYPE_p_ofBufferObject); }  arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4); (arg1)->setColorBuffer(*arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Vbo_setColorBuffer__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ;
  ofBufferObject *arg2 = 0 ; int arg3 ; SWIG_check_num_args("ofVbo::setColorBuffer",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::setColorBuffer",1,"ofVbo *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVbo::setColorBuffer",2,"ofBufferObject &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVbo::setColorBuffer",3,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_setColorBuffer",1,SWIGTYPE_p_ofVbo); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofBufferObject,0))){
    SWIG_fail_ptr("Vbo_setColorBuffer",2,SWIGTYPE_p_ofBufferObject); }  arg3 = (int)lua_tonumber(L, 3);
  (arg1)->setColorBuffer(*arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vbo_setColorBuffer(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L); if (argc == 3) {
    int _v; { void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVbo, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofBufferObject, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { return _wrap_Vbo_setColorBuffer__SWIG_1(L);}
         }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVbo, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofBufferObject, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); } 
          if (_v) { return _wrap_Vbo_setColorBuffer__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Vbo_setColorBuffer'\n" "  Possible C/C++ prototypes are:\n"
  "    ofVbo::setColorBuffer(ofBufferObject &,int,int)\n" "    ofVbo::setColorBuffer(ofBufferObject &,int)\n");
  lua_error(L);return 0; }
static int _wrap_Vbo_setNormalBuffer__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ;
  ofBufferObject *arg2 = 0 ; int arg3 ; int arg4 ; SWIG_check_num_args("ofVbo::setNormalBuffer",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::setNormalBuffer",1,"ofVbo *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVbo::setNormalBuffer",2,"ofBufferObject &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVbo::setNormalBuffer",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofVbo::setNormalBuffer",4,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_setNormalBuffer",1,SWIGTYPE_p_ofVbo); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofBufferObject,0))){
    SWIG_fail_ptr("Vbo_setNormalBuffer",2,SWIGTYPE_p_ofBufferObject); }  arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4); (arg1)->setNormalBuffer(*arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vbo_setNormalBuffer__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ;
  ofBufferObject *arg2 = 0 ; int arg3 ; SWIG_check_num_args("ofVbo::setNormalBuffer",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::setNormalBuffer",1,"ofVbo *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVbo::setNormalBuffer",2,"ofBufferObject &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVbo::setNormalBuffer",3,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_setNormalBuffer",1,SWIGTYPE_p_ofVbo); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofBufferObject,0))){
    SWIG_fail_ptr("Vbo_setNormalBuffer",2,SWIGTYPE_p_ofBufferObject); }  arg3 = (int)lua_tonumber(L, 3);
  (arg1)->setNormalBuffer(*arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vbo_setNormalBuffer(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L); if (argc == 3) {
    int _v; { void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVbo, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofBufferObject, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_Vbo_setNormalBuffer__SWIG_1(L);}  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVbo, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofBufferObject, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); } 
          if (_v) { return _wrap_Vbo_setNormalBuffer__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Vbo_setNormalBuffer'\n"
  "  Possible C/C++ prototypes are:\n" "    ofVbo::setNormalBuffer(ofBufferObject &,int,int)\n"
  "    ofVbo::setNormalBuffer(ofBufferObject &,int)\n"); lua_error(L);return 0; }
static int _wrap_Vbo_setTexCoordBuffer__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ;
  ofBufferObject *arg2 = 0 ; int arg3 ; int arg4 ; SWIG_check_num_args("ofVbo::setTexCoordBuffer",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::setTexCoordBuffer",1,"ofVbo *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVbo::setTexCoordBuffer",2,"ofBufferObject &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVbo::setTexCoordBuffer",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofVbo::setTexCoordBuffer",4,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_setTexCoordBuffer",1,SWIGTYPE_p_ofVbo); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofBufferObject,0))){
    SWIG_fail_ptr("Vbo_setTexCoordBuffer",2,SWIGTYPE_p_ofBufferObject); }  arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4); (arg1)->setTexCoordBuffer(*arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vbo_setTexCoordBuffer__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ;
  ofBufferObject *arg2 = 0 ; int arg3 ; SWIG_check_num_args("ofVbo::setTexCoordBuffer",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::setTexCoordBuffer",1,"ofVbo *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVbo::setTexCoordBuffer",2,"ofBufferObject &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVbo::setTexCoordBuffer",3,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_setTexCoordBuffer",1,SWIGTYPE_p_ofVbo); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofBufferObject,0))){
    SWIG_fail_ptr("Vbo_setTexCoordBuffer",2,SWIGTYPE_p_ofBufferObject); }  arg3 = (int)lua_tonumber(L, 3);
  (arg1)->setTexCoordBuffer(*arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vbo_setTexCoordBuffer(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L);
  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVbo, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofBufferObject, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_Vbo_setTexCoordBuffer__SWIG_1(L);}  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVbo, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofBufferObject, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); } 
          if (_v) { return _wrap_Vbo_setTexCoordBuffer__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Vbo_setTexCoordBuffer'\n"
  "  Possible C/C++ prototypes are:\n" "    ofVbo::setTexCoordBuffer(ofBufferObject &,int,int)\n"
  "    ofVbo::setTexCoordBuffer(ofBufferObject &,int)\n"); lua_error(L);return 0; }
static int _wrap_Vbo_setIndexBuffer(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ; ofBufferObject *arg2 = 0 ;
  SWIG_check_num_args("ofVbo::setIndexBuffer",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::setIndexBuffer",1,"ofVbo *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVbo::setIndexBuffer",2,"ofBufferObject &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_setIndexBuffer",1,SWIGTYPE_p_ofVbo); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofBufferObject,0))){
    SWIG_fail_ptr("Vbo_setIndexBuffer",2,SWIGTYPE_p_ofBufferObject); }  (arg1)->setIndexBuffer(*arg2); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vbo_setAttributeBuffer__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ; int arg2 ;
  ofBufferObject *arg3 = 0 ; int arg4 ; int arg5 ; int arg6 ; SWIG_check_num_args("ofVbo::setAttributeBuffer",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::setAttributeBuffer",1,"ofVbo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVbo::setAttributeBuffer",2,"int");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofVbo::setAttributeBuffer",3,"ofBufferObject &");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofVbo::setAttributeBuffer",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofVbo::setAttributeBuffer",5,"int");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofVbo::setAttributeBuffer",6,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_setAttributeBuffer",1,SWIGTYPE_p_ofVbo); }  arg2 = (int)lua_tonumber(L, 2);
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_ofBufferObject,0))){
    SWIG_fail_ptr("Vbo_setAttributeBuffer",3,SWIGTYPE_p_ofBufferObject); }  arg4 = (int)lua_tonumber(L, 4);
  arg5 = (int)lua_tonumber(L, 5); arg6 = (int)lua_tonumber(L, 6); (arg1)->setAttributeBuffer(arg2,*arg3,arg4,arg5,arg6);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vbo_setAttributeBuffer__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ; int arg2 ;
  ofBufferObject *arg3 = 0 ; int arg4 ; int arg5 ; SWIG_check_num_args("ofVbo::setAttributeBuffer",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::setAttributeBuffer",1,"ofVbo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVbo::setAttributeBuffer",2,"int");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofVbo::setAttributeBuffer",3,"ofBufferObject &");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofVbo::setAttributeBuffer",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofVbo::setAttributeBuffer",5,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_setAttributeBuffer",1,SWIGTYPE_p_ofVbo); }  arg2 = (int)lua_tonumber(L, 2);
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_ofBufferObject,0))){
    SWIG_fail_ptr("Vbo_setAttributeBuffer",3,SWIGTYPE_p_ofBufferObject); }  arg4 = (int)lua_tonumber(L, 4);
  arg5 = (int)lua_tonumber(L, 5); (arg1)->setAttributeBuffer(arg2,*arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vbo_setAttributeBuffer(lua_State* L) { int argc; int argv[7]={ 1,2,3,4,5,6,7} ; argc = lua_gettop(L);
  if (argc == 5) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVbo, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_ofBufferObject, 0)) {
            _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { {
              _v = lua_isnumber(L,argv[4]); }  if (_v) { return _wrap_Vbo_setAttributeBuffer__SWIG_1(L);}  }  }  }  }  } 
  if (argc == 6) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVbo, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_ofBufferObject, 0)) {
            _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { {
              _v = lua_isnumber(L,argv[4]); }  if (_v) { { _v = lua_isnumber(L,argv[5]); }  if (_v) {
                return _wrap_Vbo_setAttributeBuffer__SWIG_0(L);}  }  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Vbo_setAttributeBuffer'\n"
  "  Possible C/C++ prototypes are:\n" "    ofVbo::setAttributeBuffer(int,ofBufferObject &,int,int,int)\n"
  "    ofVbo::setAttributeBuffer(int,ofBufferObject &,int,int)\n"); lua_error(L);return 0; }
static int _wrap_Vbo_getVertexBuffer__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ;
  ofBufferObject *result = 0 ; SWIG_check_num_args("ofVbo::getVertexBuffer",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::getVertexBuffer",1,"ofVbo *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_getVertexBuffer",1,SWIGTYPE_p_ofVbo); }  result = (ofBufferObject *) &(arg1)->getVertexBuffer();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofBufferObject,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Vbo_getColorBuffer__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ;
  ofBufferObject *result = 0 ; SWIG_check_num_args("ofVbo::getColorBuffer",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::getColorBuffer",1,"ofVbo *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_getColorBuffer",1,SWIGTYPE_p_ofVbo); }  result = (ofBufferObject *) &(arg1)->getColorBuffer();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofBufferObject,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Vbo_getNormalBuffer__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ;
  ofBufferObject *result = 0 ; SWIG_check_num_args("ofVbo::getNormalBuffer",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::getNormalBuffer",1,"ofVbo *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_getNormalBuffer",1,SWIGTYPE_p_ofVbo); }  result = (ofBufferObject *) &(arg1)->getNormalBuffer();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofBufferObject,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Vbo_getTexCoordBuffer__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ;
  ofBufferObject *result = 0 ; SWIG_check_num_args("ofVbo::getTexCoordBuffer",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::getTexCoordBuffer",1,"ofVbo *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_getTexCoordBuffer",1,SWIGTYPE_p_ofVbo); }  result = (ofBufferObject *) &(arg1)->getTexCoordBuffer();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofBufferObject,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Vbo_getIndexBuffer__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ;
  ofBufferObject *result = 0 ; SWIG_check_num_args("ofVbo::getIndexBuffer",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::getIndexBuffer",1,"ofVbo *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_getIndexBuffer",1,SWIGTYPE_p_ofVbo); }  result = (ofBufferObject *) &(arg1)->getIndexBuffer();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofBufferObject,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Vbo_getAttributeBuffer__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ; int arg2 ;
  ofBufferObject *result = 0 ; SWIG_check_num_args("ofVbo::getAttributeBuffer",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::getAttributeBuffer",1,"ofVbo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVbo::getAttributeBuffer",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_getAttributeBuffer",1,SWIGTYPE_p_ofVbo); }  arg2 = (int)lua_tonumber(L, 2);
  result = (ofBufferObject *) &(arg1)->getAttributeBuffer(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofBufferObject,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Vbo_getVertexBuffer__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ;
  ofBufferObject *result = 0 ; SWIG_check_num_args("ofVbo::getVertexBuffer",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::getVertexBuffer",1,"ofVbo const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_getVertexBuffer",1,SWIGTYPE_p_ofVbo); } 
  result = (ofBufferObject *) &((ofVbo const *)arg1)->getVertexBuffer();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofBufferObject,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Vbo_getVertexBuffer(lua_State* L) { int argc; int argv[2]={ 1,2} ; argc = lua_gettop(L); if (argc == 1) {
    int _v; { void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVbo, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Vbo_getVertexBuffer__SWIG_0(L);}  }  if (argc == 1) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVbo, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { return _wrap_Vbo_getVertexBuffer__SWIG_1(L);}  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Vbo_getVertexBuffer'\n"
  "  Possible C/C++ prototypes are:\n" "    ofVbo::getVertexBuffer()\n" "    ofVbo::getVertexBuffer() const\n");
  lua_error(L);return 0; }
static int _wrap_Vbo_getColorBuffer__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ;
  ofBufferObject *result = 0 ; SWIG_check_num_args("ofVbo::getColorBuffer",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::getColorBuffer",1,"ofVbo const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_getColorBuffer",1,SWIGTYPE_p_ofVbo); } 
  result = (ofBufferObject *) &((ofVbo const *)arg1)->getColorBuffer();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofBufferObject,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Vbo_getColorBuffer(lua_State* L) { int argc; int argv[2]={ 1,2} ; argc = lua_gettop(L); if (argc == 1) {
    int _v; { void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVbo, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Vbo_getColorBuffer__SWIG_0(L);}  }  if (argc == 1) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVbo, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { return _wrap_Vbo_getColorBuffer__SWIG_1(L);}  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Vbo_getColorBuffer'\n" "  Possible C/C++ prototypes are:\n"
  "    ofVbo::getColorBuffer()\n" "    ofVbo::getColorBuffer() const\n"); lua_error(L);return 0; }
static int _wrap_Vbo_getNormalBuffer__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ;
  ofBufferObject *result = 0 ; SWIG_check_num_args("ofVbo::getNormalBuffer",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::getNormalBuffer",1,"ofVbo const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_getNormalBuffer",1,SWIGTYPE_p_ofVbo); } 
  result = (ofBufferObject *) &((ofVbo const *)arg1)->getNormalBuffer();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofBufferObject,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Vbo_getNormalBuffer(lua_State* L) { int argc; int argv[2]={ 1,2} ; argc = lua_gettop(L); if (argc == 1) {
    int _v; { void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVbo, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Vbo_getNormalBuffer__SWIG_0(L);}  }  if (argc == 1) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVbo, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { return _wrap_Vbo_getNormalBuffer__SWIG_1(L);}  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Vbo_getNormalBuffer'\n"
  "  Possible C/C++ prototypes are:\n" "    ofVbo::getNormalBuffer()\n" "    ofVbo::getNormalBuffer() const\n");
  lua_error(L);return 0; }
static int _wrap_Vbo_getTexCoordBuffer__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ;
  ofBufferObject *result = 0 ; SWIG_check_num_args("ofVbo::getTexCoordBuffer",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::getTexCoordBuffer",1,"ofVbo const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_getTexCoordBuffer",1,SWIGTYPE_p_ofVbo); } 
  result = (ofBufferObject *) &((ofVbo const *)arg1)->getTexCoordBuffer();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofBufferObject,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Vbo_getTexCoordBuffer(lua_State* L) { int argc; int argv[2]={ 1,2} ; argc = lua_gettop(L); if (argc == 1) {
    int _v; { void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVbo, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Vbo_getTexCoordBuffer__SWIG_0(L);}  }  if (argc == 1) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVbo, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { return _wrap_Vbo_getTexCoordBuffer__SWIG_1(L);}  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Vbo_getTexCoordBuffer'\n"
  "  Possible C/C++ prototypes are:\n" "    ofVbo::getTexCoordBuffer()\n" "    ofVbo::getTexCoordBuffer() const\n");
  lua_error(L);return 0; }
static int _wrap_Vbo_getIndexBuffer__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ;
  ofBufferObject *result = 0 ; SWIG_check_num_args("ofVbo::getIndexBuffer",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::getIndexBuffer",1,"ofVbo const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_getIndexBuffer",1,SWIGTYPE_p_ofVbo); } 
  result = (ofBufferObject *) &((ofVbo const *)arg1)->getIndexBuffer();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofBufferObject,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Vbo_getIndexBuffer(lua_State* L) { int argc; int argv[2]={ 1,2} ; argc = lua_gettop(L); if (argc == 1) {
    int _v; { void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVbo, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Vbo_getIndexBuffer__SWIG_0(L);}  }  if (argc == 1) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVbo, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { return _wrap_Vbo_getIndexBuffer__SWIG_1(L);}  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Vbo_getIndexBuffer'\n" "  Possible C/C++ prototypes are:\n"
  "    ofVbo::getIndexBuffer()\n" "    ofVbo::getIndexBuffer() const\n"); lua_error(L);return 0; }
static int _wrap_Vbo_getAttributeBuffer__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ; int arg2 ;
  ofBufferObject *result = 0 ; SWIG_check_num_args("ofVbo::getAttributeBuffer",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::getAttributeBuffer",1,"ofVbo const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVbo::getAttributeBuffer",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_getAttributeBuffer",1,SWIGTYPE_p_ofVbo); }  arg2 = (int)lua_tonumber(L, 2);
  result = (ofBufferObject *) &((ofVbo const *)arg1)->getAttributeBuffer(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofBufferObject,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Vbo_getAttributeBuffer(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVbo, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_Vbo_getAttributeBuffer__SWIG_0(L);}  }  }  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVbo, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { return _wrap_Vbo_getAttributeBuffer__SWIG_1(L);}  }
     }  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Vbo_getAttributeBuffer'\n"
  "  Possible C/C++ prototypes are:\n" "    ofVbo::getAttributeBuffer(int)\n" "    ofVbo::getAttributeBuffer(int) const\n");
  lua_error(L);return 0; }
static int _wrap_Vbo_updateMesh(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ; ofMesh *arg2 = 0 ;
  SWIG_check_num_args("ofVbo::updateMesh",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::updateMesh",1,"ofVbo *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVbo::updateMesh",2,"ofMesh const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){ SWIG_fail_ptr("Vbo_updateMesh",1,SWIGTYPE_p_ofVbo); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("Vbo_updateMesh",2,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   (arg1)->updateMesh((ofMesh const &)*arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vbo_updateVertexData__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ;
  glm::vec3 *arg2 = (glm::vec3 *) 0 ; int arg3 ; SWIG_check_num_args("ofVbo::updateVertexData",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::updateVertexData",1,"ofVbo *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofVbo::updateVertexData",2,"glm::vec3 const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVbo::updateVertexData",3,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_updateVertexData",1,SWIGTYPE_p_ofVbo); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("Vbo_updateVertexData",2,SWIGTYPE_p_glm__vec3); }  arg3 = (int)lua_tonumber(L, 3);
  (arg1)->updateVertexData((glm::vec3 const *)arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Vbo_updateVertexData__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ;
  glm::vec2 *arg2 = (glm::vec2 *) 0 ; int arg3 ; SWIG_check_num_args("ofVbo::updateVertexData",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::updateVertexData",1,"ofVbo *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofVbo::updateVertexData",2,"glm::vec2 const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVbo::updateVertexData",3,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_updateVertexData",1,SWIGTYPE_p_ofVbo); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec2,0))){
    SWIG_fail_ptr("Vbo_updateVertexData",2,SWIGTYPE_p_glm__vec2); }  arg3 = (int)lua_tonumber(L, 3);
  (arg1)->updateVertexData((glm::vec2 const *)arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Vbo_updateVertexData__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ;
  ofVec3f *arg2 = (ofVec3f *) 0 ; int arg3 ; SWIG_check_num_args("ofVbo::updateVertexData",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::updateVertexData",1,"ofVbo *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofVbo::updateVertexData",2,"ofVec3f const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVbo::updateVertexData",3,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_updateVertexData",1,SWIGTYPE_p_ofVbo); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Vbo_updateVertexData",2,SWIGTYPE_p_ofVec3f); }  arg3 = (int)lua_tonumber(L, 3);
  (arg1)->updateVertexData((ofVec3f const *)arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vbo_updateVertexData__SWIG_3(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ;
  ofVec2f *arg2 = (ofVec2f *) 0 ; int arg3 ; SWIG_check_num_args("ofVbo::updateVertexData",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::updateVertexData",1,"ofVbo *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofVbo::updateVertexData",2,"ofVec2f const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVbo::updateVertexData",3,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_updateVertexData",1,SWIGTYPE_p_ofVbo); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec2f,0))){
    SWIG_fail_ptr("Vbo_updateVertexData",2,SWIGTYPE_p_ofVec2f); }  arg3 = (int)lua_tonumber(L, 3);
  (arg1)->updateVertexData((ofVec2f const *)arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vbo_updateColorData__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ;
  ofFloatColor *arg2 = (ofFloatColor *) 0 ; int arg3 ; SWIG_check_num_args("ofVbo::updateColorData",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::updateColorData",1,"ofVbo *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofVbo::updateColorData",2,"ofFloatColor const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVbo::updateColorData",3,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_updateColorData",1,SWIGTYPE_p_ofVbo); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("Vbo_updateColorData",2,SWIGTYPE_p_ofColor_T_float_t); }  arg3 = (int)lua_tonumber(L, 3);
  (arg1)->updateColorData((ofFloatColor const *)arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Vbo_updateNormalData__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ;
  glm::vec3 *arg2 = (glm::vec3 *) 0 ; int arg3 ; SWIG_check_num_args("ofVbo::updateNormalData",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::updateNormalData",1,"ofVbo *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofVbo::updateNormalData",2,"glm::vec3 const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVbo::updateNormalData",3,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_updateNormalData",1,SWIGTYPE_p_ofVbo); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("Vbo_updateNormalData",2,SWIGTYPE_p_glm__vec3); }  arg3 = (int)lua_tonumber(L, 3);
  (arg1)->updateNormalData((glm::vec3 const *)arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Vbo_updateNormalData__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ;
  ofVec3f *arg2 = (ofVec3f *) 0 ; int arg3 ; SWIG_check_num_args("ofVbo::updateNormalData",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::updateNormalData",1,"ofVbo *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofVbo::updateNormalData",2,"ofVec3f const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVbo::updateNormalData",3,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_updateNormalData",1,SWIGTYPE_p_ofVbo); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec3f,0))){
    SWIG_fail_ptr("Vbo_updateNormalData",2,SWIGTYPE_p_ofVec3f); }  arg3 = (int)lua_tonumber(L, 3);
  (arg1)->updateNormalData((ofVec3f const *)arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vbo_updateTexCoordData__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ;
  glm::vec2 *arg2 = (glm::vec2 *) 0 ; int arg3 ; SWIG_check_num_args("ofVbo::updateTexCoordData",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::updateTexCoordData",1,"ofVbo *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofVbo::updateTexCoordData",2,"glm::vec2 const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVbo::updateTexCoordData",3,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_updateTexCoordData",1,SWIGTYPE_p_ofVbo); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec2,0))){
    SWIG_fail_ptr("Vbo_updateTexCoordData",2,SWIGTYPE_p_glm__vec2); }  arg3 = (int)lua_tonumber(L, 3);
  (arg1)->updateTexCoordData((glm::vec2 const *)arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Vbo_updateTexCoordData__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ;
  ofVec2f *arg2 = (ofVec2f *) 0 ; int arg3 ; SWIG_check_num_args("ofVbo::updateTexCoordData",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::updateTexCoordData",1,"ofVbo *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofVbo::updateTexCoordData",2,"ofVec2f const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVbo::updateTexCoordData",3,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_updateTexCoordData",1,SWIGTYPE_p_ofVbo); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofVec2f,0))){
    SWIG_fail_ptr("Vbo_updateTexCoordData",2,SWIGTYPE_p_ofVec2f); }  arg3 = (int)lua_tonumber(L, 3);
  (arg1)->updateTexCoordData((ofVec2f const *)arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Vbo_updateIndexData(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ;
  ofIndexType *arg2 = (ofIndexType *) 0 ; int arg3 ; SWIG_check_num_args("ofVbo::updateIndexData",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::updateIndexData",1,"ofVbo *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofVbo::updateIndexData",2,"ofIndexType const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVbo::updateIndexData",3,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_updateIndexData",1,SWIGTYPE_p_ofVbo); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_TESSindex,0))){
    SWIG_fail_ptr("Vbo_updateIndexData",2,SWIGTYPE_p_TESSindex); }  arg3 = (int)lua_tonumber(L, 3);
  (arg1)->updateIndexData((ofIndexType const *)arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Vbo_updateVertexData__SWIG_4(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ;
  float *arg2 = (float *) 0 ; int arg3 ; SWIG_check_num_args("ofVbo::updateVertexData",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::updateVertexData",1,"ofVbo *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofVbo::updateVertexData",2,"float const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVbo::updateVertexData",3,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_updateVertexData",1,SWIGTYPE_p_ofVbo); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("Vbo_updateVertexData",2,SWIGTYPE_p_float); }  arg3 = (int)lua_tonumber(L, 3);
  (arg1)->updateVertexData((float const *)arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vbo_updateVertexData(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 3) {
    int _v; { void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVbo, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_Vbo_updateVertexData__SWIG_0(L);}  }  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVbo, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec2, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_Vbo_updateVertexData__SWIG_1(L);}  }  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVbo, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_Vbo_updateVertexData__SWIG_2(L);}  }  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVbo, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofVec2f, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_Vbo_updateVertexData__SWIG_3(L);}  }  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVbo, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_float, 0)) { _v = 0; }  else {
          _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { return _wrap_Vbo_updateVertexData__SWIG_4(L);}  }
       }  }  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Vbo_updateVertexData'\n"
  "  Possible C/C++ prototypes are:\n" "    ofVbo::updateVertexData(glm::vec3 const *,int)\n"
  "    ofVbo::updateVertexData(glm::vec2 const *,int)\n" "    ofVbo::updateVertexData(ofVec3f const *,int)\n"
  "    ofVbo::updateVertexData(ofVec2f const *,int)\n" "    ofVbo::updateVertexData(float const *,int)\n");
  lua_error(L);return 0; }
static int _wrap_Vbo_updateColorData__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ;
  float *arg2 = (float *) 0 ; int arg3 ; SWIG_check_num_args("ofVbo::updateColorData",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::updateColorData",1,"ofVbo *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofVbo::updateColorData",2,"float const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVbo::updateColorData",3,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_updateColorData",1,SWIGTYPE_p_ofVbo); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("Vbo_updateColorData",2,SWIGTYPE_p_float); }  arg3 = (int)lua_tonumber(L, 3);
  (arg1)->updateColorData((float const *)arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vbo_updateColorData(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 3) {
    int _v; { void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVbo, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofColor_T_float_t, 0)) {
          _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_Vbo_updateColorData__SWIG_0(L);}  }  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVbo, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_float, 0)) { _v = 0; }  else {
          _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { return _wrap_Vbo_updateColorData__SWIG_1(L);}  }
       }  }  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Vbo_updateColorData'\n"
  "  Possible C/C++ prototypes are:\n" "    ofVbo::updateColorData(ofFloatColor const *,int)\n"
  "    ofVbo::updateColorData(float const *,int)\n"); lua_error(L);return 0; }
static int _wrap_Vbo_updateNormalData__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ;
  float *arg2 = (float *) 0 ; int arg3 ; SWIG_check_num_args("ofVbo::updateNormalData",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::updateNormalData",1,"ofVbo *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofVbo::updateNormalData",2,"float const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVbo::updateNormalData",3,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_updateNormalData",1,SWIGTYPE_p_ofVbo); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("Vbo_updateNormalData",2,SWIGTYPE_p_float); }  arg3 = (int)lua_tonumber(L, 3);
  (arg1)->updateNormalData((float const *)arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vbo_updateNormalData(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 3) {
    int _v; { void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVbo, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_Vbo_updateNormalData__SWIG_0(L);}  }  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVbo, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofVec3f, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_Vbo_updateNormalData__SWIG_1(L);}  }  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVbo, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_float, 0)) { _v = 0; }  else {
          _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { return _wrap_Vbo_updateNormalData__SWIG_2(L);}  }
       }  }  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Vbo_updateNormalData'\n"
  "  Possible C/C++ prototypes are:\n" "    ofVbo::updateNormalData(glm::vec3 const *,int)\n"
  "    ofVbo::updateNormalData(ofVec3f const *,int)\n" "    ofVbo::updateNormalData(float const *,int)\n");
  lua_error(L);return 0; }
static int _wrap_Vbo_updateTexCoordData__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ;
  float *arg2 = (float *) 0 ; int arg3 ; SWIG_check_num_args("ofVbo::updateTexCoordData",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::updateTexCoordData",1,"ofVbo *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofVbo::updateTexCoordData",2,"float const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVbo::updateTexCoordData",3,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_updateTexCoordData",1,SWIGTYPE_p_ofVbo); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("Vbo_updateTexCoordData",2,SWIGTYPE_p_float); }  arg3 = (int)lua_tonumber(L, 3);
  (arg1)->updateTexCoordData((float const *)arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vbo_updateTexCoordData(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L);
  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVbo, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec2, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_Vbo_updateTexCoordData__SWIG_0(L);}  }  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVbo, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofVec2f, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_Vbo_updateTexCoordData__SWIG_1(L);}  }  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVbo, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_float, 0)) { _v = 0; }  else {
          _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { return _wrap_Vbo_updateTexCoordData__SWIG_2(L);}
         }  }  }  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Vbo_updateTexCoordData'\n"
  "  Possible C/C++ prototypes are:\n" "    ofVbo::updateTexCoordData(glm::vec2 const *,int)\n"
  "    ofVbo::updateTexCoordData(ofVec2f const *,int)\n" "    ofVbo::updateTexCoordData(float const *,int)\n");
  lua_error(L);return 0; }
static int _wrap_Vbo_updateAttributeData(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ; int arg2 ;
  float *arg3 = (float *) 0 ; int arg4 ; SWIG_check_num_args("ofVbo::updateAttributeData",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::updateAttributeData",1,"ofVbo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVbo::updateAttributeData",2,"int");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("ofVbo::updateAttributeData",3,"float const *");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofVbo::updateAttributeData",4,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_updateAttributeData",1,SWIGTYPE_p_ofVbo); }  arg2 = (int)lua_tonumber(L, 2);
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("Vbo_updateAttributeData",3,SWIGTYPE_p_float); }  arg4 = (int)lua_tonumber(L, 4);
  (arg1)->updateAttributeData(arg2,(float const *)arg3,arg4); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Vbo_enableColors(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ;
  SWIG_check_num_args("ofVbo::enableColors",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::enableColors",1,"ofVbo *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){ SWIG_fail_ptr("Vbo_enableColors",1,SWIGTYPE_p_ofVbo); }
   (arg1)->enableColors(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vbo_enableNormals(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ;
  SWIG_check_num_args("ofVbo::enableNormals",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::enableNormals",1,"ofVbo *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_enableNormals",1,SWIGTYPE_p_ofVbo); }  (arg1)->enableNormals(); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vbo_enableTexCoords(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ;
  SWIG_check_num_args("ofVbo::enableTexCoords",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::enableTexCoords",1,"ofVbo *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_enableTexCoords",1,SWIGTYPE_p_ofVbo); }  (arg1)->enableTexCoords(); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vbo_enableIndices(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ;
  SWIG_check_num_args("ofVbo::enableIndices",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::enableIndices",1,"ofVbo *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_enableIndices",1,SWIGTYPE_p_ofVbo); }  (arg1)->enableIndices(); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vbo_disableColors(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ;
  SWIG_check_num_args("ofVbo::disableColors",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::disableColors",1,"ofVbo *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_disableColors",1,SWIGTYPE_p_ofVbo); }  (arg1)->disableColors(); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vbo_disableNormals(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ;
  SWIG_check_num_args("ofVbo::disableNormals",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::disableNormals",1,"ofVbo *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_disableNormals",1,SWIGTYPE_p_ofVbo); }  (arg1)->disableNormals(); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vbo_disableTexCoords(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ;
  SWIG_check_num_args("ofVbo::disableTexCoords",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::disableTexCoords",1,"ofVbo *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_disableTexCoords",1,SWIGTYPE_p_ofVbo); }  (arg1)->disableTexCoords(); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vbo_disableIndices(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ;
  SWIG_check_num_args("ofVbo::disableIndices",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::disableIndices",1,"ofVbo *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_disableIndices",1,SWIGTYPE_p_ofVbo); }  (arg1)->disableIndices(); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vbo_getVaoId(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ; GLuint result;
  SWIG_check_num_args("ofVbo::getVaoId",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::getVaoId",1,"ofVbo const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){ SWIG_fail_ptr("Vbo_getVaoId",1,SWIGTYPE_p_ofVbo); } 
  result = (GLuint)((ofVbo const *)arg1)->getVaoId(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vbo_getVertId(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ; GLuint result;
  SWIG_check_num_args("ofVbo::getVertId",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::getVertId",1,"ofVbo const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){ SWIG_fail_ptr("Vbo_getVertId",1,SWIGTYPE_p_ofVbo); } 
  result = (GLuint)((ofVbo const *)arg1)->getVertId(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vbo_getColorId(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ; GLuint result;
  SWIG_check_num_args("ofVbo::getColorId",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::getColorId",1,"ofVbo const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){ SWIG_fail_ptr("Vbo_getColorId",1,SWIGTYPE_p_ofVbo); } 
  result = (GLuint)((ofVbo const *)arg1)->getColorId(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vbo_getNormalId(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ; GLuint result;
  SWIG_check_num_args("ofVbo::getNormalId",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::getNormalId",1,"ofVbo const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){ SWIG_fail_ptr("Vbo_getNormalId",1,SWIGTYPE_p_ofVbo); }
   result = (GLuint)((ofVbo const *)arg1)->getNormalId(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vbo_getTexCoordId(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ; GLuint result;
  SWIG_check_num_args("ofVbo::getTexCoordId",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::getTexCoordId",1,"ofVbo const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_getTexCoordId",1,SWIGTYPE_p_ofVbo); }  result = (GLuint)((ofVbo const *)arg1)->getTexCoordId();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vbo_getIndexId(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ; GLuint result;
  SWIG_check_num_args("ofVbo::getIndexId",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::getIndexId",1,"ofVbo const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){ SWIG_fail_ptr("Vbo_getIndexId",1,SWIGTYPE_p_ofVbo); } 
  result = (GLuint)((ofVbo const *)arg1)->getIndexId(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vbo_getAttributeId(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ; int arg2 ; GLuint result;
  SWIG_check_num_args("ofVbo::getAttributeId",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::getAttributeId",1,"ofVbo const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVbo::getAttributeId",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_getAttributeId",1,SWIGTYPE_p_ofVbo); }  arg2 = (int)lua_tonumber(L, 2);
  result = (GLuint)((ofVbo const *)arg1)->getAttributeId(arg2); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vbo_getIsAllocated(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ; bool result;
  SWIG_check_num_args("ofVbo::getIsAllocated",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::getIsAllocated",1,"ofVbo const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_getIsAllocated",1,SWIGTYPE_p_ofVbo); }  result = (bool)((ofVbo const *)arg1)->getIsAllocated();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vbo_getUsingVerts(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ; bool result;
  SWIG_check_num_args("ofVbo::getUsingVerts",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::getUsingVerts",1,"ofVbo const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_getUsingVerts",1,SWIGTYPE_p_ofVbo); }  result = (bool)((ofVbo const *)arg1)->getUsingVerts();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vbo_getUsingColors(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ; bool result;
  SWIG_check_num_args("ofVbo::getUsingColors",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::getUsingColors",1,"ofVbo const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_getUsingColors",1,SWIGTYPE_p_ofVbo); }  result = (bool)((ofVbo const *)arg1)->getUsingColors();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vbo_getUsingNormals(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ; bool result;
  SWIG_check_num_args("ofVbo::getUsingNormals",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::getUsingNormals",1,"ofVbo const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_getUsingNormals",1,SWIGTYPE_p_ofVbo); }  result = (bool)((ofVbo const *)arg1)->getUsingNormals();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vbo_getUsingTexCoords(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ; bool result;
  SWIG_check_num_args("ofVbo::getUsingTexCoords",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::getUsingTexCoords",1,"ofVbo const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_getUsingTexCoords",1,SWIGTYPE_p_ofVbo); }  result = (bool)((ofVbo const *)arg1)->getUsingTexCoords();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vbo_getUsingIndices(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ; bool result;
  SWIG_check_num_args("ofVbo::getUsingIndices",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::getUsingIndices",1,"ofVbo const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_getUsingIndices",1,SWIGTYPE_p_ofVbo); }  result = (bool)((ofVbo const *)arg1)->getUsingIndices();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vbo_draw(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ; int arg2 ; int arg3 ; int arg4 ;
  SWIG_check_num_args("ofVbo::draw",4,4) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::draw",1,"ofVbo const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVbo::draw",2,"int"); if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVbo::draw",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofVbo::draw",4,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){ SWIG_fail_ptr("Vbo_draw",1,SWIGTYPE_p_ofVbo); } 
  arg2 = (int)lua_tonumber(L, 2); arg3 = (int)lua_tonumber(L, 3); arg4 = (int)lua_tonumber(L, 4);
  ((ofVbo const *)arg1)->draw(arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vbo_drawElements__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ; int arg2 ; int arg3 ;
  int arg4 ; SWIG_check_num_args("ofVbo::drawElements",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::drawElements",1,"ofVbo const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVbo::drawElements",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVbo::drawElements",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofVbo::drawElements",4,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){ SWIG_fail_ptr("Vbo_drawElements",1,SWIGTYPE_p_ofVbo); }
   arg2 = (int)lua_tonumber(L, 2); arg3 = (int)lua_tonumber(L, 3); arg4 = (int)lua_tonumber(L, 4);
  ((ofVbo const *)arg1)->drawElements(arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vbo_drawElements__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ; int arg2 ; int arg3 ;
  SWIG_check_num_args("ofVbo::drawElements",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::drawElements",1,"ofVbo const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVbo::drawElements",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVbo::drawElements",3,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){ SWIG_fail_ptr("Vbo_drawElements",1,SWIGTYPE_p_ofVbo); }
   arg2 = (int)lua_tonumber(L, 2); arg3 = (int)lua_tonumber(L, 3); ((ofVbo const *)arg1)->drawElements(arg2,arg3);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vbo_drawElements(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L); if (argc == 3) {
    int _v; { void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVbo, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { return _wrap_Vbo_drawElements__SWIG_1(L);}  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVbo, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { {
            _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_Vbo_drawElements__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Vbo_drawElements'\n" "  Possible C/C++ prototypes are:\n"
  "    ofVbo::drawElements(int,int,int) const\n" "    ofVbo::drawElements(int,int) const\n"); lua_error(L);return 0; }
static int _wrap_Vbo_drawInstanced(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ; int arg2 ; int arg3 ;
  int arg4 ; int arg5 ; SWIG_check_num_args("ofVbo::drawInstanced",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::drawInstanced",1,"ofVbo const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVbo::drawInstanced",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVbo::drawInstanced",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofVbo::drawInstanced",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofVbo::drawInstanced",5,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_drawInstanced",1,SWIGTYPE_p_ofVbo); }  arg2 = (int)lua_tonumber(L, 2); arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4); arg5 = (int)lua_tonumber(L, 5); ((ofVbo const *)arg1)->drawInstanced(arg2,arg3,arg4,arg5);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vbo_drawElementsInstanced(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ; int arg2 ; int arg3 ;
  int arg4 ; SWIG_check_num_args("ofVbo::drawElementsInstanced",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::drawElementsInstanced",1,"ofVbo const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVbo::drawElementsInstanced",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVbo::drawElementsInstanced",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofVbo::drawElementsInstanced",4,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_drawElementsInstanced",1,SWIGTYPE_p_ofVbo); }  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3); arg4 = (int)lua_tonumber(L, 4); ((ofVbo const *)arg1)->drawElementsInstanced(arg2,arg3,arg4);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vbo_bind(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ; SWIG_check_num_args("ofVbo::bind",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::bind",1,"ofVbo const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){ SWIG_fail_ptr("Vbo_bind",1,SWIGTYPE_p_ofVbo); } 
  ((ofVbo const *)arg1)->bind(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vbo_unbind(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ;
  SWIG_check_num_args("ofVbo::unbind",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::unbind",1,"ofVbo const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){ SWIG_fail_ptr("Vbo_unbind",1,SWIGTYPE_p_ofVbo); } 
  ((ofVbo const *)arg1)->unbind(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vbo_clear(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ; SWIG_check_num_args("ofVbo::clear",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::clear",1,"ofVbo *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){ SWIG_fail_ptr("Vbo_clear",1,SWIGTYPE_p_ofVbo); } 
  (arg1)->clear(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vbo_clearVertices(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ;
  SWIG_check_num_args("ofVbo::clearVertices",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::clearVertices",1,"ofVbo *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_clearVertices",1,SWIGTYPE_p_ofVbo); }  (arg1)->clearVertices(); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vbo_clearNormals(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ;
  SWIG_check_num_args("ofVbo::clearNormals",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::clearNormals",1,"ofVbo *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){ SWIG_fail_ptr("Vbo_clearNormals",1,SWIGTYPE_p_ofVbo); }
   (arg1)->clearNormals(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vbo_clearColors(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ;
  SWIG_check_num_args("ofVbo::clearColors",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::clearColors",1,"ofVbo *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){ SWIG_fail_ptr("Vbo_clearColors",1,SWIGTYPE_p_ofVbo); }
   (arg1)->clearColors(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vbo_clearTexCoords(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ;
  SWIG_check_num_args("ofVbo::clearTexCoords",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::clearTexCoords",1,"ofVbo *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_clearTexCoords",1,SWIGTYPE_p_ofVbo); }  (arg1)->clearTexCoords(); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Vbo_clearIndices(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ;
  SWIG_check_num_args("ofVbo::clearIndices",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::clearIndices",1,"ofVbo *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){ SWIG_fail_ptr("Vbo_clearIndices",1,SWIGTYPE_p_ofVbo); }
   (arg1)->clearIndices(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vbo_clearAttribute(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ; int arg2 ;
  SWIG_check_num_args("ofVbo::clearAttribute",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::clearAttribute",1,"ofVbo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVbo::clearAttribute",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_clearAttribute",1,SWIGTYPE_p_ofVbo); }  arg2 = (int)lua_tonumber(L, 2); (arg1)->clearAttribute(arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vbo_getNumVertices(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ; int result;
  SWIG_check_num_args("ofVbo::getNumVertices",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::getNumVertices",1,"ofVbo const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_getNumVertices",1,SWIGTYPE_p_ofVbo); }  result = (int)((ofVbo const *)arg1)->getNumVertices();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vbo_getNumIndices(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ; int result;
  SWIG_check_num_args("ofVbo::getNumIndices",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::getNumIndices",1,"ofVbo const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){
    SWIG_fail_ptr("Vbo_getNumIndices",1,SWIGTYPE_p_ofVbo); }  result = (int)((ofVbo const *)arg1)->getNumIndices();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Vbo_hasAttribute(lua_State* L) { int SWIG_arg = 0; ofVbo *arg1 = (ofVbo *) 0 ; int arg2 ; bool result;
  SWIG_check_num_args("ofVbo::hasAttribute",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVbo::hasAttribute",1,"ofVbo const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVbo::hasAttribute",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVbo,0))){ SWIG_fail_ptr("Vbo_hasAttribute",1,SWIGTYPE_p_ofVbo); }
   arg2 = (int)lua_tonumber(L, 2); result = (bool)((ofVbo const *)arg1)->hasAttribute(arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static void swig_delete_Vbo(void *obj) {
ofVbo *arg1 = (ofVbo *) obj;
delete arg1;
}
static int _proxy__wrap_new_Vbo(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_Vbo);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_Vbo_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_Vbo_methods[]= {
    { "setMesh", _wrap_Vbo_setMesh},
    { "setIndexData", _wrap_Vbo_setIndexData},
    { "setVertexData", _wrap_Vbo_setVertexData},
    { "setColorData", _wrap_Vbo_setColorData},
    { "setNormalData", _wrap_Vbo_setNormalData},
    { "setTexCoordData", _wrap_Vbo_setTexCoordData},
    { "setAttributeData", _wrap_Vbo_setAttributeData},
    { "setAttributeDivisor", _wrap_Vbo_setAttributeDivisor},
    { "setVertexBuffer", _wrap_Vbo_setVertexBuffer},
    { "setColorBuffer", _wrap_Vbo_setColorBuffer},
    { "setNormalBuffer", _wrap_Vbo_setNormalBuffer},
    { "setTexCoordBuffer", _wrap_Vbo_setTexCoordBuffer},
    { "setIndexBuffer", _wrap_Vbo_setIndexBuffer},
    { "setAttributeBuffer", _wrap_Vbo_setAttributeBuffer},
    { "getVertexBuffer", _wrap_Vbo_getVertexBuffer},
    { "getColorBuffer", _wrap_Vbo_getColorBuffer},
    { "getNormalBuffer", _wrap_Vbo_getNormalBuffer},
    { "getTexCoordBuffer", _wrap_Vbo_getTexCoordBuffer},
    { "getIndexBuffer", _wrap_Vbo_getIndexBuffer},
    { "getAttributeBuffer", _wrap_Vbo_getAttributeBuffer},
    { "updateMesh", _wrap_Vbo_updateMesh},
    { "updateIndexData", _wrap_Vbo_updateIndexData},
    { "updateVertexData", _wrap_Vbo_updateVertexData},
    { "updateColorData", _wrap_Vbo_updateColorData},
    { "updateNormalData", _wrap_Vbo_updateNormalData},
    { "updateTexCoordData", _wrap_Vbo_updateTexCoordData},
    { "updateAttributeData", _wrap_Vbo_updateAttributeData},
    { "enableColors", _wrap_Vbo_enableColors},
    { "enableNormals", _wrap_Vbo_enableNormals},
    { "enableTexCoords", _wrap_Vbo_enableTexCoords},
    { "enableIndices", _wrap_Vbo_enableIndices},
    { "disableColors", _wrap_Vbo_disableColors},
    { "disableNormals", _wrap_Vbo_disableNormals},
    { "disableTexCoords", _wrap_Vbo_disableTexCoords},
    { "disableIndices", _wrap_Vbo_disableIndices},
    { "getVaoId", _wrap_Vbo_getVaoId},
    { "getVertId", _wrap_Vbo_getVertId},
    { "getColorId", _wrap_Vbo_getColorId},
    { "getNormalId", _wrap_Vbo_getNormalId},
    { "getTexCoordId", _wrap_Vbo_getTexCoordId},
    { "getIndexId", _wrap_Vbo_getIndexId},
    { "getAttributeId", _wrap_Vbo_getAttributeId},
    { "getIsAllocated", _wrap_Vbo_getIsAllocated},
    { "getUsingVerts", _wrap_Vbo_getUsingVerts},
    { "getUsingColors", _wrap_Vbo_getUsingColors},
    { "getUsingNormals", _wrap_Vbo_getUsingNormals},
    { "getUsingTexCoords", _wrap_Vbo_getUsingTexCoords},
    { "getUsingIndices", _wrap_Vbo_getUsingIndices},
    { "draw", _wrap_Vbo_draw},
    { "drawElements", _wrap_Vbo_drawElements},
    { "drawInstanced", _wrap_Vbo_drawInstanced},
    { "drawElementsInstanced", _wrap_Vbo_drawElementsInstanced},
    { "bind", _wrap_Vbo_bind},
    { "unbind", _wrap_Vbo_unbind},
    { "clear", _wrap_Vbo_clear},
    { "clearVertices", _wrap_Vbo_clearVertices},
    { "clearNormals", _wrap_Vbo_clearNormals},
    { "clearColors", _wrap_Vbo_clearColors},
    { "clearTexCoords", _wrap_Vbo_clearTexCoords},
    { "clearIndices", _wrap_Vbo_clearIndices},
    { "clearAttribute", _wrap_Vbo_clearAttribute},
    { "getNumVertices", _wrap_Vbo_getNumVertices},
    { "getNumIndices", _wrap_Vbo_getNumIndices},
    { "hasAttribute", _wrap_Vbo_hasAttribute},
    {0,0}
};
static swig_lua_method swig_Vbo_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_Vbo_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_Vbo_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_Vbo_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_Vbo_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_Vbo_Sf_SwigStatic = {
    "Vbo",
    swig_Vbo_Sf_SwigStatic_methods,
    swig_Vbo_Sf_SwigStatic_attributes,
    swig_Vbo_Sf_SwigStatic_constants,
    swig_Vbo_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_Vbo_bases[] = {0};
static const char *swig_Vbo_base_names[] = {0};
static swig_lua_class _wrap_class_Vbo = { "Vbo", "Vbo", &SWIGTYPE_p_ofVbo,_proxy__wrap_new_Vbo, swig_delete_Vbo, swig_Vbo_methods, swig_Vbo_attributes, &swig_Vbo_Sf_SwigStatic, swig_Vbo_meta, swig_Vbo_bases, swig_Vbo_base_names };

static int _wrap_VboMesh_draw__SWIG_0_0(lua_State* L) { int SWIG_arg = 0; ofVboMesh *arg1 = (ofVboMesh *) 0 ;
  SWIG_check_num_args("draw",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("draw",1,"ofVboMesh const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVboMesh,0))){
    SWIG_fail_ptr("VboMesh_draw",1,SWIGTYPE_p_ofVboMesh); }  ((ofVboMesh const *)arg1)->draw(); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_new_VboMesh__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofVboMesh *result = 0 ;
  SWIG_check_num_args("ofVboMesh::ofVboMesh",0,0) result = (ofVboMesh *)new ofVboMesh();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofVboMesh,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_VboMesh__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofMesh *arg1 = 0 ; ofVboMesh *result = 0 ;
  SWIG_check_num_args("ofVboMesh::ofVboMesh",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofVboMesh::ofVboMesh",1,"ofMesh const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0))){
    SWIG_fail_ptr("new_VboMesh",1,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t); }
   result = (ofVboMesh *)new ofVboMesh((ofMesh const &)*arg1); SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofVboMesh,1); SWIG_arg++; 
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_new_VboMesh(lua_State* L) { int argc; int argv[2]={ 1,2} ; argc = lua_gettop(L); if (argc == 0) {
    return _wrap_new_VboMesh__SWIG_0(L);}  if (argc == 1) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_new_VboMesh__SWIG_1(L);}  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_VboMesh'\n" "  Possible C/C++ prototypes are:\n"
  "    ofVboMesh::ofVboMesh()\n" "    ofVboMesh::ofVboMesh(ofMesh const &)\n"); lua_error(L);return 0; }
static int _wrap_VboMesh_setUsage(lua_State* L) { int SWIG_arg = 0; ofVboMesh *arg1 = (ofVboMesh *) 0 ; int arg2 ;
  SWIG_check_num_args("ofVboMesh::setUsage",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVboMesh::setUsage",1,"ofVboMesh *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVboMesh::setUsage",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVboMesh,0))){
    SWIG_fail_ptr("VboMesh_setUsage",1,SWIGTYPE_p_ofVboMesh); }  arg2 = (int)lua_tonumber(L, 2); (arg1)->setUsage(arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_VboMesh_draw__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofVboMesh *arg1 = (ofVboMesh *) 0 ;
  ofPolyRenderMode arg2 ; SWIG_check_num_args("ofVboMesh::draw",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVboMesh::draw",1,"ofVboMesh const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVboMesh::draw",2,"ofPolyRenderMode");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVboMesh,0))){
    SWIG_fail_ptr("VboMesh_draw",1,SWIGTYPE_p_ofVboMesh); }  arg2 = (ofPolyRenderMode)(int)lua_tonumber(L, 2);
  ((ofVboMesh const *)arg1)->draw(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_VboMesh_draw(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 1) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVboMesh, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_VboMesh_draw__SWIG_0_0(L);}  }  if (argc == 2) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVboMesh, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_VboMesh_draw__SWIG_1(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'VboMesh_draw'\n" "  Possible C/C++ prototypes are:\n"
  "    draw() const\n" "    ofVboMesh::draw(ofPolyRenderMode) const\n"); lua_error(L);return 0; }
static int _wrap_VboMesh_drawInstanced(lua_State* L) { int SWIG_arg = 0; ofVboMesh *arg1 = (ofVboMesh *) 0 ;
  ofPolyRenderMode arg2 ; int arg3 ; SWIG_check_num_args("ofVboMesh::drawInstanced",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVboMesh::drawInstanced",1,"ofVboMesh const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVboMesh::drawInstanced",2,"ofPolyRenderMode");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVboMesh::drawInstanced",3,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVboMesh,0))){
    SWIG_fail_ptr("VboMesh_drawInstanced",1,SWIGTYPE_p_ofVboMesh); }  arg2 = (ofPolyRenderMode)(int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3); ((ofVboMesh const *)arg1)->drawInstanced(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_VboMesh_getVbo__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofVboMesh *arg1 = (ofVboMesh *) 0 ;
  ofVbo *result = 0 ; SWIG_check_num_args("ofVboMesh::getVbo",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVboMesh::getVbo",1,"ofVboMesh *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVboMesh,0))){
    SWIG_fail_ptr("VboMesh_getVbo",1,SWIGTYPE_p_ofVboMesh); }  result = (ofVbo *) &(arg1)->getVbo();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofVbo,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_VboMesh_getVbo__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofVboMesh *arg1 = (ofVboMesh *) 0 ;
  ofVbo *result = 0 ; SWIG_check_num_args("ofVboMesh::getVbo",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVboMesh::getVbo",1,"ofVboMesh const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVboMesh,0))){
    SWIG_fail_ptr("VboMesh_getVbo",1,SWIGTYPE_p_ofVboMesh); }  result = (ofVbo *) &((ofVboMesh const *)arg1)->getVbo();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofVbo,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_VboMesh_getVbo(lua_State* L) { int argc; int argv[2]={ 1,2} ; argc = lua_gettop(L); if (argc == 1) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVboMesh, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_VboMesh_getVbo__SWIG_0(L);}  }  if (argc == 1) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVboMesh, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_VboMesh_getVbo__SWIG_1(L);}  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'VboMesh_getVbo'\n" "  Possible C/C++ prototypes are:\n"
  "    ofVboMesh::getVbo()\n" "    ofVboMesh::getVbo() const\n"); lua_error(L);return 0; }
static void swig_delete_VboMesh(void *obj) {
ofVboMesh *arg1 = (ofVboMesh *) obj;
delete arg1;
}
static int _proxy__wrap_new_VboMesh(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_VboMesh);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_VboMesh_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_VboMesh_methods[]= {
    { "setUsage", _wrap_VboMesh_setUsage},
    { "draw", _wrap_VboMesh_draw},
    { "drawInstanced", _wrap_VboMesh_drawInstanced},
    { "getVbo", _wrap_VboMesh_getVbo},
    {0,0}
};
static swig_lua_method swig_VboMesh_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_VboMesh_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_VboMesh_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_VboMesh_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_VboMesh_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_VboMesh_Sf_SwigStatic = {
    "VboMesh",
    swig_VboMesh_Sf_SwigStatic_methods,
    swig_VboMesh_Sf_SwigStatic_attributes,
    swig_VboMesh_Sf_SwigStatic_constants,
    swig_VboMesh_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_VboMesh_bases[] = {0,0};
static const char *swig_VboMesh_base_names[] = {"ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *",0};
static swig_lua_class _wrap_class_VboMesh = { "VboMesh", "VboMesh", &SWIGTYPE_p_ofVboMesh,_proxy__wrap_new_VboMesh, swig_delete_VboMesh, swig_VboMesh_methods, swig_VboMesh_attributes, &swig_VboMesh_Sf_SwigStatic, swig_VboMesh_meta, swig_VboMesh_bases, swig_VboMesh_base_names };

static int _wrap_new_Pixels__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofPixels_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofPixels_< unsigned char >::ofPixels_",0,0)
  result = (ofPixels_< unsigned char > *)new ofPixels_< unsigned char >();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofPixels_T_unsigned_char_t,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_Pixels__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofPixels_< unsigned char > *arg1 = 0 ;
  ofPixels_< unsigned char > *result = 0 ; SWIG_check_num_args("ofPixels_< unsigned char >::ofPixels_",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofPixels_< unsigned char >::ofPixels_",1,"ofPixels_< unsigned char > &&");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0))){
    SWIG_fail_ptr("new_Pixels",1,SWIGTYPE_p_ofPixels_T_unsigned_char_t); } 
  result = (ofPixels_< unsigned char > *)new ofPixels_< unsigned char >((ofPixels_< unsigned char > &&)*arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofPixels_T_unsigned_char_t,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_Pixels(lua_State* L) { int argc; int argv[2]={ 1,2} ; argc = lua_gettop(L); if (argc == 0) {
    return _wrap_new_Pixels__SWIG_0(L);}  if (argc == 1) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofPixels_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_new_Pixels__SWIG_1(L);}  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_Pixels'\n" "  Possible C/C++ prototypes are:\n"
  "    ofPixels_< unsigned char >::ofPixels_()\n" "    ofPixels_< unsigned char >::ofPixels_(ofPixels_< unsigned char > &&)\n");
  lua_error(L);return 0; }
static int _wrap_Pixels_allocate(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned char > *arg1 = (ofPixels_< unsigned char > *) 0 ; size_t arg2 ; size_t arg3 ; size_t arg4 ;
  SWIG_check_num_args("ofPixels_< unsigned char >::allocate",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned char >::allocate",1,"ofPixels_< unsigned char > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofPixels_< unsigned char >::allocate",2,"size_t");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofPixels_< unsigned char >::allocate",3,"size_t");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofPixels_< unsigned char >::allocate",4,"size_t");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Pixels_allocate",1,SWIGTYPE_p_ofPixels_T_unsigned_char_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (size_t)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (size_t)lua_tonumber(L, 3);
  SWIG_contract_assert((lua_tonumber(L,4)>=0),"number must not be negative") arg4 = (size_t)lua_tonumber(L, 4);
  (arg1)->allocate(arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Pixels_allocatePixelFormat(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned char > *arg1 = (ofPixels_< unsigned char > *) 0 ; size_t arg2 ; size_t arg3 ; ofPixelFormat arg4 ;
  SWIG_check_num_args("ofPixels_< unsigned char >::allocate",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned char >::allocate",1,"ofPixels_< unsigned char > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofPixels_< unsigned char >::allocate",2,"size_t");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofPixels_< unsigned char >::allocate",3,"size_t");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofPixels_< unsigned char >::allocate",4,"ofPixelFormat");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Pixels_allocatePixelFormat",1,SWIGTYPE_p_ofPixels_T_unsigned_char_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (size_t)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (size_t)lua_tonumber(L, 3);
  arg4 = (ofPixelFormat)(int)lua_tonumber(L, 4); (arg1)->allocate(arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Pixels_allocateImageType(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned char > *arg1 = (ofPixels_< unsigned char > *) 0 ; size_t arg2 ; size_t arg3 ; ofImageType arg4 ;
  SWIG_check_num_args("ofPixels_< unsigned char >::allocate",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned char >::allocate",1,"ofPixels_< unsigned char > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofPixels_< unsigned char >::allocate",2,"size_t");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofPixels_< unsigned char >::allocate",3,"size_t");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofPixels_< unsigned char >::allocate",4,"ofImageType");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Pixels_allocateImageType",1,SWIGTYPE_p_ofPixels_T_unsigned_char_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (size_t)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (size_t)lua_tonumber(L, 3);
  arg4 = (ofImageType)(int)lua_tonumber(L, 4); (arg1)->allocate(arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Pixels_isAllocated(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned char > *arg1 = (ofPixels_< unsigned char > *) 0 ; bool result;
  SWIG_check_num_args("ofPixels_< unsigned char >::isAllocated",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned char >::isAllocated",1,"ofPixels_< unsigned char > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Pixels_isAllocated",1,SWIGTYPE_p_ofPixels_T_unsigned_char_t); } 
  result = (bool)((ofPixels_< unsigned char > const *)arg1)->isAllocated(); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Pixels_clear(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned char > *arg1 = (ofPixels_< unsigned char > *) 0 ;
  SWIG_check_num_args("ofPixels_< unsigned char >::clear",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned char >::clear",1,"ofPixels_< unsigned char > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Pixels_clear",1,SWIGTYPE_p_ofPixels_T_unsigned_char_t); }  (arg1)->clear(); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Pixels_set__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned char > *arg1 = (ofPixels_< unsigned char > *) 0 ; unsigned char arg2 ;
  SWIG_check_num_args("ofPixels_< unsigned char >::set",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned char >::set",1,"ofPixels_< unsigned char > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofPixels_< unsigned char >::set",2,"unsigned char");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Pixels_set",1,SWIGTYPE_p_ofPixels_T_unsigned_char_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (unsigned char)lua_tonumber(L, 2);
  (arg1)->set(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Pixels_set__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned char > *arg1 = (ofPixels_< unsigned char > *) 0 ; size_t arg2 ; unsigned char arg3 ;
  SWIG_check_num_args("ofPixels_< unsigned char >::set",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned char >::set",1,"ofPixels_< unsigned char > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofPixels_< unsigned char >::set",2,"size_t");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofPixels_< unsigned char >::set",3,"unsigned char");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Pixels_set",1,SWIGTYPE_p_ofPixels_T_unsigned_char_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (size_t)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (unsigned char)lua_tonumber(L, 3);
  (arg1)->set(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Pixels_set(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 2) { int _v; {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofPixels_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_Pixels_set__SWIG_0(L);}  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofPixels_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { return _wrap_Pixels_set__SWIG_1(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Pixels_set'\n" "  Possible C/C++ prototypes are:\n"
  "    ofPixels_< unsigned char >::set(unsigned char)\n" "    ofPixels_< unsigned char >::set(size_t,unsigned char)\n");
  lua_error(L);return 0; }
static int _wrap_Pixels_setFromPixels(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned char > *arg1 = (ofPixels_< unsigned char > *) 0 ; unsigned char *arg2 = (unsigned char *) 0 ;
  size_t arg3 ; size_t arg4 ; ofPixelFormat arg5 ; SWIG_check_num_args("ofPixels_< unsigned char >::setFromPixels",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned char >::setFromPixels",1,"ofPixels_< unsigned char > *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofPixels_< unsigned char >::setFromPixels",2,"unsigned char const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofPixels_< unsigned char >::setFromPixels",3,"size_t");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofPixels_< unsigned char >::setFromPixels",4,"size_t");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofPixels_< unsigned char >::setFromPixels",5,"ofPixelFormat");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Pixels_setFromPixels",1,SWIGTYPE_p_ofPixels_T_unsigned_char_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_unsigned_char,0))){
    SWIG_fail_ptr("Pixels_setFromPixels",2,SWIGTYPE_p_unsigned_char); } 
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (size_t)lua_tonumber(L, 3);
  SWIG_contract_assert((lua_tonumber(L,4)>=0),"number must not be negative") arg4 = (size_t)lua_tonumber(L, 4);
  arg5 = (ofPixelFormat)(int)lua_tonumber(L, 5); (arg1)->setFromPixels((unsigned char const *)arg2,arg3,arg4,arg5);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Pixels_setFromPixelsImageType(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned char > *arg1 = (ofPixels_< unsigned char > *) 0 ; unsigned char *arg2 = (unsigned char *) 0 ;
  size_t arg3 ; size_t arg4 ; ofImageType arg5 ; SWIG_check_num_args("ofPixels_< unsigned char >::setFromPixels",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned char >::setFromPixels",1,"ofPixels_< unsigned char > *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofPixels_< unsigned char >::setFromPixels",2,"unsigned char const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofPixels_< unsigned char >::setFromPixels",3,"size_t");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofPixels_< unsigned char >::setFromPixels",4,"size_t");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofPixels_< unsigned char >::setFromPixels",5,"ofImageType");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Pixels_setFromPixelsImageType",1,SWIGTYPE_p_ofPixels_T_unsigned_char_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_unsigned_char,0))){
    SWIG_fail_ptr("Pixels_setFromPixelsImageType",2,SWIGTYPE_p_unsigned_char); } 
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (size_t)lua_tonumber(L, 3);
  SWIG_contract_assert((lua_tonumber(L,4)>=0),"number must not be negative") arg4 = (size_t)lua_tonumber(L, 4);
  arg5 = (ofImageType)(int)lua_tonumber(L, 5); (arg1)->setFromPixels((unsigned char const *)arg2,arg3,arg4,arg5);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Pixels_setFromExternalPixels(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned char > *arg1 = (ofPixels_< unsigned char > *) 0 ; unsigned char *arg2 = (unsigned char *) 0 ;
  size_t arg3 ; size_t arg4 ; ofPixelFormat arg5 ; SWIG_check_num_args("ofPixels_< unsigned char >::setFromExternalPixels",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned char >::setFromExternalPixels",1,"ofPixels_< unsigned char > *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofPixels_< unsigned char >::setFromExternalPixels",2,"unsigned char *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofPixels_< unsigned char >::setFromExternalPixels",3,"size_t");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofPixels_< unsigned char >::setFromExternalPixels",4,"size_t");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofPixels_< unsigned char >::setFromExternalPixels",5,"ofPixelFormat");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Pixels_setFromExternalPixels",1,SWIGTYPE_p_ofPixels_T_unsigned_char_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_unsigned_char,0))){
    SWIG_fail_ptr("Pixels_setFromExternalPixels",2,SWIGTYPE_p_unsigned_char); } 
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (size_t)lua_tonumber(L, 3);
  SWIG_contract_assert((lua_tonumber(L,4)>=0),"number must not be negative") arg4 = (size_t)lua_tonumber(L, 4);
  arg5 = (ofPixelFormat)(int)lua_tonumber(L, 5); (arg1)->setFromExternalPixels(arg2,arg3,arg4,arg5); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Pixels_setFromAlignedPixels(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned char > *arg1 = (ofPixels_< unsigned char > *) 0 ; unsigned char *arg2 = (unsigned char *) 0 ;
  size_t arg3 ; size_t arg4 ; ofPixelFormat arg5 ; size_t arg6 ;
  SWIG_check_num_args("ofPixels_< unsigned char >::setFromAlignedPixels",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned char >::setFromAlignedPixels",1,"ofPixels_< unsigned char > *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofPixels_< unsigned char >::setFromAlignedPixels",2,"unsigned char const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofPixels_< unsigned char >::setFromAlignedPixels",3,"size_t");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofPixels_< unsigned char >::setFromAlignedPixels",4,"size_t");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofPixels_< unsigned char >::setFromAlignedPixels",5,"ofPixelFormat");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofPixels_< unsigned char >::setFromAlignedPixels",6,"size_t");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Pixels_setFromAlignedPixels",1,SWIGTYPE_p_ofPixels_T_unsigned_char_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_unsigned_char,0))){
    SWIG_fail_ptr("Pixels_setFromAlignedPixels",2,SWIGTYPE_p_unsigned_char); } 
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (size_t)lua_tonumber(L, 3);
  SWIG_contract_assert((lua_tonumber(L,4)>=0),"number must not be negative") arg4 = (size_t)lua_tonumber(L, 4);
  arg5 = (ofPixelFormat)(int)lua_tonumber(L, 5); SWIG_contract_assert((lua_tonumber(L,6)>=0),"number must not be negative")
  arg6 = (size_t)lua_tonumber(L, 6); (arg1)->setFromAlignedPixels((unsigned char const *)arg2,arg3,arg4,arg5,arg6);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Pixels_swap(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned char > *arg1 = (ofPixels_< unsigned char > *) 0 ; ofPixels_< unsigned char > *arg2 = 0 ;
  SWIG_check_num_args("ofPixels_< unsigned char >::swap",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned char >::swap",1,"ofPixels_< unsigned char > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofPixels_< unsigned char >::swap",2,"ofPixels_< unsigned char > &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Pixels_swap",1,SWIGTYPE_p_ofPixels_T_unsigned_char_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Pixels_swap",2,SWIGTYPE_p_ofPixels_T_unsigned_char_t); }  (arg1)->swap(*arg2); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Pixels_crop(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned char > *arg1 = (ofPixels_< unsigned char > *) 0 ; size_t arg2 ; size_t arg3 ; size_t arg4 ; size_t arg5 ;
  SWIG_check_num_args("ofPixels_< unsigned char >::crop",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned char >::crop",1,"ofPixels_< unsigned char > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofPixels_< unsigned char >::crop",2,"size_t");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofPixels_< unsigned char >::crop",3,"size_t");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofPixels_< unsigned char >::crop",4,"size_t");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofPixels_< unsigned char >::crop",5,"size_t");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Pixels_crop",1,SWIGTYPE_p_ofPixels_T_unsigned_char_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (size_t)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (size_t)lua_tonumber(L, 3);
  SWIG_contract_assert((lua_tonumber(L,4)>=0),"number must not be negative") arg4 = (size_t)lua_tonumber(L, 4);
  SWIG_contract_assert((lua_tonumber(L,5)>=0),"number must not be negative") arg5 = (size_t)lua_tonumber(L, 5);
  (arg1)->crop(arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Pixels_cropTo(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned char > *arg1 = (ofPixels_< unsigned char > *) 0 ; ofPixels_< unsigned char > *arg2 = 0 ; size_t arg3 ;
  size_t arg4 ; size_t arg5 ; size_t arg6 ; SWIG_check_num_args("ofPixels_< unsigned char >::cropTo",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned char >::cropTo",1,"ofPixels_< unsigned char > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofPixels_< unsigned char >::cropTo",2,"ofPixels_< unsigned char > &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofPixels_< unsigned char >::cropTo",3,"size_t");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofPixels_< unsigned char >::cropTo",4,"size_t");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofPixels_< unsigned char >::cropTo",5,"size_t");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofPixels_< unsigned char >::cropTo",6,"size_t");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Pixels_cropTo",1,SWIGTYPE_p_ofPixels_T_unsigned_char_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Pixels_cropTo",2,SWIGTYPE_p_ofPixels_T_unsigned_char_t); } 
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (size_t)lua_tonumber(L, 3);
  SWIG_contract_assert((lua_tonumber(L,4)>=0),"number must not be negative") arg4 = (size_t)lua_tonumber(L, 4);
  SWIG_contract_assert((lua_tonumber(L,5)>=0),"number must not be negative") arg5 = (size_t)lua_tonumber(L, 5);
  SWIG_contract_assert((lua_tonumber(L,6)>=0),"number must not be negative") arg6 = (size_t)lua_tonumber(L, 6);
  ((ofPixels_< unsigned char > const *)arg1)->cropTo(*arg2,arg3,arg4,arg5,arg6); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Pixels_rotate90(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned char > *arg1 = (ofPixels_< unsigned char > *) 0 ; int arg2 ;
  SWIG_check_num_args("ofPixels_< unsigned char >::rotate90",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned char >::rotate90",1,"ofPixels_< unsigned char > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofPixels_< unsigned char >::rotate90",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Pixels_rotate90",1,SWIGTYPE_p_ofPixels_T_unsigned_char_t); }  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->rotate90(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Pixels_rotate90To(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned char > *arg1 = (ofPixels_< unsigned char > *) 0 ; ofPixels_< unsigned char > *arg2 = 0 ; int arg3 ;
  SWIG_check_num_args("ofPixels_< unsigned char >::rotate90To",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned char >::rotate90To",1,"ofPixels_< unsigned char > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofPixels_< unsigned char >::rotate90To",2,"ofPixels_< unsigned char > &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofPixels_< unsigned char >::rotate90To",3,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Pixels_rotate90To",1,SWIGTYPE_p_ofPixels_T_unsigned_char_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Pixels_rotate90To",2,SWIGTYPE_p_ofPixels_T_unsigned_char_t); }  arg3 = (int)lua_tonumber(L, 3);
  ((ofPixels_< unsigned char > const *)arg1)->rotate90To(*arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Pixels_mirrorTo(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned char > *arg1 = (ofPixels_< unsigned char > *) 0 ; ofPixels_< unsigned char > *arg2 = 0 ; bool arg3 ;
  bool arg4 ; SWIG_check_num_args("ofPixels_< unsigned char >::mirrorTo",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned char >::mirrorTo",1,"ofPixels_< unsigned char > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofPixels_< unsigned char >::mirrorTo",2,"ofPixels_< unsigned char > &");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("ofPixels_< unsigned char >::mirrorTo",3,"bool");
  if(!lua_isboolean(L,4)) SWIG_fail_arg("ofPixels_< unsigned char >::mirrorTo",4,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Pixels_mirrorTo",1,SWIGTYPE_p_ofPixels_T_unsigned_char_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Pixels_mirrorTo",2,SWIGTYPE_p_ofPixels_T_unsigned_char_t); }  arg3 = (lua_toboolean(L, 3)!=0);
  arg4 = (lua_toboolean(L, 4)!=0); ((ofPixels_< unsigned char > const *)arg1)->mirrorTo(*arg2,arg3,arg4); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Pixels_mirror(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned char > *arg1 = (ofPixels_< unsigned char > *) 0 ; bool arg2 ; bool arg3 ;
  SWIG_check_num_args("ofPixels_< unsigned char >::mirror",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned char >::mirror",1,"ofPixels_< unsigned char > *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofPixels_< unsigned char >::mirror",2,"bool");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("ofPixels_< unsigned char >::mirror",3,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Pixels_mirror",1,SWIGTYPE_p_ofPixels_T_unsigned_char_t); }  arg2 = (lua_toboolean(L, 2)!=0);
  arg3 = (lua_toboolean(L, 3)!=0); (arg1)->mirror(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Pixels_resize__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned char > *arg1 = (ofPixels_< unsigned char > *) 0 ; size_t arg2 ; size_t arg3 ; ofInterpolationMethod arg4 ;
  bool result; SWIG_check_num_args("ofPixels_< unsigned char >::resize",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned char >::resize",1,"ofPixels_< unsigned char > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofPixels_< unsigned char >::resize",2,"size_t");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofPixels_< unsigned char >::resize",3,"size_t");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofPixels_< unsigned char >::resize",4,"ofInterpolationMethod");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Pixels_resize",1,SWIGTYPE_p_ofPixels_T_unsigned_char_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (size_t)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (size_t)lua_tonumber(L, 3);
  arg4 = (ofInterpolationMethod)(int)lua_tonumber(L, 4); result = (bool)(arg1)->resize(arg2,arg3,arg4);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Pixels_resize__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned char > *arg1 = (ofPixels_< unsigned char > *) 0 ; size_t arg2 ; size_t arg3 ; bool result;
  SWIG_check_num_args("ofPixels_< unsigned char >::resize",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned char >::resize",1,"ofPixels_< unsigned char > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofPixels_< unsigned char >::resize",2,"size_t");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofPixels_< unsigned char >::resize",3,"size_t");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Pixels_resize",1,SWIGTYPE_p_ofPixels_T_unsigned_char_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (size_t)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (size_t)lua_tonumber(L, 3);
  result = (bool)(arg1)->resize(arg2,arg3); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Pixels_resize(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L); if (argc == 3) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofPixels_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { return _wrap_Pixels_resize__SWIG_1(L);}  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofPixels_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_Pixels_resize__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Pixels_resize'\n" "  Possible C/C++ prototypes are:\n"
  "    ofPixels_< unsigned char >::resize(size_t,size_t,ofInterpolationMethod)\n"
  "    ofPixels_< unsigned char >::resize(size_t,size_t)\n"); lua_error(L);return 0; }
static int _wrap_Pixels_resizeTo__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned char > *arg1 = (ofPixels_< unsigned char > *) 0 ; ofPixels_< unsigned char > *arg2 = 0 ;
  ofInterpolationMethod arg3 ; bool result; SWIG_check_num_args("ofPixels_< unsigned char >::resizeTo",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned char >::resizeTo",1,"ofPixels_< unsigned char > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofPixels_< unsigned char >::resizeTo",2,"ofPixels_< unsigned char > &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofPixels_< unsigned char >::resizeTo",3,"ofInterpolationMethod");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Pixels_resizeTo",1,SWIGTYPE_p_ofPixels_T_unsigned_char_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Pixels_resizeTo",2,SWIGTYPE_p_ofPixels_T_unsigned_char_t); } 
  arg3 = (ofInterpolationMethod)(int)lua_tonumber(L, 3);
  result = (bool)((ofPixels_< unsigned char > const *)arg1)->resizeTo(*arg2,arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Pixels_resizeTo__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned char > *arg1 = (ofPixels_< unsigned char > *) 0 ; ofPixels_< unsigned char > *arg2 = 0 ; bool result;
  SWIG_check_num_args("ofPixels_< unsigned char >::resizeTo",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned char >::resizeTo",1,"ofPixels_< unsigned char > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofPixels_< unsigned char >::resizeTo",2,"ofPixels_< unsigned char > &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Pixels_resizeTo",1,SWIGTYPE_p_ofPixels_T_unsigned_char_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Pixels_resizeTo",2,SWIGTYPE_p_ofPixels_T_unsigned_char_t); } 
  result = (bool)((ofPixels_< unsigned char > const *)arg1)->resizeTo(*arg2); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Pixels_resizeTo(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofPixels_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofPixels_T_unsigned_char_t, 0)) {
          _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Pixels_resizeTo__SWIG_1(L);}  }  }  if (argc == 3) { int _v; {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofPixels_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofPixels_T_unsigned_char_t, 0)) {
          _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_Pixels_resizeTo__SWIG_0(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Pixels_resizeTo'\n" "  Possible C/C++ prototypes are:\n"
  "    ofPixels_< unsigned char >::resizeTo(ofPixels_< unsigned char > &,ofInterpolationMethod) const\n"
  "    ofPixels_< unsigned char >::resizeTo(ofPixels_< unsigned char > &) const\n"); lua_error(L);return 0; }
static int _wrap_Pixels_pasteInto(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned char > *arg1 = (ofPixels_< unsigned char > *) 0 ; ofPixels_< unsigned char > *arg2 = 0 ; size_t arg3 ;
  size_t arg4 ; bool result; SWIG_check_num_args("ofPixels_< unsigned char >::pasteInto",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned char >::pasteInto",1,"ofPixels_< unsigned char > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofPixels_< unsigned char >::pasteInto",2,"ofPixels_< unsigned char > &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofPixels_< unsigned char >::pasteInto",3,"size_t");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofPixels_< unsigned char >::pasteInto",4,"size_t");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Pixels_pasteInto",1,SWIGTYPE_p_ofPixels_T_unsigned_char_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Pixels_pasteInto",2,SWIGTYPE_p_ofPixels_T_unsigned_char_t); } 
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (size_t)lua_tonumber(L, 3);
  SWIG_contract_assert((lua_tonumber(L,4)>=0),"number must not be negative") arg4 = (size_t)lua_tonumber(L, 4);
  result = (bool)((ofPixels_< unsigned char > const *)arg1)->pasteInto(*arg2,arg3,arg4);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Pixels_blendInto(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned char > *arg1 = (ofPixels_< unsigned char > *) 0 ; ofPixels_< unsigned char > *arg2 = 0 ; size_t arg3 ;
  size_t arg4 ; bool result; SWIG_check_num_args("ofPixels_< unsigned char >::blendInto",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned char >::blendInto",1,"ofPixels_< unsigned char > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofPixels_< unsigned char >::blendInto",2,"ofPixels_< unsigned char > &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofPixels_< unsigned char >::blendInto",3,"size_t");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofPixels_< unsigned char >::blendInto",4,"size_t");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Pixels_blendInto",1,SWIGTYPE_p_ofPixels_T_unsigned_char_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Pixels_blendInto",2,SWIGTYPE_p_ofPixels_T_unsigned_char_t); } 
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (size_t)lua_tonumber(L, 3);
  SWIG_contract_assert((lua_tonumber(L,4)>=0),"number must not be negative") arg4 = (size_t)lua_tonumber(L, 4);
  result = (bool)((ofPixels_< unsigned char > const *)arg1)->blendInto(*arg2,arg3,arg4);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Pixels_swapRgb(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned char > *arg1 = (ofPixels_< unsigned char > *) 0 ;
  SWIG_check_num_args("ofPixels_< unsigned char >::swapRgb",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned char >::swapRgb",1,"ofPixels_< unsigned char > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Pixels_swapRgb",1,SWIGTYPE_p_ofPixels_T_unsigned_char_t); }  (arg1)->swapRgb(); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Pixels_getData__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned char > *arg1 = (ofPixels_< unsigned char > *) 0 ; unsigned char *result = 0 ;
  SWIG_check_num_args("ofPixels_< unsigned char >::getData",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned char >::getData",1,"ofPixels_< unsigned char > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Pixels_getData",1,SWIGTYPE_p_ofPixels_T_unsigned_char_t); }  result = (unsigned char *)(arg1)->getData();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_unsigned_char,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Pixels_getData__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned char > *arg1 = (ofPixels_< unsigned char > *) 0 ; unsigned char *result = 0 ;
  SWIG_check_num_args("ofPixels_< unsigned char >::getData",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned char >::getData",1,"ofPixels_< unsigned char > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Pixels_getData",1,SWIGTYPE_p_ofPixels_T_unsigned_char_t); } 
  result = (unsigned char *)((ofPixels_< unsigned char > const *)arg1)->getData();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_unsigned_char,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Pixels_getData(lua_State* L) { int argc; int argv[2]={ 1,2} ; argc = lua_gettop(L); if (argc == 1) { int _v; {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofPixels_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Pixels_getData__SWIG_0(L);}  }  if (argc == 1) { int _v; {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofPixels_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Pixels_getData__SWIG_1(L);}  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Pixels_getData'\n" "  Possible C/C++ prototypes are:\n"
  "    ofPixels_< unsigned char >::getData()\n" "    ofPixels_< unsigned char >::getData() const\n"); lua_error(L);return 0; }
static int _wrap_Pixels_getPixelIndex(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned char > *arg1 = (ofPixels_< unsigned char > *) 0 ; size_t arg2 ; size_t arg3 ; size_t result;
  SWIG_check_num_args("ofPixels_< unsigned char >::getPixelIndex",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned char >::getPixelIndex",1,"ofPixels_< unsigned char > const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofPixels_< unsigned char >::getPixelIndex",2,"size_t");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofPixels_< unsigned char >::getPixelIndex",3,"size_t");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Pixels_getPixelIndex",1,SWIGTYPE_p_ofPixels_T_unsigned_char_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (size_t)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (size_t)lua_tonumber(L, 3);
  result = (size_t)((ofPixels_< unsigned char > const *)arg1)->getPixelIndex(arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Pixels_getColor__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned char > *arg1 = (ofPixels_< unsigned char > *) 0 ; size_t arg2 ; size_t arg3 ;
  ofColor_< unsigned char > result; SWIG_check_num_args("ofPixels_< unsigned char >::getColor",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned char >::getColor",1,"ofPixels_< unsigned char > const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofPixels_< unsigned char >::getColor",2,"size_t");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofPixels_< unsigned char >::getColor",3,"size_t");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Pixels_getColor",1,SWIGTYPE_p_ofPixels_T_unsigned_char_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (size_t)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (size_t)lua_tonumber(L, 3);
  result = ((ofPixels_< unsigned char > const *)arg1)->getColor(arg2,arg3); {
    ofColor_< unsigned char > * resultptr = new ofColor_< unsigned char >((const ofColor_< unsigned char > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofColor_T_unsigned_char_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Pixels_getColor__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned char > *arg1 = (ofPixels_< unsigned char > *) 0 ; size_t arg2 ; ofColor_< unsigned char > result;
  SWIG_check_num_args("ofPixels_< unsigned char >::getColor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned char >::getColor",1,"ofPixels_< unsigned char > const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofPixels_< unsigned char >::getColor",2,"size_t");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Pixels_getColor",1,SWIGTYPE_p_ofPixels_T_unsigned_char_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (size_t)lua_tonumber(L, 2);
  result = ((ofPixels_< unsigned char > const *)arg1)->getColor(arg2); {
    ofColor_< unsigned char > * resultptr = new ofColor_< unsigned char >((const ofColor_< unsigned char > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofColor_T_unsigned_char_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Pixels_getColor(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofPixels_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_Pixels_getColor__SWIG_1(L);}  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofPixels_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { return _wrap_Pixels_getColor__SWIG_0(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Pixels_getColor'\n" "  Possible C/C++ prototypes are:\n"
  "    ofPixels_< unsigned char >::getColor(size_t,size_t) const\n" "    ofPixels_< unsigned char >::getColor(size_t) const\n");
  lua_error(L);return 0; }
static int _wrap_Pixels_setColor__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned char > *arg1 = (ofPixels_< unsigned char > *) 0 ; size_t arg2 ; size_t arg3 ;
  ofColor_< unsigned char > *arg4 = 0 ; SWIG_check_num_args("ofPixels_< unsigned char >::setColor",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned char >::setColor",1,"ofPixels_< unsigned char > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofPixels_< unsigned char >::setColor",2,"size_t");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofPixels_< unsigned char >::setColor",3,"size_t");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("ofPixels_< unsigned char >::setColor",4,"ofColor_< unsigned char > const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Pixels_setColor",1,SWIGTYPE_p_ofPixels_T_unsigned_char_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (size_t)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (size_t)lua_tonumber(L, 3);
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Pixels_setColor",4,SWIGTYPE_p_ofColor_T_unsigned_char_t); } 
  (arg1)->setColor(arg2,arg3,(ofColor_< unsigned char > const &)*arg4); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Pixels_setColor__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned char > *arg1 = (ofPixels_< unsigned char > *) 0 ; size_t arg2 ; ofColor_< unsigned char > *arg3 = 0 ;
  SWIG_check_num_args("ofPixels_< unsigned char >::setColor",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned char >::setColor",1,"ofPixels_< unsigned char > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofPixels_< unsigned char >::setColor",2,"size_t");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofPixels_< unsigned char >::setColor",3,"ofColor_< unsigned char > const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Pixels_setColor",1,SWIGTYPE_p_ofPixels_T_unsigned_char_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (size_t)lua_tonumber(L, 2);
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Pixels_setColor",3,SWIGTYPE_p_ofColor_T_unsigned_char_t); } 
  (arg1)->setColor(arg2,(ofColor_< unsigned char > const &)*arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Pixels_setColor__SWIG_2(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned char > *arg1 = (ofPixels_< unsigned char > *) 0 ; ofColor_< unsigned char > *arg2 = 0 ;
  SWIG_check_num_args("ofPixels_< unsigned char >::setColor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned char >::setColor",1,"ofPixels_< unsigned char > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofPixels_< unsigned char >::setColor",2,"ofColor_< unsigned char > const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Pixels_setColor",1,SWIGTYPE_p_ofPixels_T_unsigned_char_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Pixels_setColor",2,SWIGTYPE_p_ofColor_T_unsigned_char_t); } 
  (arg1)->setColor((ofColor_< unsigned char > const &)*arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Pixels_setColor(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofPixels_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofColor_T_unsigned_char_t, 0)) {
          _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Pixels_setColor__SWIG_2(L);}  }  }  if (argc == 3) { int _v; {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofPixels_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_ofColor_T_unsigned_char_t, 0)) {
            _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Pixels_setColor__SWIG_1(L);}  }  }  }  if (argc == 4) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofPixels_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { { void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_ofColor_T_unsigned_char_t, 0)) {
              _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Pixels_setColor__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Pixels_setColor'\n" "  Possible C/C++ prototypes are:\n"
  "    ofPixels_< unsigned char >::setColor(size_t,size_t,ofColor_< unsigned char > const &)\n"
  "    ofPixels_< unsigned char >::setColor(size_t,ofColor_< unsigned char > const &)\n"
  "    ofPixels_< unsigned char >::setColor(ofColor_< unsigned char > const &)\n"); lua_error(L);return 0; }
static int _wrap_Pixels_getWidth(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned char > *arg1 = (ofPixels_< unsigned char > *) 0 ; size_t result;
  SWIG_check_num_args("ofPixels_< unsigned char >::getWidth",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned char >::getWidth",1,"ofPixels_< unsigned char > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Pixels_getWidth",1,SWIGTYPE_p_ofPixels_T_unsigned_char_t); } 
  result = (size_t)((ofPixels_< unsigned char > const *)arg1)->getWidth(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Pixels_getHeight(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned char > *arg1 = (ofPixels_< unsigned char > *) 0 ; size_t result;
  SWIG_check_num_args("ofPixels_< unsigned char >::getHeight",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned char >::getHeight",1,"ofPixels_< unsigned char > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Pixels_getHeight",1,SWIGTYPE_p_ofPixels_T_unsigned_char_t); } 
  result = (size_t)((ofPixels_< unsigned char > const *)arg1)->getHeight(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Pixels_getBytesPerPixel(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned char > *arg1 = (ofPixels_< unsigned char > *) 0 ; size_t result;
  SWIG_check_num_args("ofPixels_< unsigned char >::getBytesPerPixel",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned char >::getBytesPerPixel",1,"ofPixels_< unsigned char > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Pixels_getBytesPerPixel",1,SWIGTYPE_p_ofPixels_T_unsigned_char_t); } 
  result = (size_t)((ofPixels_< unsigned char > const *)arg1)->getBytesPerPixel();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Pixels_getBitsPerPixel(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned char > *arg1 = (ofPixels_< unsigned char > *) 0 ; size_t result;
  SWIG_check_num_args("ofPixels_< unsigned char >::getBitsPerPixel",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned char >::getBitsPerPixel",1,"ofPixels_< unsigned char > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Pixels_getBitsPerPixel",1,SWIGTYPE_p_ofPixels_T_unsigned_char_t); } 
  result = (size_t)((ofPixels_< unsigned char > const *)arg1)->getBitsPerPixel();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Pixels_getBytesPerChannel(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned char > *arg1 = (ofPixels_< unsigned char > *) 0 ; size_t result;
  SWIG_check_num_args("ofPixels_< unsigned char >::getBytesPerChannel",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned char >::getBytesPerChannel",1,"ofPixels_< unsigned char > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Pixels_getBytesPerChannel",1,SWIGTYPE_p_ofPixels_T_unsigned_char_t); } 
  result = (size_t)((ofPixels_< unsigned char > const *)arg1)->getBytesPerChannel();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Pixels_getBitsPerChannel(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned char > *arg1 = (ofPixels_< unsigned char > *) 0 ; size_t result;
  SWIG_check_num_args("ofPixels_< unsigned char >::getBitsPerChannel",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned char >::getBitsPerChannel",1,"ofPixels_< unsigned char > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Pixels_getBitsPerChannel",1,SWIGTYPE_p_ofPixels_T_unsigned_char_t); } 
  result = (size_t)((ofPixels_< unsigned char > const *)arg1)->getBitsPerChannel();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Pixels_getBytesStride(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned char > *arg1 = (ofPixels_< unsigned char > *) 0 ; size_t result;
  SWIG_check_num_args("ofPixels_< unsigned char >::getBytesStride",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned char >::getBytesStride",1,"ofPixels_< unsigned char > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Pixels_getBytesStride",1,SWIGTYPE_p_ofPixels_T_unsigned_char_t); } 
  result = (size_t)((ofPixels_< unsigned char > const *)arg1)->getBytesStride();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Pixels_getNumChannels(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned char > *arg1 = (ofPixels_< unsigned char > *) 0 ; size_t result;
  SWIG_check_num_args("ofPixels_< unsigned char >::getNumChannels",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned char >::getNumChannels",1,"ofPixels_< unsigned char > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Pixels_getNumChannels",1,SWIGTYPE_p_ofPixels_T_unsigned_char_t); } 
  result = (size_t)((ofPixels_< unsigned char > const *)arg1)->getNumChannels();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Pixels_getTotalBytes(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned char > *arg1 = (ofPixels_< unsigned char > *) 0 ; size_t result;
  SWIG_check_num_args("ofPixels_< unsigned char >::getTotalBytes",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned char >::getTotalBytes",1,"ofPixels_< unsigned char > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Pixels_getTotalBytes",1,SWIGTYPE_p_ofPixels_T_unsigned_char_t); } 
  result = (size_t)((ofPixels_< unsigned char > const *)arg1)->getTotalBytes();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Pixels_getNumPlanes(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned char > *arg1 = (ofPixels_< unsigned char > *) 0 ; size_t result;
  SWIG_check_num_args("ofPixels_< unsigned char >::getNumPlanes",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned char >::getNumPlanes",1,"ofPixels_< unsigned char > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Pixels_getNumPlanes",1,SWIGTYPE_p_ofPixels_T_unsigned_char_t); } 
  result = (size_t)((ofPixels_< unsigned char > const *)arg1)->getNumPlanes();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Pixels_getPlane(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned char > *arg1 = (ofPixels_< unsigned char > *) 0 ; size_t arg2 ; ofPixels_< unsigned char > result;
  SWIG_check_num_args("ofPixels_< unsigned char >::getPlane",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned char >::getPlane",1,"ofPixels_< unsigned char > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofPixels_< unsigned char >::getPlane",2,"size_t");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Pixels_getPlane",1,SWIGTYPE_p_ofPixels_T_unsigned_char_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (size_t)lua_tonumber(L, 2);
  result = (arg1)->getPlane(arg2); {
    ofPixels_< unsigned char > * resultptr = new ofPixels_< unsigned char >((const ofPixels_< unsigned char > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofPixels_T_unsigned_char_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Pixels_getChannel(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned char > *arg1 = (ofPixels_< unsigned char > *) 0 ; size_t arg2 ; ofPixels_< unsigned char > result;
  SWIG_check_num_args("ofPixels_< unsigned char >::getChannel",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned char >::getChannel",1,"ofPixels_< unsigned char > const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofPixels_< unsigned char >::getChannel",2,"size_t");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Pixels_getChannel",1,SWIGTYPE_p_ofPixels_T_unsigned_char_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (size_t)lua_tonumber(L, 2);
  result = ((ofPixels_< unsigned char > const *)arg1)->getChannel(arg2); {
    ofPixels_< unsigned char > * resultptr = new ofPixels_< unsigned char >((const ofPixels_< unsigned char > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofPixels_T_unsigned_char_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Pixels_getPixelFormat(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned char > *arg1 = (ofPixels_< unsigned char > *) 0 ; ofPixelFormat result;
  SWIG_check_num_args("ofPixels_< unsigned char >::getPixelFormat",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned char >::getPixelFormat",1,"ofPixels_< unsigned char > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Pixels_getPixelFormat",1,SWIGTYPE_p_ofPixels_T_unsigned_char_t); } 
  result = (ofPixelFormat)((ofPixels_< unsigned char > const *)arg1)->getPixelFormat();
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Pixels_size(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned char > *arg1 = (ofPixels_< unsigned char > *) 0 ; size_t result;
  SWIG_check_num_args("ofPixels_< unsigned char >::size",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned char >::size",1,"ofPixels_< unsigned char > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Pixels_size",1,SWIGTYPE_p_ofPixels_T_unsigned_char_t); } 
  result = (size_t)((ofPixels_< unsigned char > const *)arg1)->size(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Pixels_getImageType(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned char > *arg1 = (ofPixels_< unsigned char > *) 0 ; ofImageType result;
  SWIG_check_num_args("ofPixels_< unsigned char >::getImageType",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned char >::getImageType",1,"ofPixels_< unsigned char > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Pixels_getImageType",1,SWIGTYPE_p_ofPixels_T_unsigned_char_t); } 
  result = (ofImageType)((ofPixels_< unsigned char > const *)arg1)->getImageType();
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Pixels_setChannel(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned char > *arg1 = (ofPixels_< unsigned char > *) 0 ; size_t arg2 ; ofPixels_< unsigned char > arg3 ;
  ofPixels_< unsigned char > *argp3 ; SWIG_check_num_args("ofPixels_< unsigned char >::setChannel",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned char >::setChannel",1,"ofPixels_< unsigned char > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofPixels_< unsigned char >::setChannel",2,"size_t");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofPixels_< unsigned char >::setChannel",3,"ofPixels_< unsigned char > const");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Pixels_setChannel",1,SWIGTYPE_p_ofPixels_T_unsigned_char_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (size_t)lua_tonumber(L, 2);
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Pixels_setChannel",3,SWIGTYPE_p_ofPixels_T_unsigned_char_t); }  arg3 = *argp3; (arg1)->setChannel(arg2,arg3);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Pixels_setImageType(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned char > *arg1 = (ofPixels_< unsigned char > *) 0 ; ofImageType arg2 ;
  SWIG_check_num_args("ofPixels_< unsigned char >::setImageType",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned char >::setImageType",1,"ofPixels_< unsigned char > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofPixels_< unsigned char >::setImageType",2,"ofImageType");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Pixels_setImageType",1,SWIGTYPE_p_ofPixels_T_unsigned_char_t); } 
  arg2 = (ofImageType)(int)lua_tonumber(L, 2); (arg1)->setImageType(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Pixels_setNumChannels(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned char > *arg1 = (ofPixels_< unsigned char > *) 0 ; size_t arg2 ;
  SWIG_check_num_args("ofPixels_< unsigned char >::setNumChannels",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned char >::setNumChannels",1,"ofPixels_< unsigned char > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofPixels_< unsigned char >::setNumChannels",2,"size_t");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Pixels_setNumChannels",1,SWIGTYPE_p_ofPixels_T_unsigned_char_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (size_t)lua_tonumber(L, 2);
  (arg1)->setNumChannels(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static void swig_delete_Pixels(void *obj) {
ofPixels_< unsigned char > *arg1 = (ofPixels_< unsigned char > *) obj;
delete arg1;
}
static int _proxy__wrap_new_Pixels(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_Pixels);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_Pixels_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_Pixels_methods[]= {
    { "allocate", _wrap_Pixels_allocate},
    { "allocatePixelFormat", _wrap_Pixels_allocatePixelFormat},
    { "allocateImageType", _wrap_Pixels_allocateImageType},
    { "isAllocated", _wrap_Pixels_isAllocated},
    { "clear", _wrap_Pixels_clear},
    { "set", _wrap_Pixels_set},
    { "setFromPixels", _wrap_Pixels_setFromPixels},
    { "setFromPixelsImageType", _wrap_Pixels_setFromPixelsImageType},
    { "setFromExternalPixels", _wrap_Pixels_setFromExternalPixels},
    { "setFromAlignedPixels", _wrap_Pixels_setFromAlignedPixels},
    { "swap", _wrap_Pixels_swap},
    { "crop", _wrap_Pixels_crop},
    { "cropTo", _wrap_Pixels_cropTo},
    { "rotate90", _wrap_Pixels_rotate90},
    { "rotate90To", _wrap_Pixels_rotate90To},
    { "mirrorTo", _wrap_Pixels_mirrorTo},
    { "mirror", _wrap_Pixels_mirror},
    { "resize", _wrap_Pixels_resize},
    { "resizeTo", _wrap_Pixels_resizeTo},
    { "pasteInto", _wrap_Pixels_pasteInto},
    { "blendInto", _wrap_Pixels_blendInto},
    { "swapRgb", _wrap_Pixels_swapRgb},
    { "getData", _wrap_Pixels_getData},
    { "getPixelIndex", _wrap_Pixels_getPixelIndex},
    { "getColor", _wrap_Pixels_getColor},
    { "setColor", _wrap_Pixels_setColor},
    { "getWidth", _wrap_Pixels_getWidth},
    { "getHeight", _wrap_Pixels_getHeight},
    { "getBytesPerPixel", _wrap_Pixels_getBytesPerPixel},
    { "getBitsPerPixel", _wrap_Pixels_getBitsPerPixel},
    { "getBytesPerChannel", _wrap_Pixels_getBytesPerChannel},
    { "getBitsPerChannel", _wrap_Pixels_getBitsPerChannel},
    { "getBytesStride", _wrap_Pixels_getBytesStride},
    { "getNumChannels", _wrap_Pixels_getNumChannels},
    { "getTotalBytes", _wrap_Pixels_getTotalBytes},
    { "getNumPlanes", _wrap_Pixels_getNumPlanes},
    { "getPlane", _wrap_Pixels_getPlane},
    { "getChannel", _wrap_Pixels_getChannel},
    { "getPixelFormat", _wrap_Pixels_getPixelFormat},
    { "size", _wrap_Pixels_size},
    { "getImageType", _wrap_Pixels_getImageType},
    { "setChannel", _wrap_Pixels_setChannel},
    { "setImageType", _wrap_Pixels_setImageType},
    { "setNumChannels", _wrap_Pixels_setNumChannels},
    {0,0}
};
static swig_lua_method swig_Pixels_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_Pixels_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_Pixels_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_Pixels_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_Pixels_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_Pixels_Sf_SwigStatic = {
    "Pixels",
    swig_Pixels_Sf_SwigStatic_methods,
    swig_Pixels_Sf_SwigStatic_attributes,
    swig_Pixels_Sf_SwigStatic_constants,
    swig_Pixels_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_Pixels_bases[] = {0};
static const char *swig_Pixels_base_names[] = {0};
static swig_lua_class _wrap_class_Pixels = { "Pixels", "Pixels", &SWIGTYPE_p_ofPixels_T_unsigned_char_t,_proxy__wrap_new_Pixels, swig_delete_Pixels, swig_Pixels_methods, swig_Pixels_attributes, &swig_Pixels_Sf_SwigStatic, swig_Pixels_meta, swig_Pixels_bases, swig_Pixels_base_names };

static int _wrap_new_FloatPixels__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofPixels_< float > *result = 0 ;
  SWIG_check_num_args("ofPixels_< float >::ofPixels_",0,0) result = (ofPixels_< float > *)new ofPixels_< float >();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofPixels_T_float_t,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_FloatPixels__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofPixels_< float > *arg1 = 0 ;
  ofPixels_< float > *result = 0 ; SWIG_check_num_args("ofPixels_< float >::ofPixels_",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofPixels_< float >::ofPixels_",1,"ofPixels_< float > &&");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_float_t,0))){
    SWIG_fail_ptr("new_FloatPixels",1,SWIGTYPE_p_ofPixels_T_float_t); } 
  result = (ofPixels_< float > *)new ofPixels_< float >((ofPixels_< float > &&)*arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofPixels_T_float_t,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_FloatPixels(lua_State* L) { int argc; int argv[2]={ 1,2} ; argc = lua_gettop(L); if (argc == 0) {
    return _wrap_new_FloatPixels__SWIG_0(L);}  if (argc == 1) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofPixels_T_float_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_new_FloatPixels__SWIG_1(L);}  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_FloatPixels'\n" "  Possible C/C++ prototypes are:\n"
  "    ofPixels_< float >::ofPixels_()\n" "    ofPixels_< float >::ofPixels_(ofPixels_< float > &&)\n"); lua_error(L);return 0; }
static int _wrap_FloatPixels_allocate(lua_State* L) { int SWIG_arg = 0; ofPixels_< float > *arg1 = (ofPixels_< float > *) 0 ;
  size_t arg2 ; size_t arg3 ; size_t arg4 ; SWIG_check_num_args("ofPixels_< float >::allocate",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< float >::allocate",1,"ofPixels_< float > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofPixels_< float >::allocate",2,"size_t");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofPixels_< float >::allocate",3,"size_t");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofPixels_< float >::allocate",4,"size_t");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_float_t,0))){
    SWIG_fail_ptr("FloatPixels_allocate",1,SWIGTYPE_p_ofPixels_T_float_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (size_t)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (size_t)lua_tonumber(L, 3);
  SWIG_contract_assert((lua_tonumber(L,4)>=0),"number must not be negative") arg4 = (size_t)lua_tonumber(L, 4);
  (arg1)->allocate(arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatPixels_allocatePixelFormat(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< float > *arg1 = (ofPixels_< float > *) 0 ; size_t arg2 ; size_t arg3 ; ofPixelFormat arg4 ;
  SWIG_check_num_args("ofPixels_< float >::allocate",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< float >::allocate",1,"ofPixels_< float > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofPixels_< float >::allocate",2,"size_t");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofPixels_< float >::allocate",3,"size_t");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofPixels_< float >::allocate",4,"ofPixelFormat");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_float_t,0))){
    SWIG_fail_ptr("FloatPixels_allocatePixelFormat",1,SWIGTYPE_p_ofPixels_T_float_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (size_t)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (size_t)lua_tonumber(L, 3);
  arg4 = (ofPixelFormat)(int)lua_tonumber(L, 4); (arg1)->allocate(arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatPixels_allocateImageType(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< float > *arg1 = (ofPixels_< float > *) 0 ; size_t arg2 ; size_t arg3 ; ofImageType arg4 ;
  SWIG_check_num_args("ofPixels_< float >::allocate",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< float >::allocate",1,"ofPixels_< float > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofPixels_< float >::allocate",2,"size_t");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofPixels_< float >::allocate",3,"size_t");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofPixels_< float >::allocate",4,"ofImageType");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_float_t,0))){
    SWIG_fail_ptr("FloatPixels_allocateImageType",1,SWIGTYPE_p_ofPixels_T_float_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (size_t)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (size_t)lua_tonumber(L, 3);
  arg4 = (ofImageType)(int)lua_tonumber(L, 4); (arg1)->allocate(arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatPixels_isAllocated(lua_State* L) { int SWIG_arg = 0; ofPixels_< float > *arg1 = (ofPixels_< float > *) 0 ;
  bool result; SWIG_check_num_args("ofPixels_< float >::isAllocated",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< float >::isAllocated",1,"ofPixels_< float > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_float_t,0))){
    SWIG_fail_ptr("FloatPixels_isAllocated",1,SWIGTYPE_p_ofPixels_T_float_t); } 
  result = (bool)((ofPixels_< float > const *)arg1)->isAllocated(); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatPixels_clear(lua_State* L) { int SWIG_arg = 0; ofPixels_< float > *arg1 = (ofPixels_< float > *) 0 ;
  SWIG_check_num_args("ofPixels_< float >::clear",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< float >::clear",1,"ofPixels_< float > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_float_t,0))){
    SWIG_fail_ptr("FloatPixels_clear",1,SWIGTYPE_p_ofPixels_T_float_t); }  (arg1)->clear(); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatPixels_set__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofPixels_< float > *arg1 = (ofPixels_< float > *) 0 ;
  float arg2 ; SWIG_check_num_args("ofPixels_< float >::set",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< float >::set",1,"ofPixels_< float > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofPixels_< float >::set",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_float_t,0))){
    SWIG_fail_ptr("FloatPixels_set",1,SWIGTYPE_p_ofPixels_T_float_t); }  arg2 = (float)lua_tonumber(L, 2); (arg1)->set(arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatPixels_set__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofPixels_< float > *arg1 = (ofPixels_< float > *) 0 ;
  size_t arg2 ; float arg3 ; SWIG_check_num_args("ofPixels_< float >::set",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< float >::set",1,"ofPixels_< float > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofPixels_< float >::set",2,"size_t");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofPixels_< float >::set",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_float_t,0))){
    SWIG_fail_ptr("FloatPixels_set",1,SWIGTYPE_p_ofPixels_T_float_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (size_t)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); (arg1)->set(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_FloatPixels_set(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofPixels_T_float_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_FloatPixels_set__SWIG_0(L);}  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofPixels_T_float_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { return _wrap_FloatPixels_set__SWIG_1(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'FloatPixels_set'\n" "  Possible C/C++ prototypes are:\n"
  "    ofPixels_< float >::set(float)\n" "    ofPixels_< float >::set(size_t,float)\n"); lua_error(L);return 0; }
static int _wrap_FloatPixels_setFromPixels(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< float > *arg1 = (ofPixels_< float > *) 0 ; float *arg2 = (float *) 0 ; size_t arg3 ; size_t arg4 ;
  ofPixelFormat arg5 ; SWIG_check_num_args("ofPixels_< float >::setFromPixels",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< float >::setFromPixels",1,"ofPixels_< float > *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofPixels_< float >::setFromPixels",2,"float const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofPixels_< float >::setFromPixels",3,"size_t");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofPixels_< float >::setFromPixels",4,"size_t");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofPixels_< float >::setFromPixels",5,"ofPixelFormat");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_float_t,0))){
    SWIG_fail_ptr("FloatPixels_setFromPixels",1,SWIGTYPE_p_ofPixels_T_float_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("FloatPixels_setFromPixels",2,SWIGTYPE_p_float); } 
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (size_t)lua_tonumber(L, 3);
  SWIG_contract_assert((lua_tonumber(L,4)>=0),"number must not be negative") arg4 = (size_t)lua_tonumber(L, 4);
  arg5 = (ofPixelFormat)(int)lua_tonumber(L, 5); (arg1)->setFromPixels((float const *)arg2,arg3,arg4,arg5); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatPixels_setFromPixelsImageType(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< float > *arg1 = (ofPixels_< float > *) 0 ; float *arg2 = (float *) 0 ; size_t arg3 ; size_t arg4 ;
  ofImageType arg5 ; SWIG_check_num_args("ofPixels_< float >::setFromPixels",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< float >::setFromPixels",1,"ofPixels_< float > *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofPixels_< float >::setFromPixels",2,"float const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofPixels_< float >::setFromPixels",3,"size_t");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofPixels_< float >::setFromPixels",4,"size_t");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofPixels_< float >::setFromPixels",5,"ofImageType");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_float_t,0))){
    SWIG_fail_ptr("FloatPixels_setFromPixelsImageType",1,SWIGTYPE_p_ofPixels_T_float_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("FloatPixels_setFromPixelsImageType",2,SWIGTYPE_p_float); } 
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (size_t)lua_tonumber(L, 3);
  SWIG_contract_assert((lua_tonumber(L,4)>=0),"number must not be negative") arg4 = (size_t)lua_tonumber(L, 4);
  arg5 = (ofImageType)(int)lua_tonumber(L, 5); (arg1)->setFromPixels((float const *)arg2,arg3,arg4,arg5); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatPixels_setFromExternalPixels(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< float > *arg1 = (ofPixels_< float > *) 0 ; float *arg2 = (float *) 0 ; size_t arg3 ; size_t arg4 ;
  ofPixelFormat arg5 ; SWIG_check_num_args("ofPixels_< float >::setFromExternalPixels",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< float >::setFromExternalPixels",1,"ofPixels_< float > *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofPixels_< float >::setFromExternalPixels",2,"float *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofPixels_< float >::setFromExternalPixels",3,"size_t");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofPixels_< float >::setFromExternalPixels",4,"size_t");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofPixels_< float >::setFromExternalPixels",5,"ofPixelFormat");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_float_t,0))){
    SWIG_fail_ptr("FloatPixels_setFromExternalPixels",1,SWIGTYPE_p_ofPixels_T_float_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("FloatPixels_setFromExternalPixels",2,SWIGTYPE_p_float); } 
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (size_t)lua_tonumber(L, 3);
  SWIG_contract_assert((lua_tonumber(L,4)>=0),"number must not be negative") arg4 = (size_t)lua_tonumber(L, 4);
  arg5 = (ofPixelFormat)(int)lua_tonumber(L, 5); (arg1)->setFromExternalPixels(arg2,arg3,arg4,arg5); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatPixels_setFromAlignedPixels(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< float > *arg1 = (ofPixels_< float > *) 0 ; float *arg2 = (float *) 0 ; size_t arg3 ; size_t arg4 ;
  ofPixelFormat arg5 ; size_t arg6 ; SWIG_check_num_args("ofPixels_< float >::setFromAlignedPixels",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< float >::setFromAlignedPixels",1,"ofPixels_< float > *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofPixels_< float >::setFromAlignedPixels",2,"float const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofPixels_< float >::setFromAlignedPixels",3,"size_t");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofPixels_< float >::setFromAlignedPixels",4,"size_t");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofPixels_< float >::setFromAlignedPixels",5,"ofPixelFormat");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofPixels_< float >::setFromAlignedPixels",6,"size_t");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_float_t,0))){
    SWIG_fail_ptr("FloatPixels_setFromAlignedPixels",1,SWIGTYPE_p_ofPixels_T_float_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("FloatPixels_setFromAlignedPixels",2,SWIGTYPE_p_float); } 
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (size_t)lua_tonumber(L, 3);
  SWIG_contract_assert((lua_tonumber(L,4)>=0),"number must not be negative") arg4 = (size_t)lua_tonumber(L, 4);
  arg5 = (ofPixelFormat)(int)lua_tonumber(L, 5); SWIG_contract_assert((lua_tonumber(L,6)>=0),"number must not be negative")
  arg6 = (size_t)lua_tonumber(L, 6); (arg1)->setFromAlignedPixels((float const *)arg2,arg3,arg4,arg5,arg6); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatPixels_swap(lua_State* L) { int SWIG_arg = 0; ofPixels_< float > *arg1 = (ofPixels_< float > *) 0 ;
  ofPixels_< float > *arg2 = 0 ; SWIG_check_num_args("ofPixels_< float >::swap",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< float >::swap",1,"ofPixels_< float > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofPixels_< float >::swap",2,"ofPixels_< float > &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_float_t,0))){
    SWIG_fail_ptr("FloatPixels_swap",1,SWIGTYPE_p_ofPixels_T_float_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofPixels_T_float_t,0))){
    SWIG_fail_ptr("FloatPixels_swap",2,SWIGTYPE_p_ofPixels_T_float_t); }  (arg1)->swap(*arg2); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatPixels_crop(lua_State* L) { int SWIG_arg = 0; ofPixels_< float > *arg1 = (ofPixels_< float > *) 0 ;
  size_t arg2 ; size_t arg3 ; size_t arg4 ; size_t arg5 ; SWIG_check_num_args("ofPixels_< float >::crop",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< float >::crop",1,"ofPixels_< float > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofPixels_< float >::crop",2,"size_t");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofPixels_< float >::crop",3,"size_t");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofPixels_< float >::crop",4,"size_t");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofPixels_< float >::crop",5,"size_t");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_float_t,0))){
    SWIG_fail_ptr("FloatPixels_crop",1,SWIGTYPE_p_ofPixels_T_float_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (size_t)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (size_t)lua_tonumber(L, 3);
  SWIG_contract_assert((lua_tonumber(L,4)>=0),"number must not be negative") arg4 = (size_t)lua_tonumber(L, 4);
  SWIG_contract_assert((lua_tonumber(L,5)>=0),"number must not be negative") arg5 = (size_t)lua_tonumber(L, 5);
  (arg1)->crop(arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatPixels_cropTo(lua_State* L) { int SWIG_arg = 0; ofPixels_< float > *arg1 = (ofPixels_< float > *) 0 ;
  ofPixels_< float > *arg2 = 0 ; size_t arg3 ; size_t arg4 ; size_t arg5 ; size_t arg6 ;
  SWIG_check_num_args("ofPixels_< float >::cropTo",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< float >::cropTo",1,"ofPixels_< float > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofPixels_< float >::cropTo",2,"ofPixels_< float > &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofPixels_< float >::cropTo",3,"size_t");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofPixels_< float >::cropTo",4,"size_t");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofPixels_< float >::cropTo",5,"size_t");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofPixels_< float >::cropTo",6,"size_t");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_float_t,0))){
    SWIG_fail_ptr("FloatPixels_cropTo",1,SWIGTYPE_p_ofPixels_T_float_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofPixels_T_float_t,0))){
    SWIG_fail_ptr("FloatPixels_cropTo",2,SWIGTYPE_p_ofPixels_T_float_t); } 
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (size_t)lua_tonumber(L, 3);
  SWIG_contract_assert((lua_tonumber(L,4)>=0),"number must not be negative") arg4 = (size_t)lua_tonumber(L, 4);
  SWIG_contract_assert((lua_tonumber(L,5)>=0),"number must not be negative") arg5 = (size_t)lua_tonumber(L, 5);
  SWIG_contract_assert((lua_tonumber(L,6)>=0),"number must not be negative") arg6 = (size_t)lua_tonumber(L, 6);
  ((ofPixels_< float > const *)arg1)->cropTo(*arg2,arg3,arg4,arg5,arg6); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_FloatPixels_rotate90(lua_State* L) { int SWIG_arg = 0; ofPixels_< float > *arg1 = (ofPixels_< float > *) 0 ;
  int arg2 ; SWIG_check_num_args("ofPixels_< float >::rotate90",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< float >::rotate90",1,"ofPixels_< float > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofPixels_< float >::rotate90",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_float_t,0))){
    SWIG_fail_ptr("FloatPixels_rotate90",1,SWIGTYPE_p_ofPixels_T_float_t); }  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->rotate90(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatPixels_rotate90To(lua_State* L) { int SWIG_arg = 0; ofPixels_< float > *arg1 = (ofPixels_< float > *) 0 ;
  ofPixels_< float > *arg2 = 0 ; int arg3 ; SWIG_check_num_args("ofPixels_< float >::rotate90To",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< float >::rotate90To",1,"ofPixels_< float > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofPixels_< float >::rotate90To",2,"ofPixels_< float > &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofPixels_< float >::rotate90To",3,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_float_t,0))){
    SWIG_fail_ptr("FloatPixels_rotate90To",1,SWIGTYPE_p_ofPixels_T_float_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofPixels_T_float_t,0))){
    SWIG_fail_ptr("FloatPixels_rotate90To",2,SWIGTYPE_p_ofPixels_T_float_t); }  arg3 = (int)lua_tonumber(L, 3);
  ((ofPixels_< float > const *)arg1)->rotate90To(*arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_FloatPixels_mirrorTo(lua_State* L) { int SWIG_arg = 0; ofPixels_< float > *arg1 = (ofPixels_< float > *) 0 ;
  ofPixels_< float > *arg2 = 0 ; bool arg3 ; bool arg4 ; SWIG_check_num_args("ofPixels_< float >::mirrorTo",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< float >::mirrorTo",1,"ofPixels_< float > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofPixels_< float >::mirrorTo",2,"ofPixels_< float > &");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("ofPixels_< float >::mirrorTo",3,"bool");
  if(!lua_isboolean(L,4)) SWIG_fail_arg("ofPixels_< float >::mirrorTo",4,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_float_t,0))){
    SWIG_fail_ptr("FloatPixels_mirrorTo",1,SWIGTYPE_p_ofPixels_T_float_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofPixels_T_float_t,0))){
    SWIG_fail_ptr("FloatPixels_mirrorTo",2,SWIGTYPE_p_ofPixels_T_float_t); }  arg3 = (lua_toboolean(L, 3)!=0);
  arg4 = (lua_toboolean(L, 4)!=0); ((ofPixels_< float > const *)arg1)->mirrorTo(*arg2,arg3,arg4); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatPixels_mirror(lua_State* L) { int SWIG_arg = 0; ofPixels_< float > *arg1 = (ofPixels_< float > *) 0 ;
  bool arg2 ; bool arg3 ; SWIG_check_num_args("ofPixels_< float >::mirror",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< float >::mirror",1,"ofPixels_< float > *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofPixels_< float >::mirror",2,"bool");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("ofPixels_< float >::mirror",3,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_float_t,0))){
    SWIG_fail_ptr("FloatPixels_mirror",1,SWIGTYPE_p_ofPixels_T_float_t); }  arg2 = (lua_toboolean(L, 2)!=0);
  arg3 = (lua_toboolean(L, 3)!=0); (arg1)->mirror(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_FloatPixels_resize__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< float > *arg1 = (ofPixels_< float > *) 0 ; size_t arg2 ; size_t arg3 ; ofInterpolationMethod arg4 ; bool result;
  SWIG_check_num_args("ofPixels_< float >::resize",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< float >::resize",1,"ofPixels_< float > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofPixels_< float >::resize",2,"size_t");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofPixels_< float >::resize",3,"size_t");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofPixels_< float >::resize",4,"ofInterpolationMethod");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_float_t,0))){
    SWIG_fail_ptr("FloatPixels_resize",1,SWIGTYPE_p_ofPixels_T_float_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (size_t)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (size_t)lua_tonumber(L, 3);
  arg4 = (ofInterpolationMethod)(int)lua_tonumber(L, 4); result = (bool)(arg1)->resize(arg2,arg3,arg4);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatPixels_resize__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< float > *arg1 = (ofPixels_< float > *) 0 ; size_t arg2 ; size_t arg3 ; bool result;
  SWIG_check_num_args("ofPixels_< float >::resize",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< float >::resize",1,"ofPixels_< float > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofPixels_< float >::resize",2,"size_t");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofPixels_< float >::resize",3,"size_t");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_float_t,0))){
    SWIG_fail_ptr("FloatPixels_resize",1,SWIGTYPE_p_ofPixels_T_float_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (size_t)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (size_t)lua_tonumber(L, 3);
  result = (bool)(arg1)->resize(arg2,arg3); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatPixels_resize(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L); if (argc == 3) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofPixels_T_float_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { return _wrap_FloatPixels_resize__SWIG_1(L);}  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofPixels_T_float_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_FloatPixels_resize__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'FloatPixels_resize'\n" "  Possible C/C++ prototypes are:\n"
  "    ofPixels_< float >::resize(size_t,size_t,ofInterpolationMethod)\n" "    ofPixels_< float >::resize(size_t,size_t)\n");
  lua_error(L);return 0; }
static int _wrap_FloatPixels_resizeTo__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< float > *arg1 = (ofPixels_< float > *) 0 ; ofPixels_< float > *arg2 = 0 ; ofInterpolationMethod arg3 ; bool result;
  SWIG_check_num_args("ofPixels_< float >::resizeTo",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< float >::resizeTo",1,"ofPixels_< float > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofPixels_< float >::resizeTo",2,"ofPixels_< float > &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofPixels_< float >::resizeTo",3,"ofInterpolationMethod");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_float_t,0))){
    SWIG_fail_ptr("FloatPixels_resizeTo",1,SWIGTYPE_p_ofPixels_T_float_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofPixels_T_float_t,0))){
    SWIG_fail_ptr("FloatPixels_resizeTo",2,SWIGTYPE_p_ofPixels_T_float_t); } 
  arg3 = (ofInterpolationMethod)(int)lua_tonumber(L, 3);
  result = (bool)((ofPixels_< float > const *)arg1)->resizeTo(*arg2,arg3); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatPixels_resizeTo__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< float > *arg1 = (ofPixels_< float > *) 0 ; ofPixels_< float > *arg2 = 0 ; bool result;
  SWIG_check_num_args("ofPixels_< float >::resizeTo",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< float >::resizeTo",1,"ofPixels_< float > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofPixels_< float >::resizeTo",2,"ofPixels_< float > &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_float_t,0))){
    SWIG_fail_ptr("FloatPixels_resizeTo",1,SWIGTYPE_p_ofPixels_T_float_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofPixels_T_float_t,0))){
    SWIG_fail_ptr("FloatPixels_resizeTo",2,SWIGTYPE_p_ofPixels_T_float_t); } 
  result = (bool)((ofPixels_< float > const *)arg1)->resizeTo(*arg2); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatPixels_resizeTo(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofPixels_T_float_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofPixels_T_float_t, 0)) {
          _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_FloatPixels_resizeTo__SWIG_1(L);}  }  }  if (argc == 3) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofPixels_T_float_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofPixels_T_float_t, 0)) {
          _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_FloatPixels_resizeTo__SWIG_0(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'FloatPixels_resizeTo'\n"
  "  Possible C/C++ prototypes are:\n" "    ofPixels_< float >::resizeTo(ofPixels_< float > &,ofInterpolationMethod) const\n"
  "    ofPixels_< float >::resizeTo(ofPixels_< float > &) const\n"); lua_error(L);return 0; }
static int _wrap_FloatPixels_pasteInto(lua_State* L) { int SWIG_arg = 0; ofPixels_< float > *arg1 = (ofPixels_< float > *) 0 ;
  ofPixels_< float > *arg2 = 0 ; size_t arg3 ; size_t arg4 ; bool result;
  SWIG_check_num_args("ofPixels_< float >::pasteInto",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< float >::pasteInto",1,"ofPixels_< float > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofPixels_< float >::pasteInto",2,"ofPixels_< float > &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofPixels_< float >::pasteInto",3,"size_t");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofPixels_< float >::pasteInto",4,"size_t");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_float_t,0))){
    SWIG_fail_ptr("FloatPixels_pasteInto",1,SWIGTYPE_p_ofPixels_T_float_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofPixels_T_float_t,0))){
    SWIG_fail_ptr("FloatPixels_pasteInto",2,SWIGTYPE_p_ofPixels_T_float_t); } 
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (size_t)lua_tonumber(L, 3);
  SWIG_contract_assert((lua_tonumber(L,4)>=0),"number must not be negative") arg4 = (size_t)lua_tonumber(L, 4);
  result = (bool)((ofPixels_< float > const *)arg1)->pasteInto(*arg2,arg3,arg4);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatPixels_blendInto(lua_State* L) { int SWIG_arg = 0; ofPixels_< float > *arg1 = (ofPixels_< float > *) 0 ;
  ofPixels_< float > *arg2 = 0 ; size_t arg3 ; size_t arg4 ; bool result;
  SWIG_check_num_args("ofPixels_< float >::blendInto",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< float >::blendInto",1,"ofPixels_< float > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofPixels_< float >::blendInto",2,"ofPixels_< float > &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofPixels_< float >::blendInto",3,"size_t");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofPixels_< float >::blendInto",4,"size_t");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_float_t,0))){
    SWIG_fail_ptr("FloatPixels_blendInto",1,SWIGTYPE_p_ofPixels_T_float_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofPixels_T_float_t,0))){
    SWIG_fail_ptr("FloatPixels_blendInto",2,SWIGTYPE_p_ofPixels_T_float_t); } 
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (size_t)lua_tonumber(L, 3);
  SWIG_contract_assert((lua_tonumber(L,4)>=0),"number must not be negative") arg4 = (size_t)lua_tonumber(L, 4);
  result = (bool)((ofPixels_< float > const *)arg1)->blendInto(*arg2,arg3,arg4);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatPixels_swapRgb(lua_State* L) { int SWIG_arg = 0; ofPixels_< float > *arg1 = (ofPixels_< float > *) 0 ;
  SWIG_check_num_args("ofPixels_< float >::swapRgb",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< float >::swapRgb",1,"ofPixels_< float > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_float_t,0))){
    SWIG_fail_ptr("FloatPixels_swapRgb",1,SWIGTYPE_p_ofPixels_T_float_t); }  (arg1)->swapRgb(); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatPixels_getData__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< float > *arg1 = (ofPixels_< float > *) 0 ; float *result = 0 ;
  SWIG_check_num_args("ofPixels_< float >::getData",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< float >::getData",1,"ofPixels_< float > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_float_t,0))){
    SWIG_fail_ptr("FloatPixels_getData",1,SWIGTYPE_p_ofPixels_T_float_t); }  result = (float *)(arg1)->getData();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_float,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_FloatPixels_getData__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< float > *arg1 = (ofPixels_< float > *) 0 ; float *result = 0 ;
  SWIG_check_num_args("ofPixels_< float >::getData",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< float >::getData",1,"ofPixels_< float > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_float_t,0))){
    SWIG_fail_ptr("FloatPixels_getData",1,SWIGTYPE_p_ofPixels_T_float_t); } 
  result = (float *)((ofPixels_< float > const *)arg1)->getData(); SWIG_NewPointerObj(L,result,SWIGTYPE_p_float,0); SWIG_arg++; 
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatPixels_getData(lua_State* L) { int argc; int argv[2]={ 1,2} ; argc = lua_gettop(L); if (argc == 1) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofPixels_T_float_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_FloatPixels_getData__SWIG_0(L);}  }  if (argc == 1) { int _v; {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofPixels_T_float_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_FloatPixels_getData__SWIG_1(L);}  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'FloatPixels_getData'\n"
  "  Possible C/C++ prototypes are:\n" "    ofPixels_< float >::getData()\n" "    ofPixels_< float >::getData() const\n");
  lua_error(L);return 0; }
static int _wrap_FloatPixels_getPixelIndex(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< float > *arg1 = (ofPixels_< float > *) 0 ; size_t arg2 ; size_t arg3 ; size_t result;
  SWIG_check_num_args("ofPixels_< float >::getPixelIndex",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< float >::getPixelIndex",1,"ofPixels_< float > const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofPixels_< float >::getPixelIndex",2,"size_t");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofPixels_< float >::getPixelIndex",3,"size_t");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_float_t,0))){
    SWIG_fail_ptr("FloatPixels_getPixelIndex",1,SWIGTYPE_p_ofPixels_T_float_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (size_t)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (size_t)lua_tonumber(L, 3);
  result = (size_t)((ofPixels_< float > const *)arg1)->getPixelIndex(arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatPixels_getColor__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< float > *arg1 = (ofPixels_< float > *) 0 ; size_t arg2 ; size_t arg3 ; ofColor_< float > result;
  SWIG_check_num_args("ofPixels_< float >::getColor",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< float >::getColor",1,"ofPixels_< float > const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofPixels_< float >::getColor",2,"size_t");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofPixels_< float >::getColor",3,"size_t");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_float_t,0))){
    SWIG_fail_ptr("FloatPixels_getColor",1,SWIGTYPE_p_ofPixels_T_float_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (size_t)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (size_t)lua_tonumber(L, 3);
  result = ((ofPixels_< float > const *)arg1)->getColor(arg2,arg3); {
    ofColor_< float > * resultptr = new ofColor_< float >((const ofColor_< float > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofColor_T_float_t,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatPixels_getColor__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< float > *arg1 = (ofPixels_< float > *) 0 ; size_t arg2 ; ofColor_< float > result;
  SWIG_check_num_args("ofPixels_< float >::getColor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< float >::getColor",1,"ofPixels_< float > const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofPixels_< float >::getColor",2,"size_t");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_float_t,0))){
    SWIG_fail_ptr("FloatPixels_getColor",1,SWIGTYPE_p_ofPixels_T_float_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (size_t)lua_tonumber(L, 2);
  result = ((ofPixels_< float > const *)arg1)->getColor(arg2); {
    ofColor_< float > * resultptr = new ofColor_< float >((const ofColor_< float > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofColor_T_float_t,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatPixels_getColor(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofPixels_T_float_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_FloatPixels_getColor__SWIG_1(L);}  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofPixels_T_float_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { return _wrap_FloatPixels_getColor__SWIG_0(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'FloatPixels_getColor'\n"
  "  Possible C/C++ prototypes are:\n" "    ofPixels_< float >::getColor(size_t,size_t) const\n"
  "    ofPixels_< float >::getColor(size_t) const\n"); lua_error(L);return 0; }
static int _wrap_FloatPixels_setColor__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< float > *arg1 = (ofPixels_< float > *) 0 ; size_t arg2 ; size_t arg3 ; ofColor_< float > *arg4 = 0 ;
  SWIG_check_num_args("ofPixels_< float >::setColor",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< float >::setColor",1,"ofPixels_< float > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofPixels_< float >::setColor",2,"size_t");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofPixels_< float >::setColor",3,"size_t");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("ofPixels_< float >::setColor",4,"ofColor_< float > const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_float_t,0))){
    SWIG_fail_ptr("FloatPixels_setColor",1,SWIGTYPE_p_ofPixels_T_float_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (size_t)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (size_t)lua_tonumber(L, 3);
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("FloatPixels_setColor",4,SWIGTYPE_p_ofColor_T_float_t); } 
  (arg1)->setColor(arg2,arg3,(ofColor_< float > const &)*arg4); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_FloatPixels_setColor__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< float > *arg1 = (ofPixels_< float > *) 0 ; size_t arg2 ; ofColor_< float > *arg3 = 0 ;
  SWIG_check_num_args("ofPixels_< float >::setColor",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< float >::setColor",1,"ofPixels_< float > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofPixels_< float >::setColor",2,"size_t");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofPixels_< float >::setColor",3,"ofColor_< float > const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_float_t,0))){
    SWIG_fail_ptr("FloatPixels_setColor",1,SWIGTYPE_p_ofPixels_T_float_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (size_t)lua_tonumber(L, 2);
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("FloatPixels_setColor",3,SWIGTYPE_p_ofColor_T_float_t); } 
  (arg1)->setColor(arg2,(ofColor_< float > const &)*arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_FloatPixels_setColor__SWIG_2(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< float > *arg1 = (ofPixels_< float > *) 0 ; ofColor_< float > *arg2 = 0 ;
  SWIG_check_num_args("ofPixels_< float >::setColor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< float >::setColor",1,"ofPixels_< float > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofPixels_< float >::setColor",2,"ofColor_< float > const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_float_t,0))){
    SWIG_fail_ptr("FloatPixels_setColor",1,SWIGTYPE_p_ofPixels_T_float_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("FloatPixels_setColor",2,SWIGTYPE_p_ofColor_T_float_t); }  (arg1)->setColor((ofColor_< float > const &)*arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatPixels_setColor(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L);
  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofPixels_T_float_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofColor_T_float_t, 0)) {
          _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_FloatPixels_setColor__SWIG_2(L);}  }  }  if (argc == 3) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofPixels_T_float_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_ofColor_T_float_t, 0)) {
            _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_FloatPixels_setColor__SWIG_1(L);}  }  }  }  if (argc == 4) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofPixels_T_float_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { { void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_ofColor_T_float_t, 0)) {
              _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_FloatPixels_setColor__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'FloatPixels_setColor'\n"
  "  Possible C/C++ prototypes are:\n" "    ofPixels_< float >::setColor(size_t,size_t,ofColor_< float > const &)\n"
  "    ofPixels_< float >::setColor(size_t,ofColor_< float > const &)\n"
  "    ofPixels_< float >::setColor(ofColor_< float > const &)\n"); lua_error(L);return 0; }
static int _wrap_FloatPixels_getWidth(lua_State* L) { int SWIG_arg = 0; ofPixels_< float > *arg1 = (ofPixels_< float > *) 0 ;
  size_t result; SWIG_check_num_args("ofPixels_< float >::getWidth",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< float >::getWidth",1,"ofPixels_< float > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_float_t,0))){
    SWIG_fail_ptr("FloatPixels_getWidth",1,SWIGTYPE_p_ofPixels_T_float_t); } 
  result = (size_t)((ofPixels_< float > const *)arg1)->getWidth(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatPixels_getHeight(lua_State* L) { int SWIG_arg = 0; ofPixels_< float > *arg1 = (ofPixels_< float > *) 0 ;
  size_t result; SWIG_check_num_args("ofPixels_< float >::getHeight",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< float >::getHeight",1,"ofPixels_< float > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_float_t,0))){
    SWIG_fail_ptr("FloatPixels_getHeight",1,SWIGTYPE_p_ofPixels_T_float_t); } 
  result = (size_t)((ofPixels_< float > const *)arg1)->getHeight(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatPixels_getBytesPerPixel(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< float > *arg1 = (ofPixels_< float > *) 0 ; size_t result;
  SWIG_check_num_args("ofPixels_< float >::getBytesPerPixel",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< float >::getBytesPerPixel",1,"ofPixels_< float > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_float_t,0))){
    SWIG_fail_ptr("FloatPixels_getBytesPerPixel",1,SWIGTYPE_p_ofPixels_T_float_t); } 
  result = (size_t)((ofPixels_< float > const *)arg1)->getBytesPerPixel(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatPixels_getBitsPerPixel(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< float > *arg1 = (ofPixels_< float > *) 0 ; size_t result;
  SWIG_check_num_args("ofPixels_< float >::getBitsPerPixel",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< float >::getBitsPerPixel",1,"ofPixels_< float > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_float_t,0))){
    SWIG_fail_ptr("FloatPixels_getBitsPerPixel",1,SWIGTYPE_p_ofPixels_T_float_t); } 
  result = (size_t)((ofPixels_< float > const *)arg1)->getBitsPerPixel(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatPixels_getBytesPerChannel(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< float > *arg1 = (ofPixels_< float > *) 0 ; size_t result;
  SWIG_check_num_args("ofPixels_< float >::getBytesPerChannel",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< float >::getBytesPerChannel",1,"ofPixels_< float > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_float_t,0))){
    SWIG_fail_ptr("FloatPixels_getBytesPerChannel",1,SWIGTYPE_p_ofPixels_T_float_t); } 
  result = (size_t)((ofPixels_< float > const *)arg1)->getBytesPerChannel(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatPixels_getBitsPerChannel(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< float > *arg1 = (ofPixels_< float > *) 0 ; size_t result;
  SWIG_check_num_args("ofPixels_< float >::getBitsPerChannel",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< float >::getBitsPerChannel",1,"ofPixels_< float > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_float_t,0))){
    SWIG_fail_ptr("FloatPixels_getBitsPerChannel",1,SWIGTYPE_p_ofPixels_T_float_t); } 
  result = (size_t)((ofPixels_< float > const *)arg1)->getBitsPerChannel(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatPixels_getBytesStride(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< float > *arg1 = (ofPixels_< float > *) 0 ; size_t result;
  SWIG_check_num_args("ofPixels_< float >::getBytesStride",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< float >::getBytesStride",1,"ofPixels_< float > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_float_t,0))){
    SWIG_fail_ptr("FloatPixels_getBytesStride",1,SWIGTYPE_p_ofPixels_T_float_t); } 
  result = (size_t)((ofPixels_< float > const *)arg1)->getBytesStride(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatPixels_getNumChannels(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< float > *arg1 = (ofPixels_< float > *) 0 ; size_t result;
  SWIG_check_num_args("ofPixels_< float >::getNumChannels",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< float >::getNumChannels",1,"ofPixels_< float > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_float_t,0))){
    SWIG_fail_ptr("FloatPixels_getNumChannels",1,SWIGTYPE_p_ofPixels_T_float_t); } 
  result = (size_t)((ofPixels_< float > const *)arg1)->getNumChannels(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatPixels_getTotalBytes(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< float > *arg1 = (ofPixels_< float > *) 0 ; size_t result;
  SWIG_check_num_args("ofPixels_< float >::getTotalBytes",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< float >::getTotalBytes",1,"ofPixels_< float > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_float_t,0))){
    SWIG_fail_ptr("FloatPixels_getTotalBytes",1,SWIGTYPE_p_ofPixels_T_float_t); } 
  result = (size_t)((ofPixels_< float > const *)arg1)->getTotalBytes(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatPixels_getNumPlanes(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< float > *arg1 = (ofPixels_< float > *) 0 ; size_t result;
  SWIG_check_num_args("ofPixels_< float >::getNumPlanes",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< float >::getNumPlanes",1,"ofPixels_< float > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_float_t,0))){
    SWIG_fail_ptr("FloatPixels_getNumPlanes",1,SWIGTYPE_p_ofPixels_T_float_t); } 
  result = (size_t)((ofPixels_< float > const *)arg1)->getNumPlanes(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatPixels_getPlane(lua_State* L) { int SWIG_arg = 0; ofPixels_< float > *arg1 = (ofPixels_< float > *) 0 ;
  size_t arg2 ; ofPixels_< float > result; SWIG_check_num_args("ofPixels_< float >::getPlane",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< float >::getPlane",1,"ofPixels_< float > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofPixels_< float >::getPlane",2,"size_t");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_float_t,0))){
    SWIG_fail_ptr("FloatPixels_getPlane",1,SWIGTYPE_p_ofPixels_T_float_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (size_t)lua_tonumber(L, 2);
  result = (arg1)->getPlane(arg2); {
    ofPixels_< float > * resultptr = new ofPixels_< float >((const ofPixels_< float > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofPixels_T_float_t,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatPixels_getChannel(lua_State* L) { int SWIG_arg = 0; ofPixels_< float > *arg1 = (ofPixels_< float > *) 0 ;
  size_t arg2 ; ofPixels_< float > result; SWIG_check_num_args("ofPixels_< float >::getChannel",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< float >::getChannel",1,"ofPixels_< float > const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofPixels_< float >::getChannel",2,"size_t");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_float_t,0))){
    SWIG_fail_ptr("FloatPixels_getChannel",1,SWIGTYPE_p_ofPixels_T_float_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (size_t)lua_tonumber(L, 2);
  result = ((ofPixels_< float > const *)arg1)->getChannel(arg2); {
    ofPixels_< float > * resultptr = new ofPixels_< float >((const ofPixels_< float > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofPixels_T_float_t,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatPixels_getPixelFormat(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< float > *arg1 = (ofPixels_< float > *) 0 ; ofPixelFormat result;
  SWIG_check_num_args("ofPixels_< float >::getPixelFormat",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< float >::getPixelFormat",1,"ofPixels_< float > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_float_t,0))){
    SWIG_fail_ptr("FloatPixels_getPixelFormat",1,SWIGTYPE_p_ofPixels_T_float_t); } 
  result = (ofPixelFormat)((ofPixels_< float > const *)arg1)->getPixelFormat();
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_FloatPixels_size(lua_State* L) { int SWIG_arg = 0; ofPixels_< float > *arg1 = (ofPixels_< float > *) 0 ;
  size_t result; SWIG_check_num_args("ofPixels_< float >::size",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< float >::size",1,"ofPixels_< float > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_float_t,0))){
    SWIG_fail_ptr("FloatPixels_size",1,SWIGTYPE_p_ofPixels_T_float_t); } 
  result = (size_t)((ofPixels_< float > const *)arg1)->size(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatPixels_getImageType(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< float > *arg1 = (ofPixels_< float > *) 0 ; ofImageType result;
  SWIG_check_num_args("ofPixels_< float >::getImageType",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< float >::getImageType",1,"ofPixels_< float > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_float_t,0))){
    SWIG_fail_ptr("FloatPixels_getImageType",1,SWIGTYPE_p_ofPixels_T_float_t); } 
  result = (ofImageType)((ofPixels_< float > const *)arg1)->getImageType();
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_FloatPixels_setChannel(lua_State* L) { int SWIG_arg = 0; ofPixels_< float > *arg1 = (ofPixels_< float > *) 0 ;
  size_t arg2 ; ofPixels_< float > arg3 ; ofPixels_< float > *argp3 ; SWIG_check_num_args("ofPixels_< float >::setChannel",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< float >::setChannel",1,"ofPixels_< float > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofPixels_< float >::setChannel",2,"size_t");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofPixels_< float >::setChannel",3,"ofPixels_< float > const");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_float_t,0))){
    SWIG_fail_ptr("FloatPixels_setChannel",1,SWIGTYPE_p_ofPixels_T_float_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (size_t)lua_tonumber(L, 2);
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_ofPixels_T_float_t,0))){
    SWIG_fail_ptr("FloatPixels_setChannel",3,SWIGTYPE_p_ofPixels_T_float_t); }  arg3 = *argp3; (arg1)->setChannel(arg2,arg3);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatPixels_setImageType(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< float > *arg1 = (ofPixels_< float > *) 0 ; ofImageType arg2 ;
  SWIG_check_num_args("ofPixels_< float >::setImageType",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< float >::setImageType",1,"ofPixels_< float > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofPixels_< float >::setImageType",2,"ofImageType");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_float_t,0))){
    SWIG_fail_ptr("FloatPixels_setImageType",1,SWIGTYPE_p_ofPixels_T_float_t); }  arg2 = (ofImageType)(int)lua_tonumber(L, 2);
  (arg1)->setImageType(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatPixels_setNumChannels(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< float > *arg1 = (ofPixels_< float > *) 0 ; size_t arg2 ;
  SWIG_check_num_args("ofPixels_< float >::setNumChannels",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< float >::setNumChannels",1,"ofPixels_< float > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofPixels_< float >::setNumChannels",2,"size_t");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_float_t,0))){
    SWIG_fail_ptr("FloatPixels_setNumChannels",1,SWIGTYPE_p_ofPixels_T_float_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (size_t)lua_tonumber(L, 2);
  (arg1)->setNumChannels(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static void swig_delete_FloatPixels(void *obj) {
ofPixels_< float > *arg1 = (ofPixels_< float > *) obj;
delete arg1;
}
static int _proxy__wrap_new_FloatPixels(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_FloatPixels);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_FloatPixels_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_FloatPixels_methods[]= {
    { "allocate", _wrap_FloatPixels_allocate},
    { "allocatePixelFormat", _wrap_FloatPixels_allocatePixelFormat},
    { "allocateImageType", _wrap_FloatPixels_allocateImageType},
    { "isAllocated", _wrap_FloatPixels_isAllocated},
    { "clear", _wrap_FloatPixels_clear},
    { "set", _wrap_FloatPixels_set},
    { "setFromPixels", _wrap_FloatPixels_setFromPixels},
    { "setFromPixelsImageType", _wrap_FloatPixels_setFromPixelsImageType},
    { "setFromExternalPixels", _wrap_FloatPixels_setFromExternalPixels},
    { "setFromAlignedPixels", _wrap_FloatPixels_setFromAlignedPixels},
    { "swap", _wrap_FloatPixels_swap},
    { "crop", _wrap_FloatPixels_crop},
    { "cropTo", _wrap_FloatPixels_cropTo},
    { "rotate90", _wrap_FloatPixels_rotate90},
    { "rotate90To", _wrap_FloatPixels_rotate90To},
    { "mirrorTo", _wrap_FloatPixels_mirrorTo},
    { "mirror", _wrap_FloatPixels_mirror},
    { "resize", _wrap_FloatPixels_resize},
    { "resizeTo", _wrap_FloatPixels_resizeTo},
    { "pasteInto", _wrap_FloatPixels_pasteInto},
    { "blendInto", _wrap_FloatPixels_blendInto},
    { "swapRgb", _wrap_FloatPixels_swapRgb},
    { "getData", _wrap_FloatPixels_getData},
    { "getPixelIndex", _wrap_FloatPixels_getPixelIndex},
    { "getColor", _wrap_FloatPixels_getColor},
    { "setColor", _wrap_FloatPixels_setColor},
    { "getWidth", _wrap_FloatPixels_getWidth},
    { "getHeight", _wrap_FloatPixels_getHeight},
    { "getBytesPerPixel", _wrap_FloatPixels_getBytesPerPixel},
    { "getBitsPerPixel", _wrap_FloatPixels_getBitsPerPixel},
    { "getBytesPerChannel", _wrap_FloatPixels_getBytesPerChannel},
    { "getBitsPerChannel", _wrap_FloatPixels_getBitsPerChannel},
    { "getBytesStride", _wrap_FloatPixels_getBytesStride},
    { "getNumChannels", _wrap_FloatPixels_getNumChannels},
    { "getTotalBytes", _wrap_FloatPixels_getTotalBytes},
    { "getNumPlanes", _wrap_FloatPixels_getNumPlanes},
    { "getPlane", _wrap_FloatPixels_getPlane},
    { "getChannel", _wrap_FloatPixels_getChannel},
    { "getPixelFormat", _wrap_FloatPixels_getPixelFormat},
    { "size", _wrap_FloatPixels_size},
    { "getImageType", _wrap_FloatPixels_getImageType},
    { "setChannel", _wrap_FloatPixels_setChannel},
    { "setImageType", _wrap_FloatPixels_setImageType},
    { "setNumChannels", _wrap_FloatPixels_setNumChannels},
    {0,0}
};
static swig_lua_method swig_FloatPixels_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_FloatPixels_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_FloatPixels_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_FloatPixels_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_FloatPixels_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_FloatPixels_Sf_SwigStatic = {
    "FloatPixels",
    swig_FloatPixels_Sf_SwigStatic_methods,
    swig_FloatPixels_Sf_SwigStatic_attributes,
    swig_FloatPixels_Sf_SwigStatic_constants,
    swig_FloatPixels_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_FloatPixels_bases[] = {0};
static const char *swig_FloatPixels_base_names[] = {0};
static swig_lua_class _wrap_class_FloatPixels = { "FloatPixels", "FloatPixels", &SWIGTYPE_p_ofPixels_T_float_t,_proxy__wrap_new_FloatPixels, swig_delete_FloatPixels, swig_FloatPixels_methods, swig_FloatPixels_attributes, &swig_FloatPixels_Sf_SwigStatic, swig_FloatPixels_meta, swig_FloatPixels_bases, swig_FloatPixels_base_names };

static int _wrap_new_ShortPixels__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofPixels_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofPixels_< unsigned short >::ofPixels_",0,0)
  result = (ofPixels_< unsigned short > *)new ofPixels_< unsigned short >();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofPixels_T_unsigned_short_t,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_ShortPixels__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofPixels_< unsigned short > *arg1 = 0 ;
  ofPixels_< unsigned short > *result = 0 ; SWIG_check_num_args("ofPixels_< unsigned short >::ofPixels_",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofPixels_< unsigned short >::ofPixels_",1,"ofPixels_< unsigned short > &&");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_short_t,0))){
    SWIG_fail_ptr("new_ShortPixels",1,SWIGTYPE_p_ofPixels_T_unsigned_short_t); } 
  result = (ofPixels_< unsigned short > *)new ofPixels_< unsigned short >((ofPixels_< unsigned short > &&)*arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofPixels_T_unsigned_short_t,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_ShortPixels(lua_State* L) { int argc; int argv[2]={ 1,2} ; argc = lua_gettop(L); if (argc == 0) {
    return _wrap_new_ShortPixels__SWIG_0(L);}  if (argc == 1) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofPixels_T_unsigned_short_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_new_ShortPixels__SWIG_1(L);}  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_ShortPixels'\n" "  Possible C/C++ prototypes are:\n"
  "    ofPixels_< unsigned short >::ofPixels_()\n"
  "    ofPixels_< unsigned short >::ofPixels_(ofPixels_< unsigned short > &&)\n"); lua_error(L);return 0; }
static int _wrap_ShortPixels_allocate(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned short > *arg1 = (ofPixels_< unsigned short > *) 0 ; size_t arg2 ; size_t arg3 ; size_t arg4 ;
  SWIG_check_num_args("ofPixels_< unsigned short >::allocate",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned short >::allocate",1,"ofPixels_< unsigned short > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofPixels_< unsigned short >::allocate",2,"size_t");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofPixels_< unsigned short >::allocate",3,"size_t");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofPixels_< unsigned short >::allocate",4,"size_t");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortPixels_allocate",1,SWIGTYPE_p_ofPixels_T_unsigned_short_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (size_t)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (size_t)lua_tonumber(L, 3);
  SWIG_contract_assert((lua_tonumber(L,4)>=0),"number must not be negative") arg4 = (size_t)lua_tonumber(L, 4);
  (arg1)->allocate(arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortPixels_allocatePixelFormat(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned short > *arg1 = (ofPixels_< unsigned short > *) 0 ; size_t arg2 ; size_t arg3 ; ofPixelFormat arg4 ;
  SWIG_check_num_args("ofPixels_< unsigned short >::allocate",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned short >::allocate",1,"ofPixels_< unsigned short > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofPixels_< unsigned short >::allocate",2,"size_t");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofPixels_< unsigned short >::allocate",3,"size_t");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofPixels_< unsigned short >::allocate",4,"ofPixelFormat");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortPixels_allocatePixelFormat",1,SWIGTYPE_p_ofPixels_T_unsigned_short_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (size_t)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (size_t)lua_tonumber(L, 3);
  arg4 = (ofPixelFormat)(int)lua_tonumber(L, 4); (arg1)->allocate(arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortPixels_allocateImageType(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned short > *arg1 = (ofPixels_< unsigned short > *) 0 ; size_t arg2 ; size_t arg3 ; ofImageType arg4 ;
  SWIG_check_num_args("ofPixels_< unsigned short >::allocate",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned short >::allocate",1,"ofPixels_< unsigned short > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofPixels_< unsigned short >::allocate",2,"size_t");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofPixels_< unsigned short >::allocate",3,"size_t");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofPixels_< unsigned short >::allocate",4,"ofImageType");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortPixels_allocateImageType",1,SWIGTYPE_p_ofPixels_T_unsigned_short_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (size_t)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (size_t)lua_tonumber(L, 3);
  arg4 = (ofImageType)(int)lua_tonumber(L, 4); (arg1)->allocate(arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortPixels_isAllocated(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned short > *arg1 = (ofPixels_< unsigned short > *) 0 ; bool result;
  SWIG_check_num_args("ofPixels_< unsigned short >::isAllocated",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned short >::isAllocated",1,"ofPixels_< unsigned short > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortPixels_isAllocated",1,SWIGTYPE_p_ofPixels_T_unsigned_short_t); } 
  result = (bool)((ofPixels_< unsigned short > const *)arg1)->isAllocated(); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortPixels_clear(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned short > *arg1 = (ofPixels_< unsigned short > *) 0 ;
  SWIG_check_num_args("ofPixels_< unsigned short >::clear",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned short >::clear",1,"ofPixels_< unsigned short > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortPixels_clear",1,SWIGTYPE_p_ofPixels_T_unsigned_short_t); }  (arg1)->clear(); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortPixels_set__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned short > *arg1 = (ofPixels_< unsigned short > *) 0 ; unsigned short arg2 ;
  SWIG_check_num_args("ofPixels_< unsigned short >::set",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned short >::set",1,"ofPixels_< unsigned short > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofPixels_< unsigned short >::set",2,"unsigned short");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortPixels_set",1,SWIGTYPE_p_ofPixels_T_unsigned_short_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (unsigned short)lua_tonumber(L, 2);
  (arg1)->set(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortPixels_set__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned short > *arg1 = (ofPixels_< unsigned short > *) 0 ; size_t arg2 ; unsigned short arg3 ;
  SWIG_check_num_args("ofPixels_< unsigned short >::set",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned short >::set",1,"ofPixels_< unsigned short > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofPixels_< unsigned short >::set",2,"size_t");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofPixels_< unsigned short >::set",3,"unsigned short");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortPixels_set",1,SWIGTYPE_p_ofPixels_T_unsigned_short_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (size_t)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (unsigned short)lua_tonumber(L, 3);
  (arg1)->set(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortPixels_set(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofPixels_T_unsigned_short_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_ShortPixels_set__SWIG_0(L);}  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofPixels_T_unsigned_short_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { return _wrap_ShortPixels_set__SWIG_1(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'ShortPixels_set'\n" "  Possible C/C++ prototypes are:\n"
  "    ofPixels_< unsigned short >::set(unsigned short)\n" "    ofPixels_< unsigned short >::set(size_t,unsigned short)\n");
  lua_error(L);return 0; }
static int _wrap_ShortPixels_setFromPixels(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned short > *arg1 = (ofPixels_< unsigned short > *) 0 ; unsigned short *arg2 = (unsigned short *) 0 ;
  size_t arg3 ; size_t arg4 ; ofPixelFormat arg5 ; SWIG_check_num_args("ofPixels_< unsigned short >::setFromPixels",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned short >::setFromPixels",1,"ofPixels_< unsigned short > *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofPixels_< unsigned short >::setFromPixels",2,"unsigned short const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofPixels_< unsigned short >::setFromPixels",3,"size_t");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofPixels_< unsigned short >::setFromPixels",4,"size_t");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofPixels_< unsigned short >::setFromPixels",5,"ofPixelFormat");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortPixels_setFromPixels",1,SWIGTYPE_p_ofPixels_T_unsigned_short_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_unsigned_short,0))){
    SWIG_fail_ptr("ShortPixels_setFromPixels",2,SWIGTYPE_p_unsigned_short); } 
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (size_t)lua_tonumber(L, 3);
  SWIG_contract_assert((lua_tonumber(L,4)>=0),"number must not be negative") arg4 = (size_t)lua_tonumber(L, 4);
  arg5 = (ofPixelFormat)(int)lua_tonumber(L, 5); (arg1)->setFromPixels((unsigned short const *)arg2,arg3,arg4,arg5);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortPixels_setFromPixelsImageType(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned short > *arg1 = (ofPixels_< unsigned short > *) 0 ; unsigned short *arg2 = (unsigned short *) 0 ;
  size_t arg3 ; size_t arg4 ; ofImageType arg5 ; SWIG_check_num_args("ofPixels_< unsigned short >::setFromPixels",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned short >::setFromPixels",1,"ofPixels_< unsigned short > *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofPixels_< unsigned short >::setFromPixels",2,"unsigned short const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofPixels_< unsigned short >::setFromPixels",3,"size_t");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofPixels_< unsigned short >::setFromPixels",4,"size_t");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofPixels_< unsigned short >::setFromPixels",5,"ofImageType");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortPixels_setFromPixelsImageType",1,SWIGTYPE_p_ofPixels_T_unsigned_short_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_unsigned_short,0))){
    SWIG_fail_ptr("ShortPixels_setFromPixelsImageType",2,SWIGTYPE_p_unsigned_short); } 
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (size_t)lua_tonumber(L, 3);
  SWIG_contract_assert((lua_tonumber(L,4)>=0),"number must not be negative") arg4 = (size_t)lua_tonumber(L, 4);
  arg5 = (ofImageType)(int)lua_tonumber(L, 5); (arg1)->setFromPixels((unsigned short const *)arg2,arg3,arg4,arg5);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortPixels_setFromExternalPixels(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned short > *arg1 = (ofPixels_< unsigned short > *) 0 ; unsigned short *arg2 = (unsigned short *) 0 ;
  size_t arg3 ; size_t arg4 ; ofPixelFormat arg5 ; SWIG_check_num_args("ofPixels_< unsigned short >::setFromExternalPixels",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned short >::setFromExternalPixels",1,"ofPixels_< unsigned short > *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofPixels_< unsigned short >::setFromExternalPixels",2,"unsigned short *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofPixels_< unsigned short >::setFromExternalPixels",3,"size_t");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofPixels_< unsigned short >::setFromExternalPixels",4,"size_t");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofPixels_< unsigned short >::setFromExternalPixels",5,"ofPixelFormat");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortPixels_setFromExternalPixels",1,SWIGTYPE_p_ofPixels_T_unsigned_short_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_unsigned_short,0))){
    SWIG_fail_ptr("ShortPixels_setFromExternalPixels",2,SWIGTYPE_p_unsigned_short); } 
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (size_t)lua_tonumber(L, 3);
  SWIG_contract_assert((lua_tonumber(L,4)>=0),"number must not be negative") arg4 = (size_t)lua_tonumber(L, 4);
  arg5 = (ofPixelFormat)(int)lua_tonumber(L, 5); (arg1)->setFromExternalPixels(arg2,arg3,arg4,arg5); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortPixels_setFromAlignedPixels(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned short > *arg1 = (ofPixels_< unsigned short > *) 0 ; unsigned short *arg2 = (unsigned short *) 0 ;
  size_t arg3 ; size_t arg4 ; ofPixelFormat arg5 ; size_t arg6 ;
  SWIG_check_num_args("ofPixels_< unsigned short >::setFromAlignedPixels",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned short >::setFromAlignedPixels",1,"ofPixels_< unsigned short > *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofPixels_< unsigned short >::setFromAlignedPixels",2,"unsigned short const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofPixels_< unsigned short >::setFromAlignedPixels",3,"size_t");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofPixels_< unsigned short >::setFromAlignedPixels",4,"size_t");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofPixels_< unsigned short >::setFromAlignedPixels",5,"ofPixelFormat");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofPixels_< unsigned short >::setFromAlignedPixels",6,"size_t");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortPixels_setFromAlignedPixels",1,SWIGTYPE_p_ofPixels_T_unsigned_short_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_unsigned_short,0))){
    SWIG_fail_ptr("ShortPixels_setFromAlignedPixels",2,SWIGTYPE_p_unsigned_short); } 
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (size_t)lua_tonumber(L, 3);
  SWIG_contract_assert((lua_tonumber(L,4)>=0),"number must not be negative") arg4 = (size_t)lua_tonumber(L, 4);
  arg5 = (ofPixelFormat)(int)lua_tonumber(L, 5); SWIG_contract_assert((lua_tonumber(L,6)>=0),"number must not be negative")
  arg6 = (size_t)lua_tonumber(L, 6); (arg1)->setFromAlignedPixels((unsigned short const *)arg2,arg3,arg4,arg5,arg6);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortPixels_swap(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned short > *arg1 = (ofPixels_< unsigned short > *) 0 ; ofPixels_< unsigned short > *arg2 = 0 ;
  SWIG_check_num_args("ofPixels_< unsigned short >::swap",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned short >::swap",1,"ofPixels_< unsigned short > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofPixels_< unsigned short >::swap",2,"ofPixels_< unsigned short > &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortPixels_swap",1,SWIGTYPE_p_ofPixels_T_unsigned_short_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofPixels_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortPixels_swap",2,SWIGTYPE_p_ofPixels_T_unsigned_short_t); }  (arg1)->swap(*arg2); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortPixels_crop(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned short > *arg1 = (ofPixels_< unsigned short > *) 0 ; size_t arg2 ; size_t arg3 ; size_t arg4 ;
  size_t arg5 ; SWIG_check_num_args("ofPixels_< unsigned short >::crop",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned short >::crop",1,"ofPixels_< unsigned short > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofPixels_< unsigned short >::crop",2,"size_t");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofPixels_< unsigned short >::crop",3,"size_t");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofPixels_< unsigned short >::crop",4,"size_t");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofPixels_< unsigned short >::crop",5,"size_t");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortPixels_crop",1,SWIGTYPE_p_ofPixels_T_unsigned_short_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (size_t)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (size_t)lua_tonumber(L, 3);
  SWIG_contract_assert((lua_tonumber(L,4)>=0),"number must not be negative") arg4 = (size_t)lua_tonumber(L, 4);
  SWIG_contract_assert((lua_tonumber(L,5)>=0),"number must not be negative") arg5 = (size_t)lua_tonumber(L, 5);
  (arg1)->crop(arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortPixels_cropTo(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned short > *arg1 = (ofPixels_< unsigned short > *) 0 ; ofPixels_< unsigned short > *arg2 = 0 ; size_t arg3 ;
  size_t arg4 ; size_t arg5 ; size_t arg6 ; SWIG_check_num_args("ofPixels_< unsigned short >::cropTo",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned short >::cropTo",1,"ofPixels_< unsigned short > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofPixels_< unsigned short >::cropTo",2,"ofPixels_< unsigned short > &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofPixels_< unsigned short >::cropTo",3,"size_t");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofPixels_< unsigned short >::cropTo",4,"size_t");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofPixels_< unsigned short >::cropTo",5,"size_t");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofPixels_< unsigned short >::cropTo",6,"size_t");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortPixels_cropTo",1,SWIGTYPE_p_ofPixels_T_unsigned_short_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofPixels_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortPixels_cropTo",2,SWIGTYPE_p_ofPixels_T_unsigned_short_t); } 
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (size_t)lua_tonumber(L, 3);
  SWIG_contract_assert((lua_tonumber(L,4)>=0),"number must not be negative") arg4 = (size_t)lua_tonumber(L, 4);
  SWIG_contract_assert((lua_tonumber(L,5)>=0),"number must not be negative") arg5 = (size_t)lua_tonumber(L, 5);
  SWIG_contract_assert((lua_tonumber(L,6)>=0),"number must not be negative") arg6 = (size_t)lua_tonumber(L, 6);
  ((ofPixels_< unsigned short > const *)arg1)->cropTo(*arg2,arg3,arg4,arg5,arg6); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortPixels_rotate90(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned short > *arg1 = (ofPixels_< unsigned short > *) 0 ; int arg2 ;
  SWIG_check_num_args("ofPixels_< unsigned short >::rotate90",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned short >::rotate90",1,"ofPixels_< unsigned short > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofPixels_< unsigned short >::rotate90",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortPixels_rotate90",1,SWIGTYPE_p_ofPixels_T_unsigned_short_t); }  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->rotate90(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortPixels_rotate90To(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned short > *arg1 = (ofPixels_< unsigned short > *) 0 ; ofPixels_< unsigned short > *arg2 = 0 ; int arg3 ;
  SWIG_check_num_args("ofPixels_< unsigned short >::rotate90To",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned short >::rotate90To",1,"ofPixels_< unsigned short > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofPixels_< unsigned short >::rotate90To",2,"ofPixels_< unsigned short > &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofPixels_< unsigned short >::rotate90To",3,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortPixels_rotate90To",1,SWIGTYPE_p_ofPixels_T_unsigned_short_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofPixels_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortPixels_rotate90To",2,SWIGTYPE_p_ofPixels_T_unsigned_short_t); }  arg3 = (int)lua_tonumber(L, 3);
  ((ofPixels_< unsigned short > const *)arg1)->rotate90To(*arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_ShortPixels_mirrorTo(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned short > *arg1 = (ofPixels_< unsigned short > *) 0 ; ofPixels_< unsigned short > *arg2 = 0 ; bool arg3 ;
  bool arg4 ; SWIG_check_num_args("ofPixels_< unsigned short >::mirrorTo",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned short >::mirrorTo",1,"ofPixels_< unsigned short > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofPixels_< unsigned short >::mirrorTo",2,"ofPixels_< unsigned short > &");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("ofPixels_< unsigned short >::mirrorTo",3,"bool");
  if(!lua_isboolean(L,4)) SWIG_fail_arg("ofPixels_< unsigned short >::mirrorTo",4,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortPixels_mirrorTo",1,SWIGTYPE_p_ofPixels_T_unsigned_short_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofPixels_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortPixels_mirrorTo",2,SWIGTYPE_p_ofPixels_T_unsigned_short_t); }  arg3 = (lua_toboolean(L, 3)!=0);
  arg4 = (lua_toboolean(L, 4)!=0); ((ofPixels_< unsigned short > const *)arg1)->mirrorTo(*arg2,arg3,arg4); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortPixels_mirror(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned short > *arg1 = (ofPixels_< unsigned short > *) 0 ; bool arg2 ; bool arg3 ;
  SWIG_check_num_args("ofPixels_< unsigned short >::mirror",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned short >::mirror",1,"ofPixels_< unsigned short > *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofPixels_< unsigned short >::mirror",2,"bool");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("ofPixels_< unsigned short >::mirror",3,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortPixels_mirror",1,SWIGTYPE_p_ofPixels_T_unsigned_short_t); }  arg2 = (lua_toboolean(L, 2)!=0);
  arg3 = (lua_toboolean(L, 3)!=0); (arg1)->mirror(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_ShortPixels_resize__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned short > *arg1 = (ofPixels_< unsigned short > *) 0 ; size_t arg2 ; size_t arg3 ;
  ofInterpolationMethod arg4 ; bool result; SWIG_check_num_args("ofPixels_< unsigned short >::resize",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned short >::resize",1,"ofPixels_< unsigned short > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofPixels_< unsigned short >::resize",2,"size_t");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofPixels_< unsigned short >::resize",3,"size_t");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofPixels_< unsigned short >::resize",4,"ofInterpolationMethod");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortPixels_resize",1,SWIGTYPE_p_ofPixels_T_unsigned_short_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (size_t)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (size_t)lua_tonumber(L, 3);
  arg4 = (ofInterpolationMethod)(int)lua_tonumber(L, 4); result = (bool)(arg1)->resize(arg2,arg3,arg4);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortPixels_resize__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned short > *arg1 = (ofPixels_< unsigned short > *) 0 ; size_t arg2 ; size_t arg3 ; bool result;
  SWIG_check_num_args("ofPixels_< unsigned short >::resize",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned short >::resize",1,"ofPixels_< unsigned short > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofPixels_< unsigned short >::resize",2,"size_t");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofPixels_< unsigned short >::resize",3,"size_t");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortPixels_resize",1,SWIGTYPE_p_ofPixels_T_unsigned_short_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (size_t)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (size_t)lua_tonumber(L, 3);
  result = (bool)(arg1)->resize(arg2,arg3); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortPixels_resize(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L); if (argc == 3) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofPixels_T_unsigned_short_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { return _wrap_ShortPixels_resize__SWIG_1(L);}  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofPixels_T_unsigned_short_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_ShortPixels_resize__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'ShortPixels_resize'\n" "  Possible C/C++ prototypes are:\n"
  "    ofPixels_< unsigned short >::resize(size_t,size_t,ofInterpolationMethod)\n"
  "    ofPixels_< unsigned short >::resize(size_t,size_t)\n"); lua_error(L);return 0; }
static int _wrap_ShortPixels_resizeTo__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned short > *arg1 = (ofPixels_< unsigned short > *) 0 ; ofPixels_< unsigned short > *arg2 = 0 ;
  ofInterpolationMethod arg3 ; bool result; SWIG_check_num_args("ofPixels_< unsigned short >::resizeTo",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned short >::resizeTo",1,"ofPixels_< unsigned short > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofPixels_< unsigned short >::resizeTo",2,"ofPixels_< unsigned short > &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofPixels_< unsigned short >::resizeTo",3,"ofInterpolationMethod");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortPixels_resizeTo",1,SWIGTYPE_p_ofPixels_T_unsigned_short_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofPixels_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortPixels_resizeTo",2,SWIGTYPE_p_ofPixels_T_unsigned_short_t); } 
  arg3 = (ofInterpolationMethod)(int)lua_tonumber(L, 3);
  result = (bool)((ofPixels_< unsigned short > const *)arg1)->resizeTo(*arg2,arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortPixels_resizeTo__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned short > *arg1 = (ofPixels_< unsigned short > *) 0 ; ofPixels_< unsigned short > *arg2 = 0 ; bool result;
  SWIG_check_num_args("ofPixels_< unsigned short >::resizeTo",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned short >::resizeTo",1,"ofPixels_< unsigned short > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofPixels_< unsigned short >::resizeTo",2,"ofPixels_< unsigned short > &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortPixels_resizeTo",1,SWIGTYPE_p_ofPixels_T_unsigned_short_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofPixels_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortPixels_resizeTo",2,SWIGTYPE_p_ofPixels_T_unsigned_short_t); } 
  result = (bool)((ofPixels_< unsigned short > const *)arg1)->resizeTo(*arg2); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortPixels_resizeTo(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofPixels_T_unsigned_short_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofPixels_T_unsigned_short_t, 0)) {
          _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_ShortPixels_resizeTo__SWIG_1(L);}  }  }  if (argc == 3) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofPixels_T_unsigned_short_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofPixels_T_unsigned_short_t, 0)) {
          _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_ShortPixels_resizeTo__SWIG_0(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'ShortPixels_resizeTo'\n"
  "  Possible C/C++ prototypes are:\n"
  "    ofPixels_< unsigned short >::resizeTo(ofPixels_< unsigned short > &,ofInterpolationMethod) const\n"
  "    ofPixels_< unsigned short >::resizeTo(ofPixels_< unsigned short > &) const\n"); lua_error(L);return 0; }
static int _wrap_ShortPixels_pasteInto(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned short > *arg1 = (ofPixels_< unsigned short > *) 0 ; ofPixels_< unsigned short > *arg2 = 0 ; size_t arg3 ;
  size_t arg4 ; bool result; SWIG_check_num_args("ofPixels_< unsigned short >::pasteInto",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned short >::pasteInto",1,"ofPixels_< unsigned short > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofPixels_< unsigned short >::pasteInto",2,"ofPixels_< unsigned short > &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofPixels_< unsigned short >::pasteInto",3,"size_t");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofPixels_< unsigned short >::pasteInto",4,"size_t");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortPixels_pasteInto",1,SWIGTYPE_p_ofPixels_T_unsigned_short_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofPixels_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortPixels_pasteInto",2,SWIGTYPE_p_ofPixels_T_unsigned_short_t); } 
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (size_t)lua_tonumber(L, 3);
  SWIG_contract_assert((lua_tonumber(L,4)>=0),"number must not be negative") arg4 = (size_t)lua_tonumber(L, 4);
  result = (bool)((ofPixels_< unsigned short > const *)arg1)->pasteInto(*arg2,arg3,arg4);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortPixels_blendInto(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned short > *arg1 = (ofPixels_< unsigned short > *) 0 ; ofPixels_< unsigned short > *arg2 = 0 ; size_t arg3 ;
  size_t arg4 ; bool result; SWIG_check_num_args("ofPixels_< unsigned short >::blendInto",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned short >::blendInto",1,"ofPixels_< unsigned short > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofPixels_< unsigned short >::blendInto",2,"ofPixels_< unsigned short > &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofPixels_< unsigned short >::blendInto",3,"size_t");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofPixels_< unsigned short >::blendInto",4,"size_t");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortPixels_blendInto",1,SWIGTYPE_p_ofPixels_T_unsigned_short_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofPixels_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortPixels_blendInto",2,SWIGTYPE_p_ofPixels_T_unsigned_short_t); } 
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (size_t)lua_tonumber(L, 3);
  SWIG_contract_assert((lua_tonumber(L,4)>=0),"number must not be negative") arg4 = (size_t)lua_tonumber(L, 4);
  result = (bool)((ofPixels_< unsigned short > const *)arg1)->blendInto(*arg2,arg3,arg4);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortPixels_swapRgb(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned short > *arg1 = (ofPixels_< unsigned short > *) 0 ;
  SWIG_check_num_args("ofPixels_< unsigned short >::swapRgb",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned short >::swapRgb",1,"ofPixels_< unsigned short > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortPixels_swapRgb",1,SWIGTYPE_p_ofPixels_T_unsigned_short_t); }  (arg1)->swapRgb(); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortPixels_getData__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned short > *arg1 = (ofPixels_< unsigned short > *) 0 ; unsigned short *result = 0 ;
  SWIG_check_num_args("ofPixels_< unsigned short >::getData",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned short >::getData",1,"ofPixels_< unsigned short > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortPixels_getData",1,SWIGTYPE_p_ofPixels_T_unsigned_short_t); } 
  result = (unsigned short *)(arg1)->getData(); SWIG_NewPointerObj(L,result,SWIGTYPE_p_unsigned_short,0); SWIG_arg++; 
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortPixels_getData__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned short > *arg1 = (ofPixels_< unsigned short > *) 0 ; unsigned short *result = 0 ;
  SWIG_check_num_args("ofPixels_< unsigned short >::getData",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned short >::getData",1,"ofPixels_< unsigned short > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortPixels_getData",1,SWIGTYPE_p_ofPixels_T_unsigned_short_t); } 
  result = (unsigned short *)((ofPixels_< unsigned short > const *)arg1)->getData();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_unsigned_short,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_ShortPixels_getData(lua_State* L) { int argc; int argv[2]={ 1,2} ; argc = lua_gettop(L); if (argc == 1) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofPixels_T_unsigned_short_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_ShortPixels_getData__SWIG_0(L);}  }  if (argc == 1) { int _v; {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofPixels_T_unsigned_short_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_ShortPixels_getData__SWIG_1(L);}  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'ShortPixels_getData'\n"
  "  Possible C/C++ prototypes are:\n" "    ofPixels_< unsigned short >::getData()\n"
  "    ofPixels_< unsigned short >::getData() const\n"); lua_error(L);return 0; }
static int _wrap_ShortPixels_getPixelIndex(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned short > *arg1 = (ofPixels_< unsigned short > *) 0 ; size_t arg2 ; size_t arg3 ; size_t result;
  SWIG_check_num_args("ofPixels_< unsigned short >::getPixelIndex",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned short >::getPixelIndex",1,"ofPixels_< unsigned short > const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofPixels_< unsigned short >::getPixelIndex",2,"size_t");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofPixels_< unsigned short >::getPixelIndex",3,"size_t");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortPixels_getPixelIndex",1,SWIGTYPE_p_ofPixels_T_unsigned_short_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (size_t)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (size_t)lua_tonumber(L, 3);
  result = (size_t)((ofPixels_< unsigned short > const *)arg1)->getPixelIndex(arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortPixels_getColor__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned short > *arg1 = (ofPixels_< unsigned short > *) 0 ; size_t arg2 ; size_t arg3 ;
  ofColor_< unsigned short > result; SWIG_check_num_args("ofPixels_< unsigned short >::getColor",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned short >::getColor",1,"ofPixels_< unsigned short > const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofPixels_< unsigned short >::getColor",2,"size_t");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofPixels_< unsigned short >::getColor",3,"size_t");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortPixels_getColor",1,SWIGTYPE_p_ofPixels_T_unsigned_short_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (size_t)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (size_t)lua_tonumber(L, 3);
  result = ((ofPixels_< unsigned short > const *)arg1)->getColor(arg2,arg3); {
    ofColor_< unsigned short > * resultptr = new ofColor_< unsigned short >((const ofColor_< unsigned short > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofColor_T_unsigned_short_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortPixels_getColor__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned short > *arg1 = (ofPixels_< unsigned short > *) 0 ; size_t arg2 ; ofColor_< unsigned short > result;
  SWIG_check_num_args("ofPixels_< unsigned short >::getColor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned short >::getColor",1,"ofPixels_< unsigned short > const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofPixels_< unsigned short >::getColor",2,"size_t");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortPixels_getColor",1,SWIGTYPE_p_ofPixels_T_unsigned_short_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (size_t)lua_tonumber(L, 2);
  result = ((ofPixels_< unsigned short > const *)arg1)->getColor(arg2); {
    ofColor_< unsigned short > * resultptr = new ofColor_< unsigned short >((const ofColor_< unsigned short > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofColor_T_unsigned_short_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortPixels_getColor(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofPixels_T_unsigned_short_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_ShortPixels_getColor__SWIG_1(L);}  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofPixels_T_unsigned_short_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { return _wrap_ShortPixels_getColor__SWIG_0(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'ShortPixels_getColor'\n"
  "  Possible C/C++ prototypes are:\n" "    ofPixels_< unsigned short >::getColor(size_t,size_t) const\n"
  "    ofPixels_< unsigned short >::getColor(size_t) const\n"); lua_error(L);return 0; }
static int _wrap_ShortPixels_setColor__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned short > *arg1 = (ofPixels_< unsigned short > *) 0 ; size_t arg2 ; size_t arg3 ;
  ofColor_< unsigned short > *arg4 = 0 ; SWIG_check_num_args("ofPixels_< unsigned short >::setColor",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned short >::setColor",1,"ofPixels_< unsigned short > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofPixels_< unsigned short >::setColor",2,"size_t");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofPixels_< unsigned short >::setColor",3,"size_t");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("ofPixels_< unsigned short >::setColor",4,"ofColor_< unsigned short > const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortPixels_setColor",1,SWIGTYPE_p_ofPixels_T_unsigned_short_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (size_t)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (size_t)lua_tonumber(L, 3);
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_ofColor_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortPixels_setColor",4,SWIGTYPE_p_ofColor_T_unsigned_short_t); } 
  (arg1)->setColor(arg2,arg3,(ofColor_< unsigned short > const &)*arg4); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_ShortPixels_setColor__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned short > *arg1 = (ofPixels_< unsigned short > *) 0 ; size_t arg2 ; ofColor_< unsigned short > *arg3 = 0 ;
  SWIG_check_num_args("ofPixels_< unsigned short >::setColor",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned short >::setColor",1,"ofPixels_< unsigned short > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofPixels_< unsigned short >::setColor",2,"size_t");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofPixels_< unsigned short >::setColor",3,"ofColor_< unsigned short > const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortPixels_setColor",1,SWIGTYPE_p_ofPixels_T_unsigned_short_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (size_t)lua_tonumber(L, 2);
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_ofColor_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortPixels_setColor",3,SWIGTYPE_p_ofColor_T_unsigned_short_t); } 
  (arg1)->setColor(arg2,(ofColor_< unsigned short > const &)*arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_ShortPixels_setColor__SWIG_2(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned short > *arg1 = (ofPixels_< unsigned short > *) 0 ; ofColor_< unsigned short > *arg2 = 0 ;
  SWIG_check_num_args("ofPixels_< unsigned short >::setColor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned short >::setColor",1,"ofPixels_< unsigned short > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofPixels_< unsigned short >::setColor",2,"ofColor_< unsigned short > const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortPixels_setColor",1,SWIGTYPE_p_ofPixels_T_unsigned_short_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofColor_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortPixels_setColor",2,SWIGTYPE_p_ofColor_T_unsigned_short_t); } 
  (arg1)->setColor((ofColor_< unsigned short > const &)*arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_ShortPixels_setColor(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L);
  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofPixels_T_unsigned_short_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofColor_T_unsigned_short_t, 0)) {
          _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_ShortPixels_setColor__SWIG_2(L);}  }  }  if (argc == 3) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofPixels_T_unsigned_short_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_ofColor_T_unsigned_short_t, 0)) {
            _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_ShortPixels_setColor__SWIG_1(L);}  }  }  }  if (argc == 4) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofPixels_T_unsigned_short_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { { void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_ofColor_T_unsigned_short_t, 0)) {
              _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_ShortPixels_setColor__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'ShortPixels_setColor'\n"
  "  Possible C/C++ prototypes are:\n"
  "    ofPixels_< unsigned short >::setColor(size_t,size_t,ofColor_< unsigned short > const &)\n"
  "    ofPixels_< unsigned short >::setColor(size_t,ofColor_< unsigned short > const &)\n"
  "    ofPixels_< unsigned short >::setColor(ofColor_< unsigned short > const &)\n"); lua_error(L);return 0; }
static int _wrap_ShortPixels_getWidth(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned short > *arg1 = (ofPixels_< unsigned short > *) 0 ; size_t result;
  SWIG_check_num_args("ofPixels_< unsigned short >::getWidth",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned short >::getWidth",1,"ofPixels_< unsigned short > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortPixels_getWidth",1,SWIGTYPE_p_ofPixels_T_unsigned_short_t); } 
  result = (size_t)((ofPixels_< unsigned short > const *)arg1)->getWidth(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortPixels_getHeight(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned short > *arg1 = (ofPixels_< unsigned short > *) 0 ; size_t result;
  SWIG_check_num_args("ofPixels_< unsigned short >::getHeight",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned short >::getHeight",1,"ofPixels_< unsigned short > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortPixels_getHeight",1,SWIGTYPE_p_ofPixels_T_unsigned_short_t); } 
  result = (size_t)((ofPixels_< unsigned short > const *)arg1)->getHeight(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortPixels_getBytesPerPixel(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned short > *arg1 = (ofPixels_< unsigned short > *) 0 ; size_t result;
  SWIG_check_num_args("ofPixels_< unsigned short >::getBytesPerPixel",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned short >::getBytesPerPixel",1,"ofPixels_< unsigned short > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortPixels_getBytesPerPixel",1,SWIGTYPE_p_ofPixels_T_unsigned_short_t); } 
  result = (size_t)((ofPixels_< unsigned short > const *)arg1)->getBytesPerPixel();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortPixels_getBitsPerPixel(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned short > *arg1 = (ofPixels_< unsigned short > *) 0 ; size_t result;
  SWIG_check_num_args("ofPixels_< unsigned short >::getBitsPerPixel",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned short >::getBitsPerPixel",1,"ofPixels_< unsigned short > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortPixels_getBitsPerPixel",1,SWIGTYPE_p_ofPixels_T_unsigned_short_t); } 
  result = (size_t)((ofPixels_< unsigned short > const *)arg1)->getBitsPerPixel();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortPixels_getBytesPerChannel(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned short > *arg1 = (ofPixels_< unsigned short > *) 0 ; size_t result;
  SWIG_check_num_args("ofPixels_< unsigned short >::getBytesPerChannel",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned short >::getBytesPerChannel",1,"ofPixels_< unsigned short > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortPixels_getBytesPerChannel",1,SWIGTYPE_p_ofPixels_T_unsigned_short_t); } 
  result = (size_t)((ofPixels_< unsigned short > const *)arg1)->getBytesPerChannel();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortPixels_getBitsPerChannel(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned short > *arg1 = (ofPixels_< unsigned short > *) 0 ; size_t result;
  SWIG_check_num_args("ofPixels_< unsigned short >::getBitsPerChannel",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned short >::getBitsPerChannel",1,"ofPixels_< unsigned short > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortPixels_getBitsPerChannel",1,SWIGTYPE_p_ofPixels_T_unsigned_short_t); } 
  result = (size_t)((ofPixels_< unsigned short > const *)arg1)->getBitsPerChannel();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortPixels_getBytesStride(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned short > *arg1 = (ofPixels_< unsigned short > *) 0 ; size_t result;
  SWIG_check_num_args("ofPixels_< unsigned short >::getBytesStride",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned short >::getBytesStride",1,"ofPixels_< unsigned short > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortPixels_getBytesStride",1,SWIGTYPE_p_ofPixels_T_unsigned_short_t); } 
  result = (size_t)((ofPixels_< unsigned short > const *)arg1)->getBytesStride();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortPixels_getNumChannels(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned short > *arg1 = (ofPixels_< unsigned short > *) 0 ; size_t result;
  SWIG_check_num_args("ofPixels_< unsigned short >::getNumChannels",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned short >::getNumChannels",1,"ofPixels_< unsigned short > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortPixels_getNumChannels",1,SWIGTYPE_p_ofPixels_T_unsigned_short_t); } 
  result = (size_t)((ofPixels_< unsigned short > const *)arg1)->getNumChannels();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortPixels_getTotalBytes(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned short > *arg1 = (ofPixels_< unsigned short > *) 0 ; size_t result;
  SWIG_check_num_args("ofPixels_< unsigned short >::getTotalBytes",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned short >::getTotalBytes",1,"ofPixels_< unsigned short > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortPixels_getTotalBytes",1,SWIGTYPE_p_ofPixels_T_unsigned_short_t); } 
  result = (size_t)((ofPixels_< unsigned short > const *)arg1)->getTotalBytes();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortPixels_getNumPlanes(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned short > *arg1 = (ofPixels_< unsigned short > *) 0 ; size_t result;
  SWIG_check_num_args("ofPixels_< unsigned short >::getNumPlanes",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned short >::getNumPlanes",1,"ofPixels_< unsigned short > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortPixels_getNumPlanes",1,SWIGTYPE_p_ofPixels_T_unsigned_short_t); } 
  result = (size_t)((ofPixels_< unsigned short > const *)arg1)->getNumPlanes();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortPixels_getPlane(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned short > *arg1 = (ofPixels_< unsigned short > *) 0 ; size_t arg2 ; ofPixels_< unsigned short > result;
  SWIG_check_num_args("ofPixels_< unsigned short >::getPlane",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned short >::getPlane",1,"ofPixels_< unsigned short > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofPixels_< unsigned short >::getPlane",2,"size_t");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortPixels_getPlane",1,SWIGTYPE_p_ofPixels_T_unsigned_short_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (size_t)lua_tonumber(L, 2);
  result = (arg1)->getPlane(arg2); {
    ofPixels_< unsigned short > * resultptr = new ofPixels_< unsigned short >((const ofPixels_< unsigned short > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofPixels_T_unsigned_short_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortPixels_getChannel(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned short > *arg1 = (ofPixels_< unsigned short > *) 0 ; size_t arg2 ; ofPixels_< unsigned short > result;
  SWIG_check_num_args("ofPixels_< unsigned short >::getChannel",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned short >::getChannel",1,"ofPixels_< unsigned short > const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofPixels_< unsigned short >::getChannel",2,"size_t");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortPixels_getChannel",1,SWIGTYPE_p_ofPixels_T_unsigned_short_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (size_t)lua_tonumber(L, 2);
  result = ((ofPixels_< unsigned short > const *)arg1)->getChannel(arg2); {
    ofPixels_< unsigned short > * resultptr = new ofPixels_< unsigned short >((const ofPixels_< unsigned short > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofPixels_T_unsigned_short_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortPixels_getPixelFormat(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned short > *arg1 = (ofPixels_< unsigned short > *) 0 ; ofPixelFormat result;
  SWIG_check_num_args("ofPixels_< unsigned short >::getPixelFormat",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned short >::getPixelFormat",1,"ofPixels_< unsigned short > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortPixels_getPixelFormat",1,SWIGTYPE_p_ofPixels_T_unsigned_short_t); } 
  result = (ofPixelFormat)((ofPixels_< unsigned short > const *)arg1)->getPixelFormat();
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_ShortPixels_size(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned short > *arg1 = (ofPixels_< unsigned short > *) 0 ; size_t result;
  SWIG_check_num_args("ofPixels_< unsigned short >::size",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned short >::size",1,"ofPixels_< unsigned short > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortPixels_size",1,SWIGTYPE_p_ofPixels_T_unsigned_short_t); } 
  result = (size_t)((ofPixels_< unsigned short > const *)arg1)->size(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortPixels_getImageType(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned short > *arg1 = (ofPixels_< unsigned short > *) 0 ; ofImageType result;
  SWIG_check_num_args("ofPixels_< unsigned short >::getImageType",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned short >::getImageType",1,"ofPixels_< unsigned short > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortPixels_getImageType",1,SWIGTYPE_p_ofPixels_T_unsigned_short_t); } 
  result = (ofImageType)((ofPixels_< unsigned short > const *)arg1)->getImageType();
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_ShortPixels_setChannel(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned short > *arg1 = (ofPixels_< unsigned short > *) 0 ; size_t arg2 ; ofPixels_< unsigned short > arg3 ;
  ofPixels_< unsigned short > *argp3 ; SWIG_check_num_args("ofPixels_< unsigned short >::setChannel",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned short >::setChannel",1,"ofPixels_< unsigned short > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofPixels_< unsigned short >::setChannel",2,"size_t");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofPixels_< unsigned short >::setChannel",3,"ofPixels_< unsigned short > const");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortPixels_setChannel",1,SWIGTYPE_p_ofPixels_T_unsigned_short_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (size_t)lua_tonumber(L, 2);
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_ofPixels_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortPixels_setChannel",3,SWIGTYPE_p_ofPixels_T_unsigned_short_t); }  arg3 = *argp3;
  (arg1)->setChannel(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortPixels_setImageType(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned short > *arg1 = (ofPixels_< unsigned short > *) 0 ; ofImageType arg2 ;
  SWIG_check_num_args("ofPixels_< unsigned short >::setImageType",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned short >::setImageType",1,"ofPixels_< unsigned short > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofPixels_< unsigned short >::setImageType",2,"ofImageType");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortPixels_setImageType",1,SWIGTYPE_p_ofPixels_T_unsigned_short_t); } 
  arg2 = (ofImageType)(int)lua_tonumber(L, 2); (arg1)->setImageType(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_ShortPixels_setNumChannels(lua_State* L) { int SWIG_arg = 0;
  ofPixels_< unsigned short > *arg1 = (ofPixels_< unsigned short > *) 0 ; size_t arg2 ;
  SWIG_check_num_args("ofPixels_< unsigned short >::setNumChannels",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofPixels_< unsigned short >::setNumChannels",1,"ofPixels_< unsigned short > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofPixels_< unsigned short >::setNumChannels",2,"size_t");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofPixels_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortPixels_setNumChannels",1,SWIGTYPE_p_ofPixels_T_unsigned_short_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (size_t)lua_tonumber(L, 2);
  (arg1)->setNumChannels(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static void swig_delete_ShortPixels(void *obj) {
ofPixels_< unsigned short > *arg1 = (ofPixels_< unsigned short > *) obj;
delete arg1;
}
static int _proxy__wrap_new_ShortPixels(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_ShortPixels);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_ShortPixels_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_ShortPixels_methods[]= {
    { "allocate", _wrap_ShortPixels_allocate},
    { "allocatePixelFormat", _wrap_ShortPixels_allocatePixelFormat},
    { "allocateImageType", _wrap_ShortPixels_allocateImageType},
    { "isAllocated", _wrap_ShortPixels_isAllocated},
    { "clear", _wrap_ShortPixels_clear},
    { "set", _wrap_ShortPixels_set},
    { "setFromPixels", _wrap_ShortPixels_setFromPixels},
    { "setFromPixelsImageType", _wrap_ShortPixels_setFromPixelsImageType},
    { "setFromExternalPixels", _wrap_ShortPixels_setFromExternalPixels},
    { "setFromAlignedPixels", _wrap_ShortPixels_setFromAlignedPixels},
    { "swap", _wrap_ShortPixels_swap},
    { "crop", _wrap_ShortPixels_crop},
    { "cropTo", _wrap_ShortPixels_cropTo},
    { "rotate90", _wrap_ShortPixels_rotate90},
    { "rotate90To", _wrap_ShortPixels_rotate90To},
    { "mirrorTo", _wrap_ShortPixels_mirrorTo},
    { "mirror", _wrap_ShortPixels_mirror},
    { "resize", _wrap_ShortPixels_resize},
    { "resizeTo", _wrap_ShortPixels_resizeTo},
    { "pasteInto", _wrap_ShortPixels_pasteInto},
    { "blendInto", _wrap_ShortPixels_blendInto},
    { "swapRgb", _wrap_ShortPixels_swapRgb},
    { "getData", _wrap_ShortPixels_getData},
    { "getPixelIndex", _wrap_ShortPixels_getPixelIndex},
    { "getColor", _wrap_ShortPixels_getColor},
    { "setColor", _wrap_ShortPixels_setColor},
    { "getWidth", _wrap_ShortPixels_getWidth},
    { "getHeight", _wrap_ShortPixels_getHeight},
    { "getBytesPerPixel", _wrap_ShortPixels_getBytesPerPixel},
    { "getBitsPerPixel", _wrap_ShortPixels_getBitsPerPixel},
    { "getBytesPerChannel", _wrap_ShortPixels_getBytesPerChannel},
    { "getBitsPerChannel", _wrap_ShortPixels_getBitsPerChannel},
    { "getBytesStride", _wrap_ShortPixels_getBytesStride},
    { "getNumChannels", _wrap_ShortPixels_getNumChannels},
    { "getTotalBytes", _wrap_ShortPixels_getTotalBytes},
    { "getNumPlanes", _wrap_ShortPixels_getNumPlanes},
    { "getPlane", _wrap_ShortPixels_getPlane},
    { "getChannel", _wrap_ShortPixels_getChannel},
    { "getPixelFormat", _wrap_ShortPixels_getPixelFormat},
    { "size", _wrap_ShortPixels_size},
    { "getImageType", _wrap_ShortPixels_getImageType},
    { "setChannel", _wrap_ShortPixels_setChannel},
    { "setImageType", _wrap_ShortPixels_setImageType},
    { "setNumChannels", _wrap_ShortPixels_setNumChannels},
    {0,0}
};
static swig_lua_method swig_ShortPixels_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_ShortPixels_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_ShortPixels_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_ShortPixels_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_ShortPixels_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_ShortPixels_Sf_SwigStatic = {
    "ShortPixels",
    swig_ShortPixels_Sf_SwigStatic_methods,
    swig_ShortPixels_Sf_SwigStatic_attributes,
    swig_ShortPixels_Sf_SwigStatic_constants,
    swig_ShortPixels_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_ShortPixels_bases[] = {0};
static const char *swig_ShortPixels_base_names[] = {0};
static swig_lua_class _wrap_class_ShortPixels = { "ShortPixels", "ShortPixels", &SWIGTYPE_p_ofPixels_T_unsigned_short_t,_proxy__wrap_new_ShortPixels, swig_delete_ShortPixels, swig_ShortPixels_methods, swig_ShortPixels_attributes, &swig_ShortPixels_Sf_SwigStatic, swig_ShortPixels_meta, swig_ShortPixels_bases, swig_ShortPixels_base_names };

static int _wrap_new_PolylineVector__SWIG_0(lua_State* L) { int SWIG_arg = 0; std::vector< ofPolyline > *result = 0 ;
  SWIG_check_num_args("std::vector< ofPolyline >::vector",0,0)
  result = (std::vector< ofPolyline > *)new std::vector< ofPolyline >();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorT_ofPolyline_T_ofDefaultVertexType_t_t,1); SWIG_arg++;  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_new_PolylineVector__SWIG_1(lua_State* L) { int SWIG_arg = 0; unsigned int arg1 ;
  std::vector< ofPolyline > *result = 0 ; SWIG_check_num_args("std::vector< ofPolyline >::vector",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("std::vector< ofPolyline >::vector",1,"unsigned int");
  SWIG_contract_assert((lua_tonumber(L,1)>=0),"number must not be negative") arg1 = (unsigned int)lua_tonumber(L, 1);
  result = (std::vector< ofPolyline > *)new std::vector< ofPolyline >(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorT_ofPolyline_T_ofDefaultVertexType_t_t,1); SWIG_arg++;  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_new_PolylineVector__SWIG_2(lua_State* L) { int SWIG_arg = 0; std::vector< ofPolyline > *arg1 = 0 ;
  std::vector< ofPolyline > *result = 0 ; SWIG_check_num_args("std::vector< ofPolyline >::vector",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("std::vector< ofPolyline >::vector",1,"std::vector< ofPolyline > const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_ofPolyline_T_ofDefaultVertexType_t_t,0))){
    SWIG_fail_ptr("new_PolylineVector",1,SWIGTYPE_p_std__vectorT_ofPolyline_T_ofDefaultVertexType_t_t); } 
  result = (std::vector< ofPolyline > *)new std::vector< ofPolyline >((std::vector< ofPolyline > const &)*arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorT_ofPolyline_T_ofDefaultVertexType_t_t,1); SWIG_arg++;  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_new_PolylineVector__SWIG_3(lua_State* L) { int SWIG_arg = 0; unsigned int arg1 ;
  ofPolyline_< glm::vec3 > arg2 ; ofPolyline_< glm::vec3 > *argp2 ; std::vector< ofPolyline > *result = 0 ;
  SWIG_check_num_args("std::vector< ofPolyline >::vector",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("std::vector< ofPolyline >::vector",1,"unsigned int");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("std::vector< ofPolyline >::vector",2,"ofPolyline_< glm::vec3 >");
  SWIG_contract_assert((lua_tonumber(L,1)>=0),"number must not be negative") arg1 = (unsigned int)lua_tonumber(L, 1);
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_ofPolyline_T_glm__vec3_t,0))){
    SWIG_fail_ptr("new_PolylineVector",2,SWIGTYPE_p_ofPolyline_T_glm__vec3_t); }  arg2 = *argp2;
  result = (std::vector< ofPolyline > *)new std::vector< ofPolyline >(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorT_ofPolyline_T_ofDefaultVertexType_t_t,1); SWIG_arg++;  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_new_PolylineVector(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 0) {
    return _wrap_new_PolylineVector__SWIG_0(L);}  if (argc == 1) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_std__vectorT_ofPolyline_T_ofDefaultVertexType_t_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_new_PolylineVector__SWIG_2(L);}  }  if (argc == 1) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { return _wrap_new_PolylineVector__SWIG_1(L);}  }  if (argc == 2) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofPolyline_T_glm__vec3_t, 0)) {
          _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_new_PolylineVector__SWIG_3(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_PolylineVector'\n" "  Possible C/C++ prototypes are:\n"
  "    std::vector< ofPolyline >::vector()\n" "    std::vector< ofPolyline >::vector(unsigned int)\n"
  "    std::vector< ofPolyline >::vector(std::vector< ofPolyline > const &)\n"
  "    std::vector< ofPolyline >::vector(unsigned int,ofPolyline_< glm::vec3 >)\n"); lua_error(L);return 0; }
static int _wrap_PolylineVector_size(lua_State* L) { int SWIG_arg = 0;
  std::vector< ofPolyline > *arg1 = (std::vector< ofPolyline > *) 0 ; unsigned int result;
  SWIG_check_num_args("std::vector< ofPolyline >::size",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< ofPolyline >::size",1,"std::vector< ofPolyline > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_ofPolyline_T_ofDefaultVertexType_t_t,0))){
    SWIG_fail_ptr("PolylineVector_size",1,SWIGTYPE_p_std__vectorT_ofPolyline_T_ofDefaultVertexType_t_t); } 
  result = (unsigned int)((std::vector< ofPolyline > const *)arg1)->size(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_PolylineVector_max_size(lua_State* L) { int SWIG_arg = 0;
  std::vector< ofPolyline > *arg1 = (std::vector< ofPolyline > *) 0 ; unsigned int result;
  SWIG_check_num_args("std::vector< ofPolyline >::max_size",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< ofPolyline >::max_size",1,"std::vector< ofPolyline > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_ofPolyline_T_ofDefaultVertexType_t_t,0))){
    SWIG_fail_ptr("PolylineVector_max_size",1,SWIGTYPE_p_std__vectorT_ofPolyline_T_ofDefaultVertexType_t_t); } 
  result = (unsigned int)((std::vector< ofPolyline > const *)arg1)->max_size();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_PolylineVector_empty(lua_State* L) { int SWIG_arg = 0;
  std::vector< ofPolyline > *arg1 = (std::vector< ofPolyline > *) 0 ; bool result;
  SWIG_check_num_args("std::vector< ofPolyline >::empty",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< ofPolyline >::empty",1,"std::vector< ofPolyline > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_ofPolyline_T_ofDefaultVertexType_t_t,0))){
    SWIG_fail_ptr("PolylineVector_empty",1,SWIGTYPE_p_std__vectorT_ofPolyline_T_ofDefaultVertexType_t_t); } 
  result = (bool)((std::vector< ofPolyline > const *)arg1)->empty(); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_PolylineVector_clear(lua_State* L) { int SWIG_arg = 0;
  std::vector< ofPolyline > *arg1 = (std::vector< ofPolyline > *) 0 ;
  SWIG_check_num_args("std::vector< ofPolyline >::clear",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< ofPolyline >::clear",1,"std::vector< ofPolyline > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_ofPolyline_T_ofDefaultVertexType_t_t,0))){
    SWIG_fail_ptr("PolylineVector_clear",1,SWIGTYPE_p_std__vectorT_ofPolyline_T_ofDefaultVertexType_t_t); }  (arg1)->clear();
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_PolylineVector_push_back(lua_State* L) { int SWIG_arg = 0;
  std::vector< ofPolyline > *arg1 = (std::vector< ofPolyline > *) 0 ; ofPolyline_< glm::vec3 > arg2 ;
  ofPolyline_< glm::vec3 > *argp2 ; SWIG_check_num_args("std::vector< ofPolyline >::push_back",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< ofPolyline >::push_back",1,"std::vector< ofPolyline > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("std::vector< ofPolyline >::push_back",2,"ofPolyline_< glm::vec3 >");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_ofPolyline_T_ofDefaultVertexType_t_t,0))){
    SWIG_fail_ptr("PolylineVector_push_back",1,SWIGTYPE_p_std__vectorT_ofPolyline_T_ofDefaultVertexType_t_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_ofPolyline_T_glm__vec3_t,0))){
    SWIG_fail_ptr("PolylineVector_push_back",2,SWIGTYPE_p_ofPolyline_T_glm__vec3_t); }  arg2 = *argp2; (arg1)->push_back(arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_PolylineVector_pop_back(lua_State* L) { int SWIG_arg = 0;
  std::vector< ofPolyline > *arg1 = (std::vector< ofPolyline > *) 0 ;
  SWIG_check_num_args("std::vector< ofPolyline >::pop_back",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< ofPolyline >::pop_back",1,"std::vector< ofPolyline > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_ofPolyline_T_ofDefaultVertexType_t_t,0))){
    SWIG_fail_ptr("PolylineVector_pop_back",1,SWIGTYPE_p_std__vectorT_ofPolyline_T_ofDefaultVertexType_t_t); } 
  (arg1)->pop_back(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_PolylineVector_front(lua_State* L) { int SWIG_arg = 0;
  std::vector< ofPolyline > *arg1 = (std::vector< ofPolyline > *) 0 ; ofPolyline_< glm::vec3 > result;
  SWIG_check_num_args("std::vector< ofPolyline >::front",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< ofPolyline >::front",1,"std::vector< ofPolyline > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_ofPolyline_T_ofDefaultVertexType_t_t,0))){
    SWIG_fail_ptr("PolylineVector_front",1,SWIGTYPE_p_std__vectorT_ofPolyline_T_ofDefaultVertexType_t_t); } 
  result = ((std::vector< ofPolyline > const *)arg1)->front(); {
    ofPolyline_< glm::vec3 > * resultptr = new ofPolyline_< glm::vec3 >((const ofPolyline_< glm::vec3 > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofPolyline_T_glm__vec3_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_PolylineVector_back(lua_State* L) { int SWIG_arg = 0;
  std::vector< ofPolyline > *arg1 = (std::vector< ofPolyline > *) 0 ; ofPolyline_< glm::vec3 > result;
  SWIG_check_num_args("std::vector< ofPolyline >::back",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< ofPolyline >::back",1,"std::vector< ofPolyline > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_ofPolyline_T_ofDefaultVertexType_t_t,0))){
    SWIG_fail_ptr("PolylineVector_back",1,SWIGTYPE_p_std__vectorT_ofPolyline_T_ofDefaultVertexType_t_t); } 
  result = ((std::vector< ofPolyline > const *)arg1)->back(); {
    ofPolyline_< glm::vec3 > * resultptr = new ofPolyline_< glm::vec3 >((const ofPolyline_< glm::vec3 > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofPolyline_T_glm__vec3_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_PolylineVector___getitem(lua_State* L) { int SWIG_arg = 0;
  std::vector< ofPolyline > *arg1 = (std::vector< ofPolyline > *) 0 ; unsigned int arg2 ; ofPolyline_< glm::vec3 > result;
  SWIG_check_num_args("std::vector< ofPolyline >::__getitem__",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< ofPolyline >::__getitem__",1,"std::vector< ofPolyline > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("std::vector< ofPolyline >::__getitem__",2,"unsigned int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_ofPolyline_T_ofDefaultVertexType_t_t,0))){
    SWIG_fail_ptr("PolylineVector___getitem",1,SWIGTYPE_p_std__vectorT_ofPolyline_T_ofDefaultVertexType_t_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (unsigned int)lua_tonumber(L, 2); try {
    result = std_vector_Sl_ofPolyline_Sg____getitem__(arg1,arg2);}  catch(std::out_of_range &_e) {
    SWIG_exception(SWIG_IndexError, (&_e)->what()); }  {
    ofPolyline_< glm::vec3 > * resultptr = new ofPolyline_< glm::vec3 >((const ofPolyline_< glm::vec3 > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofPolyline_T_glm__vec3_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_PolylineVector___setitem(lua_State* L) { int SWIG_arg = 0;
  std::vector< ofPolyline > *arg1 = (std::vector< ofPolyline > *) 0 ; unsigned int arg2 ; ofPolyline_< glm::vec3 > arg3 ;
  ofPolyline_< glm::vec3 > *argp3 ; SWIG_check_num_args("std::vector< ofPolyline >::__setitem__",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std::vector< ofPolyline >::__setitem__",1,"std::vector< ofPolyline > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("std::vector< ofPolyline >::__setitem__",2,"unsigned int");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("std::vector< ofPolyline >::__setitem__",3,"ofPolyline_< glm::vec3 >");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_ofPolyline_T_ofDefaultVertexType_t_t,0))){
    SWIG_fail_ptr("PolylineVector___setitem",1,SWIGTYPE_p_std__vectorT_ofPolyline_T_ofDefaultVertexType_t_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (unsigned int)lua_tonumber(L, 2);
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_ofPolyline_T_glm__vec3_t,0))){
    SWIG_fail_ptr("PolylineVector___setitem",3,SWIGTYPE_p_ofPolyline_T_glm__vec3_t); }  arg3 = *argp3; try {
    std_vector_Sl_ofPolyline_Sg____setitem__(arg1,arg2,arg3);}  catch(std::out_of_range &_e) {
    SWIG_exception(SWIG_IndexError, (&_e)->what()); }  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static void swig_delete_PolylineVector(void *obj) {
std::vector< ofPolyline > *arg1 = (std::vector< ofPolyline > *) obj;
delete arg1;
}
static int _proxy__wrap_new_PolylineVector(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_PolylineVector);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_PolylineVector_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_PolylineVector_methods[]= {
    { "size", _wrap_PolylineVector_size},
    { "max_size", _wrap_PolylineVector_max_size},
    { "empty", _wrap_PolylineVector_empty},
    { "clear", _wrap_PolylineVector_clear},
    { "push_back", _wrap_PolylineVector_push_back},
    { "pop_back", _wrap_PolylineVector_pop_back},
    { "front", _wrap_PolylineVector_front},
    { "back", _wrap_PolylineVector_back},
    { "__getitem", _wrap_PolylineVector___getitem},
    { "__setitem", _wrap_PolylineVector___setitem},
    {0,0}
};
static swig_lua_method swig_PolylineVector_meta[] = {
    { "__getitem", _wrap_PolylineVector___getitem},
    { "__setitem", _wrap_PolylineVector___setitem},
    {0,0}
};

static swig_lua_attribute swig_PolylineVector_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_PolylineVector_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_PolylineVector_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_PolylineVector_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_PolylineVector_Sf_SwigStatic = {
    "PolylineVector",
    swig_PolylineVector_Sf_SwigStatic_methods,
    swig_PolylineVector_Sf_SwigStatic_attributes,
    swig_PolylineVector_Sf_SwigStatic_constants,
    swig_PolylineVector_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_PolylineVector_bases[] = {0};
static const char *swig_PolylineVector_base_names[] = {0};
static swig_lua_class _wrap_class_PolylineVector = { "PolylineVector", "PolylineVector", &SWIGTYPE_p_std__vectorT_ofPolyline_T_ofDefaultVertexType_t_t,_proxy__wrap_new_PolylineVector, swig_delete_PolylineVector, swig_PolylineVector_methods, swig_PolylineVector_attributes, &swig_PolylineVector_Sf_SwigStatic, swig_PolylineVector_meta, swig_PolylineVector_bases, swig_PolylineVector_base_names };

static int _wrap_drawBitmapString__SWIG_0(lua_State* L) { int SWIG_arg = 0; std::string *arg1 = 0 ; float arg2 ; float arg3 ;
  std::string temp1 ; SWIG_check_num_args("ofDrawBitmapString",3,3)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofDrawBitmapString",1,"std::string const &");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofDrawBitmapString",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofDrawBitmapString",3,"float");
  temp1.assign(lua_tostring(L,1),lua_rawlen(L,1)); arg1=&temp1; arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); ofDrawBitmapString((std::string const &)*arg1,arg2,arg3); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_drawBitmapString__SWIG_1(lua_State* L) { int SWIG_arg = 0; std::string *arg1 = 0 ; glm::vec3 *arg2 = 0 ;
  std::string temp1 ; SWIG_check_num_args("ofDrawBitmapString",2,2)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofDrawBitmapString",1,"std::string const &");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofDrawBitmapString",2,"glm::vec3 const &");
  temp1.assign(lua_tostring(L,1),lua_rawlen(L,1)); arg1=&temp1;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("drawBitmapString",2,SWIGTYPE_p_glm__vec3); } 
  ofDrawBitmapString((std::string const &)*arg1,(glm::vec3 const &)*arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_drawBitmapString__SWIG_2(lua_State* L) { int SWIG_arg = 0; std::string *arg1 = 0 ; glm::vec2 *arg2 = 0 ;
  std::string temp1 ; SWIG_check_num_args("ofDrawBitmapString",2,2)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofDrawBitmapString",1,"std::string const &");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofDrawBitmapString",2,"glm::vec2 const &");
  temp1.assign(lua_tostring(L,1),lua_rawlen(L,1)); arg1=&temp1;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec2,0))){
    SWIG_fail_ptr("drawBitmapString",2,SWIGTYPE_p_glm__vec2); } 
  ofDrawBitmapString((std::string const &)*arg1,(glm::vec2 const &)*arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_drawBitmapString__SWIG_3(lua_State* L) { int SWIG_arg = 0; std::string *arg1 = 0 ; float arg2 ; float arg3 ;
  float arg4 ; std::string temp1 ; SWIG_check_num_args("ofDrawBitmapString",4,4)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofDrawBitmapString",1,"std::string const &");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofDrawBitmapString",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofDrawBitmapString",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofDrawBitmapString",4,"float");
  temp1.assign(lua_tostring(L,1),lua_rawlen(L,1)); arg1=&temp1; arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  ofDrawBitmapString((std::string const &)*arg1,arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_drawBitmapString(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { _v = lua_isstring(L,argv[0]); }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_drawBitmapString__SWIG_1(L);}  }  }  if (argc == 2) { int _v; {
      _v = lua_isstring(L,argv[0]); }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec2, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_drawBitmapString__SWIG_2(L);}  }  }  if (argc == 3) { int _v; {
      _v = lua_isstring(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); } 
        if (_v) { return _wrap_drawBitmapString__SWIG_0(L);}  }  }  }  if (argc == 4) { int _v; { _v = lua_isstring(L,argv[0]); }
     if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { {
            _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_drawBitmapString__SWIG_3(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'drawBitmapString'\n" "  Possible C/C++ prototypes are:\n"
  "    ofDrawBitmapString(std::string const &,float,float)\n" "    ofDrawBitmapString(std::string const &,glm::vec3 const &)\n"
  "    ofDrawBitmapString(std::string const &,glm::vec2 const &)\n"
  "    ofDrawBitmapString(std::string const &,float,float,float)\n"); lua_error(L);return 0; }
static int _wrap_setColor__SWIG_0(lua_State* L) { int SWIG_arg = 0; int arg1 ; int arg2 ; int arg3 ;
  SWIG_check_num_args("ofSetColor",3,3) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofSetColor",1,"int");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofSetColor",2,"int"); if(!lua_isnumber(L,3)) SWIG_fail_arg("ofSetColor",3,"int");
  arg1 = (int)lua_tonumber(L, 1); arg2 = (int)lua_tonumber(L, 2); arg3 = (int)lua_tonumber(L, 3); ofSetColor(arg1,arg2,arg3);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_setColor__SWIG_1(lua_State* L) { int SWIG_arg = 0; int arg1 ; int arg2 ; int arg3 ; int arg4 ;
  SWIG_check_num_args("ofSetColor",4,4) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofSetColor",1,"int");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofSetColor",2,"int"); if(!lua_isnumber(L,3)) SWIG_fail_arg("ofSetColor",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofSetColor",4,"int"); arg1 = (int)lua_tonumber(L, 1); arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3); arg4 = (int)lua_tonumber(L, 4); ofSetColor(arg1,arg2,arg3,arg4); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_setColor__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofColor *arg1 = 0 ; SWIG_check_num_args("ofSetColor",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofSetColor",1,"ofColor const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("setColor",1,SWIGTYPE_p_ofColor_T_unsigned_char_t); }  ofSetColor((ofColor_< unsigned char > const &)*arg1);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_setColor__SWIG_3(lua_State* L) { int SWIG_arg = 0; ofColor *arg1 = 0 ; int arg2 ;
  SWIG_check_num_args("ofSetColor",2,2) if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofSetColor",1,"ofColor const &");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofSetColor",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("setColor",1,SWIGTYPE_p_ofColor_T_unsigned_char_t); }  arg2 = (int)lua_tonumber(L, 2);
  ofSetColor((ofColor_< unsigned char > const &)*arg1,arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_setColor__SWIG_4(lua_State* L) { int SWIG_arg = 0; int arg1 ; SWIG_check_num_args("ofSetColor",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofSetColor",1,"int"); arg1 = (int)lua_tonumber(L, 1); ofSetColor(arg1); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_setColor(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L); if (argc == 1) { int _v; {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofColor_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_setColor__SWIG_2(L);}  }  if (argc == 1) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { return _wrap_setColor__SWIG_4(L);}  }  if (argc == 2) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofColor_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { return _wrap_setColor__SWIG_3(L);}
       }  }  if (argc == 3) { int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        { _v = lua_isnumber(L,argv[2]); }  if (_v) { return _wrap_setColor__SWIG_0(L);}  }  }  }  if (argc == 4) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); } 
        if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_setColor__SWIG_1(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'setColor'\n" "  Possible C/C++ prototypes are:\n"
  "    ofSetColor(int,int,int)\n" "    ofSetColor(int,int,int,int)\n" "    ofSetColor(ofColor const &)\n"
  "    ofSetColor(ofColor const &,int)\n" "    ofSetColor(int)\n"); lua_error(L);return 0; }
static int _wrap_setHexColor(lua_State* L) { int SWIG_arg = 0; int arg1 ; SWIG_check_num_args("ofSetHexColor",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofSetHexColor",1,"int"); arg1 = (int)lua_tonumber(L, 1); ofSetHexColor(arg1);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_noFill(lua_State* L) { int SWIG_arg = 0; SWIG_check_num_args("ofNoFill",0,0) ofNoFill(); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_fill(lua_State* L) { int SWIG_arg = 0; SWIG_check_num_args("ofFill",0,0) ofFill(); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_getFill(lua_State* L) { int SWIG_arg = 0; ofFillFlag result; SWIG_check_num_args("ofGetFill",0,0)
  result = (ofFillFlag)ofGetFill(); lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_getBackgroundColor(lua_State* L) { int SWIG_arg = 0; ofColor result;
  SWIG_check_num_args("ofGetBackgroundColor",0,0) result = ofGetBackgroundColor(); {
    ofColor * resultptr = new ofColor((const ofColor &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofColor_T_unsigned_char_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_background__SWIG_0(lua_State* L) { int SWIG_arg = 0; int arg1 ; int arg2 ; int arg3 ; int arg4 ;
  SWIG_check_num_args("ofBackground",4,4) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofBackground",1,"int");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofBackground",2,"int"); if(!lua_isnumber(L,3)) SWIG_fail_arg("ofBackground",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofBackground",4,"int"); arg1 = (int)lua_tonumber(L, 1); arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3); arg4 = (int)lua_tonumber(L, 4); ofBackground(arg1,arg2,arg3,arg4); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_background__SWIG_1(lua_State* L) { int SWIG_arg = 0; int arg1 ; int arg2 ; int arg3 ;
  SWIG_check_num_args("ofBackground",3,3) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofBackground",1,"int");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofBackground",2,"int"); if(!lua_isnumber(L,3)) SWIG_fail_arg("ofBackground",3,"int");
  arg1 = (int)lua_tonumber(L, 1); arg2 = (int)lua_tonumber(L, 2); arg3 = (int)lua_tonumber(L, 3); ofBackground(arg1,arg2,arg3);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_background__SWIG_2(lua_State* L) { int SWIG_arg = 0; int arg1 ; int arg2 ;
  SWIG_check_num_args("ofBackground",2,2) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofBackground",1,"int");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofBackground",2,"int"); arg1 = (int)lua_tonumber(L, 1); arg2 = (int)lua_tonumber(L, 2);
  ofBackground(arg1,arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_background__SWIG_3(lua_State* L) { int SWIG_arg = 0; int arg1 ; SWIG_check_num_args("ofBackground",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofBackground",1,"int"); arg1 = (int)lua_tonumber(L, 1); ofBackground(arg1);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_background__SWIG_4(lua_State* L) { int SWIG_arg = 0; ofColor *arg1 = 0 ;
  SWIG_check_num_args("ofBackground",1,1) if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofBackground",1,"ofColor const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("background",1,SWIGTYPE_p_ofColor_T_unsigned_char_t); } 
  ofBackground((ofColor_< unsigned char > const &)*arg1); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_background(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L); if (argc == 1) { int _v;
    { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofColor_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_background__SWIG_4(L);}  }  if (argc == 1) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { return _wrap_background__SWIG_3(L);}  }  if (argc == 2) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_background__SWIG_2(L);}  }  }  if (argc == 3) { int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { {
        _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_background__SWIG_1(L);}  }  }  }  if (argc == 4) { int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { {
        _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); }
           if (_v) { return _wrap_background__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'background'\n" "  Possible C/C++ prototypes are:\n"
  "    ofBackground(int,int,int,int)\n" "    ofBackground(int,int,int)\n" "    ofBackground(int,int)\n"
  "    ofBackground(int)\n" "    ofBackground(ofColor const &)\n"); lua_error(L);return 0; }
static int _wrap_backgroundHex__SWIG_0(lua_State* L) { int SWIG_arg = 0; int arg1 ; int arg2 ;
  SWIG_check_num_args("ofBackgroundHex",2,2) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofBackgroundHex",1,"int");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofBackgroundHex",2,"int"); arg1 = (int)lua_tonumber(L, 1);
  arg2 = (int)lua_tonumber(L, 2); ofBackgroundHex(arg1,arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_backgroundHex__SWIG_1(lua_State* L) { int SWIG_arg = 0; int arg1 ; SWIG_check_num_args("ofBackgroundHex",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofBackgroundHex",1,"int"); arg1 = (int)lua_tonumber(L, 1); ofBackgroundHex(arg1);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_backgroundHex(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 1) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { return _wrap_backgroundHex__SWIG_1(L);}  }  if (argc == 2) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_backgroundHex__SWIG_0(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'backgroundHex'\n" "  Possible C/C++ prototypes are:\n"
  "    ofBackgroundHex(int,int)\n" "    ofBackgroundHex(int)\n"); lua_error(L);return 0; }
static int _wrap_backgroundGradient__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofColor *arg1 = 0 ; ofColor *arg2 = 0 ;
  ofGradientMode arg3 ; SWIG_check_num_args("ofBackgroundGradient",3,3)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofBackgroundGradient",1,"ofColor const &");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofBackgroundGradient",2,"ofColor const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofBackgroundGradient",3,"ofGradientMode");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("backgroundGradient",1,SWIGTYPE_p_ofColor_T_unsigned_char_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("backgroundGradient",2,SWIGTYPE_p_ofColor_T_unsigned_char_t); } 
  arg3 = (ofGradientMode)(int)lua_tonumber(L, 3);
  ofBackgroundGradient((ofColor_< unsigned char > const &)*arg1,(ofColor_< unsigned char > const &)*arg2,arg3); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_backgroundGradient__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofColor *arg1 = 0 ; ofColor *arg2 = 0 ;
  SWIG_check_num_args("ofBackgroundGradient",2,2)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofBackgroundGradient",1,"ofColor const &");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofBackgroundGradient",2,"ofColor const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("backgroundGradient",1,SWIGTYPE_p_ofColor_T_unsigned_char_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("backgroundGradient",2,SWIGTYPE_p_ofColor_T_unsigned_char_t); } 
  ofBackgroundGradient((ofColor_< unsigned char > const &)*arg1,(ofColor_< unsigned char > const &)*arg2); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_backgroundGradient(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofColor_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofColor_T_unsigned_char_t, 0)) {
          _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_backgroundGradient__SWIG_1(L);}  }  }  if (argc == 3) { int _v;
    { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofColor_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofColor_T_unsigned_char_t, 0)) {
          _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_backgroundGradient__SWIG_0(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'backgroundGradient'\n" "  Possible C/C++ prototypes are:\n"
  "    ofBackgroundGradient(ofColor const &,ofColor const &,ofGradientMode)\n"
  "    ofBackgroundGradient(ofColor const &,ofColor const &)\n"); lua_error(L);return 0; }
static int _wrap_setBackgroundColor__SWIG_0(lua_State* L) { int SWIG_arg = 0; int arg1 ; int arg2 ; int arg3 ; int arg4 ;
  SWIG_check_num_args("ofSetBackgroundColor",4,4) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofSetBackgroundColor",1,"int");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofSetBackgroundColor",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofSetBackgroundColor",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofSetBackgroundColor",4,"int"); arg1 = (int)lua_tonumber(L, 1);
  arg2 = (int)lua_tonumber(L, 2); arg3 = (int)lua_tonumber(L, 3); arg4 = (int)lua_tonumber(L, 4);
  ofSetBackgroundColor(arg1,arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_setBackgroundColor__SWIG_1(lua_State* L) { int SWIG_arg = 0; int arg1 ; int arg2 ; int arg3 ;
  SWIG_check_num_args("ofSetBackgroundColor",3,3) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofSetBackgroundColor",1,"int");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofSetBackgroundColor",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofSetBackgroundColor",3,"int"); arg1 = (int)lua_tonumber(L, 1);
  arg2 = (int)lua_tonumber(L, 2); arg3 = (int)lua_tonumber(L, 3); ofSetBackgroundColor(arg1,arg2,arg3); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_setBackgroundColor__SWIG_2(lua_State* L) { int SWIG_arg = 0; int arg1 ; int arg2 ;
  SWIG_check_num_args("ofSetBackgroundColor",2,2) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofSetBackgroundColor",1,"int");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofSetBackgroundColor",2,"int"); arg1 = (int)lua_tonumber(L, 1);
  arg2 = (int)lua_tonumber(L, 2); ofSetBackgroundColor(arg1,arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_setBackgroundColor__SWIG_3(lua_State* L) { int SWIG_arg = 0; int arg1 ;
  SWIG_check_num_args("ofSetBackgroundColor",1,1) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofSetBackgroundColor",1,"int");
  arg1 = (int)lua_tonumber(L, 1); ofSetBackgroundColor(arg1); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_setBackgroundColor__SWIG_4(lua_State* L) { int SWIG_arg = 0; ofColor *arg1 = 0 ;
  SWIG_check_num_args("ofSetBackgroundColor",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofSetBackgroundColor",1,"ofColor const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("setBackgroundColor",1,SWIGTYPE_p_ofColor_T_unsigned_char_t); } 
  ofSetBackgroundColor((ofColor_< unsigned char > const &)*arg1); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_setBackgroundColor(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L); if (argc == 1) {
    int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofColor_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_setBackgroundColor__SWIG_4(L);}  }  if (argc == 1) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { return _wrap_setBackgroundColor__SWIG_3(L);}  }  if (argc == 2) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_setBackgroundColor__SWIG_2(L);}  }  }  if (argc == 3) { int _v; { _v = lua_isnumber(L,argv[0]); } 
    if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_setBackgroundColor__SWIG_1(L);}  }  }  }  if (argc == 4) { int _v; { _v = lua_isnumber(L,argv[0]); } 
    if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { {
            _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_setBackgroundColor__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'setBackgroundColor'\n" "  Possible C/C++ prototypes are:\n"
  "    ofSetBackgroundColor(int,int,int,int)\n" "    ofSetBackgroundColor(int,int,int)\n" "    ofSetBackgroundColor(int,int)\n"
  "    ofSetBackgroundColor(int)\n" "    ofSetBackgroundColor(ofColor const &)\n"); lua_error(L);return 0; }
static int _wrap_setBackgroundColorHex__SWIG_0(lua_State* L) { int SWIG_arg = 0; int arg1 ; int arg2 ;
  SWIG_check_num_args("ofSetBackgroundColorHex",2,2) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofSetBackgroundColorHex",1,"int");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofSetBackgroundColorHex",2,"int"); arg1 = (int)lua_tonumber(L, 1);
  arg2 = (int)lua_tonumber(L, 2); ofSetBackgroundColorHex(arg1,arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_setBackgroundColorHex__SWIG_1(lua_State* L) { int SWIG_arg = 0; int arg1 ;
  SWIG_check_num_args("ofSetBackgroundColorHex",1,1) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofSetBackgroundColorHex",1,"int");
  arg1 = (int)lua_tonumber(L, 1); ofSetBackgroundColorHex(arg1); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_setBackgroundColorHex(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 1) {
    int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { return _wrap_setBackgroundColorHex__SWIG_1(L);}  }  if (argc == 2) {
    int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_setBackgroundColorHex__SWIG_0(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'setBackgroundColorHex'\n"
  "  Possible C/C++ prototypes are:\n" "    ofSetBackgroundColorHex(int,int)\n" "    ofSetBackgroundColorHex(int)\n");
  lua_error(L);return 0; }
static int _wrap_setBackgroundAuto(lua_State* L) { int SWIG_arg = 0; bool arg1 ; SWIG_check_num_args("ofSetBackgroundAuto",1,1)
  if(!lua_isboolean(L,1)) SWIG_fail_arg("ofSetBackgroundAuto",1,"bool"); arg1 = (lua_toboolean(L, 1)!=0);
  ofSetBackgroundAuto(arg1); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_getBackgroundAuto(lua_State* L) { int SWIG_arg = 0; bool result; SWIG_check_num_args("ofGetBackgroundAuto",0,0)
  result = (bool)ofGetBackgroundAuto(); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_clear__SWIG_0(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ; float arg4 ;
  SWIG_check_num_args("ofClear",4,4) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofClear",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofClear",2,"float"); if(!lua_isnumber(L,3)) SWIG_fail_arg("ofClear",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofClear",4,"float"); arg1 = (float)lua_tonumber(L, 1); arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); ofClear(arg1,arg2,arg3,arg4); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_clear__SWIG_1(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ;
  SWIG_check_num_args("ofClear",3,3) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofClear",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofClear",2,"float"); if(!lua_isnumber(L,3)) SWIG_fail_arg("ofClear",3,"float");
  arg1 = (float)lua_tonumber(L, 1); arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); ofClear(arg1,arg2,arg3);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_clear__SWIG_2(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; SWIG_check_num_args("ofClear",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofClear",1,"float"); if(!lua_isnumber(L,2)) SWIG_fail_arg("ofClear",2,"float");
  arg1 = (float)lua_tonumber(L, 1); arg2 = (float)lua_tonumber(L, 2); ofClear(arg1,arg2); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_clear__SWIG_3(lua_State* L) { int SWIG_arg = 0; float arg1 ; SWIG_check_num_args("ofClear",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofClear",1,"float"); arg1 = (float)lua_tonumber(L, 1); ofClear(arg1); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_clear__SWIG_4(lua_State* L) { int SWIG_arg = 0; ofColor *arg1 = 0 ; SWIG_check_num_args("ofClear",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofClear",1,"ofColor const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("clear",1,SWIGTYPE_p_ofColor_T_unsigned_char_t); }  ofClear((ofColor_< unsigned char > const &)*arg1);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_clear(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L); if (argc == 1) { int _v; {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofColor_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_clear__SWIG_4(L);}  }  if (argc == 1) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { return _wrap_clear__SWIG_3(L);}  }  if (argc == 2) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { return _wrap_clear__SWIG_2(L);}  }
     }  if (argc == 3) { int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { {
          _v = lua_isnumber(L,argv[2]); }  if (_v) { return _wrap_clear__SWIG_1(L);}  }  }  }  if (argc == 4) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); } 
        if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_clear__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'clear'\n" "  Possible C/C++ prototypes are:\n"
  "    ofClear(float,float,float,float)\n" "    ofClear(float,float,float)\n" "    ofClear(float,float)\n"
  "    ofClear(float)\n" "    ofClear(ofColor const &)\n"); lua_error(L);return 0; }
static int _wrap_clearAlpha(lua_State* L) { int SWIG_arg = 0; SWIG_check_num_args("ofClearAlpha",0,0) ofClearAlpha();
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_drawTriangle__SWIG_0(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ; float arg4 ;
  float arg5 ; float arg6 ; SWIG_check_num_args("ofDrawTriangle",6,6)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofDrawTriangle",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofDrawTriangle",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofDrawTriangle",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofDrawTriangle",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofDrawTriangle",5,"float");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofDrawTriangle",6,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  arg5 = (float)lua_tonumber(L, 5); arg6 = (float)lua_tonumber(L, 6); ofDrawTriangle(arg1,arg2,arg3,arg4,arg5,arg6);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_drawTriangle__SWIG_1(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ; float arg4 ;
  float arg5 ; float arg6 ; float arg7 ; float arg8 ; float arg9 ; SWIG_check_num_args("ofDrawTriangle",9,9)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofDrawTriangle",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofDrawTriangle",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofDrawTriangle",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofDrawTriangle",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofDrawTriangle",5,"float");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofDrawTriangle",6,"float");
  if(!lua_isnumber(L,7)) SWIG_fail_arg("ofDrawTriangle",7,"float");
  if(!lua_isnumber(L,8)) SWIG_fail_arg("ofDrawTriangle",8,"float");
  if(!lua_isnumber(L,9)) SWIG_fail_arg("ofDrawTriangle",9,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  arg5 = (float)lua_tonumber(L, 5); arg6 = (float)lua_tonumber(L, 6); arg7 = (float)lua_tonumber(L, 7);
  arg8 = (float)lua_tonumber(L, 8); arg9 = (float)lua_tonumber(L, 9);
  ofDrawTriangle(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_drawTriangle__SWIG_2(lua_State* L) { int SWIG_arg = 0; glm::vec3 *arg1 = 0 ; glm::vec3 *arg2 = 0 ;
  glm::vec3 *arg3 = 0 ; SWIG_check_num_args("ofDrawTriangle",3,3)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofDrawTriangle",1,"glm::vec3 const &");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofDrawTriangle",2,"glm::vec3 const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofDrawTriangle",3,"glm::vec3 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("drawTriangle",1,SWIGTYPE_p_glm__vec3); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("drawTriangle",2,SWIGTYPE_p_glm__vec3); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("drawTriangle",3,SWIGTYPE_p_glm__vec3); } 
  ofDrawTriangle((glm::vec3 const &)*arg1,(glm::vec3 const &)*arg2,(glm::vec3 const &)*arg3); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_drawTriangle__SWIG_3(lua_State* L) { int SWIG_arg = 0; glm::vec2 *arg1 = 0 ; glm::vec2 *arg2 = 0 ;
  glm::vec2 *arg3 = 0 ; SWIG_check_num_args("ofDrawTriangle",3,3)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofDrawTriangle",1,"glm::vec2 const &");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofDrawTriangle",2,"glm::vec2 const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofDrawTriangle",3,"glm::vec2 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glm__vec2,0))){
    SWIG_fail_ptr("drawTriangle",1,SWIGTYPE_p_glm__vec2); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec2,0))){
    SWIG_fail_ptr("drawTriangle",2,SWIGTYPE_p_glm__vec2); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_glm__vec2,0))){
    SWIG_fail_ptr("drawTriangle",3,SWIGTYPE_p_glm__vec2); } 
  ofDrawTriangle((glm::vec2 const &)*arg1,(glm::vec2 const &)*arg2,(glm::vec2 const &)*arg3); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_drawTriangle(lua_State* L) { int argc; int argv[10]={ 1,2,3,4,5,6,7,8,9,10} ; argc = lua_gettop(L);
  if (argc == 3) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
           else { _v = 1; }  }  if (_v) { return _wrap_drawTriangle__SWIG_2(L);}  }  }  }  if (argc == 3) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_glm__vec2, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec2, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_glm__vec2, 0)) { _v = 0; }
           else { _v = 1; }  }  if (_v) { return _wrap_drawTriangle__SWIG_3(L);}  }  }  }  if (argc == 6) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); } 
        if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) { {
                _v = lua_isnumber(L,argv[5]); }  if (_v) { return _wrap_drawTriangle__SWIG_0(L);}  }  }  }  }  }  } 
  if (argc == 9) { int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { {
          _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { {
              _v = lua_isnumber(L,argv[4]); }  if (_v) { { _v = lua_isnumber(L,argv[5]); }  if (_v) { {
                  _v = lua_isnumber(L,argv[6]); }  if (_v) { { _v = lua_isnumber(L,argv[7]); }  if (_v) { {
                      _v = lua_isnumber(L,argv[8]); }  if (_v) { return _wrap_drawTriangle__SWIG_1(L);}  }  }  }  }  }  }  }  }
     }  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'drawTriangle'\n" "  Possible C/C++ prototypes are:\n"
  "    ofDrawTriangle(float,float,float,float,float,float)\n"
  "    ofDrawTriangle(float,float,float,float,float,float,float,float,float)\n"
  "    ofDrawTriangle(glm::vec3 const &,glm::vec3 const &,glm::vec3 const &)\n"
  "    ofDrawTriangle(glm::vec2 const &,glm::vec2 const &,glm::vec2 const &)\n"); lua_error(L);return 0; }
static int _wrap_drawCircle__SWIG_0(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ;
  SWIG_check_num_args("ofDrawCircle",3,3) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofDrawCircle",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofDrawCircle",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofDrawCircle",3,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); ofDrawCircle(arg1,arg2,arg3); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_drawCircle__SWIG_1(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ; float arg4 ;
  SWIG_check_num_args("ofDrawCircle",4,4) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofDrawCircle",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofDrawCircle",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofDrawCircle",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofDrawCircle",4,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  ofDrawCircle(arg1,arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_drawCircle__SWIG_2(lua_State* L) { int SWIG_arg = 0; glm::vec3 *arg1 = 0 ; float arg2 ;
  SWIG_check_num_args("ofDrawCircle",2,2) if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofDrawCircle",1,"glm::vec3 const &");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofDrawCircle",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("drawCircle",1,SWIGTYPE_p_glm__vec3); }  arg2 = (float)lua_tonumber(L, 2);
  ofDrawCircle((glm::vec3 const &)*arg1,arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_drawCircle__SWIG_3(lua_State* L) { int SWIG_arg = 0; glm::vec2 *arg1 = 0 ; float arg2 ;
  SWIG_check_num_args("ofDrawCircle",2,2) if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofDrawCircle",1,"glm::vec2 const &");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofDrawCircle",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glm__vec2,0))){
    SWIG_fail_ptr("drawCircle",1,SWIGTYPE_p_glm__vec2); }  arg2 = (float)lua_tonumber(L, 2);
  ofDrawCircle((glm::vec2 const &)*arg1,arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_drawCircle(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L); if (argc == 2) { int _v;
    { void *ptr; if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_drawCircle__SWIG_2(L);}  }  }  if (argc == 2) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_glm__vec2, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { return _wrap_drawCircle__SWIG_3(L);}  }  } 
  if (argc == 3) { int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { {
          _v = lua_isnumber(L,argv[2]); }  if (_v) { return _wrap_drawCircle__SWIG_0(L);}  }  }  }  if (argc == 4) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); } 
        if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_drawCircle__SWIG_1(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'drawCircle'\n" "  Possible C/C++ prototypes are:\n"
  "    ofDrawCircle(float,float,float)\n" "    ofDrawCircle(float,float,float,float)\n"
  "    ofDrawCircle(glm::vec3 const &,float)\n" "    ofDrawCircle(glm::vec2 const &,float)\n"); lua_error(L);return 0; }
static int _wrap_drawEllipse__SWIG_0(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ; float arg4 ;
  SWIG_check_num_args("ofDrawEllipse",4,4) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofDrawEllipse",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofDrawEllipse",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofDrawEllipse",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofDrawEllipse",4,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  ofDrawEllipse(arg1,arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_drawEllipse__SWIG_1(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ; float arg4 ;
  float arg5 ; SWIG_check_num_args("ofDrawEllipse",5,5) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofDrawEllipse",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofDrawEllipse",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofDrawEllipse",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofDrawEllipse",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofDrawEllipse",5,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  arg5 = (float)lua_tonumber(L, 5); ofDrawEllipse(arg1,arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_drawEllipse__SWIG_2(lua_State* L) { int SWIG_arg = 0; glm::vec3 *arg1 = 0 ; float arg2 ; float arg3 ;
  SWIG_check_num_args("ofDrawEllipse",3,3) if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofDrawEllipse",1,"glm::vec3 const &");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofDrawEllipse",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofDrawEllipse",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("drawEllipse",1,SWIGTYPE_p_glm__vec3); }  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3);
  ofDrawEllipse((glm::vec3 const &)*arg1,arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_drawEllipse__SWIG_3(lua_State* L) { int SWIG_arg = 0; glm::vec2 *arg1 = 0 ; float arg2 ; float arg3 ;
  SWIG_check_num_args("ofDrawEllipse",3,3) if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofDrawEllipse",1,"glm::vec2 const &");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofDrawEllipse",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofDrawEllipse",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glm__vec2,0))){
    SWIG_fail_ptr("drawEllipse",1,SWIGTYPE_p_glm__vec2); }  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3);
  ofDrawEllipse((glm::vec2 const &)*arg1,arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_drawEllipse(lua_State* L) { int argc; int argv[6]={ 1,2,3,4,5,6} ; argc = lua_gettop(L); if (argc == 3) {
    int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_drawEllipse__SWIG_2(L);}  }  }  }  if (argc == 3) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_glm__vec2, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_drawEllipse__SWIG_3(L);}  }  }  }  if (argc == 4) { int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) {
      { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); }
           if (_v) { return _wrap_drawEllipse__SWIG_0(L);}  }  }  }  }  if (argc == 5) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); } 
        if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) {
              return _wrap_drawEllipse__SWIG_1(L);}  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'drawEllipse'\n" "  Possible C/C++ prototypes are:\n"
  "    ofDrawEllipse(float,float,float,float)\n" "    ofDrawEllipse(float,float,float,float,float)\n"
  "    ofDrawEllipse(glm::vec3 const &,float,float)\n" "    ofDrawEllipse(glm::vec2 const &,float,float)\n");
  lua_error(L);return 0; }
static int _wrap_drawLine__SWIG_0(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ; float arg4 ;
  SWIG_check_num_args("ofDrawLine",4,4) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofDrawLine",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofDrawLine",2,"float"); if(!lua_isnumber(L,3)) SWIG_fail_arg("ofDrawLine",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofDrawLine",4,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  ofDrawLine(arg1,arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_drawLine__SWIG_1(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ; float arg4 ;
  float arg5 ; float arg6 ; SWIG_check_num_args("ofDrawLine",6,6) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofDrawLine",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofDrawLine",2,"float"); if(!lua_isnumber(L,3)) SWIG_fail_arg("ofDrawLine",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofDrawLine",4,"float"); if(!lua_isnumber(L,5)) SWIG_fail_arg("ofDrawLine",5,"float");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofDrawLine",6,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  arg5 = (float)lua_tonumber(L, 5); arg6 = (float)lua_tonumber(L, 6); ofDrawLine(arg1,arg2,arg3,arg4,arg5,arg6);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_drawLine__SWIG_2(lua_State* L) { int SWIG_arg = 0; glm::vec3 *arg1 = 0 ; glm::vec3 *arg2 = 0 ;
  SWIG_check_num_args("ofDrawLine",2,2) if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofDrawLine",1,"glm::vec3 const &");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofDrawLine",2,"glm::vec3 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glm__vec3,0))){ SWIG_fail_ptr("drawLine",1,SWIGTYPE_p_glm__vec3); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("drawLine",2,SWIGTYPE_p_glm__vec3); }  ofDrawLine((glm::vec3 const &)*arg1,(glm::vec3 const &)*arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_drawLine__SWIG_3(lua_State* L) { int SWIG_arg = 0; glm::vec2 *arg1 = 0 ; glm::vec2 *arg2 = 0 ;
  SWIG_check_num_args("ofDrawLine",2,2) if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofDrawLine",1,"glm::vec2 const &");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofDrawLine",2,"glm::vec2 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glm__vec2,0))){ SWIG_fail_ptr("drawLine",1,SWIGTYPE_p_glm__vec2); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec2,0))){
    SWIG_fail_ptr("drawLine",2,SWIGTYPE_p_glm__vec2); }  ofDrawLine((glm::vec2 const &)*arg1,(glm::vec2 const &)*arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_drawLine(lua_State* L) { int argc; int argv[7]={ 1,2,3,4,5,6,7} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_drawLine__SWIG_2(L);}  }  }  if (argc == 2) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_glm__vec2, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec2, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_drawLine__SWIG_3(L);}  }  }  if (argc == 4) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); } 
        if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_drawLine__SWIG_0(L);}  }  }  }  }  if (argc == 6) {
    int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { {
          _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { {
              _v = lua_isnumber(L,argv[4]); }  if (_v) { { _v = lua_isnumber(L,argv[5]); }  if (_v) {
                return _wrap_drawLine__SWIG_1(L);}  }  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'drawLine'\n" "  Possible C/C++ prototypes are:\n"
  "    ofDrawLine(float,float,float,float)\n" "    ofDrawLine(float,float,float,float,float,float)\n"
  "    ofDrawLine(glm::vec3 const &,glm::vec3 const &)\n" "    ofDrawLine(glm::vec2 const &,glm::vec2 const &)\n");
  lua_error(L);return 0; }
static int _wrap_drawRectangle__SWIG_0(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ; float arg4 ;
  SWIG_check_num_args("ofDrawRectangle",4,4) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofDrawRectangle",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofDrawRectangle",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofDrawRectangle",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofDrawRectangle",4,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  ofDrawRectangle(arg1,arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_drawRectangle__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = 0 ;
  SWIG_check_num_args("ofDrawRectangle",1,1) if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofDrawRectangle",1,"ofRectangle const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("drawRectangle",1,SWIGTYPE_p_ofRectangle); }  ofDrawRectangle((ofRectangle const &)*arg1); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_drawRectangle__SWIG_2(lua_State* L) { int SWIG_arg = 0; glm::vec3 *arg1 = 0 ; float arg2 ; float arg3 ;
  SWIG_check_num_args("ofDrawRectangle",3,3) if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofDrawRectangle",1,"glm::vec3 const &");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofDrawRectangle",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofDrawRectangle",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("drawRectangle",1,SWIGTYPE_p_glm__vec3); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); ofDrawRectangle((glm::vec3 const &)*arg1,arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_drawRectangle__SWIG_3(lua_State* L) { int SWIG_arg = 0; glm::vec2 *arg1 = 0 ; float arg2 ; float arg3 ;
  SWIG_check_num_args("ofDrawRectangle",3,3) if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofDrawRectangle",1,"glm::vec2 const &");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofDrawRectangle",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofDrawRectangle",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glm__vec2,0))){
    SWIG_fail_ptr("drawRectangle",1,SWIGTYPE_p_glm__vec2); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); ofDrawRectangle((glm::vec2 const &)*arg1,arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_drawRectangle__SWIG_4(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ; float arg4 ;
  float arg5 ; SWIG_check_num_args("ofDrawRectangle",5,5) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofDrawRectangle",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofDrawRectangle",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofDrawRectangle",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofDrawRectangle",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofDrawRectangle",5,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  arg5 = (float)lua_tonumber(L, 5); ofDrawRectangle(arg1,arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_drawRectangle(lua_State* L) { int argc; int argv[6]={ 1,2,3,4,5,6} ; argc = lua_gettop(L); if (argc == 1) {
    int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { return _wrap_drawRectangle__SWIG_1(L);}  }  if (argc == 3) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_drawRectangle__SWIG_2(L);}  }  }  }  if (argc == 3) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_glm__vec2, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_drawRectangle__SWIG_3(L);}  }  }  }  if (argc == 4) { int _v; { _v = lua_isnumber(L,argv[0]); } 
    if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { {
            _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_drawRectangle__SWIG_0(L);}  }  }  }  }  if (argc == 5) {
    int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { {
          _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { {
              _v = lua_isnumber(L,argv[4]); }  if (_v) { return _wrap_drawRectangle__SWIG_4(L);}  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'drawRectangle'\n" "  Possible C/C++ prototypes are:\n"
  "    ofDrawRectangle(float,float,float,float)\n" "    ofDrawRectangle(ofRectangle const &)\n"
  "    ofDrawRectangle(glm::vec3 const &,float,float)\n" "    ofDrawRectangle(glm::vec2 const &,float,float)\n"
  "    ofDrawRectangle(float,float,float,float,float)\n"); lua_error(L);return 0; }
static int _wrap_drawRectRounded__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = 0 ; float arg2 ;
  SWIG_check_num_args("ofDrawRectRounded",2,2)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofDrawRectRounded",1,"ofRectangle const &");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofDrawRectRounded",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("drawRectRounded",1,SWIGTYPE_p_ofRectangle); }  arg2 = (float)lua_tonumber(L, 2);
  ofDrawRectRounded((ofRectangle const &)*arg1,arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_drawRectRounded__SWIG_1(lua_State* L) { int SWIG_arg = 0; glm::vec3 *arg1 = 0 ; float arg2 ; float arg3 ;
  float arg4 ; SWIG_check_num_args("ofDrawRectRounded",4,4)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofDrawRectRounded",1,"glm::vec3 const &");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofDrawRectRounded",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofDrawRectRounded",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofDrawRectRounded",4,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("drawRectRounded",1,SWIGTYPE_p_glm__vec3); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  ofDrawRectRounded((glm::vec3 const &)*arg1,arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_drawRectRounded__SWIG_2(lua_State* L) { int SWIG_arg = 0; glm::vec2 *arg1 = 0 ; float arg2 ; float arg3 ;
  float arg4 ; SWIG_check_num_args("ofDrawRectRounded",4,4)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofDrawRectRounded",1,"glm::vec2 const &");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofDrawRectRounded",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofDrawRectRounded",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofDrawRectRounded",4,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glm__vec2,0))){
    SWIG_fail_ptr("drawRectRounded",1,SWIGTYPE_p_glm__vec2); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  ofDrawRectRounded((glm::vec2 const &)*arg1,arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_drawRectRounded__SWIG_3(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ; float arg4 ;
  float arg5 ; SWIG_check_num_args("ofDrawRectRounded",5,5) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofDrawRectRounded",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofDrawRectRounded",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofDrawRectRounded",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofDrawRectRounded",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofDrawRectRounded",5,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  arg5 = (float)lua_tonumber(L, 5); ofDrawRectRounded(arg1,arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_drawRectRounded__SWIG_4(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ; float arg4 ;
  float arg5 ; float arg6 ; SWIG_check_num_args("ofDrawRectRounded",6,6)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofDrawRectRounded",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofDrawRectRounded",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofDrawRectRounded",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofDrawRectRounded",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofDrawRectRounded",5,"float");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofDrawRectRounded",6,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  arg5 = (float)lua_tonumber(L, 5); arg6 = (float)lua_tonumber(L, 6); ofDrawRectRounded(arg1,arg2,arg3,arg4,arg5,arg6);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_drawRectRounded__SWIG_5(lua_State* L) { int SWIG_arg = 0; glm::vec3 *arg1 = 0 ; float arg2 ; float arg3 ;
  float arg4 ; float arg5 ; float arg6 ; float arg7 ; SWIG_check_num_args("ofDrawRectRounded",7,7)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofDrawRectRounded",1,"glm::vec3 const &");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofDrawRectRounded",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofDrawRectRounded",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofDrawRectRounded",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofDrawRectRounded",5,"float");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofDrawRectRounded",6,"float");
  if(!lua_isnumber(L,7)) SWIG_fail_arg("ofDrawRectRounded",7,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("drawRectRounded",1,SWIGTYPE_p_glm__vec3); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); arg5 = (float)lua_tonumber(L, 5);
  arg6 = (float)lua_tonumber(L, 6); arg7 = (float)lua_tonumber(L, 7);
  ofDrawRectRounded((glm::vec3 const &)*arg1,arg2,arg3,arg4,arg5,arg6,arg7); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_drawRectRounded__SWIG_6(lua_State* L) { int SWIG_arg = 0; glm::vec2 *arg1 = 0 ; float arg2 ; float arg3 ;
  float arg4 ; float arg5 ; float arg6 ; float arg7 ; SWIG_check_num_args("ofDrawRectRounded",7,7)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofDrawRectRounded",1,"glm::vec2 const &");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofDrawRectRounded",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofDrawRectRounded",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofDrawRectRounded",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofDrawRectRounded",5,"float");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofDrawRectRounded",6,"float");
  if(!lua_isnumber(L,7)) SWIG_fail_arg("ofDrawRectRounded",7,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glm__vec2,0))){
    SWIG_fail_ptr("drawRectRounded",1,SWIGTYPE_p_glm__vec2); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); arg5 = (float)lua_tonumber(L, 5);
  arg6 = (float)lua_tonumber(L, 6); arg7 = (float)lua_tonumber(L, 7);
  ofDrawRectRounded((glm::vec2 const &)*arg1,arg2,arg3,arg4,arg5,arg6,arg7); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_drawRectRounded__SWIG_7(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = 0 ; float arg2 ; float arg3 ;
  float arg4 ; float arg5 ; SWIG_check_num_args("ofDrawRectRounded",5,5)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofDrawRectRounded",1,"ofRectangle const &");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofDrawRectRounded",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofDrawRectRounded",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofDrawRectRounded",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofDrawRectRounded",5,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("drawRectRounded",1,SWIGTYPE_p_ofRectangle); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); arg5 = (float)lua_tonumber(L, 5);
  ofDrawRectRounded((ofRectangle const &)*arg1,arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_drawRectRounded__SWIG_8(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ; float arg4 ;
  float arg5 ; float arg6 ; float arg7 ; float arg8 ; float arg9 ; SWIG_check_num_args("ofDrawRectRounded",9,9)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofDrawRectRounded",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofDrawRectRounded",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofDrawRectRounded",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofDrawRectRounded",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofDrawRectRounded",5,"float");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofDrawRectRounded",6,"float");
  if(!lua_isnumber(L,7)) SWIG_fail_arg("ofDrawRectRounded",7,"float");
  if(!lua_isnumber(L,8)) SWIG_fail_arg("ofDrawRectRounded",8,"float");
  if(!lua_isnumber(L,9)) SWIG_fail_arg("ofDrawRectRounded",9,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  arg5 = (float)lua_tonumber(L, 5); arg6 = (float)lua_tonumber(L, 6); arg7 = (float)lua_tonumber(L, 7);
  arg8 = (float)lua_tonumber(L, 8); arg9 = (float)lua_tonumber(L, 9);
  ofDrawRectRounded(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_drawRectRounded(lua_State* L) { int argc; int argv[10]={ 1,2,3,4,5,6,7,8,9,10} ; argc = lua_gettop(L);
  if (argc == 2) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { return _wrap_drawRectRounded__SWIG_0(L);}  }
     }  if (argc == 4) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          { _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_drawRectRounded__SWIG_1(L);}  }  }  }  }  if (argc == 4) {
    int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_glm__vec2, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          { _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_drawRectRounded__SWIG_2(L);}  }  }  }  }  if (argc == 5) {
    int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) {
              return _wrap_drawRectRounded__SWIG_7(L);}  }  }  }  }  }  if (argc == 5) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); } 
        if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) {
              return _wrap_drawRectRounded__SWIG_3(L);}  }  }  }  }  }  if (argc == 6) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); } 
        if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) { {
                _v = lua_isnumber(L,argv[5]); }  if (_v) { return _wrap_drawRectRounded__SWIG_4(L);}  }  }  }  }  }  } 
  if (argc == 7) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_glm__vec2, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) { {
                _v = lua_isnumber(L,argv[5]); }  if (_v) { { _v = lua_isnumber(L,argv[6]); }  if (_v) {
                  return _wrap_drawRectRounded__SWIG_6(L);}  }  }  }  }  }  }  }  if (argc == 7) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) { {
                _v = lua_isnumber(L,argv[5]); }  if (_v) { { _v = lua_isnumber(L,argv[6]); }  if (_v) {
                  return _wrap_drawRectRounded__SWIG_5(L);}  }  }  }  }  }  }  }  if (argc == 9) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); } 
        if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) { {
                _v = lua_isnumber(L,argv[5]); }  if (_v) { { _v = lua_isnumber(L,argv[6]); }  if (_v) { {
                    _v = lua_isnumber(L,argv[7]); }  if (_v) { { _v = lua_isnumber(L,argv[8]); }  if (_v) {
                      return _wrap_drawRectRounded__SWIG_8(L);}  }  }  }  }  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'drawRectRounded'\n" "  Possible C/C++ prototypes are:\n"
  "    ofDrawRectRounded(ofRectangle const &,float)\n" "    ofDrawRectRounded(glm::vec3 const &,float,float,float)\n"
  "    ofDrawRectRounded(glm::vec2 const &,float,float,float)\n" "    ofDrawRectRounded(float,float,float,float,float)\n"
  "    ofDrawRectRounded(float,float,float,float,float,float)\n"
  "    ofDrawRectRounded(glm::vec3 const &,float,float,float,float,float,float)\n"
  "    ofDrawRectRounded(glm::vec2 const &,float,float,float,float,float,float)\n"
  "    ofDrawRectRounded(ofRectangle const &,float,float,float,float)\n"
  "    ofDrawRectRounded(float,float,float,float,float,float,float,float,float)\n"); lua_error(L);return 0; }
static int _wrap_drawCurve__SWIG_0(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ; float arg4 ;
  float arg5 ; float arg6 ; float arg7 ; float arg8 ; SWIG_check_num_args("ofDrawCurve",8,8)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofDrawCurve",1,"float"); if(!lua_isnumber(L,2)) SWIG_fail_arg("ofDrawCurve",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofDrawCurve",3,"float"); if(!lua_isnumber(L,4)) SWIG_fail_arg("ofDrawCurve",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofDrawCurve",5,"float"); if(!lua_isnumber(L,6)) SWIG_fail_arg("ofDrawCurve",6,"float");
  if(!lua_isnumber(L,7)) SWIG_fail_arg("ofDrawCurve",7,"float"); if(!lua_isnumber(L,8)) SWIG_fail_arg("ofDrawCurve",8,"float");
  arg1 = (float)lua_tonumber(L, 1); arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4); arg5 = (float)lua_tonumber(L, 5); arg6 = (float)lua_tonumber(L, 6);
  arg7 = (float)lua_tonumber(L, 7); arg8 = (float)lua_tonumber(L, 8); ofDrawCurve(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_drawCurve__SWIG_1(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ; float arg4 ;
  float arg5 ; float arg6 ; float arg7 ; float arg8 ; float arg9 ; float arg10 ; float arg11 ; float arg12 ;
  SWIG_check_num_args("ofDrawCurve",12,12) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofDrawCurve",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofDrawCurve",2,"float"); if(!lua_isnumber(L,3)) SWIG_fail_arg("ofDrawCurve",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofDrawCurve",4,"float"); if(!lua_isnumber(L,5)) SWIG_fail_arg("ofDrawCurve",5,"float");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofDrawCurve",6,"float"); if(!lua_isnumber(L,7)) SWIG_fail_arg("ofDrawCurve",7,"float");
  if(!lua_isnumber(L,8)) SWIG_fail_arg("ofDrawCurve",8,"float"); if(!lua_isnumber(L,9)) SWIG_fail_arg("ofDrawCurve",9,"float");
  if(!lua_isnumber(L,10)) SWIG_fail_arg("ofDrawCurve",10,"float");
  if(!lua_isnumber(L,11)) SWIG_fail_arg("ofDrawCurve",11,"float");
  if(!lua_isnumber(L,12)) SWIG_fail_arg("ofDrawCurve",12,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  arg5 = (float)lua_tonumber(L, 5); arg6 = (float)lua_tonumber(L, 6); arg7 = (float)lua_tonumber(L, 7);
  arg8 = (float)lua_tonumber(L, 8); arg9 = (float)lua_tonumber(L, 9); arg10 = (float)lua_tonumber(L, 10);
  arg11 = (float)lua_tonumber(L, 11); arg12 = (float)lua_tonumber(L, 12);
  ofDrawCurve(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_drawCurve(lua_State* L) { int argc; int argv[13]={ 1,2,3,4,5,6,7,8,9,10,11,12,13} ; argc = lua_gettop(L);
  if (argc == 8) { int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { {
          _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { {
              _v = lua_isnumber(L,argv[4]); }  if (_v) { { _v = lua_isnumber(L,argv[5]); }  if (_v) { {
                  _v = lua_isnumber(L,argv[6]); }  if (_v) { { _v = lua_isnumber(L,argv[7]); }  if (_v) {
                    return _wrap_drawCurve__SWIG_0(L);}  }  }  }  }  }  }  }  }  if (argc == 12) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); } 
        if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) { {
                _v = lua_isnumber(L,argv[5]); }  if (_v) { { _v = lua_isnumber(L,argv[6]); }  if (_v) { {
                    _v = lua_isnumber(L,argv[7]); }  if (_v) { { _v = lua_isnumber(L,argv[8]); }  if (_v) { {
                        _v = lua_isnumber(L,argv[9]); }  if (_v) { { _v = lua_isnumber(L,argv[10]); }  if (_v) { {
                            _v = lua_isnumber(L,argv[11]); }  if (_v) { return _wrap_drawCurve__SWIG_1(L);}  }  }  }  }  }  }  }
             }  }  }  }  }  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'drawCurve'\n"
  "  Possible C/C++ prototypes are:\n" "    ofDrawCurve(float,float,float,float,float,float,float,float)\n"
  "    ofDrawCurve(float,float,float,float,float,float,float,float,float,float,float,float)\n"); lua_error(L);return 0; }
static int _wrap_drawBezier__SWIG_0(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ; float arg4 ;
  float arg5 ; float arg6 ; float arg7 ; float arg8 ; SWIG_check_num_args("ofDrawBezier",8,8)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofDrawBezier",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofDrawBezier",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofDrawBezier",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofDrawBezier",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofDrawBezier",5,"float");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofDrawBezier",6,"float");
  if(!lua_isnumber(L,7)) SWIG_fail_arg("ofDrawBezier",7,"float");
  if(!lua_isnumber(L,8)) SWIG_fail_arg("ofDrawBezier",8,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  arg5 = (float)lua_tonumber(L, 5); arg6 = (float)lua_tonumber(L, 6); arg7 = (float)lua_tonumber(L, 7);
  arg8 = (float)lua_tonumber(L, 8); ofDrawBezier(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_drawBezier__SWIG_1(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ; float arg4 ;
  float arg5 ; float arg6 ; float arg7 ; float arg8 ; float arg9 ; float arg10 ; float arg11 ; float arg12 ;
  SWIG_check_num_args("ofDrawBezier",12,12) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofDrawBezier",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofDrawBezier",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofDrawBezier",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofDrawBezier",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofDrawBezier",5,"float");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofDrawBezier",6,"float");
  if(!lua_isnumber(L,7)) SWIG_fail_arg("ofDrawBezier",7,"float");
  if(!lua_isnumber(L,8)) SWIG_fail_arg("ofDrawBezier",8,"float");
  if(!lua_isnumber(L,9)) SWIG_fail_arg("ofDrawBezier",9,"float");
  if(!lua_isnumber(L,10)) SWIG_fail_arg("ofDrawBezier",10,"float");
  if(!lua_isnumber(L,11)) SWIG_fail_arg("ofDrawBezier",11,"float");
  if(!lua_isnumber(L,12)) SWIG_fail_arg("ofDrawBezier",12,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  arg5 = (float)lua_tonumber(L, 5); arg6 = (float)lua_tonumber(L, 6); arg7 = (float)lua_tonumber(L, 7);
  arg8 = (float)lua_tonumber(L, 8); arg9 = (float)lua_tonumber(L, 9); arg10 = (float)lua_tonumber(L, 10);
  arg11 = (float)lua_tonumber(L, 11); arg12 = (float)lua_tonumber(L, 12);
  ofDrawBezier(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_drawBezier(lua_State* L) { int argc; int argv[13]={ 1,2,3,4,5,6,7,8,9,10,11,12,13} ; argc = lua_gettop(L);
  if (argc == 8) { int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { {
          _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { {
              _v = lua_isnumber(L,argv[4]); }  if (_v) { { _v = lua_isnumber(L,argv[5]); }  if (_v) { {
                  _v = lua_isnumber(L,argv[6]); }  if (_v) { { _v = lua_isnumber(L,argv[7]); }  if (_v) {
                    return _wrap_drawBezier__SWIG_0(L);}  }  }  }  }  }  }  }  }  if (argc == 12) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); } 
        if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) { {
                _v = lua_isnumber(L,argv[5]); }  if (_v) { { _v = lua_isnumber(L,argv[6]); }  if (_v) { {
                    _v = lua_isnumber(L,argv[7]); }  if (_v) { { _v = lua_isnumber(L,argv[8]); }  if (_v) { {
                        _v = lua_isnumber(L,argv[9]); }  if (_v) { { _v = lua_isnumber(L,argv[10]); }  if (_v) { {
                            _v = lua_isnumber(L,argv[11]); }  if (_v) { return _wrap_drawBezier__SWIG_1(L);}  }  }  }  }  }  }  }
             }  }  }  }  }  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'drawBezier'\n"
  "  Possible C/C++ prototypes are:\n" "    ofDrawBezier(float,float,float,float,float,float,float,float)\n"
  "    ofDrawBezier(float,float,float,float,float,float,float,float,float,float,float,float)\n"); lua_error(L);return 0; }
static int _wrap_beginShape(lua_State* L) { int SWIG_arg = 0; SWIG_check_num_args("ofBeginShape",0,0) ofBeginShape();
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_vertex__SWIG_0(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; SWIG_check_num_args("ofVertex",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofVertex",1,"float"); if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVertex",2,"float");
  arg1 = (float)lua_tonumber(L, 1); arg2 = (float)lua_tonumber(L, 2); ofVertex(arg1,arg2); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_vertex__SWIG_1(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ;
  SWIG_check_num_args("ofVertex",3,3) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofVertex",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVertex",2,"float"); if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVertex",3,"float");
  arg1 = (float)lua_tonumber(L, 1); arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3);
  ofVertex(arg1,arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_vertex__SWIG_2(lua_State* L) { int SWIG_arg = 0; glm::vec3 *arg1 = 0 ; SWIG_check_num_args("ofVertex",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofVertex",1,"glm::vec3 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glm__vec3,0))){ SWIG_fail_ptr("vertex",1,SWIGTYPE_p_glm__vec3); } 
  ofVertex((glm::vec3 const &)*arg1); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_vertex__SWIG_3(lua_State* L) { int SWIG_arg = 0; glm::vec2 *arg1 = 0 ; SWIG_check_num_args("ofVertex",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofVertex",1,"glm::vec2 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glm__vec2,0))){ SWIG_fail_ptr("vertex",1,SWIGTYPE_p_glm__vec2); } 
  ofVertex((glm::vec2 const &)*arg1); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_vertex(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 1) { int _v; {
      void *ptr; if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_vertex__SWIG_2(L);}  }  if (argc == 1) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_glm__vec2, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { return _wrap_vertex__SWIG_3(L);}  }  if (argc == 2) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { return _wrap_vertex__SWIG_0(L);}  }
     }  if (argc == 3) { int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { {
          _v = lua_isnumber(L,argv[2]); }  if (_v) { return _wrap_vertex__SWIG_1(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'vertex'\n" "  Possible C/C++ prototypes are:\n"
  "    ofVertex(float,float)\n" "    ofVertex(float,float,float)\n" "    ofVertex(glm::vec3 const &)\n"
  "    ofVertex(glm::vec2 const &)\n"); lua_error(L);return 0; }
static int _wrap_vertices__SWIG_0(lua_State* L) { int SWIG_arg = 0; std::vector< glm::vec3 > *arg1 = 0 ;
  SWIG_check_num_args("ofVertices",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofVertices",1,"std::vector< glm::vec3 > const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_glm__vec3_t,0))){
    SWIG_fail_ptr("vertices",1,SWIGTYPE_p_std__vectorT_glm__vec3_t); }  ofVertices((std::vector< glm::vec3 > const &)*arg1);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_vertices__SWIG_1(lua_State* L) { int SWIG_arg = 0; std::vector< glm::vec2 > *arg1 = 0 ;
  SWIG_check_num_args("ofVertices",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofVertices",1,"std::vector< glm::vec2 > const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_glm__vec2_t,0))){
    SWIG_fail_ptr("vertices",1,SWIGTYPE_p_std__vectorT_glm__vec2_t); }  ofVertices((std::vector< glm::vec2 > const &)*arg1);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_vertices__SWIG_2(lua_State* L) { int SWIG_arg = 0; std::vector< ofVec3f > *arg1 = 0 ;
  SWIG_check_num_args("ofVertices",1,1) if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofVertices",1,"std::vector< ofVec3f > const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_ofVec3f_t,0))){
    SWIG_fail_ptr("vertices",1,SWIGTYPE_p_std__vectorT_ofVec3f_t); }  ofVertices((std::vector< ofVec3f > const &)*arg1);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_vertices__SWIG_3(lua_State* L) { int SWIG_arg = 0; std::vector< ofVec2f > *arg1 = 0 ;
  SWIG_check_num_args("ofVertices",1,1) if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofVertices",1,"std::vector< ofVec2f > const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_ofVec2f_t,0))){
    SWIG_fail_ptr("vertices",1,SWIGTYPE_p_std__vectorT_ofVec2f_t); }  ofVertices((std::vector< ofVec2f > const &)*arg1);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_vertices(lua_State* L) { int argc; int argv[2]={ 1,2} ; argc = lua_gettop(L); if (argc == 1) { int _v; {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_std__vectorT_glm__vec3_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_vertices__SWIG_0(L);}  }  if (argc == 1) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_std__vectorT_glm__vec2_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_vertices__SWIG_1(L);}  }  if (argc == 1) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_std__vectorT_ofVec3f_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_vertices__SWIG_2(L);}  }  if (argc == 1) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_std__vectorT_ofVec2f_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_vertices__SWIG_3(L);}  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'vertices'\n" "  Possible C/C++ prototypes are:\n"
  "    ofVertices(std::vector< glm::vec3 > const &)\n" "    ofVertices(std::vector< glm::vec2 > const &)\n"
  "    ofVertices(std::vector< ofVec3f > const &)\n" "    ofVertices(std::vector< ofVec2f > const &)\n");
  lua_error(L);return 0; }
static int _wrap_curveVertex__SWIG_0(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ;
  SWIG_check_num_args("ofCurveVertex",2,2) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofCurveVertex",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofCurveVertex",2,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); ofCurveVertex(arg1,arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_curveVertex__SWIG_1(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ;
  SWIG_check_num_args("ofCurveVertex",3,3) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofCurveVertex",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofCurveVertex",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofCurveVertex",3,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); ofCurveVertex(arg1,arg2,arg3); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_curveVertex__SWIG_2(lua_State* L) { int SWIG_arg = 0; glm::vec3 *arg1 = 0 ;
  SWIG_check_num_args("ofCurveVertex",1,1) if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofCurveVertex",1,"glm::vec3 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("curveVertex",1,SWIGTYPE_p_glm__vec3); }  ofCurveVertex((glm::vec3 const &)*arg1); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_curveVertex__SWIG_3(lua_State* L) { int SWIG_arg = 0; glm::vec2 *arg1 = 0 ;
  SWIG_check_num_args("ofCurveVertex",1,1) if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofCurveVertex",1,"glm::vec2 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glm__vec2,0))){
    SWIG_fail_ptr("curveVertex",1,SWIGTYPE_p_glm__vec2); }  ofCurveVertex((glm::vec2 const &)*arg1); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_curveVertex(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 1) { int _v; {
      void *ptr; if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_curveVertex__SWIG_2(L);}  }  if (argc == 1) { int _v; {
      void *ptr; if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_glm__vec2, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_curveVertex__SWIG_3(L);}  }  if (argc == 2) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_curveVertex__SWIG_0(L);}  }  }  if (argc == 3) { int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { {
        _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_curveVertex__SWIG_1(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'curveVertex'\n" "  Possible C/C++ prototypes are:\n"
  "    ofCurveVertex(float,float)\n" "    ofCurveVertex(float,float,float)\n" "    ofCurveVertex(glm::vec3 const &)\n"
  "    ofCurveVertex(glm::vec2 const &)\n"); lua_error(L);return 0; }
static int _wrap_curveVertices__SWIG_0(lua_State* L) { int SWIG_arg = 0; std::vector< glm::vec3 > *arg1 = 0 ;
  SWIG_check_num_args("ofCurveVertices",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofCurveVertices",1,"std::vector< glm::vec3 > const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_glm__vec3_t,0))){
    SWIG_fail_ptr("curveVertices",1,SWIGTYPE_p_std__vectorT_glm__vec3_t); } 
  ofCurveVertices((std::vector< glm::vec3 > const &)*arg1); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_curveVertices__SWIG_1(lua_State* L) { int SWIG_arg = 0; std::vector< glm::vec2 > *arg1 = 0 ;
  SWIG_check_num_args("ofCurveVertices",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofCurveVertices",1,"std::vector< glm::vec2 > const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_glm__vec2_t,0))){
    SWIG_fail_ptr("curveVertices",1,SWIGTYPE_p_std__vectorT_glm__vec2_t); } 
  ofCurveVertices((std::vector< glm::vec2 > const &)*arg1); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_curveVertices__SWIG_2(lua_State* L) { int SWIG_arg = 0; std::vector< ofVec3f > *arg1 = 0 ;
  SWIG_check_num_args("ofCurveVertices",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofCurveVertices",1,"std::vector< ofVec3f > const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_ofVec3f_t,0))){
    SWIG_fail_ptr("curveVertices",1,SWIGTYPE_p_std__vectorT_ofVec3f_t); } 
  ofCurveVertices((std::vector< ofVec3f > const &)*arg1); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_curveVertices__SWIG_3(lua_State* L) { int SWIG_arg = 0; std::vector< ofVec2f > *arg1 = 0 ;
  SWIG_check_num_args("ofCurveVertices",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofCurveVertices",1,"std::vector< ofVec2f > const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorT_ofVec2f_t,0))){
    SWIG_fail_ptr("curveVertices",1,SWIGTYPE_p_std__vectorT_ofVec2f_t); } 
  ofCurveVertices((std::vector< ofVec2f > const &)*arg1); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_curveVertices(lua_State* L) { int argc; int argv[2]={ 1,2} ; argc = lua_gettop(L); if (argc == 1) { int _v; {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_std__vectorT_glm__vec3_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_curveVertices__SWIG_0(L);}  }  if (argc == 1) { int _v; {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_std__vectorT_glm__vec2_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_curveVertices__SWIG_1(L);}  }  if (argc == 1) { int _v; {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_std__vectorT_ofVec3f_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_curveVertices__SWIG_2(L);}  }  if (argc == 1) { int _v; {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_std__vectorT_ofVec2f_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_curveVertices__SWIG_3(L);}  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'curveVertices'\n" "  Possible C/C++ prototypes are:\n"
  "    ofCurveVertices(std::vector< glm::vec3 > const &)\n" "    ofCurveVertices(std::vector< glm::vec2 > const &)\n"
  "    ofCurveVertices(std::vector< ofVec3f > const &)\n" "    ofCurveVertices(std::vector< ofVec2f > const &)\n");
  lua_error(L);return 0; }
static int _wrap_bezierVertex__SWIG_0(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ; float arg4 ;
  float arg5 ; float arg6 ; SWIG_check_num_args("ofBezierVertex",6,6)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofBezierVertex",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofBezierVertex",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofBezierVertex",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofBezierVertex",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofBezierVertex",5,"float");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofBezierVertex",6,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  arg5 = (float)lua_tonumber(L, 5); arg6 = (float)lua_tonumber(L, 6); ofBezierVertex(arg1,arg2,arg3,arg4,arg5,arg6);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_bezierVertex__SWIG_1(lua_State* L) { int SWIG_arg = 0; glm::vec3 *arg1 = 0 ; glm::vec3 *arg2 = 0 ;
  glm::vec3 *arg3 = 0 ; SWIG_check_num_args("ofBezierVertex",3,3)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofBezierVertex",1,"glm::vec3 const &");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofBezierVertex",2,"glm::vec3 const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofBezierVertex",3,"glm::vec3 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("bezierVertex",1,SWIGTYPE_p_glm__vec3); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("bezierVertex",2,SWIGTYPE_p_glm__vec3); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("bezierVertex",3,SWIGTYPE_p_glm__vec3); } 
  ofBezierVertex((glm::vec3 const &)*arg1,(glm::vec3 const &)*arg2,(glm::vec3 const &)*arg3); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_bezierVertex__SWIG_2(lua_State* L) { int SWIG_arg = 0; glm::vec2 *arg1 = 0 ; glm::vec2 *arg2 = 0 ;
  glm::vec2 *arg3 = 0 ; SWIG_check_num_args("ofBezierVertex",3,3)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofBezierVertex",1,"glm::vec2 const &");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofBezierVertex",2,"glm::vec2 const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofBezierVertex",3,"glm::vec2 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glm__vec2,0))){
    SWIG_fail_ptr("bezierVertex",1,SWIGTYPE_p_glm__vec2); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec2,0))){
    SWIG_fail_ptr("bezierVertex",2,SWIGTYPE_p_glm__vec2); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_glm__vec2,0))){
    SWIG_fail_ptr("bezierVertex",3,SWIGTYPE_p_glm__vec2); } 
  ofBezierVertex((glm::vec2 const &)*arg1,(glm::vec2 const &)*arg2,(glm::vec2 const &)*arg3); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_bezierVertex__SWIG_3(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ; float arg4 ;
  float arg5 ; float arg6 ; float arg7 ; float arg8 ; float arg9 ; SWIG_check_num_args("ofBezierVertex",9,9)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofBezierVertex",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofBezierVertex",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofBezierVertex",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofBezierVertex",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofBezierVertex",5,"float");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofBezierVertex",6,"float");
  if(!lua_isnumber(L,7)) SWIG_fail_arg("ofBezierVertex",7,"float");
  if(!lua_isnumber(L,8)) SWIG_fail_arg("ofBezierVertex",8,"float");
  if(!lua_isnumber(L,9)) SWIG_fail_arg("ofBezierVertex",9,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  arg5 = (float)lua_tonumber(L, 5); arg6 = (float)lua_tonumber(L, 6); arg7 = (float)lua_tonumber(L, 7);
  arg8 = (float)lua_tonumber(L, 8); arg9 = (float)lua_tonumber(L, 9);
  ofBezierVertex(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_bezierVertex(lua_State* L) { int argc; int argv[10]={ 1,2,3,4,5,6,7,8,9,10} ; argc = lua_gettop(L);
  if (argc == 3) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
           else { _v = 1; }  }  if (_v) { return _wrap_bezierVertex__SWIG_1(L);}  }  }  }  if (argc == 3) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_glm__vec2, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec2, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_glm__vec2, 0)) { _v = 0; }
           else { _v = 1; }  }  if (_v) { return _wrap_bezierVertex__SWIG_2(L);}  }  }  }  if (argc == 6) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); } 
        if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) { {
                _v = lua_isnumber(L,argv[5]); }  if (_v) { return _wrap_bezierVertex__SWIG_0(L);}  }  }  }  }  }  } 
  if (argc == 9) { int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { {
          _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { {
              _v = lua_isnumber(L,argv[4]); }  if (_v) { { _v = lua_isnumber(L,argv[5]); }  if (_v) { {
                  _v = lua_isnumber(L,argv[6]); }  if (_v) { { _v = lua_isnumber(L,argv[7]); }  if (_v) { {
                      _v = lua_isnumber(L,argv[8]); }  if (_v) { return _wrap_bezierVertex__SWIG_3(L);}  }  }  }  }  }  }  }  }
     }  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'bezierVertex'\n" "  Possible C/C++ prototypes are:\n"
  "    ofBezierVertex(float,float,float,float,float,float)\n"
  "    ofBezierVertex(glm::vec3 const &,glm::vec3 const &,glm::vec3 const &)\n"
  "    ofBezierVertex(glm::vec2 const &,glm::vec2 const &,glm::vec2 const &)\n"
  "    ofBezierVertex(float,float,float,float,float,float,float,float,float)\n"); lua_error(L);return 0; }
static int _wrap_endShape__SWIG_0(lua_State* L) { int SWIG_arg = 0; bool arg1 ; SWIG_check_num_args("ofEndShape",1,1)
  if(!lua_isboolean(L,1)) SWIG_fail_arg("ofEndShape",1,"bool"); arg1 = (lua_toboolean(L, 1)!=0); ofEndShape(arg1);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_endShape__SWIG_1(lua_State* L) { int SWIG_arg = 0; SWIG_check_num_args("ofEndShape",0,0) ofEndShape();
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_endShape(lua_State* L) { int argc; int argv[2]={ 1,2} ; argc = lua_gettop(L); if (argc == 0) {
    return _wrap_endShape__SWIG_1(L);}  if (argc == 1) { int _v; { _v = lua_isboolean(L,argv[0]); }  if (_v) {
      return _wrap_endShape__SWIG_0(L);}  }  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'endShape'\n"
  "  Possible C/C++ prototypes are:\n" "    ofEndShape(bool)\n" "    ofEndShape()\n"); lua_error(L);return 0; }
static int _wrap_nextContour__SWIG_0(lua_State* L) { int SWIG_arg = 0; bool arg1 ; SWIG_check_num_args("ofNextContour",1,1)
  if(!lua_isboolean(L,1)) SWIG_fail_arg("ofNextContour",1,"bool"); arg1 = (lua_toboolean(L, 1)!=0); ofNextContour(arg1);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_nextContour__SWIG_1(lua_State* L) { int SWIG_arg = 0; SWIG_check_num_args("ofNextContour",0,0) ofNextContour();
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_nextContour(lua_State* L) { int argc; int argv[2]={ 1,2} ; argc = lua_gettop(L); if (argc == 0) {
    return _wrap_nextContour__SWIG_1(L);}  if (argc == 1) { int _v; { _v = lua_isboolean(L,argv[0]); }  if (_v) {
      return _wrap_nextContour__SWIG_0(L);}  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'nextContour'\n" "  Possible C/C++ prototypes are:\n"
  "    ofNextContour(bool)\n" "    ofNextContour()\n"); lua_error(L);return 0; }
static int _wrap_setDrawBitmapMode(lua_State* L) { int SWIG_arg = 0; ofDrawBitmapMode arg1 ;
  SWIG_check_num_args("ofSetDrawBitmapMode",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofSetDrawBitmapMode",1,"ofDrawBitmapMode");
  arg1 = (ofDrawBitmapMode)(int)lua_tonumber(L, 1); ofSetDrawBitmapMode(arg1); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_drawBitmapStringHighlight__SWIG_0(lua_State* L) { int SWIG_arg = 0; std::string arg1 ; glm::vec3 *arg2 = 0 ;
  ofColor *arg3 = 0 ; ofColor *arg4 = 0 ; SWIG_check_num_args("ofDrawBitmapStringHighlight",4,4)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofDrawBitmapStringHighlight",1,"std::string");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofDrawBitmapStringHighlight",2,"glm::vec3 const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofDrawBitmapStringHighlight",3,"ofColor const &");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("ofDrawBitmapStringHighlight",4,"ofColor const &");
  (&arg1)->assign(lua_tostring(L,1),lua_rawlen(L,1));
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("drawBitmapStringHighlight",2,SWIGTYPE_p_glm__vec3); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("drawBitmapStringHighlight",3,SWIGTYPE_p_ofColor_T_unsigned_char_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("drawBitmapStringHighlight",4,SWIGTYPE_p_ofColor_T_unsigned_char_t); } 
  ofDrawBitmapStringHighlight(arg1,(glm::vec3 const &)*arg2,(ofColor_< unsigned char > const &)*arg3,(ofColor_< unsigned char > const &)*arg4);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_drawBitmapStringHighlight__SWIG_1(lua_State* L) { int SWIG_arg = 0; std::string arg1 ; glm::vec3 *arg2 = 0 ;
  ofColor *arg3 = 0 ; SWIG_check_num_args("ofDrawBitmapStringHighlight",3,3)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofDrawBitmapStringHighlight",1,"std::string");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofDrawBitmapStringHighlight",2,"glm::vec3 const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofDrawBitmapStringHighlight",3,"ofColor const &");
  (&arg1)->assign(lua_tostring(L,1),lua_rawlen(L,1));
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("drawBitmapStringHighlight",2,SWIGTYPE_p_glm__vec3); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("drawBitmapStringHighlight",3,SWIGTYPE_p_ofColor_T_unsigned_char_t); } 
  ofDrawBitmapStringHighlight(arg1,(glm::vec3 const &)*arg2,(ofColor_< unsigned char > const &)*arg3); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_drawBitmapStringHighlight__SWIG_2(lua_State* L) { int SWIG_arg = 0; std::string arg1 ; glm::vec3 *arg2 = 0 ;
  SWIG_check_num_args("ofDrawBitmapStringHighlight",2,2)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofDrawBitmapStringHighlight",1,"std::string");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofDrawBitmapStringHighlight",2,"glm::vec3 const &");
  (&arg1)->assign(lua_tostring(L,1),lua_rawlen(L,1));
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("drawBitmapStringHighlight",2,SWIGTYPE_p_glm__vec3); } 
  ofDrawBitmapStringHighlight(arg1,(glm::vec3 const &)*arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_drawBitmapStringHighlight__SWIG_3(lua_State* L) { int SWIG_arg = 0; std::string arg1 ; glm::vec2 *arg2 = 0 ;
  ofColor *arg3 = 0 ; ofColor *arg4 = 0 ; SWIG_check_num_args("ofDrawBitmapStringHighlight",4,4)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofDrawBitmapStringHighlight",1,"std::string");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofDrawBitmapStringHighlight",2,"glm::vec2 const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofDrawBitmapStringHighlight",3,"ofColor const &");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("ofDrawBitmapStringHighlight",4,"ofColor const &");
  (&arg1)->assign(lua_tostring(L,1),lua_rawlen(L,1));
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec2,0))){
    SWIG_fail_ptr("drawBitmapStringHighlight",2,SWIGTYPE_p_glm__vec2); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("drawBitmapStringHighlight",3,SWIGTYPE_p_ofColor_T_unsigned_char_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("drawBitmapStringHighlight",4,SWIGTYPE_p_ofColor_T_unsigned_char_t); } 
  ofDrawBitmapStringHighlight(arg1,(glm::vec2 const &)*arg2,(ofColor_< unsigned char > const &)*arg3,(ofColor_< unsigned char > const &)*arg4);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_drawBitmapStringHighlight__SWIG_4(lua_State* L) { int SWIG_arg = 0; std::string arg1 ; glm::vec2 *arg2 = 0 ;
  ofColor *arg3 = 0 ; SWIG_check_num_args("ofDrawBitmapStringHighlight",3,3)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofDrawBitmapStringHighlight",1,"std::string");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofDrawBitmapStringHighlight",2,"glm::vec2 const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofDrawBitmapStringHighlight",3,"ofColor const &");
  (&arg1)->assign(lua_tostring(L,1),lua_rawlen(L,1));
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec2,0))){
    SWIG_fail_ptr("drawBitmapStringHighlight",2,SWIGTYPE_p_glm__vec2); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("drawBitmapStringHighlight",3,SWIGTYPE_p_ofColor_T_unsigned_char_t); } 
  ofDrawBitmapStringHighlight(arg1,(glm::vec2 const &)*arg2,(ofColor_< unsigned char > const &)*arg3); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_drawBitmapStringHighlight__SWIG_5(lua_State* L) { int SWIG_arg = 0; std::string arg1 ; glm::vec2 *arg2 = 0 ;
  SWIG_check_num_args("ofDrawBitmapStringHighlight",2,2)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofDrawBitmapStringHighlight",1,"std::string");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofDrawBitmapStringHighlight",2,"glm::vec2 const &");
  (&arg1)->assign(lua_tostring(L,1),lua_rawlen(L,1));
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec2,0))){
    SWIG_fail_ptr("drawBitmapStringHighlight",2,SWIGTYPE_p_glm__vec2); } 
  ofDrawBitmapStringHighlight(arg1,(glm::vec2 const &)*arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_drawBitmapStringHighlight__SWIG_6(lua_State* L) { int SWIG_arg = 0; std::string arg1 ; int arg2 ; int arg3 ;
  ofColor *arg4 = 0 ; ofColor *arg5 = 0 ; SWIG_check_num_args("ofDrawBitmapStringHighlight",5,5)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofDrawBitmapStringHighlight",1,"std::string");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofDrawBitmapStringHighlight",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofDrawBitmapStringHighlight",3,"int");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("ofDrawBitmapStringHighlight",4,"ofColor const &");
  if(!lua_isuserdata(L,5)) SWIG_fail_arg("ofDrawBitmapStringHighlight",5,"ofColor const &");
  (&arg1)->assign(lua_tostring(L,1),lua_rawlen(L,1)); arg2 = (int)lua_tonumber(L, 2); arg3 = (int)lua_tonumber(L, 3);
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("drawBitmapStringHighlight",4,SWIGTYPE_p_ofColor_T_unsigned_char_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&arg5,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("drawBitmapStringHighlight",5,SWIGTYPE_p_ofColor_T_unsigned_char_t); } 
  ofDrawBitmapStringHighlight(arg1,arg2,arg3,(ofColor_< unsigned char > const &)*arg4,(ofColor_< unsigned char > const &)*arg5);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_drawBitmapStringHighlight__SWIG_7(lua_State* L) { int SWIG_arg = 0; std::string arg1 ; int arg2 ; int arg3 ;
  ofColor *arg4 = 0 ; SWIG_check_num_args("ofDrawBitmapStringHighlight",4,4)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofDrawBitmapStringHighlight",1,"std::string");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofDrawBitmapStringHighlight",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofDrawBitmapStringHighlight",3,"int");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("ofDrawBitmapStringHighlight",4,"ofColor const &");
  (&arg1)->assign(lua_tostring(L,1),lua_rawlen(L,1)); arg2 = (int)lua_tonumber(L, 2); arg3 = (int)lua_tonumber(L, 3);
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("drawBitmapStringHighlight",4,SWIGTYPE_p_ofColor_T_unsigned_char_t); } 
  ofDrawBitmapStringHighlight(arg1,arg2,arg3,(ofColor_< unsigned char > const &)*arg4); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_drawBitmapStringHighlight__SWIG_8(lua_State* L) { int SWIG_arg = 0; std::string arg1 ; int arg2 ; int arg3 ;
  SWIG_check_num_args("ofDrawBitmapStringHighlight",3,3)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofDrawBitmapStringHighlight",1,"std::string");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofDrawBitmapStringHighlight",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofDrawBitmapStringHighlight",3,"int");
  (&arg1)->assign(lua_tostring(L,1),lua_rawlen(L,1)); arg2 = (int)lua_tonumber(L, 2); arg3 = (int)lua_tonumber(L, 3);
  ofDrawBitmapStringHighlight(arg1,arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_drawBitmapStringHighlight(lua_State* L) { int argc; int argv[6]={ 1,2,3,4,5,6} ; argc = lua_gettop(L);
  if (argc == 2) { int _v; { _v = lua_isstring(L,argv[0]); }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_drawBitmapStringHighlight__SWIG_2(L);}  }  }  if (argc == 2) { int _v; {
      _v = lua_isstring(L,argv[0]); }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec2, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_drawBitmapStringHighlight__SWIG_5(L);}  }  }  if (argc == 3) { int _v; {
      _v = lua_isstring(L,argv[0]); }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec2, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_ofColor_T_unsigned_char_t, 0)) {
            _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_drawBitmapStringHighlight__SWIG_4(L);}  }  }  } 
  if (argc == 3) { int _v; { _v = lua_isstring(L,argv[0]); }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_ofColor_T_unsigned_char_t, 0)) {
            _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_drawBitmapStringHighlight__SWIG_1(L);}  }  }  } 
  if (argc == 3) { int _v; { _v = lua_isstring(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { {
          _v = lua_isnumber(L,argv[2]); }  if (_v) { return _wrap_drawBitmapStringHighlight__SWIG_8(L);}  }  }  } 
  if (argc == 4) { int _v; { _v = lua_isstring(L,argv[0]); }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec2, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_ofColor_T_unsigned_char_t, 0)) {
            _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_ofColor_T_unsigned_char_t, 0)) {
              _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_drawBitmapStringHighlight__SWIG_3(L);}  }  }  }  } 
  if (argc == 4) { int _v; { _v = lua_isstring(L,argv[0]); }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_ofColor_T_unsigned_char_t, 0)) {
            _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_ofColor_T_unsigned_char_t, 0)) {
              _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_drawBitmapStringHighlight__SWIG_0(L);}  }  }  }  } 
  if (argc == 4) { int _v; { _v = lua_isstring(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { {
          _v = lua_isnumber(L,argv[2]); }  if (_v) { { void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_ofColor_T_unsigned_char_t, 0)) {
              _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_drawBitmapStringHighlight__SWIG_7(L);}  }  }  }  } 
  if (argc == 5) { int _v; { _v = lua_isstring(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { {
          _v = lua_isnumber(L,argv[2]); }  if (_v) { { void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_ofColor_T_unsigned_char_t, 0)) {
              _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
              if (lua_isuserdata(L,argv[4])==0 || SWIG_ConvertPtr(L,argv[4], (void **) &ptr, SWIGTYPE_p_ofColor_T_unsigned_char_t, 0)) {
                _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_drawBitmapStringHighlight__SWIG_6(L);}  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'drawBitmapStringHighlight'\n"
  "  Possible C/C++ prototypes are:\n"
  "    ofDrawBitmapStringHighlight(std::string,glm::vec3 const &,ofColor const &,ofColor const &)\n"
  "    ofDrawBitmapStringHighlight(std::string,glm::vec3 const &,ofColor const &)\n"
  "    ofDrawBitmapStringHighlight(std::string,glm::vec3 const &)\n"
  "    ofDrawBitmapStringHighlight(std::string,glm::vec2 const &,ofColor const &,ofColor const &)\n"
  "    ofDrawBitmapStringHighlight(std::string,glm::vec2 const &,ofColor const &)\n"
  "    ofDrawBitmapStringHighlight(std::string,glm::vec2 const &)\n"
  "    ofDrawBitmapStringHighlight(std::string,int,int,ofColor const &,ofColor const &)\n"
  "    ofDrawBitmapStringHighlight(std::string,int,int,ofColor const &)\n"
  "    ofDrawBitmapStringHighlight(std::string,int,int)\n"); lua_error(L);return 0; }
static int _wrap_setupGraphicDefaults(lua_State* L) { int SWIG_arg = 0; SWIG_check_num_args("ofSetupGraphicDefaults",0,0)
  ofSetupGraphicDefaults(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_setupScreen(lua_State* L) { int SWIG_arg = 0; SWIG_check_num_args("ofSetupScreen",0,0) ofSetupScreen();
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_getRectMode(lua_State* L) { int SWIG_arg = 0; ofRectMode result; SWIG_check_num_args("ofGetRectMode",0,0)
  result = (ofRectMode)ofGetRectMode(); lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_setCircleResolution(lua_State* L) { int SWIG_arg = 0; int arg1 ;
  SWIG_check_num_args("ofSetCircleResolution",1,1) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofSetCircleResolution",1,"int");
  arg1 = (int)lua_tonumber(L, 1); ofSetCircleResolution(arg1); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_setCurveResolution(lua_State* L) { int SWIG_arg = 0; int arg1 ; SWIG_check_num_args("ofSetCurveResolution",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofSetCurveResolution",1,"int"); arg1 = (int)lua_tonumber(L, 1);
  ofSetCurveResolution(arg1); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_setLineWidth(lua_State* L) { int SWIG_arg = 0; float arg1 ; SWIG_check_num_args("ofSetLineWidth",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofSetLineWidth",1,"float"); arg1 = (float)lua_tonumber(L, 1); ofSetLineWidth(arg1);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_setDepthTest(lua_State* L) { int SWIG_arg = 0; bool arg1 ; SWIG_check_num_args("ofSetDepthTest",1,1)
  if(!lua_isboolean(L,1)) SWIG_fail_arg("ofSetDepthTest",1,"bool"); arg1 = (lua_toboolean(L, 1)!=0); ofSetDepthTest(arg1);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_enableDepthTest(lua_State* L) { int SWIG_arg = 0; SWIG_check_num_args("ofEnableDepthTest",0,0)
  ofEnableDepthTest(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_disableDepthTest(lua_State* L) { int SWIG_arg = 0; SWIG_check_num_args("ofDisableDepthTest",0,0)
  ofDisableDepthTest(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_enableBlendMode(lua_State* L) { int SWIG_arg = 0; ofBlendMode arg1 ;
  SWIG_check_num_args("ofEnableBlendMode",1,1) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofEnableBlendMode",1,"ofBlendMode");
  arg1 = (ofBlendMode)(int)lua_tonumber(L, 1); ofEnableBlendMode(arg1); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_disableBlendMode(lua_State* L) { int SWIG_arg = 0; SWIG_check_num_args("ofDisableBlendMode",0,0)
  ofDisableBlendMode(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_enablePointSprites(lua_State* L) { int SWIG_arg = 0; SWIG_check_num_args("ofEnablePointSprites",0,0)
  ofEnablePointSprites(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_disablePointSprites(lua_State* L) { int SWIG_arg = 0; SWIG_check_num_args("ofDisablePointSprites",0,0)
  ofDisablePointSprites(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_enableAlphaBlending(lua_State* L) { int SWIG_arg = 0; SWIG_check_num_args("ofEnableAlphaBlending",0,0)
  ofEnableAlphaBlending(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_disableAlphaBlending(lua_State* L) { int SWIG_arg = 0; SWIG_check_num_args("ofDisableAlphaBlending",0,0)
  ofDisableAlphaBlending(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_enableSmoothing(lua_State* L) { int SWIG_arg = 0; SWIG_check_num_args("ofEnableSmoothing",0,0)
  ofEnableSmoothing(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_disableSmoothing(lua_State* L) { int SWIG_arg = 0; SWIG_check_num_args("ofDisableSmoothing",0,0)
  ofDisableSmoothing(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_enableAntiAliasing(lua_State* L) { int SWIG_arg = 0; SWIG_check_num_args("ofEnableAntiAliasing",0,0)
  ofEnableAntiAliasing(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_disableAntiAliasing(lua_State* L) { int SWIG_arg = 0; SWIG_check_num_args("ofDisableAntiAliasing",0,0)
  ofDisableAntiAliasing(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_getStyle(lua_State* L) { int SWIG_arg = 0; ofStyle result; SWIG_check_num_args("ofGetStyle",0,0)
  result = ofGetStyle(); { ofStyle * resultptr = new ofStyle((const ofStyle &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofStyle,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_setStyle(lua_State* L) { int SWIG_arg = 0; ofStyle arg1 ; ofStyle *argp1 ;
  SWIG_check_num_args("ofSetStyle",1,1) if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofSetStyle",1,"ofStyle");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&argp1,SWIGTYPE_p_ofStyle,0))){ SWIG_fail_ptr("setStyle",1,SWIGTYPE_p_ofStyle); } 
  arg1 = *argp1; ofSetStyle(arg1); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_pushStyle(lua_State* L) { int SWIG_arg = 0; SWIG_check_num_args("ofPushStyle",0,0) ofPushStyle();
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_popStyle(lua_State* L) { int SWIG_arg = 0; SWIG_check_num_args("ofPopStyle",0,0) ofPopStyle(); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_setPolyMode(lua_State* L) { int SWIG_arg = 0; ofPolyWindingMode arg1 ; SWIG_check_num_args("ofSetPolyMode",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofSetPolyMode",1,"ofPolyWindingMode");
  arg1 = (ofPolyWindingMode)(int)lua_tonumber(L, 1); ofSetPolyMode(arg1); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_setRectMode(lua_State* L) { int SWIG_arg = 0; ofRectMode arg1 ; SWIG_check_num_args("ofSetRectMode",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofSetRectMode",1,"ofRectMode"); arg1 = (ofRectMode)(int)lua_tonumber(L, 1);
  ofSetRectMode(arg1); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_pushMatrix(lua_State* L) { int SWIG_arg = 0; SWIG_check_num_args("ofPushMatrix",0,0) ofPushMatrix();
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_popMatrix(lua_State* L) { int SWIG_arg = 0; SWIG_check_num_args("ofPopMatrix",0,0) ofPopMatrix();
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_getCurrentMatrix(lua_State* L) { int SWIG_arg = 0; ofMatrixMode arg1 ; glm::mat4 result;
  SWIG_check_num_args("ofGetCurrentMatrix",1,1) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofGetCurrentMatrix",1,"ofMatrixMode");
  arg1 = (ofMatrixMode)(int)lua_tonumber(L, 1); result = ofGetCurrentMatrix(arg1); {
    glm::mat4 * resultptr = new glm::mat4((const glm::mat4 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_glm__mat4,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_getCurrentOrientationMatrix(lua_State* L) { int SWIG_arg = 0; glm::mat4 result;
  SWIG_check_num_args("ofGetCurrentOrientationMatrix",0,0) result = ofGetCurrentOrientationMatrix(); {
    glm::mat4 * resultptr = new glm::mat4((const glm::mat4 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_glm__mat4,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_getCurrentNormalMatrix(lua_State* L) { int SWIG_arg = 0; glm::mat4 result;
  SWIG_check_num_args("ofGetCurrentNormalMatrix",0,0) result = ofGetCurrentNormalMatrix(); {
    glm::mat4 * resultptr = new glm::mat4((const glm::mat4 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_glm__mat4,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_translate__SWIG_0(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ;
  SWIG_check_num_args("ofTranslate",3,3) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofTranslate",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofTranslate",2,"float"); if(!lua_isnumber(L,3)) SWIG_fail_arg("ofTranslate",3,"float");
  arg1 = (float)lua_tonumber(L, 1); arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3);
  ofTranslate(arg1,arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_translate__SWIG_1(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ;
  SWIG_check_num_args("ofTranslate",2,2) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofTranslate",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofTranslate",2,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); ofTranslate(arg1,arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_translate__SWIG_2(lua_State* L) { int SWIG_arg = 0; glm::vec3 *arg1 = 0 ;
  SWIG_check_num_args("ofTranslate",1,1) if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofTranslate",1,"glm::vec3 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("translate",1,SWIGTYPE_p_glm__vec3); }  ofTranslate((glm::vec3 const &)*arg1); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_translate__SWIG_3(lua_State* L) { int SWIG_arg = 0; glm::vec2 *arg1 = 0 ;
  SWIG_check_num_args("ofTranslate",1,1) if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofTranslate",1,"glm::vec2 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glm__vec2,0))){
    SWIG_fail_ptr("translate",1,SWIGTYPE_p_glm__vec2); }  ofTranslate((glm::vec2 const &)*arg1); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_translate(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 1) { int _v; {
      void *ptr; if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_translate__SWIG_2(L);}  }  if (argc == 1) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_glm__vec2, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { return _wrap_translate__SWIG_3(L);}  }  if (argc == 2) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { return _wrap_translate__SWIG_1(L);}
       }  }  if (argc == 3) { int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        { _v = lua_isnumber(L,argv[2]); }  if (_v) { return _wrap_translate__SWIG_0(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'translate'\n" "  Possible C/C++ prototypes are:\n"
  "    ofTranslate(float,float,float)\n" "    ofTranslate(float,float)\n" "    ofTranslate(glm::vec3 const &)\n"
  "    ofTranslate(glm::vec2 const &)\n"); lua_error(L);return 0; }
static int _wrap_scale__SWIG_0(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ;
  SWIG_check_num_args("ofScale",3,3) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofScale",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofScale",2,"float"); if(!lua_isnumber(L,3)) SWIG_fail_arg("ofScale",3,"float");
  arg1 = (float)lua_tonumber(L, 1); arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); ofScale(arg1,arg2,arg3);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_scale__SWIG_1(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; SWIG_check_num_args("ofScale",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofScale",1,"float"); if(!lua_isnumber(L,2)) SWIG_fail_arg("ofScale",2,"float");
  arg1 = (float)lua_tonumber(L, 1); arg2 = (float)lua_tonumber(L, 2); ofScale(arg1,arg2); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_scale__SWIG_2(lua_State* L) { int SWIG_arg = 0; float arg1 ; SWIG_check_num_args("ofScale",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofScale",1,"float"); arg1 = (float)lua_tonumber(L, 1); ofScale(arg1); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_scale__SWIG_3(lua_State* L) { int SWIG_arg = 0; glm::vec3 *arg1 = 0 ; SWIG_check_num_args("ofScale",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofScale",1,"glm::vec3 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glm__vec3,0))){ SWIG_fail_ptr("scale",1,SWIGTYPE_p_glm__vec3); } 
  ofScale((glm::vec3 const &)*arg1); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_scale(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 1) { int _v; {
      void *ptr; if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_scale__SWIG_3(L);}  }  if (argc == 1) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { return _wrap_scale__SWIG_2(L);}  }  if (argc == 2) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { return _wrap_scale__SWIG_1(L);}  }
     }  if (argc == 3) { int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { {
          _v = lua_isnumber(L,argv[2]); }  if (_v) { return _wrap_scale__SWIG_0(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'scale'\n" "  Possible C/C++ prototypes are:\n"
  "    ofScale(float,float,float)\n" "    ofScale(float,float)\n" "    ofScale(float)\n" "    ofScale(glm::vec3 const &)\n");
  lua_error(L);return 0; }
static int _wrap_rotateDeg__SWIG_0(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ; float arg4 ;
  SWIG_check_num_args("ofRotateDeg",4,4) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofRotateDeg",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofRotateDeg",2,"float"); if(!lua_isnumber(L,3)) SWIG_fail_arg("ofRotateDeg",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofRotateDeg",4,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  ofRotateDeg(arg1,arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_rotateDeg__SWIG_1(lua_State* L) { int SWIG_arg = 0; float arg1 ; SWIG_check_num_args("ofRotateDeg",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofRotateDeg",1,"float"); arg1 = (float)lua_tonumber(L, 1); ofRotateDeg(arg1);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_rotateDeg(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L); if (argc == 1) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { return _wrap_rotateDeg__SWIG_1(L);}  }  if (argc == 4) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); } 
        if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_rotateDeg__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'rotateDeg'\n" "  Possible C/C++ prototypes are:\n"
  "    ofRotateDeg(float,float,float,float)\n" "    ofRotateDeg(float)\n"); lua_error(L);return 0; }
static int _wrap_rotateXDeg(lua_State* L) { int SWIG_arg = 0; float arg1 ; SWIG_check_num_args("ofRotateXDeg",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofRotateXDeg",1,"float"); arg1 = (float)lua_tonumber(L, 1); ofRotateXDeg(arg1);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_rotateYDeg(lua_State* L) { int SWIG_arg = 0; float arg1 ; SWIG_check_num_args("ofRotateYDeg",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofRotateYDeg",1,"float"); arg1 = (float)lua_tonumber(L, 1); ofRotateYDeg(arg1);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_rotateZDeg(lua_State* L) { int SWIG_arg = 0; float arg1 ; SWIG_check_num_args("ofRotateZDeg",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofRotateZDeg",1,"float"); arg1 = (float)lua_tonumber(L, 1); ofRotateZDeg(arg1);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_rotateRad__SWIG_0(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ; float arg4 ;
  SWIG_check_num_args("ofRotateRad",4,4) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofRotateRad",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofRotateRad",2,"float"); if(!lua_isnumber(L,3)) SWIG_fail_arg("ofRotateRad",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofRotateRad",4,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  ofRotateRad(arg1,arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_rotateRad__SWIG_1(lua_State* L) { int SWIG_arg = 0; float arg1 ; SWIG_check_num_args("ofRotateRad",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofRotateRad",1,"float"); arg1 = (float)lua_tonumber(L, 1); ofRotateRad(arg1);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_rotateRad(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L); if (argc == 1) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { return _wrap_rotateRad__SWIG_1(L);}  }  if (argc == 4) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); } 
        if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_rotateRad__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'rotateRad'\n" "  Possible C/C++ prototypes are:\n"
  "    ofRotateRad(float,float,float,float)\n" "    ofRotateRad(float)\n"); lua_error(L);return 0; }
static int _wrap_rotateXRad(lua_State* L) { int SWIG_arg = 0; float arg1 ; SWIG_check_num_args("ofRotateXRad",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofRotateXRad",1,"float"); arg1 = (float)lua_tonumber(L, 1); ofRotateXRad(arg1);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_rotateYRad(lua_State* L) { int SWIG_arg = 0; float arg1 ; SWIG_check_num_args("ofRotateYRad",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofRotateYRad",1,"float"); arg1 = (float)lua_tonumber(L, 1); ofRotateYRad(arg1);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_rotateZRad(lua_State* L) { int SWIG_arg = 0; float arg1 ; SWIG_check_num_args("ofRotateZRad",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofRotateZRad",1,"float"); arg1 = (float)lua_tonumber(L, 1); ofRotateZRad(arg1);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_loadIdentityMatrix(lua_State* L) { int SWIG_arg = 0; SWIG_check_num_args("ofLoadIdentityMatrix",0,0)
  ofLoadIdentityMatrix(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_loadMatrix__SWIG_0(lua_State* L) { int SWIG_arg = 0; glm::mat4 *arg1 = 0 ;
  SWIG_check_num_args("ofLoadMatrix",1,1) if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofLoadMatrix",1,"glm::mat4 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glm__mat4,0))){
    SWIG_fail_ptr("loadMatrix",1,SWIGTYPE_p_glm__mat4); }  ofLoadMatrix((glm::mat4 const &)*arg1); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_loadMatrix__SWIG_1(lua_State* L) { int SWIG_arg = 0; float *arg1 = (float *) 0 ;
  SWIG_check_num_args("ofLoadMatrix",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofLoadMatrix",1,"float const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_float,0))){ SWIG_fail_ptr("loadMatrix",1,SWIGTYPE_p_float); } 
  ofLoadMatrix((float const *)arg1); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_loadMatrix(lua_State* L) { int argc; int argv[2]={ 1,2} ; argc = lua_gettop(L); if (argc == 1) { int _v; {
      void *ptr; if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_glm__mat4, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_loadMatrix__SWIG_0(L);}  }  if (argc == 1) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_float, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { return _wrap_loadMatrix__SWIG_1(L);}  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'loadMatrix'\n" "  Possible C/C++ prototypes are:\n"
  "    ofLoadMatrix(glm::mat4 const &)\n" "    ofLoadMatrix(float const *)\n"); lua_error(L);return 0; }
static int _wrap_multMatrix__SWIG_0(lua_State* L) { int SWIG_arg = 0; glm::mat4 *arg1 = 0 ;
  SWIG_check_num_args("ofMultMatrix",1,1) if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofMultMatrix",1,"glm::mat4 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glm__mat4,0))){
    SWIG_fail_ptr("multMatrix",1,SWIGTYPE_p_glm__mat4); }  ofMultMatrix((glm::mat4 const &)*arg1); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_multMatrix__SWIG_1(lua_State* L) { int SWIG_arg = 0; float *arg1 = (float *) 0 ;
  SWIG_check_num_args("ofMultMatrix",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMultMatrix",1,"float const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_float,0))){ SWIG_fail_ptr("multMatrix",1,SWIGTYPE_p_float); } 
  ofMultMatrix((float const *)arg1); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_multMatrix(lua_State* L) { int argc; int argv[2]={ 1,2} ; argc = lua_gettop(L); if (argc == 1) { int _v; {
      void *ptr; if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_glm__mat4, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_multMatrix__SWIG_0(L);}  }  if (argc == 1) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_float, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { return _wrap_multMatrix__SWIG_1(L);}  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'multMatrix'\n" "  Possible C/C++ prototypes are:\n"
  "    ofMultMatrix(glm::mat4 const &)\n" "    ofMultMatrix(float const *)\n"); lua_error(L);return 0; }
static int _wrap_setMatrixMode(lua_State* L) { int SWIG_arg = 0; ofMatrixMode arg1 ; SWIG_check_num_args("ofSetMatrixMode",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofSetMatrixMode",1,"ofMatrixMode"); arg1 = (ofMatrixMode)(int)lua_tonumber(L, 1);
  ofSetMatrixMode(arg1); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_loadViewMatrix(lua_State* L) { int SWIG_arg = 0; glm::mat4 *arg1 = 0 ;
  SWIG_check_num_args("ofLoadViewMatrix",1,1) if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofLoadViewMatrix",1,"glm::mat4 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glm__mat4,0))){
    SWIG_fail_ptr("loadViewMatrix",1,SWIGTYPE_p_glm__mat4); }  ofLoadViewMatrix((glm::mat4 const &)*arg1); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_multViewMatrix(lua_State* L) { int SWIG_arg = 0; glm::mat4 *arg1 = 0 ;
  SWIG_check_num_args("ofMultViewMatrix",1,1) if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofMultViewMatrix",1,"glm::mat4 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glm__mat4,0))){
    SWIG_fail_ptr("multViewMatrix",1,SWIGTYPE_p_glm__mat4); }  ofMultViewMatrix((glm::mat4 const &)*arg1); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_getCurrentViewMatrix(lua_State* L) { int SWIG_arg = 0; glm::mat4 result;
  SWIG_check_num_args("ofGetCurrentViewMatrix",0,0) result = ofGetCurrentViewMatrix(); {
    glm::mat4 * resultptr = new glm::mat4((const glm::mat4 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_glm__mat4,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_pushView(lua_State* L) { int SWIG_arg = 0; SWIG_check_num_args("ofPushView",0,0) ofPushView(); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_popView(lua_State* L) { int SWIG_arg = 0; SWIG_check_num_args("ofPopView",0,0) ofPopView(); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_isVFlipped(lua_State* L) { int SWIG_arg = 0; bool result; SWIG_check_num_args("ofIsVFlipped",0,0)
  result = (bool)ofIsVFlipped(); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_viewport__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofRectangle arg1 ; ofRectangle *argp1 ;
  SWIG_check_num_args("ofViewport",1,1) if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofViewport",1,"ofRectangle");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&argp1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("viewport",1,SWIGTYPE_p_ofRectangle); }  arg1 = *argp1; ofViewport(arg1); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_viewport__SWIG_1(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ; float arg4 ;
  bool arg5 ; SWIG_check_num_args("ofViewport",5,5) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofViewport",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofViewport",2,"float"); if(!lua_isnumber(L,3)) SWIG_fail_arg("ofViewport",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofViewport",4,"float"); if(!lua_isboolean(L,5)) SWIG_fail_arg("ofViewport",5,"bool");
  arg1 = (float)lua_tonumber(L, 1); arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4); arg5 = (lua_toboolean(L, 5)!=0); ofViewport(arg1,arg2,arg3,arg4,arg5); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_viewport__SWIG_2(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ; float arg4 ;
  SWIG_check_num_args("ofViewport",4,4) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofViewport",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofViewport",2,"float"); if(!lua_isnumber(L,3)) SWIG_fail_arg("ofViewport",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofViewport",4,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  ofViewport(arg1,arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_viewport__SWIG_3(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ;
  SWIG_check_num_args("ofViewport",3,3) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofViewport",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofViewport",2,"float"); if(!lua_isnumber(L,3)) SWIG_fail_arg("ofViewport",3,"float");
  arg1 = (float)lua_tonumber(L, 1); arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3);
  ofViewport(arg1,arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_viewport__SWIG_4(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ;
  SWIG_check_num_args("ofViewport",2,2) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofViewport",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofViewport",2,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); ofViewport(arg1,arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_viewport__SWIG_5(lua_State* L) { int SWIG_arg = 0; float arg1 ; SWIG_check_num_args("ofViewport",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofViewport",1,"float"); arg1 = (float)lua_tonumber(L, 1); ofViewport(arg1);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_viewport__SWIG_6(lua_State* L) { int SWIG_arg = 0; SWIG_check_num_args("ofViewport",0,0) ofViewport();
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_viewport(lua_State* L) { int argc; int argv[6]={ 1,2,3,4,5,6} ; argc = lua_gettop(L); if (argc == 0) {
    return _wrap_viewport__SWIG_6(L);}  if (argc == 1) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { return _wrap_viewport__SWIG_0(L);}  }  if (argc == 1) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { return _wrap_viewport__SWIG_5(L);}  }  if (argc == 2) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { return _wrap_viewport__SWIG_4(L);}
       }  }  if (argc == 3) { int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        { _v = lua_isnumber(L,argv[2]); }  if (_v) { return _wrap_viewport__SWIG_3(L);}  }  }  }  if (argc == 4) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); } 
        if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_viewport__SWIG_2(L);}  }  }  }  }  if (argc == 5) {
    int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { {
          _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { {
              _v = lua_isboolean(L,argv[4]); }  if (_v) { return _wrap_viewport__SWIG_1(L);}  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'viewport'\n" "  Possible C/C++ prototypes are:\n"
  "    ofViewport(ofRectangle)\n" "    ofViewport(float,float,float,float,bool)\n" "    ofViewport(float,float,float,float)\n"
  "    ofViewport(float,float,float)\n" "    ofViewport(float,float)\n" "    ofViewport(float)\n" "    ofViewport()\n");
  lua_error(L);return 0; }
static int _wrap_getCurrentViewport(lua_State* L) { int SWIG_arg = 0; ofRectangle result;
  SWIG_check_num_args("ofGetCurrentViewport",0,0) result = ofGetCurrentViewport(); {
    ofRectangle * resultptr = new ofRectangle((const ofRectangle &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofRectangle,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_getNativeViewport(lua_State* L) { int SWIG_arg = 0; ofRectangle result;
  SWIG_check_num_args("ofGetNativeViewport",0,0) result = ofGetNativeViewport(); {
    ofRectangle * resultptr = new ofRectangle((const ofRectangle &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofRectangle,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_getViewportWidth(lua_State* L) { int SWIG_arg = 0; int result; SWIG_check_num_args("ofGetViewportWidth",0,0)
  result = (int)ofGetViewportWidth(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_getViewportHeight(lua_State* L) { int SWIG_arg = 0; int result; SWIG_check_num_args("ofGetViewportHeight",0,0)
  result = (int)ofGetViewportHeight(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_setupScreenPerspective__SWIG_0(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ;
  float arg4 ; float arg5 ; SWIG_check_num_args("ofSetupScreenPerspective",5,5)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofSetupScreenPerspective",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofSetupScreenPerspective",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofSetupScreenPerspective",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofSetupScreenPerspective",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofSetupScreenPerspective",5,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  arg5 = (float)lua_tonumber(L, 5); ofSetupScreenPerspective(arg1,arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_setupScreenPerspective__SWIG_1(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ;
  float arg4 ; SWIG_check_num_args("ofSetupScreenPerspective",4,4)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofSetupScreenPerspective",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofSetupScreenPerspective",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofSetupScreenPerspective",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofSetupScreenPerspective",4,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  ofSetupScreenPerspective(arg1,arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_setupScreenPerspective__SWIG_2(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ;
  SWIG_check_num_args("ofSetupScreenPerspective",3,3)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofSetupScreenPerspective",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofSetupScreenPerspective",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofSetupScreenPerspective",3,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); ofSetupScreenPerspective(arg1,arg2,arg3); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_setupScreenPerspective__SWIG_3(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ;
  SWIG_check_num_args("ofSetupScreenPerspective",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofSetupScreenPerspective",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofSetupScreenPerspective",2,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); ofSetupScreenPerspective(arg1,arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_setupScreenPerspective__SWIG_4(lua_State* L) { int SWIG_arg = 0; float arg1 ;
  SWIG_check_num_args("ofSetupScreenPerspective",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofSetupScreenPerspective",1,"float"); arg1 = (float)lua_tonumber(L, 1);
  ofSetupScreenPerspective(arg1); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_setupScreenPerspective__SWIG_5(lua_State* L) { int SWIG_arg = 0;
  SWIG_check_num_args("ofSetupScreenPerspective",0,0) ofSetupScreenPerspective(); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_setupScreenPerspective(lua_State* L) { int argc; int argv[6]={ 1,2,3,4,5,6} ; argc = lua_gettop(L);
  if (argc == 0) { return _wrap_setupScreenPerspective__SWIG_5(L);}  if (argc == 1) { int _v; { _v = lua_isnumber(L,argv[0]); } 
    if (_v) { return _wrap_setupScreenPerspective__SWIG_4(L);}  }  if (argc == 2) { int _v; { _v = lua_isnumber(L,argv[0]); } 
    if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { return _wrap_setupScreenPerspective__SWIG_3(L);}  }  } 
  if (argc == 3) { int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { {
          _v = lua_isnumber(L,argv[2]); }  if (_v) { return _wrap_setupScreenPerspective__SWIG_2(L);}  }  }  }  if (argc == 4) {
    int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { {
          _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) {
            return _wrap_setupScreenPerspective__SWIG_1(L);}  }  }  }  }  if (argc == 5) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); } 
        if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) {
              return _wrap_setupScreenPerspective__SWIG_0(L);}  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'setupScreenPerspective'\n"
  "  Possible C/C++ prototypes are:\n" "    ofSetupScreenPerspective(float,float,float,float,float)\n"
  "    ofSetupScreenPerspective(float,float,float,float)\n" "    ofSetupScreenPerspective(float,float,float)\n"
  "    ofSetupScreenPerspective(float,float)\n" "    ofSetupScreenPerspective(float)\n" "    ofSetupScreenPerspective()\n");
  lua_error(L);return 0; }
static int _wrap_setupScreenOrtho__SWIG_0(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ; float arg4 ;
  SWIG_check_num_args("ofSetupScreenOrtho",4,4) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofSetupScreenOrtho",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofSetupScreenOrtho",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofSetupScreenOrtho",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofSetupScreenOrtho",4,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  ofSetupScreenOrtho(arg1,arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_setupScreenOrtho__SWIG_1(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ;
  SWIG_check_num_args("ofSetupScreenOrtho",3,3) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofSetupScreenOrtho",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofSetupScreenOrtho",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofSetupScreenOrtho",3,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); ofSetupScreenOrtho(arg1,arg2,arg3); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_setupScreenOrtho__SWIG_2(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ;
  SWIG_check_num_args("ofSetupScreenOrtho",2,2) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofSetupScreenOrtho",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofSetupScreenOrtho",2,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); ofSetupScreenOrtho(arg1,arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_setupScreenOrtho__SWIG_3(lua_State* L) { int SWIG_arg = 0; float arg1 ;
  SWIG_check_num_args("ofSetupScreenOrtho",1,1) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofSetupScreenOrtho",1,"float");
  arg1 = (float)lua_tonumber(L, 1); ofSetupScreenOrtho(arg1); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_setupScreenOrtho__SWIG_4(lua_State* L) { int SWIG_arg = 0; SWIG_check_num_args("ofSetupScreenOrtho",0,0)
  ofSetupScreenOrtho(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_setupScreenOrtho(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L); if (argc == 0) {
    return _wrap_setupScreenOrtho__SWIG_4(L);}  if (argc == 1) { int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) {
      return _wrap_setupScreenOrtho__SWIG_3(L);}  }  if (argc == 2) { int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { {
        _v = lua_isnumber(L,argv[1]); }  if (_v) { return _wrap_setupScreenOrtho__SWIG_2(L);}  }  }  if (argc == 3) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); } 
        if (_v) { return _wrap_setupScreenOrtho__SWIG_1(L);}  }  }  }  if (argc == 4) { int _v; { _v = lua_isnumber(L,argv[0]); }
     if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { {
            _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_setupScreenOrtho__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'setupScreenOrtho'\n" "  Possible C/C++ prototypes are:\n"
  "    ofSetupScreenOrtho(float,float,float,float)\n" "    ofSetupScreenOrtho(float,float,float)\n"
  "    ofSetupScreenOrtho(float,float)\n" "    ofSetupScreenOrtho(float)\n" "    ofSetupScreenOrtho()\n");
  lua_error(L);return 0; }
static int _wrap_orientationToDegrees(lua_State* L) { int SWIG_arg = 0; ofOrientation arg1 ; int result;
  SWIG_check_num_args("ofOrientationToDegrees",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofOrientationToDegrees",1,"ofOrientation");
  arg1 = (ofOrientation)(int)lua_tonumber(L, 1); result = (int)ofOrientationToDegrees(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_setCoordHandedness(lua_State* L) { int SWIG_arg = 0; ofHandednessType arg1 ;
  SWIG_check_num_args("ofSetCoordHandedness",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofSetCoordHandedness",1,"ofHandednessType");
  arg1 = (ofHandednessType)(int)lua_tonumber(L, 1); ofSetCoordHandedness(arg1); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_getCoordHandedness(lua_State* L) { int SWIG_arg = 0; ofHandednessType result;
  SWIG_check_num_args("ofGetCoordHandedness",0,0) result = (ofHandednessType)ofGetCoordHandedness();
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_beginSaveScreenAsPDF__SWIG_0(lua_State* L) { int SWIG_arg = 0; std::string arg1 ; bool arg2 ; bool arg3 ;
  ofRectangle arg4 ; ofRectangle *argp4 ; SWIG_check_num_args("ofBeginSaveScreenAsPDF",4,4)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofBeginSaveScreenAsPDF",1,"std::string");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofBeginSaveScreenAsPDF",2,"bool");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("ofBeginSaveScreenAsPDF",3,"bool");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("ofBeginSaveScreenAsPDF",4,"ofRectangle");
  (&arg1)->assign(lua_tostring(L,1),lua_rawlen(L,1)); arg2 = (lua_toboolean(L, 2)!=0); arg3 = (lua_toboolean(L, 3)!=0);
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&argp4,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("beginSaveScreenAsPDF",4,SWIGTYPE_p_ofRectangle); }  arg4 = *argp4;
  ofBeginSaveScreenAsPDF(arg1,arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_beginSaveScreenAsPDF__SWIG_1(lua_State* L) { int SWIG_arg = 0; std::string arg1 ; bool arg2 ; bool arg3 ;
  SWIG_check_num_args("ofBeginSaveScreenAsPDF",3,3)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofBeginSaveScreenAsPDF",1,"std::string");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofBeginSaveScreenAsPDF",2,"bool");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("ofBeginSaveScreenAsPDF",3,"bool"); (&arg1)->assign(lua_tostring(L,1),lua_rawlen(L,1));
  arg2 = (lua_toboolean(L, 2)!=0); arg3 = (lua_toboolean(L, 3)!=0); ofBeginSaveScreenAsPDF(arg1,arg2,arg3); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_beginSaveScreenAsPDF__SWIG_2(lua_State* L) { int SWIG_arg = 0; std::string arg1 ; bool arg2 ;
  SWIG_check_num_args("ofBeginSaveScreenAsPDF",2,2)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofBeginSaveScreenAsPDF",1,"std::string");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofBeginSaveScreenAsPDF",2,"bool"); (&arg1)->assign(lua_tostring(L,1),lua_rawlen(L,1));
  arg2 = (lua_toboolean(L, 2)!=0); ofBeginSaveScreenAsPDF(arg1,arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_beginSaveScreenAsPDF__SWIG_3(lua_State* L) { int SWIG_arg = 0; std::string arg1 ;
  SWIG_check_num_args("ofBeginSaveScreenAsPDF",1,1)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofBeginSaveScreenAsPDF",1,"std::string");
  (&arg1)->assign(lua_tostring(L,1),lua_rawlen(L,1)); ofBeginSaveScreenAsPDF(arg1); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_beginSaveScreenAsPDF(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L);
  if (argc == 1) { int _v; { _v = lua_isstring(L,argv[0]); }  if (_v) { return _wrap_beginSaveScreenAsPDF__SWIG_3(L);}  } 
  if (argc == 2) { int _v; { _v = lua_isstring(L,argv[0]); }  if (_v) { { _v = lua_isboolean(L,argv[1]); }  if (_v) {
        return _wrap_beginSaveScreenAsPDF__SWIG_2(L);}  }  }  if (argc == 3) { int _v; { _v = lua_isstring(L,argv[0]); } 
    if (_v) { { _v = lua_isboolean(L,argv[1]); }  if (_v) { { _v = lua_isboolean(L,argv[2]); }  if (_v) {
          return _wrap_beginSaveScreenAsPDF__SWIG_1(L);}  }  }  }  if (argc == 4) { int _v; { _v = lua_isstring(L,argv[0]); } 
    if (_v) { { _v = lua_isboolean(L,argv[1]); }  if (_v) { { _v = lua_isboolean(L,argv[2]); }  if (_v) { { void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) {
              _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_beginSaveScreenAsPDF__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'beginSaveScreenAsPDF'\n"
  "  Possible C/C++ prototypes are:\n" "    ofBeginSaveScreenAsPDF(std::string,bool,bool,ofRectangle)\n"
  "    ofBeginSaveScreenAsPDF(std::string,bool,bool)\n" "    ofBeginSaveScreenAsPDF(std::string,bool)\n"
  "    ofBeginSaveScreenAsPDF(std::string)\n"); lua_error(L);return 0; }
static int _wrap_endSaveScreenAsPDF(lua_State* L) { int SWIG_arg = 0; SWIG_check_num_args("ofEndSaveScreenAsPDF",0,0)
  ofEndSaveScreenAsPDF(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_beginSaveScreenAsSVG__SWIG_0(lua_State* L) { int SWIG_arg = 0; std::string arg1 ; bool arg2 ; bool arg3 ;
  ofRectangle arg4 ; ofRectangle *argp4 ; SWIG_check_num_args("ofBeginSaveScreenAsSVG",4,4)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofBeginSaveScreenAsSVG",1,"std::string");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofBeginSaveScreenAsSVG",2,"bool");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("ofBeginSaveScreenAsSVG",3,"bool");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("ofBeginSaveScreenAsSVG",4,"ofRectangle");
  (&arg1)->assign(lua_tostring(L,1),lua_rawlen(L,1)); arg2 = (lua_toboolean(L, 2)!=0); arg3 = (lua_toboolean(L, 3)!=0);
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&argp4,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("beginSaveScreenAsSVG",4,SWIGTYPE_p_ofRectangle); }  arg4 = *argp4;
  ofBeginSaveScreenAsSVG(arg1,arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_beginSaveScreenAsSVG__SWIG_1(lua_State* L) { int SWIG_arg = 0; std::string arg1 ; bool arg2 ; bool arg3 ;
  SWIG_check_num_args("ofBeginSaveScreenAsSVG",3,3)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofBeginSaveScreenAsSVG",1,"std::string");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofBeginSaveScreenAsSVG",2,"bool");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("ofBeginSaveScreenAsSVG",3,"bool"); (&arg1)->assign(lua_tostring(L,1),lua_rawlen(L,1));
  arg2 = (lua_toboolean(L, 2)!=0); arg3 = (lua_toboolean(L, 3)!=0); ofBeginSaveScreenAsSVG(arg1,arg2,arg3); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_beginSaveScreenAsSVG__SWIG_2(lua_State* L) { int SWIG_arg = 0; std::string arg1 ; bool arg2 ;
  SWIG_check_num_args("ofBeginSaveScreenAsSVG",2,2)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofBeginSaveScreenAsSVG",1,"std::string");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofBeginSaveScreenAsSVG",2,"bool"); (&arg1)->assign(lua_tostring(L,1),lua_rawlen(L,1));
  arg2 = (lua_toboolean(L, 2)!=0); ofBeginSaveScreenAsSVG(arg1,arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_beginSaveScreenAsSVG__SWIG_3(lua_State* L) { int SWIG_arg = 0; std::string arg1 ;
  SWIG_check_num_args("ofBeginSaveScreenAsSVG",1,1)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofBeginSaveScreenAsSVG",1,"std::string");
  (&arg1)->assign(lua_tostring(L,1),lua_rawlen(L,1)); ofBeginSaveScreenAsSVG(arg1); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_beginSaveScreenAsSVG(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L);
  if (argc == 1) { int _v; { _v = lua_isstring(L,argv[0]); }  if (_v) { return _wrap_beginSaveScreenAsSVG__SWIG_3(L);}  } 
  if (argc == 2) { int _v; { _v = lua_isstring(L,argv[0]); }  if (_v) { { _v = lua_isboolean(L,argv[1]); }  if (_v) {
        return _wrap_beginSaveScreenAsSVG__SWIG_2(L);}  }  }  if (argc == 3) { int _v; { _v = lua_isstring(L,argv[0]); } 
    if (_v) { { _v = lua_isboolean(L,argv[1]); }  if (_v) { { _v = lua_isboolean(L,argv[2]); }  if (_v) {
          return _wrap_beginSaveScreenAsSVG__SWIG_1(L);}  }  }  }  if (argc == 4) { int _v; { _v = lua_isstring(L,argv[0]); } 
    if (_v) { { _v = lua_isboolean(L,argv[1]); }  if (_v) { { _v = lua_isboolean(L,argv[2]); }  if (_v) { { void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) {
              _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_beginSaveScreenAsSVG__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'beginSaveScreenAsSVG'\n"
  "  Possible C/C++ prototypes are:\n" "    ofBeginSaveScreenAsSVG(std::string,bool,bool,ofRectangle)\n"
  "    ofBeginSaveScreenAsSVG(std::string,bool,bool)\n" "    ofBeginSaveScreenAsSVG(std::string,bool)\n"
  "    ofBeginSaveScreenAsSVG(std::string)\n"); lua_error(L);return 0; }
static int _wrap_endSaveScreenAsSVG(lua_State* L) { int SWIG_arg = 0; SWIG_check_num_args("ofEndSaveScreenAsSVG",0,0)
  ofEndSaveScreenAsSVG(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_setPlaneResolution(lua_State* L) { int SWIG_arg = 0; int arg1 ; int arg2 ;
  SWIG_check_num_args("ofSetPlaneResolution",2,2) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofSetPlaneResolution",1,"int");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofSetPlaneResolution",2,"int"); arg1 = (int)lua_tonumber(L, 1);
  arg2 = (int)lua_tonumber(L, 2); ofSetPlaneResolution(arg1,arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_getPlaneResolution(lua_State* L) { int SWIG_arg = 0; glm::vec2 result;
  SWIG_check_num_args("ofGetPlaneResolution",0,0) result = ofGetPlaneResolution(); {
    glm::vec2 * resultptr = new glm::vec2((const glm::vec2 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_glm__vec2,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_drawPlane__SWIG_0(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ; float arg4 ;
  SWIG_check_num_args("ofDrawPlane",4,4) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofDrawPlane",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofDrawPlane",2,"float"); if(!lua_isnumber(L,3)) SWIG_fail_arg("ofDrawPlane",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofDrawPlane",4,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  ofDrawPlane(arg1,arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_drawPlane__SWIG_1(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ; float arg4 ;
  float arg5 ; SWIG_check_num_args("ofDrawPlane",5,5) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofDrawPlane",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofDrawPlane",2,"float"); if(!lua_isnumber(L,3)) SWIG_fail_arg("ofDrawPlane",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofDrawPlane",4,"float"); if(!lua_isnumber(L,5)) SWIG_fail_arg("ofDrawPlane",5,"float");
  arg1 = (float)lua_tonumber(L, 1); arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4); arg5 = (float)lua_tonumber(L, 5); ofDrawPlane(arg1,arg2,arg3,arg4,arg5); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_drawPlane__SWIG_2(lua_State* L) { int SWIG_arg = 0; glm::vec3 *arg1 = 0 ; float arg2 ; float arg3 ;
  SWIG_check_num_args("ofDrawPlane",3,3) if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofDrawPlane",1,"glm::vec3 &");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofDrawPlane",2,"float"); if(!lua_isnumber(L,3)) SWIG_fail_arg("ofDrawPlane",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("drawPlane",1,SWIGTYPE_p_glm__vec3); }  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3);
  ofDrawPlane(*arg1,arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_drawPlane__SWIG_3(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ;
  SWIG_check_num_args("ofDrawPlane",2,2) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofDrawPlane",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofDrawPlane",2,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); ofDrawPlane(arg1,arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_drawPlane(lua_State* L) { int argc; int argv[6]={ 1,2,3,4,5,6} ; argc = lua_gettop(L); if (argc == 2) { int _v;
    { _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { return _wrap_drawPlane__SWIG_3(L);}
       }  }  if (argc == 3) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_drawPlane__SWIG_2(L);}  }  }  }  if (argc == 4) { int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { {
        _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); }
           if (_v) { return _wrap_drawPlane__SWIG_0(L);}  }  }  }  }  if (argc == 5) { int _v; { _v = lua_isnumber(L,argv[0]); }
     if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { {
            _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) {
              return _wrap_drawPlane__SWIG_1(L);}  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'drawPlane'\n" "  Possible C/C++ prototypes are:\n"
  "    ofDrawPlane(float,float,float,float)\n" "    ofDrawPlane(float,float,float,float,float)\n"
  "    ofDrawPlane(glm::vec3 &,float,float)\n" "    ofDrawPlane(float,float)\n"); lua_error(L);return 0; }
static int _wrap_setSphereResolution(lua_State* L) { int SWIG_arg = 0; int arg1 ;
  SWIG_check_num_args("ofSetSphereResolution",1,1) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofSetSphereResolution",1,"int");
  arg1 = (int)lua_tonumber(L, 1); ofSetSphereResolution(arg1); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_getSphereResolution(lua_State* L) { int SWIG_arg = 0; int result;
  SWIG_check_num_args("ofGetSphereResolution",0,0) result = (int)ofGetSphereResolution();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_drawSphere__SWIG_0(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ;
  SWIG_check_num_args("ofDrawSphere",3,3) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofDrawSphere",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofDrawSphere",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofDrawSphere",3,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); ofDrawSphere(arg1,arg2,arg3); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_drawSphere__SWIG_1(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ; float arg4 ;
  SWIG_check_num_args("ofDrawSphere",4,4) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofDrawSphere",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofDrawSphere",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofDrawSphere",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofDrawSphere",4,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  ofDrawSphere(arg1,arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_drawSphere__SWIG_2(lua_State* L) { int SWIG_arg = 0; glm::vec3 *arg1 = 0 ; float arg2 ;
  SWIG_check_num_args("ofDrawSphere",2,2) if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofDrawSphere",1,"glm::vec3 const &");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofDrawSphere",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("drawSphere",1,SWIGTYPE_p_glm__vec3); }  arg2 = (float)lua_tonumber(L, 2);
  ofDrawSphere((glm::vec3 const &)*arg1,arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_drawSphere__SWIG_3(lua_State* L) { int SWIG_arg = 0; float arg1 ; SWIG_check_num_args("ofDrawSphere",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofDrawSphere",1,"float"); arg1 = (float)lua_tonumber(L, 1); ofDrawSphere(arg1);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_drawSphere(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L); if (argc == 1) { int _v;
    { _v = lua_isnumber(L,argv[0]); }  if (_v) { return _wrap_drawSphere__SWIG_3(L);}  }  if (argc == 2) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { return _wrap_drawSphere__SWIG_2(L);}  }  } 
  if (argc == 3) { int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { {
          _v = lua_isnumber(L,argv[2]); }  if (_v) { return _wrap_drawSphere__SWIG_0(L);}  }  }  }  if (argc == 4) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); } 
        if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_drawSphere__SWIG_1(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'drawSphere'\n" "  Possible C/C++ prototypes are:\n"
  "    ofDrawSphere(float,float,float)\n" "    ofDrawSphere(float,float,float,float)\n"
  "    ofDrawSphere(glm::vec3 const &,float)\n" "    ofDrawSphere(float)\n"); lua_error(L);return 0; }
static int _wrap_setIcoSphereResolution(lua_State* L) { int SWIG_arg = 0; int arg1 ;
  SWIG_check_num_args("ofSetIcoSphereResolution",1,1) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofSetIcoSphereResolution",1,"int");
  arg1 = (int)lua_tonumber(L, 1); ofSetIcoSphereResolution(arg1); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_getIcoSphereResolution(lua_State* L) { int SWIG_arg = 0; int result;
  SWIG_check_num_args("ofGetIcoSphereResolution",0,0) result = (int)ofGetIcoSphereResolution();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_drawIcoSphere__SWIG_0(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ; float arg4 ;
  SWIG_check_num_args("ofDrawIcoSphere",4,4) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofDrawIcoSphere",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofDrawIcoSphere",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofDrawIcoSphere",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofDrawIcoSphere",4,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  ofDrawIcoSphere(arg1,arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_drawIcoSphere__SWIG_1(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ;
  SWIG_check_num_args("ofDrawIcoSphere",3,3) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofDrawIcoSphere",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofDrawIcoSphere",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofDrawIcoSphere",3,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); ofDrawIcoSphere(arg1,arg2,arg3); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_drawIcoSphere__SWIG_2(lua_State* L) { int SWIG_arg = 0; glm::vec3 *arg1 = 0 ; float arg2 ;
  SWIG_check_num_args("ofDrawIcoSphere",2,2) if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofDrawIcoSphere",1,"glm::vec3 const &");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofDrawIcoSphere",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("drawIcoSphere",1,SWIGTYPE_p_glm__vec3); }  arg2 = (float)lua_tonumber(L, 2);
  ofDrawIcoSphere((glm::vec3 const &)*arg1,arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_drawIcoSphere__SWIG_3(lua_State* L) { int SWIG_arg = 0; float arg1 ; SWIG_check_num_args("ofDrawIcoSphere",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofDrawIcoSphere",1,"float"); arg1 = (float)lua_tonumber(L, 1); ofDrawIcoSphere(arg1);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_drawIcoSphere(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L); if (argc == 1) {
    int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { return _wrap_drawIcoSphere__SWIG_3(L);}  }  if (argc == 2) { int _v; {
      void *ptr; if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_drawIcoSphere__SWIG_2(L);}  }  }  if (argc == 3) { int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { {
        _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_drawIcoSphere__SWIG_1(L);}  }  }  }  if (argc == 4) { int _v; { _v = lua_isnumber(L,argv[0]); } 
    if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { {
            _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_drawIcoSphere__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'drawIcoSphere'\n" "  Possible C/C++ prototypes are:\n"
  "    ofDrawIcoSphere(float,float,float,float)\n" "    ofDrawIcoSphere(float,float,float)\n"
  "    ofDrawIcoSphere(glm::vec3 const &,float)\n" "    ofDrawIcoSphere(float)\n"); lua_error(L);return 0; }
static int _wrap_setCylinderResolution__SWIG_0(lua_State* L) { int SWIG_arg = 0; int arg1 ; int arg2 ; int arg3 ;
  SWIG_check_num_args("ofSetCylinderResolution",3,3) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofSetCylinderResolution",1,"int");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofSetCylinderResolution",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofSetCylinderResolution",3,"int"); arg1 = (int)lua_tonumber(L, 1);
  arg2 = (int)lua_tonumber(L, 2); arg3 = (int)lua_tonumber(L, 3); ofSetCylinderResolution(arg1,arg2,arg3); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_setCylinderResolution__SWIG_1(lua_State* L) { int SWIG_arg = 0; int arg1 ; int arg2 ;
  SWIG_check_num_args("ofSetCylinderResolution",2,2) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofSetCylinderResolution",1,"int");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofSetCylinderResolution",2,"int"); arg1 = (int)lua_tonumber(L, 1);
  arg2 = (int)lua_tonumber(L, 2); ofSetCylinderResolution(arg1,arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_setCylinderResolution(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_setCylinderResolution__SWIG_1(L);}  }  }  if (argc == 3) { int _v; { _v = lua_isnumber(L,argv[0]); } 
    if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_setCylinderResolution__SWIG_0(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'setCylinderResolution'\n"
  "  Possible C/C++ prototypes are:\n" "    ofSetCylinderResolution(int,int,int)\n" "    ofSetCylinderResolution(int,int)\n");
  lua_error(L);return 0; }
static int _wrap_getCylinderResolution(lua_State* L) { int SWIG_arg = 0; glm::vec3 result;
  SWIG_check_num_args("ofGetCylinderResolution",0,0) result = ofGetCylinderResolution(); {
    glm::vec3 * resultptr = new glm::vec3((const glm::vec3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_glm__vec3,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_drawCylinder__SWIG_0(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ; float arg4 ;
  SWIG_check_num_args("ofDrawCylinder",4,4) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofDrawCylinder",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofDrawCylinder",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofDrawCylinder",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofDrawCylinder",4,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  ofDrawCylinder(arg1,arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_drawCylinder__SWIG_1(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ; float arg4 ;
  float arg5 ; SWIG_check_num_args("ofDrawCylinder",5,5) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofDrawCylinder",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofDrawCylinder",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofDrawCylinder",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofDrawCylinder",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofDrawCylinder",5,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  arg5 = (float)lua_tonumber(L, 5); ofDrawCylinder(arg1,arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_drawCylinder__SWIG_2(lua_State* L) { int SWIG_arg = 0; glm::vec3 *arg1 = 0 ; float arg2 ; float arg3 ;
  SWIG_check_num_args("ofDrawCylinder",3,3) if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofDrawCylinder",1,"glm::vec3 const &");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofDrawCylinder",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofDrawCylinder",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("drawCylinder",1,SWIGTYPE_p_glm__vec3); }  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3);
  ofDrawCylinder((glm::vec3 const &)*arg1,arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_drawCylinder__SWIG_3(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ;
  SWIG_check_num_args("ofDrawCylinder",2,2) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofDrawCylinder",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofDrawCylinder",2,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); ofDrawCylinder(arg1,arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_drawCylinder(lua_State* L) { int argc; int argv[6]={ 1,2,3,4,5,6} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_drawCylinder__SWIG_3(L);}  }  }  if (argc == 3) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_drawCylinder__SWIG_2(L);}  }  }  }  if (argc == 4) { int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) {
      { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); }
           if (_v) { return _wrap_drawCylinder__SWIG_0(L);}  }  }  }  }  if (argc == 5) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); } 
        if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) {
              return _wrap_drawCylinder__SWIG_1(L);}  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'drawCylinder'\n" "  Possible C/C++ prototypes are:\n"
  "    ofDrawCylinder(float,float,float,float)\n" "    ofDrawCylinder(float,float,float,float,float)\n"
  "    ofDrawCylinder(glm::vec3 const &,float,float)\n" "    ofDrawCylinder(float,float)\n"); lua_error(L);return 0; }
static int _wrap_setConeResolution__SWIG_0(lua_State* L) { int SWIG_arg = 0; int arg1 ; int arg2 ; int arg3 ;
  SWIG_check_num_args("ofSetConeResolution",3,3) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofSetConeResolution",1,"int");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofSetConeResolution",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofSetConeResolution",3,"int"); arg1 = (int)lua_tonumber(L, 1);
  arg2 = (int)lua_tonumber(L, 2); arg3 = (int)lua_tonumber(L, 3); ofSetConeResolution(arg1,arg2,arg3); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_setConeResolution__SWIG_1(lua_State* L) { int SWIG_arg = 0; int arg1 ; int arg2 ;
  SWIG_check_num_args("ofSetConeResolution",2,2) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofSetConeResolution",1,"int");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofSetConeResolution",2,"int"); arg1 = (int)lua_tonumber(L, 1);
  arg2 = (int)lua_tonumber(L, 2); ofSetConeResolution(arg1,arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_setConeResolution(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_setConeResolution__SWIG_1(L);}  }  }  if (argc == 3) { int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) {
      { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_setConeResolution__SWIG_0(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'setConeResolution'\n" "  Possible C/C++ prototypes are:\n"
  "    ofSetConeResolution(int,int,int)\n" "    ofSetConeResolution(int,int)\n"); lua_error(L);return 0; }
static int _wrap_getConeResolution(lua_State* L) { int SWIG_arg = 0; glm::vec3 result;
  SWIG_check_num_args("ofGetConeResolution",0,0) result = ofGetConeResolution(); {
    glm::vec3 * resultptr = new glm::vec3((const glm::vec3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_glm__vec3,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_drawCone__SWIG_0(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ; float arg4 ;
  float arg5 ; SWIG_check_num_args("ofDrawCone",5,5) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofDrawCone",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofDrawCone",2,"float"); if(!lua_isnumber(L,3)) SWIG_fail_arg("ofDrawCone",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofDrawCone",4,"float"); if(!lua_isnumber(L,5)) SWIG_fail_arg("ofDrawCone",5,"float");
  arg1 = (float)lua_tonumber(L, 1); arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4); arg5 = (float)lua_tonumber(L, 5); ofDrawCone(arg1,arg2,arg3,arg4,arg5); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_drawCone__SWIG_1(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ; float arg4 ;
  SWIG_check_num_args("ofDrawCone",4,4) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofDrawCone",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofDrawCone",2,"float"); if(!lua_isnumber(L,3)) SWIG_fail_arg("ofDrawCone",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofDrawCone",4,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  ofDrawCone(arg1,arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_drawCone__SWIG_2(lua_State* L) { int SWIG_arg = 0; glm::vec3 *arg1 = 0 ; float arg2 ; float arg3 ;
  SWIG_check_num_args("ofDrawCone",3,3) if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofDrawCone",1,"glm::vec3 const &");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofDrawCone",2,"float"); if(!lua_isnumber(L,3)) SWIG_fail_arg("ofDrawCone",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glm__vec3,0))){ SWIG_fail_ptr("drawCone",1,SWIGTYPE_p_glm__vec3); }
   arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); ofDrawCone((glm::vec3 const &)*arg1,arg2,arg3);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_drawCone__SWIG_3(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ;
  SWIG_check_num_args("ofDrawCone",2,2) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofDrawCone",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofDrawCone",2,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); ofDrawCone(arg1,arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_drawCone(lua_State* L) { int argc; int argv[6]={ 1,2,3,4,5,6} ; argc = lua_gettop(L); if (argc == 2) { int _v;
    { _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { return _wrap_drawCone__SWIG_3(L);}
       }  }  if (argc == 3) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_drawCone__SWIG_2(L);}  }  }  }  if (argc == 4) { int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { {
        _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); }
           if (_v) { return _wrap_drawCone__SWIG_1(L);}  }  }  }  }  if (argc == 5) { int _v; { _v = lua_isnumber(L,argv[0]); } 
    if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { {
            _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) {
              return _wrap_drawCone__SWIG_0(L);}  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'drawCone'\n" "  Possible C/C++ prototypes are:\n"
  "    ofDrawCone(float,float,float,float,float)\n" "    ofDrawCone(float,float,float,float)\n"
  "    ofDrawCone(glm::vec3 const &,float,float)\n" "    ofDrawCone(float,float)\n"); lua_error(L);return 0; }
static int _wrap_setBoxResolution__SWIG_0(lua_State* L) { int SWIG_arg = 0; int arg1 ;
  SWIG_check_num_args("ofSetBoxResolution",1,1) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofSetBoxResolution",1,"int");
  arg1 = (int)lua_tonumber(L, 1); ofSetBoxResolution(arg1); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_setBoxResolution__SWIG_1(lua_State* L) { int SWIG_arg = 0; int arg1 ; int arg2 ; int arg3 ;
  SWIG_check_num_args("ofSetBoxResolution",3,3) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofSetBoxResolution",1,"int");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofSetBoxResolution",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofSetBoxResolution",3,"int"); arg1 = (int)lua_tonumber(L, 1);
  arg2 = (int)lua_tonumber(L, 2); arg3 = (int)lua_tonumber(L, 3); ofSetBoxResolution(arg1,arg2,arg3); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_setBoxResolution(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 1) {
    int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { return _wrap_setBoxResolution__SWIG_0(L);}  }  if (argc == 3) { int _v;
    { _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); } 
        if (_v) { return _wrap_setBoxResolution__SWIG_1(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'setBoxResolution'\n" "  Possible C/C++ prototypes are:\n"
  "    ofSetBoxResolution(int)\n" "    ofSetBoxResolution(int,int,int)\n"); lua_error(L);return 0; }
static int _wrap_getBoxResolution(lua_State* L) { int SWIG_arg = 0; glm::vec3 result;
  SWIG_check_num_args("ofGetBoxResolution",0,0) result = ofGetBoxResolution(); {
    glm::vec3 * resultptr = new glm::vec3((const glm::vec3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_glm__vec3,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_drawBox__SWIG_0(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ; float arg4 ;
  float arg5 ; float arg6 ; SWIG_check_num_args("ofDrawBox",6,6) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofDrawBox",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofDrawBox",2,"float"); if(!lua_isnumber(L,3)) SWIG_fail_arg("ofDrawBox",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofDrawBox",4,"float"); if(!lua_isnumber(L,5)) SWIG_fail_arg("ofDrawBox",5,"float");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofDrawBox",6,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  arg5 = (float)lua_tonumber(L, 5); arg6 = (float)lua_tonumber(L, 6); ofDrawBox(arg1,arg2,arg3,arg4,arg5,arg6); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_drawBox__SWIG_1(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ; float arg4 ;
  SWIG_check_num_args("ofDrawBox",4,4) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofDrawBox",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofDrawBox",2,"float"); if(!lua_isnumber(L,3)) SWIG_fail_arg("ofDrawBox",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofDrawBox",4,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  ofDrawBox(arg1,arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_drawBox__SWIG_2(lua_State* L) { int SWIG_arg = 0; glm::vec3 *arg1 = 0 ; float arg2 ; float arg3 ; float arg4 ;
  SWIG_check_num_args("ofDrawBox",4,4) if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofDrawBox",1,"glm::vec3 const &");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofDrawBox",2,"float"); if(!lua_isnumber(L,3)) SWIG_fail_arg("ofDrawBox",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofDrawBox",4,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glm__vec3,0))){ SWIG_fail_ptr("drawBox",1,SWIGTYPE_p_glm__vec3); }
   arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  ofDrawBox((glm::vec3 const &)*arg1,arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_drawBox__SWIG_3(lua_State* L) { int SWIG_arg = 0; glm::vec3 *arg1 = 0 ; float arg2 ;
  SWIG_check_num_args("ofDrawBox",2,2) if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofDrawBox",1,"glm::vec3 const &");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofDrawBox",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glm__vec3,0))){ SWIG_fail_ptr("drawBox",1,SWIGTYPE_p_glm__vec3); }
   arg2 = (float)lua_tonumber(L, 2); ofDrawBox((glm::vec3 const &)*arg1,arg2); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_drawBox__SWIG_4(lua_State* L) { int SWIG_arg = 0; float arg1 ; SWIG_check_num_args("ofDrawBox",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofDrawBox",1,"float"); arg1 = (float)lua_tonumber(L, 1); ofDrawBox(arg1);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_drawBox__SWIG_5(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ;
  SWIG_check_num_args("ofDrawBox",3,3) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofDrawBox",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofDrawBox",2,"float"); if(!lua_isnumber(L,3)) SWIG_fail_arg("ofDrawBox",3,"float");
  arg1 = (float)lua_tonumber(L, 1); arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3);
  ofDrawBox(arg1,arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_drawBox(lua_State* L) { int argc; int argv[7]={ 1,2,3,4,5,6,7} ; argc = lua_gettop(L); if (argc == 1) { int _v;
    { _v = lua_isnumber(L,argv[0]); }  if (_v) { return _wrap_drawBox__SWIG_4(L);}  }  if (argc == 2) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { return _wrap_drawBox__SWIG_3(L);}  }  } 
  if (argc == 3) { int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { {
          _v = lua_isnumber(L,argv[2]); }  if (_v) { return _wrap_drawBox__SWIG_5(L);}  }  }  }  if (argc == 4) { int _v; {
      void *ptr; if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_drawBox__SWIG_2(L);}  }  }  }  }  if (argc == 4) {
    int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { {
          _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) {
            return _wrap_drawBox__SWIG_1(L);}  }  }  }  }  if (argc == 6) { int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) {
      { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); }
           if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) { { _v = lua_isnumber(L,argv[5]); }  if (_v) {
                return _wrap_drawBox__SWIG_0(L);}  }  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'drawBox'\n" "  Possible C/C++ prototypes are:\n"
  "    ofDrawBox(float,float,float,float,float,float)\n" "    ofDrawBox(float,float,float,float)\n"
  "    ofDrawBox(glm::vec3 const &,float,float,float)\n" "    ofDrawBox(glm::vec3 const &,float)\n" "    ofDrawBox(float)\n"
  "    ofDrawBox(float,float,float)\n"); lua_error(L);return 0; }
static int _wrap_TTF_SANS_get(lua_State* L) { int SWIG_arg = 0; std::string *result = 0 ; SWIG_check_num_args("OF_TTF_SANS",0,0)
  result = (std::string *) &OF_TTF_SANS; lua_pushlstring(L,result->data(),result->size()); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TTF_SERIF_get(lua_State* L) { int SWIG_arg = 0; std::string *result = 0 ;
  SWIG_check_num_args("OF_TTF_SERIF",0,0) result = (std::string *) &OF_TTF_SERIF;
  lua_pushlstring(L,result->data(),result->size()); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_TTF_MONO_get(lua_State* L) { int SWIG_arg = 0; std::string *result = 0 ; SWIG_check_num_args("OF_TTF_MONO",0,0)
  result = (std::string *) &OF_TTF_MONO; lua_pushlstring(L,result->data(),result->size()); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_new_TrueTypeFont__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofTrueTypeFont *result = 0 ;
  SWIG_check_num_args("ofTrueTypeFont::ofTrueTypeFont",0,0) result = (ofTrueTypeFont *)new ofTrueTypeFont();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofTrueTypeFont,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_TrueTypeFont__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofTrueTypeFont *arg1 = 0 ;
  ofTrueTypeFont *result = 0 ; SWIG_check_num_args("ofTrueTypeFont::ofTrueTypeFont",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofTrueTypeFont::ofTrueTypeFont",1,"ofTrueTypeFont &&");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTrueTypeFont,0))){
    SWIG_fail_ptr("new_TrueTypeFont",1,SWIGTYPE_p_ofTrueTypeFont); } 
  result = (ofTrueTypeFont *)new ofTrueTypeFont((ofTrueTypeFont &&)*arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofTrueTypeFont,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_TrueTypeFont(lua_State* L) { int argc; int argv[2]={ 1,2} ; argc = lua_gettop(L); if (argc == 0) {
    return _wrap_new_TrueTypeFont__SWIG_0(L);}  if (argc == 1) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofTrueTypeFont, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { return _wrap_new_TrueTypeFont__SWIG_1(L);}  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_TrueTypeFont'\n" "  Possible C/C++ prototypes are:\n"
  "    ofTrueTypeFont::ofTrueTypeFont()\n" "    ofTrueTypeFont::ofTrueTypeFont(ofTrueTypeFont &&)\n"); lua_error(L);return 0; }
static int _wrap_TrueTypeFont_load__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofTrueTypeFont *arg1 = (ofTrueTypeFont *) 0 ;
  std::filesystem::path *arg2 = 0 ; int arg3 ; bool arg4 ; bool arg5 ; bool arg6 ; float arg7 ; int arg8 ;
  std::filesystem::path temp2 ; bool result; SWIG_check_num_args("ofTrueTypeFont::load",8,8)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTrueTypeFont::load",1,"ofTrueTypeFont *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofTrueTypeFont::load",2,"std::filesystem::path const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofTrueTypeFont::load",3,"int");
  if(!lua_isboolean(L,4)) SWIG_fail_arg("ofTrueTypeFont::load",4,"bool");
  if(!lua_isboolean(L,5)) SWIG_fail_arg("ofTrueTypeFont::load",5,"bool");
  if(!lua_isboolean(L,6)) SWIG_fail_arg("ofTrueTypeFont::load",6,"bool");
  if(!lua_isnumber(L,7)) SWIG_fail_arg("ofTrueTypeFont::load",7,"float");
  if(!lua_isnumber(L,8)) SWIG_fail_arg("ofTrueTypeFont::load",8,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTrueTypeFont,0))){
    SWIG_fail_ptr("TrueTypeFont_load",1,SWIGTYPE_p_ofTrueTypeFont); }  { size_t len = lua_rawlen(L, 2);
    temp2 = lua_tolstring(L, 2, &len); arg2 = &temp2; }  arg3 = (int)lua_tonumber(L, 3); arg4 = (lua_toboolean(L, 4)!=0);
  arg5 = (lua_toboolean(L, 5)!=0); arg6 = (lua_toboolean(L, 6)!=0); arg7 = (float)lua_tonumber(L, 7);
  arg8 = (int)lua_tonumber(L, 8);
  result = (bool)(arg1)->load((std::filesystem::path const &)*arg2,arg3,arg4,arg5,arg6,arg7,arg8);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TrueTypeFont_load__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofTrueTypeFont *arg1 = (ofTrueTypeFont *) 0 ;
  std::filesystem::path *arg2 = 0 ; int arg3 ; bool arg4 ; bool arg5 ; bool arg6 ; float arg7 ; std::filesystem::path temp2 ;
  bool result; SWIG_check_num_args("ofTrueTypeFont::load",7,7)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTrueTypeFont::load",1,"ofTrueTypeFont *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofTrueTypeFont::load",2,"std::filesystem::path const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofTrueTypeFont::load",3,"int");
  if(!lua_isboolean(L,4)) SWIG_fail_arg("ofTrueTypeFont::load",4,"bool");
  if(!lua_isboolean(L,5)) SWIG_fail_arg("ofTrueTypeFont::load",5,"bool");
  if(!lua_isboolean(L,6)) SWIG_fail_arg("ofTrueTypeFont::load",6,"bool");
  if(!lua_isnumber(L,7)) SWIG_fail_arg("ofTrueTypeFont::load",7,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTrueTypeFont,0))){
    SWIG_fail_ptr("TrueTypeFont_load",1,SWIGTYPE_p_ofTrueTypeFont); }  { size_t len = lua_rawlen(L, 2);
    temp2 = lua_tolstring(L, 2, &len); arg2 = &temp2; }  arg3 = (int)lua_tonumber(L, 3); arg4 = (lua_toboolean(L, 4)!=0);
  arg5 = (lua_toboolean(L, 5)!=0); arg6 = (lua_toboolean(L, 6)!=0); arg7 = (float)lua_tonumber(L, 7);
  result = (bool)(arg1)->load((std::filesystem::path const &)*arg2,arg3,arg4,arg5,arg6,arg7);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TrueTypeFont_load__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofTrueTypeFont *arg1 = (ofTrueTypeFont *) 0 ;
  std::filesystem::path *arg2 = 0 ; int arg3 ; bool arg4 ; bool arg5 ; bool arg6 ; std::filesystem::path temp2 ; bool result;
  SWIG_check_num_args("ofTrueTypeFont::load",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTrueTypeFont::load",1,"ofTrueTypeFont *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofTrueTypeFont::load",2,"std::filesystem::path const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofTrueTypeFont::load",3,"int");
  if(!lua_isboolean(L,4)) SWIG_fail_arg("ofTrueTypeFont::load",4,"bool");
  if(!lua_isboolean(L,5)) SWIG_fail_arg("ofTrueTypeFont::load",5,"bool");
  if(!lua_isboolean(L,6)) SWIG_fail_arg("ofTrueTypeFont::load",6,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTrueTypeFont,0))){
    SWIG_fail_ptr("TrueTypeFont_load",1,SWIGTYPE_p_ofTrueTypeFont); }  { size_t len = lua_rawlen(L, 2);
    temp2 = lua_tolstring(L, 2, &len); arg2 = &temp2; }  arg3 = (int)lua_tonumber(L, 3); arg4 = (lua_toboolean(L, 4)!=0);
  arg5 = (lua_toboolean(L, 5)!=0); arg6 = (lua_toboolean(L, 6)!=0);
  result = (bool)(arg1)->load((std::filesystem::path const &)*arg2,arg3,arg4,arg5,arg6);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TrueTypeFont_load__SWIG_3(lua_State* L) { int SWIG_arg = 0; ofTrueTypeFont *arg1 = (ofTrueTypeFont *) 0 ;
  std::filesystem::path *arg2 = 0 ; int arg3 ; bool arg4 ; bool arg5 ; std::filesystem::path temp2 ; bool result;
  SWIG_check_num_args("ofTrueTypeFont::load",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTrueTypeFont::load",1,"ofTrueTypeFont *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofTrueTypeFont::load",2,"std::filesystem::path const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofTrueTypeFont::load",3,"int");
  if(!lua_isboolean(L,4)) SWIG_fail_arg("ofTrueTypeFont::load",4,"bool");
  if(!lua_isboolean(L,5)) SWIG_fail_arg("ofTrueTypeFont::load",5,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTrueTypeFont,0))){
    SWIG_fail_ptr("TrueTypeFont_load",1,SWIGTYPE_p_ofTrueTypeFont); }  { size_t len = lua_rawlen(L, 2);
    temp2 = lua_tolstring(L, 2, &len); arg2 = &temp2; }  arg3 = (int)lua_tonumber(L, 3); arg4 = (lua_toboolean(L, 4)!=0);
  arg5 = (lua_toboolean(L, 5)!=0); result = (bool)(arg1)->load((std::filesystem::path const &)*arg2,arg3,arg4,arg5);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TrueTypeFont_load__SWIG_4(lua_State* L) { int SWIG_arg = 0; ofTrueTypeFont *arg1 = (ofTrueTypeFont *) 0 ;
  std::filesystem::path *arg2 = 0 ; int arg3 ; bool arg4 ; std::filesystem::path temp2 ; bool result;
  SWIG_check_num_args("ofTrueTypeFont::load",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTrueTypeFont::load",1,"ofTrueTypeFont *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofTrueTypeFont::load",2,"std::filesystem::path const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofTrueTypeFont::load",3,"int");
  if(!lua_isboolean(L,4)) SWIG_fail_arg("ofTrueTypeFont::load",4,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTrueTypeFont,0))){
    SWIG_fail_ptr("TrueTypeFont_load",1,SWIGTYPE_p_ofTrueTypeFont); }  { size_t len = lua_rawlen(L, 2);
    temp2 = lua_tolstring(L, 2, &len); arg2 = &temp2; }  arg3 = (int)lua_tonumber(L, 3); arg4 = (lua_toboolean(L, 4)!=0);
  result = (bool)(arg1)->load((std::filesystem::path const &)*arg2,arg3,arg4); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TrueTypeFont_load__SWIG_5(lua_State* L) { int SWIG_arg = 0; ofTrueTypeFont *arg1 = (ofTrueTypeFont *) 0 ;
  std::filesystem::path *arg2 = 0 ; int arg3 ; std::filesystem::path temp2 ; bool result;
  SWIG_check_num_args("ofTrueTypeFont::load",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTrueTypeFont::load",1,"ofTrueTypeFont *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofTrueTypeFont::load",2,"std::filesystem::path const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofTrueTypeFont::load",3,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTrueTypeFont,0))){
    SWIG_fail_ptr("TrueTypeFont_load",1,SWIGTYPE_p_ofTrueTypeFont); }  { size_t len = lua_rawlen(L, 2);
    temp2 = lua_tolstring(L, 2, &len); arg2 = &temp2; }  arg3 = (int)lua_tonumber(L, 3);
  result = (bool)(arg1)->load((std::filesystem::path const &)*arg2,arg3); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TrueTypeFont_load(lua_State* L) { int argc; int argv[9]={ 1,2,3,4,5,6,7,8,9} ; argc = lua_gettop(L);
  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofTrueTypeFont, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L, argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_TrueTypeFont_load__SWIG_5(L);}  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofTrueTypeFont, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L, argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          { _v = lua_isboolean(L,argv[3]); }  if (_v) { return _wrap_TrueTypeFont_load__SWIG_4(L);}  }  }  }  } 
  if (argc == 5) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofTrueTypeFont, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L, argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          { _v = lua_isboolean(L,argv[3]); }  if (_v) { { _v = lua_isboolean(L,argv[4]); }  if (_v) {
              return _wrap_TrueTypeFont_load__SWIG_3(L);}  }  }  }  }  }  if (argc == 6) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofTrueTypeFont, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L, argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          { _v = lua_isboolean(L,argv[3]); }  if (_v) { { _v = lua_isboolean(L,argv[4]); }  if (_v) { {
                _v = lua_isboolean(L,argv[5]); }  if (_v) { return _wrap_TrueTypeFont_load__SWIG_2(L);}  }  }  }  }  }  } 
  if (argc == 7) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofTrueTypeFont, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L, argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          { _v = lua_isboolean(L,argv[3]); }  if (_v) { { _v = lua_isboolean(L,argv[4]); }  if (_v) { {
                _v = lua_isboolean(L,argv[5]); }  if (_v) { { _v = lua_isnumber(L,argv[6]); }  if (_v) {
                  return _wrap_TrueTypeFont_load__SWIG_1(L);}  }  }  }  }  }  }  }  if (argc == 8) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofTrueTypeFont, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L, argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          { _v = lua_isboolean(L,argv[3]); }  if (_v) { { _v = lua_isboolean(L,argv[4]); }  if (_v) { {
                _v = lua_isboolean(L,argv[5]); }  if (_v) { { _v = lua_isnumber(L,argv[6]); }  if (_v) { {
                    _v = lua_isnumber(L,argv[7]); }  if (_v) { return _wrap_TrueTypeFont_load__SWIG_0(L);}  }  }  }  }  }  }  }
     }  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'TrueTypeFont_load'\n"
  "  Possible C/C++ prototypes are:\n" "    ofTrueTypeFont::load(std::filesystem::path const &,int,bool,bool,bool,float,int)\n"
  "    ofTrueTypeFont::load(std::filesystem::path const &,int,bool,bool,bool,float)\n"
  "    ofTrueTypeFont::load(std::filesystem::path const &,int,bool,bool,bool)\n"
  "    ofTrueTypeFont::load(std::filesystem::path const &,int,bool,bool)\n"
  "    ofTrueTypeFont::load(std::filesystem::path const &,int,bool)\n"
  "    ofTrueTypeFont::load(std::filesystem::path const &,int)\n"); lua_error(L);return 0; }
static int _wrap_TrueTypeFont_isLoaded(lua_State* L) { int SWIG_arg = 0; ofTrueTypeFont *arg1 = (ofTrueTypeFont *) 0 ;
  bool result; SWIG_check_num_args("ofTrueTypeFont::isLoaded",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTrueTypeFont::isLoaded",1,"ofTrueTypeFont const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTrueTypeFont,0))){
    SWIG_fail_ptr("TrueTypeFont_isLoaded",1,SWIGTYPE_p_ofTrueTypeFont); } 
  result = (bool)((ofTrueTypeFont const *)arg1)->isLoaded(); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TrueTypeFont_setGlobalDpi(lua_State* L) { int SWIG_arg = 0; int arg1 ;
  SWIG_check_num_args("ofTrueTypeFont::setGlobalDpi",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofTrueTypeFont::setGlobalDpi",1,"int"); arg1 = (int)lua_tonumber(L, 1);
  ofTrueTypeFont::setGlobalDpi(arg1); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TrueTypeFont_isAntiAliased(lua_State* L) { int SWIG_arg = 0; ofTrueTypeFont *arg1 = (ofTrueTypeFont *) 0 ;
  bool result; SWIG_check_num_args("ofTrueTypeFont::isAntiAliased",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTrueTypeFont::isAntiAliased",1,"ofTrueTypeFont const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTrueTypeFont,0))){
    SWIG_fail_ptr("TrueTypeFont_isAntiAliased",1,SWIGTYPE_p_ofTrueTypeFont); } 
  result = (bool)((ofTrueTypeFont const *)arg1)->isAntiAliased(); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TrueTypeFont_hasFullCharacterSet(lua_State* L) { int SWIG_arg = 0;
  ofTrueTypeFont *arg1 = (ofTrueTypeFont *) 0 ; bool result; SWIG_check_num_args("ofTrueTypeFont::hasFullCharacterSet",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTrueTypeFont::hasFullCharacterSet",1,"ofTrueTypeFont const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTrueTypeFont,0))){
    SWIG_fail_ptr("TrueTypeFont_hasFullCharacterSet",1,SWIGTYPE_p_ofTrueTypeFont); } 
  result = (bool)((ofTrueTypeFont const *)arg1)->hasFullCharacterSet(); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TrueTypeFont_getNumCharacters(lua_State* L) { int SWIG_arg = 0; ofTrueTypeFont *arg1 = (ofTrueTypeFont *) 0 ;
  std::size_t result; SWIG_check_num_args("ofTrueTypeFont::getNumCharacters",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTrueTypeFont::getNumCharacters",1,"ofTrueTypeFont const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTrueTypeFont,0))){
    SWIG_fail_ptr("TrueTypeFont_getNumCharacters",1,SWIGTYPE_p_ofTrueTypeFont); } 
  result = (std::size_t)((ofTrueTypeFont const *)arg1)->getNumCharacters(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TrueTypeFont_getSize(lua_State* L) { int SWIG_arg = 0; ofTrueTypeFont *arg1 = (ofTrueTypeFont *) 0 ;
  int result; SWIG_check_num_args("ofTrueTypeFont::getSize",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTrueTypeFont::getSize",1,"ofTrueTypeFont const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTrueTypeFont,0))){
    SWIG_fail_ptr("TrueTypeFont_getSize",1,SWIGTYPE_p_ofTrueTypeFont); } 
  result = (int)((ofTrueTypeFont const *)arg1)->getSize(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TrueTypeFont_getLineHeight(lua_State* L) { int SWIG_arg = 0; ofTrueTypeFont *arg1 = (ofTrueTypeFont *) 0 ;
  float result; SWIG_check_num_args("ofTrueTypeFont::getLineHeight",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTrueTypeFont::getLineHeight",1,"ofTrueTypeFont const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTrueTypeFont,0))){
    SWIG_fail_ptr("TrueTypeFont_getLineHeight",1,SWIGTYPE_p_ofTrueTypeFont); } 
  result = (float)((ofTrueTypeFont const *)arg1)->getLineHeight(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TrueTypeFont_setLineHeight(lua_State* L) { int SWIG_arg = 0; ofTrueTypeFont *arg1 = (ofTrueTypeFont *) 0 ;
  float arg2 ; SWIG_check_num_args("ofTrueTypeFont::setLineHeight",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTrueTypeFont::setLineHeight",1,"ofTrueTypeFont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofTrueTypeFont::setLineHeight",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTrueTypeFont,0))){
    SWIG_fail_ptr("TrueTypeFont_setLineHeight",1,SWIGTYPE_p_ofTrueTypeFont); }  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setLineHeight(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TrueTypeFont_getAscenderHeight(lua_State* L) { int SWIG_arg = 0; ofTrueTypeFont *arg1 = (ofTrueTypeFont *) 0 ;
  float result; SWIG_check_num_args("ofTrueTypeFont::getAscenderHeight",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTrueTypeFont::getAscenderHeight",1,"ofTrueTypeFont const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTrueTypeFont,0))){
    SWIG_fail_ptr("TrueTypeFont_getAscenderHeight",1,SWIGTYPE_p_ofTrueTypeFont); } 
  result = (float)((ofTrueTypeFont const *)arg1)->getAscenderHeight(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TrueTypeFont_getDescenderHeight(lua_State* L) { int SWIG_arg = 0; ofTrueTypeFont *arg1 = (ofTrueTypeFont *) 0 ;
  float result; SWIG_check_num_args("ofTrueTypeFont::getDescenderHeight",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTrueTypeFont::getDescenderHeight",1,"ofTrueTypeFont const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTrueTypeFont,0))){
    SWIG_fail_ptr("TrueTypeFont_getDescenderHeight",1,SWIGTYPE_p_ofTrueTypeFont); } 
  result = (float)((ofTrueTypeFont const *)arg1)->getDescenderHeight(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TrueTypeFont_getGlyphBBox(lua_State* L) { int SWIG_arg = 0; ofTrueTypeFont *arg1 = (ofTrueTypeFont *) 0 ;
  ofRectangle *result = 0 ; SWIG_check_num_args("ofTrueTypeFont::getGlyphBBox",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTrueTypeFont::getGlyphBBox",1,"ofTrueTypeFont const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTrueTypeFont,0))){
    SWIG_fail_ptr("TrueTypeFont_getGlyphBBox",1,SWIGTYPE_p_ofTrueTypeFont); } 
  result = (ofRectangle *) &((ofTrueTypeFont const *)arg1)->getGlyphBBox();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofRectangle,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_TrueTypeFont_getLetterSpacing(lua_State* L) { int SWIG_arg = 0; ofTrueTypeFont *arg1 = (ofTrueTypeFont *) 0 ;
  float result; SWIG_check_num_args("ofTrueTypeFont::getLetterSpacing",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTrueTypeFont::getLetterSpacing",1,"ofTrueTypeFont const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTrueTypeFont,0))){
    SWIG_fail_ptr("TrueTypeFont_getLetterSpacing",1,SWIGTYPE_p_ofTrueTypeFont); } 
  result = (float)((ofTrueTypeFont const *)arg1)->getLetterSpacing(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TrueTypeFont_setLetterSpacing(lua_State* L) { int SWIG_arg = 0; ofTrueTypeFont *arg1 = (ofTrueTypeFont *) 0 ;
  float arg2 ; SWIG_check_num_args("ofTrueTypeFont::setLetterSpacing",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTrueTypeFont::setLetterSpacing",1,"ofTrueTypeFont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofTrueTypeFont::setLetterSpacing",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTrueTypeFont,0))){
    SWIG_fail_ptr("TrueTypeFont_setLetterSpacing",1,SWIGTYPE_p_ofTrueTypeFont); }  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setLetterSpacing(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TrueTypeFont_getSpaceSize(lua_State* L) { int SWIG_arg = 0; ofTrueTypeFont *arg1 = (ofTrueTypeFont *) 0 ;
  float result; SWIG_check_num_args("ofTrueTypeFont::getSpaceSize",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTrueTypeFont::getSpaceSize",1,"ofTrueTypeFont const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTrueTypeFont,0))){
    SWIG_fail_ptr("TrueTypeFont_getSpaceSize",1,SWIGTYPE_p_ofTrueTypeFont); } 
  result = (float)((ofTrueTypeFont const *)arg1)->getSpaceSize(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TrueTypeFont_setSpaceSize(lua_State* L) { int SWIG_arg = 0; ofTrueTypeFont *arg1 = (ofTrueTypeFont *) 0 ;
  float arg2 ; SWIG_check_num_args("ofTrueTypeFont::setSpaceSize",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTrueTypeFont::setSpaceSize",1,"ofTrueTypeFont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofTrueTypeFont::setSpaceSize",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTrueTypeFont,0))){
    SWIG_fail_ptr("TrueTypeFont_setSpaceSize",1,SWIGTYPE_p_ofTrueTypeFont); }  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setSpaceSize(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TrueTypeFont_stringWidth(lua_State* L) { int SWIG_arg = 0; ofTrueTypeFont *arg1 = (ofTrueTypeFont *) 0 ;
  std::string *arg2 = 0 ; std::string temp2 ; float result; SWIG_check_num_args("ofTrueTypeFont::stringWidth",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTrueTypeFont::stringWidth",1,"ofTrueTypeFont const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofTrueTypeFont::stringWidth",2,"std::string const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTrueTypeFont,0))){
    SWIG_fail_ptr("TrueTypeFont_stringWidth",1,SWIGTYPE_p_ofTrueTypeFont); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  result = (float)((ofTrueTypeFont const *)arg1)->stringWidth((std::string const &)*arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TrueTypeFont_stringHeight(lua_State* L) { int SWIG_arg = 0; ofTrueTypeFont *arg1 = (ofTrueTypeFont *) 0 ;
  std::string *arg2 = 0 ; std::string temp2 ; float result; SWIG_check_num_args("ofTrueTypeFont::stringHeight",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTrueTypeFont::stringHeight",1,"ofTrueTypeFont const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofTrueTypeFont::stringHeight",2,"std::string const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTrueTypeFont,0))){
    SWIG_fail_ptr("TrueTypeFont_stringHeight",1,SWIGTYPE_p_ofTrueTypeFont); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  result = (float)((ofTrueTypeFont const *)arg1)->stringHeight((std::string const &)*arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TrueTypeFont_getStringBoundingBox__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofTrueTypeFont *arg1 = (ofTrueTypeFont *) 0 ; std::string *arg2 = 0 ; float arg3 ; float arg4 ; bool arg5 ;
  std::string temp2 ; ofRectangle result; SWIG_check_num_args("ofTrueTypeFont::getStringBoundingBox",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTrueTypeFont::getStringBoundingBox",1,"ofTrueTypeFont const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofTrueTypeFont::getStringBoundingBox",2,"std::string const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofTrueTypeFont::getStringBoundingBox",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofTrueTypeFont::getStringBoundingBox",4,"float");
  if(!lua_isboolean(L,5)) SWIG_fail_arg("ofTrueTypeFont::getStringBoundingBox",5,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTrueTypeFont,0))){
    SWIG_fail_ptr("TrueTypeFont_getStringBoundingBox",1,SWIGTYPE_p_ofTrueTypeFont); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2; arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4); arg5 = (lua_toboolean(L, 5)!=0);
  result = ((ofTrueTypeFont const *)arg1)->getStringBoundingBox((std::string const &)*arg2,arg3,arg4,arg5); {
    ofRectangle * resultptr = new ofRectangle((const ofRectangle &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofRectangle,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_TrueTypeFont_getStringBoundingBox__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofTrueTypeFont *arg1 = (ofTrueTypeFont *) 0 ; std::string *arg2 = 0 ; float arg3 ; float arg4 ; std::string temp2 ;
  ofRectangle result; SWIG_check_num_args("ofTrueTypeFont::getStringBoundingBox",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTrueTypeFont::getStringBoundingBox",1,"ofTrueTypeFont const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofTrueTypeFont::getStringBoundingBox",2,"std::string const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofTrueTypeFont::getStringBoundingBox",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofTrueTypeFont::getStringBoundingBox",4,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTrueTypeFont,0))){
    SWIG_fail_ptr("TrueTypeFont_getStringBoundingBox",1,SWIGTYPE_p_ofTrueTypeFont); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2; arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  result = ((ofTrueTypeFont const *)arg1)->getStringBoundingBox((std::string const &)*arg2,arg3,arg4); {
    ofRectangle * resultptr = new ofRectangle((const ofRectangle &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofRectangle,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_TrueTypeFont_getStringBoundingBox(lua_State* L) { int argc; int argv[6]={ 1,2,3,4,5,6} ; argc = lua_gettop(L);
  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofTrueTypeFont, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          { _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_TrueTypeFont_getStringBoundingBox__SWIG_1(L);}  }  }  }  } 
  if (argc == 5) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofTrueTypeFont, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isboolean(L,argv[4]); }  if (_v) {
              return _wrap_TrueTypeFont_getStringBoundingBox__SWIG_0(L);}  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'TrueTypeFont_getStringBoundingBox'\n"
  "  Possible C/C++ prototypes are:\n" "    ofTrueTypeFont::getStringBoundingBox(std::string const &,float,float,bool) const\n"
  "    ofTrueTypeFont::getStringBoundingBox(std::string const &,float,float) const\n"); lua_error(L);return 0; }
static int _wrap_TrueTypeFont_drawString(lua_State* L) { int SWIG_arg = 0; ofTrueTypeFont *arg1 = (ofTrueTypeFont *) 0 ;
  std::string *arg2 = 0 ; float arg3 ; float arg4 ; std::string temp2 ; SWIG_check_num_args("ofTrueTypeFont::drawString",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTrueTypeFont::drawString",1,"ofTrueTypeFont const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofTrueTypeFont::drawString",2,"std::string const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofTrueTypeFont::drawString",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofTrueTypeFont::drawString",4,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTrueTypeFont,0))){
    SWIG_fail_ptr("TrueTypeFont_drawString",1,SWIGTYPE_p_ofTrueTypeFont); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2; arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4); ((ofTrueTypeFont const *)arg1)->drawString((std::string const &)*arg2,arg3,arg4);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TrueTypeFont_drawStringAsShapes(lua_State* L) { int SWIG_arg = 0; ofTrueTypeFont *arg1 = (ofTrueTypeFont *) 0 ;
  std::string *arg2 = 0 ; float arg3 ; float arg4 ; std::string temp2 ;
  SWIG_check_num_args("ofTrueTypeFont::drawStringAsShapes",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTrueTypeFont::drawStringAsShapes",1,"ofTrueTypeFont const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofTrueTypeFont::drawStringAsShapes",2,"std::string const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofTrueTypeFont::drawStringAsShapes",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofTrueTypeFont::drawStringAsShapes",4,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTrueTypeFont,0))){
    SWIG_fail_ptr("TrueTypeFont_drawStringAsShapes",1,SWIGTYPE_p_ofTrueTypeFont); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2; arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4); ((ofTrueTypeFont const *)arg1)->drawStringAsShapes((std::string const &)*arg2,arg3,arg4);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TrueTypeFont_getCharacterAsPoints__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofTrueTypeFont *arg1 = (ofTrueTypeFont *) 0 ; uint32_t arg2 ; bool arg3 ; bool arg4 ; uint32_t *argp2 ; ofPath result;
  SWIG_check_num_args("ofTrueTypeFont::getCharacterAsPoints",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTrueTypeFont::getCharacterAsPoints",1,"ofTrueTypeFont const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofTrueTypeFont::getCharacterAsPoints",2,"uint32_t");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("ofTrueTypeFont::getCharacterAsPoints",3,"bool");
  if(!lua_isboolean(L,4)) SWIG_fail_arg("ofTrueTypeFont::getCharacterAsPoints",4,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTrueTypeFont,0))){
    SWIG_fail_ptr("TrueTypeFont_getCharacterAsPoints",1,SWIGTYPE_p_ofTrueTypeFont); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_uint32_t,0))){
    SWIG_fail_ptr("TrueTypeFont_getCharacterAsPoints",2,SWIGTYPE_p_uint32_t); }  arg2 = *argp2; arg3 = (lua_toboolean(L, 3)!=0);
  arg4 = (lua_toboolean(L, 4)!=0); result = ((ofTrueTypeFont const *)arg1)->getCharacterAsPoints(arg2,arg3,arg4); {
    ofPath * resultptr = new ofPath((const ofPath &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofPath,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_TrueTypeFont_getCharacterAsPoints__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofTrueTypeFont *arg1 = (ofTrueTypeFont *) 0 ; uint32_t arg2 ; bool arg3 ; uint32_t *argp2 ; ofPath result;
  SWIG_check_num_args("ofTrueTypeFont::getCharacterAsPoints",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTrueTypeFont::getCharacterAsPoints",1,"ofTrueTypeFont const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofTrueTypeFont::getCharacterAsPoints",2,"uint32_t");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("ofTrueTypeFont::getCharacterAsPoints",3,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTrueTypeFont,0))){
    SWIG_fail_ptr("TrueTypeFont_getCharacterAsPoints",1,SWIGTYPE_p_ofTrueTypeFont); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_uint32_t,0))){
    SWIG_fail_ptr("TrueTypeFont_getCharacterAsPoints",2,SWIGTYPE_p_uint32_t); }  arg2 = *argp2; arg3 = (lua_toboolean(L, 3)!=0);
  result = ((ofTrueTypeFont const *)arg1)->getCharacterAsPoints(arg2,arg3); {
    ofPath * resultptr = new ofPath((const ofPath &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofPath,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_TrueTypeFont_getCharacterAsPoints__SWIG_2(lua_State* L) { int SWIG_arg = 0;
  ofTrueTypeFont *arg1 = (ofTrueTypeFont *) 0 ; uint32_t arg2 ; uint32_t *argp2 ; ofPath result;
  SWIG_check_num_args("ofTrueTypeFont::getCharacterAsPoints",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTrueTypeFont::getCharacterAsPoints",1,"ofTrueTypeFont const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofTrueTypeFont::getCharacterAsPoints",2,"uint32_t");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTrueTypeFont,0))){
    SWIG_fail_ptr("TrueTypeFont_getCharacterAsPoints",1,SWIGTYPE_p_ofTrueTypeFont); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_uint32_t,0))){
    SWIG_fail_ptr("TrueTypeFont_getCharacterAsPoints",2,SWIGTYPE_p_uint32_t); }  arg2 = *argp2;
  result = ((ofTrueTypeFont const *)arg1)->getCharacterAsPoints(arg2); {
    ofPath * resultptr = new ofPath((const ofPath &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofPath,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_TrueTypeFont_getCharacterAsPoints(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L);
  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofTrueTypeFont, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_uint32_t, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_TrueTypeFont_getCharacterAsPoints__SWIG_2(L);}  }  }  if (argc == 3) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofTrueTypeFont, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_uint32_t, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isboolean(L,argv[2]); }  if (_v) {
          return _wrap_TrueTypeFont_getCharacterAsPoints__SWIG_1(L);}  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofTrueTypeFont, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_uint32_t, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isboolean(L,argv[2]); }  if (_v) { { _v = lua_isboolean(L,argv[3]); } 
          if (_v) { return _wrap_TrueTypeFont_getCharacterAsPoints__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'TrueTypeFont_getCharacterAsPoints'\n"
  "  Possible C/C++ prototypes are:\n" "    ofTrueTypeFont::getCharacterAsPoints(uint32_t,bool,bool) const\n"
  "    ofTrueTypeFont::getCharacterAsPoints(uint32_t,bool) const\n"
  "    ofTrueTypeFont::getCharacterAsPoints(uint32_t) const\n"); lua_error(L);return 0; }
static int _wrap_TrueTypeFont_getStringAsPoints__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofTrueTypeFont *arg1 = (ofTrueTypeFont *) 0 ; std::string *arg2 = 0 ; bool arg3 ; bool arg4 ; std::string temp2 ;
  SwigValueWrapper< std::vector< ofPath > > result; SWIG_check_num_args("ofTrueTypeFont::getStringAsPoints",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTrueTypeFont::getStringAsPoints",1,"ofTrueTypeFont const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofTrueTypeFont::getStringAsPoints",2,"std::string const &");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("ofTrueTypeFont::getStringAsPoints",3,"bool");
  if(!lua_isboolean(L,4)) SWIG_fail_arg("ofTrueTypeFont::getStringAsPoints",4,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTrueTypeFont,0))){
    SWIG_fail_ptr("TrueTypeFont_getStringAsPoints",1,SWIGTYPE_p_ofTrueTypeFont); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2; arg3 = (lua_toboolean(L, 3)!=0);
  arg4 = (lua_toboolean(L, 4)!=0);
  result = ((ofTrueTypeFont const *)arg1)->getStringAsPoints((std::string const &)*arg2,arg3,arg4); {
    std::vector< ofPath > * resultptr = new std::vector< ofPath >((const std::vector< ofPath > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_std__vectorT_ofPath_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TrueTypeFont_getStringAsPoints__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofTrueTypeFont *arg1 = (ofTrueTypeFont *) 0 ; std::string *arg2 = 0 ; bool arg3 ; std::string temp2 ;
  SwigValueWrapper< std::vector< ofPath > > result; SWIG_check_num_args("ofTrueTypeFont::getStringAsPoints",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTrueTypeFont::getStringAsPoints",1,"ofTrueTypeFont const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofTrueTypeFont::getStringAsPoints",2,"std::string const &");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("ofTrueTypeFont::getStringAsPoints",3,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTrueTypeFont,0))){
    SWIG_fail_ptr("TrueTypeFont_getStringAsPoints",1,SWIGTYPE_p_ofTrueTypeFont); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2; arg3 = (lua_toboolean(L, 3)!=0);
  result = ((ofTrueTypeFont const *)arg1)->getStringAsPoints((std::string const &)*arg2,arg3); {
    std::vector< ofPath > * resultptr = new std::vector< ofPath >((const std::vector< ofPath > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_std__vectorT_ofPath_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TrueTypeFont_getStringAsPoints__SWIG_2(lua_State* L) { int SWIG_arg = 0;
  ofTrueTypeFont *arg1 = (ofTrueTypeFont *) 0 ; std::string *arg2 = 0 ; std::string temp2 ;
  SwigValueWrapper< std::vector< ofPath > > result; SWIG_check_num_args("ofTrueTypeFont::getStringAsPoints",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTrueTypeFont::getStringAsPoints",1,"ofTrueTypeFont const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofTrueTypeFont::getStringAsPoints",2,"std::string const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTrueTypeFont,0))){
    SWIG_fail_ptr("TrueTypeFont_getStringAsPoints",1,SWIGTYPE_p_ofTrueTypeFont); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  result = ((ofTrueTypeFont const *)arg1)->getStringAsPoints((std::string const &)*arg2); {
    std::vector< ofPath > * resultptr = new std::vector< ofPath >((const std::vector< ofPath > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_std__vectorT_ofPath_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TrueTypeFont_getStringAsPoints(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L);
  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofTrueTypeFont, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L,argv[1]); }  if (_v) {
        return _wrap_TrueTypeFont_getStringAsPoints__SWIG_2(L);}  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofTrueTypeFont, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L,argv[1]); }  if (_v) { { _v = lua_isboolean(L,argv[2]); }  if (_v) {
          return _wrap_TrueTypeFont_getStringAsPoints__SWIG_1(L);}  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofTrueTypeFont, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L,argv[1]); }  if (_v) { { _v = lua_isboolean(L,argv[2]); }  if (_v) {
          { _v = lua_isboolean(L,argv[3]); }  if (_v) { return _wrap_TrueTypeFont_getStringAsPoints__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'TrueTypeFont_getStringAsPoints'\n"
  "  Possible C/C++ prototypes are:\n" "    ofTrueTypeFont::getStringAsPoints(std::string const &,bool,bool) const\n"
  "    ofTrueTypeFont::getStringAsPoints(std::string const &,bool) const\n"
  "    ofTrueTypeFont::getStringAsPoints(std::string const &) const\n"); lua_error(L);return 0; }
static int _wrap_TrueTypeFont_getStringMesh__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofTrueTypeFont *arg1 = (ofTrueTypeFont *) 0 ; std::string *arg2 = 0 ; float arg3 ; float arg4 ; bool arg5 ;
  std::string temp2 ; ofMesh *result = 0 ; SWIG_check_num_args("ofTrueTypeFont::getStringMesh",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTrueTypeFont::getStringMesh",1,"ofTrueTypeFont const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofTrueTypeFont::getStringMesh",2,"std::string const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofTrueTypeFont::getStringMesh",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofTrueTypeFont::getStringMesh",4,"float");
  if(!lua_isboolean(L,5)) SWIG_fail_arg("ofTrueTypeFont::getStringMesh",5,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTrueTypeFont,0))){
    SWIG_fail_ptr("TrueTypeFont_getStringMesh",1,SWIGTYPE_p_ofTrueTypeFont); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2; arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4); arg5 = (lua_toboolean(L, 5)!=0);
  result = (ofMesh *) &((ofTrueTypeFont const *)arg1)->getStringMesh((std::string const &)*arg2,arg3,arg4,arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0); SWIG_arg++; 
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TrueTypeFont_getStringMesh__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofTrueTypeFont *arg1 = (ofTrueTypeFont *) 0 ; std::string *arg2 = 0 ; float arg3 ; float arg4 ; std::string temp2 ;
  ofMesh *result = 0 ; SWIG_check_num_args("ofTrueTypeFont::getStringMesh",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTrueTypeFont::getStringMesh",1,"ofTrueTypeFont const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofTrueTypeFont::getStringMesh",2,"std::string const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofTrueTypeFont::getStringMesh",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofTrueTypeFont::getStringMesh",4,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTrueTypeFont,0))){
    SWIG_fail_ptr("TrueTypeFont_getStringMesh",1,SWIGTYPE_p_ofTrueTypeFont); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2; arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  result = (ofMesh *) &((ofTrueTypeFont const *)arg1)->getStringMesh((std::string const &)*arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,0); SWIG_arg++; 
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_TrueTypeFont_getStringMesh(lua_State* L) { int argc; int argv[6]={ 1,2,3,4,5,6} ; argc = lua_gettop(L);
  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofTrueTypeFont, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          { _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_TrueTypeFont_getStringMesh__SWIG_1(L);}  }  }  }  } 
  if (argc == 5) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofTrueTypeFont, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isboolean(L,argv[4]); }  if (_v) {
              return _wrap_TrueTypeFont_getStringMesh__SWIG_0(L);}  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'TrueTypeFont_getStringMesh'\n"
  "  Possible C/C++ prototypes are:\n" "    ofTrueTypeFont::getStringMesh(std::string const &,float,float,bool) const\n"
  "    ofTrueTypeFont::getStringMesh(std::string const &,float,float) const\n"); lua_error(L);return 0; }
static int _wrap_TrueTypeFont_getFontTexture(lua_State* L) { int SWIG_arg = 0; ofTrueTypeFont *arg1 = (ofTrueTypeFont *) 0 ;
  ofTexture *result = 0 ; SWIG_check_num_args("ofTrueTypeFont::getFontTexture",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTrueTypeFont::getFontTexture",1,"ofTrueTypeFont const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTrueTypeFont,0))){
    SWIG_fail_ptr("TrueTypeFont_getFontTexture",1,SWIGTYPE_p_ofTrueTypeFont); } 
  result = (ofTexture *) &((ofTrueTypeFont const *)arg1)->getFontTexture();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofTexture,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_TrueTypeFont_getStringTexture__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofTrueTypeFont *arg1 = (ofTrueTypeFont *) 0 ; std::string *arg2 = 0 ; bool arg3 ; std::string temp2 ; ofTexture result;
  SWIG_check_num_args("ofTrueTypeFont::getStringTexture",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTrueTypeFont::getStringTexture",1,"ofTrueTypeFont const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofTrueTypeFont::getStringTexture",2,"std::string const &");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("ofTrueTypeFont::getStringTexture",3,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTrueTypeFont,0))){
    SWIG_fail_ptr("TrueTypeFont_getStringTexture",1,SWIGTYPE_p_ofTrueTypeFont); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2; arg3 = (lua_toboolean(L, 3)!=0);
  result = ((ofTrueTypeFont const *)arg1)->getStringTexture((std::string const &)*arg2,arg3); {
    ofTexture * resultptr = new ofTexture((const ofTexture &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofTexture,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_TrueTypeFont_getStringTexture__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofTrueTypeFont *arg1 = (ofTrueTypeFont *) 0 ; std::string *arg2 = 0 ; std::string temp2 ; ofTexture result;
  SWIG_check_num_args("ofTrueTypeFont::getStringTexture",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTrueTypeFont::getStringTexture",1,"ofTrueTypeFont const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofTrueTypeFont::getStringTexture",2,"std::string const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTrueTypeFont,0))){
    SWIG_fail_ptr("TrueTypeFont_getStringTexture",1,SWIGTYPE_p_ofTrueTypeFont); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  result = ((ofTrueTypeFont const *)arg1)->getStringTexture((std::string const &)*arg2); {
    ofTexture * resultptr = new ofTexture((const ofTexture &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofTexture,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_TrueTypeFont_getStringTexture(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L);
  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofTrueTypeFont, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L,argv[1]); }  if (_v) {
        return _wrap_TrueTypeFont_getStringTexture__SWIG_1(L);}  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofTrueTypeFont, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L,argv[1]); }  if (_v) { { _v = lua_isboolean(L,argv[2]); }  if (_v) {
          return _wrap_TrueTypeFont_getStringTexture__SWIG_0(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'TrueTypeFont_getStringTexture'\n"
  "  Possible C/C++ prototypes are:\n" "    ofTrueTypeFont::getStringTexture(std::string const &,bool) const\n"
  "    ofTrueTypeFont::getStringTexture(std::string const &) const\n"); lua_error(L);return 0; }
static int _wrap_TrueTypeFont_getFirstGlyphPosForTexture(lua_State* L) { int SWIG_arg = 0;
  ofTrueTypeFont *arg1 = (ofTrueTypeFont *) 0 ; std::string *arg2 = 0 ; bool arg3 ; std::string temp2 ; glm::vec2 result;
  SWIG_check_num_args("ofTrueTypeFont::getFirstGlyphPosForTexture",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTrueTypeFont::getFirstGlyphPosForTexture",1,"ofTrueTypeFont const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofTrueTypeFont::getFirstGlyphPosForTexture",2,"std::string const &");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("ofTrueTypeFont::getFirstGlyphPosForTexture",3,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTrueTypeFont,0))){
    SWIG_fail_ptr("TrueTypeFont_getFirstGlyphPosForTexture",1,SWIGTYPE_p_ofTrueTypeFont); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2; arg3 = (lua_toboolean(L, 3)!=0);
  result = ((ofTrueTypeFont const *)arg1)->getFirstGlyphPosForTexture((std::string const &)*arg2,arg3); {
    glm::vec2 * resultptr = new glm::vec2((const glm::vec2 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_glm__vec2,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_TrueTypeFont_isValidGlyph(lua_State* L) { int SWIG_arg = 0; ofTrueTypeFont *arg1 = (ofTrueTypeFont *) 0 ;
  uint32_t arg2 ; uint32_t *argp2 ; bool result; SWIG_check_num_args("ofTrueTypeFont::isValidGlyph",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofTrueTypeFont::isValidGlyph",1,"ofTrueTypeFont const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofTrueTypeFont::isValidGlyph",2,"uint32_t");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofTrueTypeFont,0))){
    SWIG_fail_ptr("TrueTypeFont_isValidGlyph",1,SWIGTYPE_p_ofTrueTypeFont); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_uint32_t,0))){
    SWIG_fail_ptr("TrueTypeFont_isValidGlyph",2,SWIGTYPE_p_uint32_t); }  arg2 = *argp2;
  result = (bool)((ofTrueTypeFont const *)arg1)->isValidGlyph(arg2); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static void swig_delete_TrueTypeFont(void *obj) {
ofTrueTypeFont *arg1 = (ofTrueTypeFont *) obj;
delete arg1;
}
static int _proxy__wrap_new_TrueTypeFont(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_TrueTypeFont);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_TrueTypeFont_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_TrueTypeFont_methods[]= {
    { "load", _wrap_TrueTypeFont_load},
    { "isLoaded", _wrap_TrueTypeFont_isLoaded},
    { "isAntiAliased", _wrap_TrueTypeFont_isAntiAliased},
    { "hasFullCharacterSet", _wrap_TrueTypeFont_hasFullCharacterSet},
    { "getNumCharacters", _wrap_TrueTypeFont_getNumCharacters},
    { "getSize", _wrap_TrueTypeFont_getSize},
    { "getLineHeight", _wrap_TrueTypeFont_getLineHeight},
    { "setLineHeight", _wrap_TrueTypeFont_setLineHeight},
    { "getAscenderHeight", _wrap_TrueTypeFont_getAscenderHeight},
    { "getDescenderHeight", _wrap_TrueTypeFont_getDescenderHeight},
    { "getGlyphBBox", _wrap_TrueTypeFont_getGlyphBBox},
    { "getLetterSpacing", _wrap_TrueTypeFont_getLetterSpacing},
    { "setLetterSpacing", _wrap_TrueTypeFont_setLetterSpacing},
    { "getSpaceSize", _wrap_TrueTypeFont_getSpaceSize},
    { "setSpaceSize", _wrap_TrueTypeFont_setSpaceSize},
    { "stringWidth", _wrap_TrueTypeFont_stringWidth},
    { "stringHeight", _wrap_TrueTypeFont_stringHeight},
    { "getStringBoundingBox", _wrap_TrueTypeFont_getStringBoundingBox},
    { "drawString", _wrap_TrueTypeFont_drawString},
    { "drawStringAsShapes", _wrap_TrueTypeFont_drawStringAsShapes},
    { "getCharacterAsPoints", _wrap_TrueTypeFont_getCharacterAsPoints},
    { "getStringAsPoints", _wrap_TrueTypeFont_getStringAsPoints},
    { "getStringMesh", _wrap_TrueTypeFont_getStringMesh},
    { "getFontTexture", _wrap_TrueTypeFont_getFontTexture},
    { "getStringTexture", _wrap_TrueTypeFont_getStringTexture},
    { "getFirstGlyphPosForTexture", _wrap_TrueTypeFont_getFirstGlyphPosForTexture},
    { "isValidGlyph", _wrap_TrueTypeFont_isValidGlyph},
    {0,0}
};
static swig_lua_method swig_TrueTypeFont_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_TrueTypeFont_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_TrueTypeFont_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_TrueTypeFont_Sf_SwigStatic_methods[]= {
    { "setGlobalDpi", _wrap_TrueTypeFont_setGlobalDpi},
    {0,0}
};
static swig_lua_class* swig_TrueTypeFont_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_TrueTypeFont_Sf_SwigStatic = {
    "TrueTypeFont",
    swig_TrueTypeFont_Sf_SwigStatic_methods,
    swig_TrueTypeFont_Sf_SwigStatic_attributes,
    swig_TrueTypeFont_Sf_SwigStatic_constants,
    swig_TrueTypeFont_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_TrueTypeFont_bases[] = {0};
static const char *swig_TrueTypeFont_base_names[] = {0};
static swig_lua_class _wrap_class_TrueTypeFont = { "TrueTypeFont", "TrueTypeFont", &SWIGTYPE_p_ofTrueTypeFont,_proxy__wrap_new_TrueTypeFont, swig_delete_TrueTypeFont, swig_TrueTypeFont_methods, swig_TrueTypeFont_attributes, &swig_TrueTypeFont_Sf_SwigStatic, swig_TrueTypeFont_meta, swig_TrueTypeFont_bases, swig_TrueTypeFont_base_names };

static int _wrap_soundStreamSetup(lua_State* L) { int SWIG_arg = 0; ofSoundStreamSettings *arg1 = 0 ;
  SWIG_check_num_args("ofSoundStreamSetup",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofSoundStreamSetup",1,"ofSoundStreamSettings &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSoundStreamSettings,0))){
    SWIG_fail_ptr("soundStreamSetup",1,SWIGTYPE_p_ofSoundStreamSettings); }  ofSoundStreamSetup(*arg1); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_soundStreamStop(lua_State* L) { int SWIG_arg = 0; SWIG_check_num_args("ofSoundStreamStop",0,0)
  ofSoundStreamStop(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_soundStreamStart(lua_State* L) { int SWIG_arg = 0; SWIG_check_num_args("ofSoundStreamStart",0,0)
  ofSoundStreamStart(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_soundStreamClose(lua_State* L) { int SWIG_arg = 0; SWIG_check_num_args("ofSoundStreamClose",0,0)
  ofSoundStreamClose(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_soundStreamListDevices(lua_State* L) { int SWIG_arg = 0;
  SwigValueWrapper< std::vector< ofSoundDevice > > result; SWIG_check_num_args("ofSoundStreamListDevices",0,0)
  result = ofSoundStreamListDevices(); {
    std::vector< ofSoundDevice > * resultptr = new std::vector< ofSoundDevice >((const std::vector< ofSoundDevice > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_std__vectorT_ofSoundDevice_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_new_SoundStream(lua_State* L) { int SWIG_arg = 0; ofSoundStream *result = 0 ;
  SWIG_check_num_args("ofSoundStream::ofSoundStream",0,0) result = (ofSoundStream *)new ofSoundStream();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofSoundStream,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_SoundStream_setSoundStream(lua_State* L) { int SWIG_arg = 0; ofSoundStream *arg1 = (ofSoundStream *) 0 ;
  SwigValueWrapper< std::shared_ptr< ofBaseSoundStream > > arg2 ; std::shared_ptr< ofBaseSoundStream > *argp2 ;
  SWIG_check_num_args("ofSoundStream::setSoundStream",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSoundStream::setSoundStream",1,"ofSoundStream *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofSoundStream::setSoundStream",2,"std::shared_ptr< ofBaseSoundStream >");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSoundStream,0))){
    SWIG_fail_ptr("SoundStream_setSoundStream",1,SWIGTYPE_p_ofSoundStream); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_std__shared_ptrT_ofBaseSoundStream_t,0))){
    SWIG_fail_ptr("SoundStream_setSoundStream",2,SWIGTYPE_p_std__shared_ptrT_ofBaseSoundStream_t); }  arg2 = *argp2;
  (arg1)->setSoundStream(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_SoundStream_getSoundStream(lua_State* L) { int SWIG_arg = 0; ofSoundStream *arg1 = (ofSoundStream *) 0 ;
  SwigValueWrapper< std::shared_ptr< ofBaseSoundStream > > result; SWIG_check_num_args("ofSoundStream::getSoundStream",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSoundStream::getSoundStream",1,"ofSoundStream *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSoundStream,0))){
    SWIG_fail_ptr("SoundStream_getSoundStream",1,SWIGTYPE_p_ofSoundStream); }  result = (arg1)->getSoundStream(); {
    std::shared_ptr< ofBaseSoundStream > * resultptr = new std::shared_ptr< ofBaseSoundStream >((const std::shared_ptr< ofBaseSoundStream > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_std__shared_ptrT_ofBaseSoundStream_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_SoundStream_printDeviceList(lua_State* L) { int SWIG_arg = 0; ofSoundStream *arg1 = (ofSoundStream *) 0 ;
  SWIG_check_num_args("ofSoundStream::printDeviceList",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSoundStream::printDeviceList",1,"ofSoundStream const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSoundStream,0))){
    SWIG_fail_ptr("SoundStream_printDeviceList",1,SWIGTYPE_p_ofSoundStream); } 
  ((ofSoundStream const *)arg1)->printDeviceList(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_SoundStream_getDeviceList__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofSoundStream *arg1 = (ofSoundStream *) 0 ;
  ofSoundDevice::Api arg2 ; SwigValueWrapper< std::vector< ofSoundDevice > > result;
  SWIG_check_num_args("ofSoundStream::getDeviceList",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSoundStream::getDeviceList",1,"ofSoundStream const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofSoundStream::getDeviceList",2,"ofSoundDevice::Api");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSoundStream,0))){
    SWIG_fail_ptr("SoundStream_getDeviceList",1,SWIGTYPE_p_ofSoundStream); } 
  arg2 = (ofSoundDevice::Api)(int)lua_tonumber(L, 2); result = ((ofSoundStream const *)arg1)->getDeviceList(arg2); {
    std::vector< ofSoundDevice > * resultptr = new std::vector< ofSoundDevice >((const std::vector< ofSoundDevice > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_std__vectorT_ofSoundDevice_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_SoundStream_getDeviceList__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofSoundStream *arg1 = (ofSoundStream *) 0 ;
  SwigValueWrapper< std::vector< ofSoundDevice > > result; SWIG_check_num_args("ofSoundStream::getDeviceList",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSoundStream::getDeviceList",1,"ofSoundStream const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSoundStream,0))){
    SWIG_fail_ptr("SoundStream_getDeviceList",1,SWIGTYPE_p_ofSoundStream); } 
  result = ((ofSoundStream const *)arg1)->getDeviceList(); {
    std::vector< ofSoundDevice > * resultptr = new std::vector< ofSoundDevice >((const std::vector< ofSoundDevice > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_std__vectorT_ofSoundDevice_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_SoundStream_getDeviceList(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L);
  if (argc == 1) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofSoundStream, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { return _wrap_SoundStream_getDeviceList__SWIG_1(L);}  }  if (argc == 2) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofSoundStream, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_SoundStream_getDeviceList__SWIG_0(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'SoundStream_getDeviceList'\n"
  "  Possible C/C++ prototypes are:\n" "    ofSoundStream::getDeviceList(ofSoundDevice::Api) const\n"
  "    ofSoundStream::getDeviceList() const\n"); lua_error(L);return 0; }
static int _wrap_SoundStream_getMatchingDevices__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofSoundStream *arg1 = (ofSoundStream *) 0 ; std::string *arg2 = 0 ; unsigned int arg3 ; unsigned int arg4 ;
  ofSoundDevice::Api arg5 ; std::string temp2 ; SwigValueWrapper< std::vector< ofSoundDevice > > result;
  SWIG_check_num_args("ofSoundStream::getMatchingDevices",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSoundStream::getMatchingDevices",1,"ofSoundStream const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofSoundStream::getMatchingDevices",2,"std::string const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofSoundStream::getMatchingDevices",3,"unsigned int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofSoundStream::getMatchingDevices",4,"unsigned int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofSoundStream::getMatchingDevices",5,"ofSoundDevice::Api");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSoundStream,0))){
    SWIG_fail_ptr("SoundStream_getMatchingDevices",1,SWIGTYPE_p_ofSoundStream); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (unsigned int)lua_tonumber(L, 3);
  SWIG_contract_assert((lua_tonumber(L,4)>=0),"number must not be negative") arg4 = (unsigned int)lua_tonumber(L, 4);
  arg5 = (ofSoundDevice::Api)(int)lua_tonumber(L, 5);
  result = ((ofSoundStream const *)arg1)->getMatchingDevices((std::string const &)*arg2,arg3,arg4,arg5); {
    std::vector< ofSoundDevice > * resultptr = new std::vector< ofSoundDevice >((const std::vector< ofSoundDevice > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_std__vectorT_ofSoundDevice_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_SoundStream_getMatchingDevices__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofSoundStream *arg1 = (ofSoundStream *) 0 ; std::string *arg2 = 0 ; unsigned int arg3 ; unsigned int arg4 ;
  std::string temp2 ; SwigValueWrapper< std::vector< ofSoundDevice > > result;
  SWIG_check_num_args("ofSoundStream::getMatchingDevices",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSoundStream::getMatchingDevices",1,"ofSoundStream const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofSoundStream::getMatchingDevices",2,"std::string const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofSoundStream::getMatchingDevices",3,"unsigned int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofSoundStream::getMatchingDevices",4,"unsigned int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSoundStream,0))){
    SWIG_fail_ptr("SoundStream_getMatchingDevices",1,SWIGTYPE_p_ofSoundStream); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (unsigned int)lua_tonumber(L, 3);
  SWIG_contract_assert((lua_tonumber(L,4)>=0),"number must not be negative") arg4 = (unsigned int)lua_tonumber(L, 4);
  result = ((ofSoundStream const *)arg1)->getMatchingDevices((std::string const &)*arg2,arg3,arg4); {
    std::vector< ofSoundDevice > * resultptr = new std::vector< ofSoundDevice >((const std::vector< ofSoundDevice > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_std__vectorT_ofSoundDevice_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_SoundStream_getMatchingDevices__SWIG_2(lua_State* L) { int SWIG_arg = 0;
  ofSoundStream *arg1 = (ofSoundStream *) 0 ; std::string *arg2 = 0 ; unsigned int arg3 ; std::string temp2 ;
  SwigValueWrapper< std::vector< ofSoundDevice > > result; SWIG_check_num_args("ofSoundStream::getMatchingDevices",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSoundStream::getMatchingDevices",1,"ofSoundStream const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofSoundStream::getMatchingDevices",2,"std::string const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofSoundStream::getMatchingDevices",3,"unsigned int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSoundStream,0))){
    SWIG_fail_ptr("SoundStream_getMatchingDevices",1,SWIGTYPE_p_ofSoundStream); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (unsigned int)lua_tonumber(L, 3);
  result = ((ofSoundStream const *)arg1)->getMatchingDevices((std::string const &)*arg2,arg3); {
    std::vector< ofSoundDevice > * resultptr = new std::vector< ofSoundDevice >((const std::vector< ofSoundDevice > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_std__vectorT_ofSoundDevice_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_SoundStream_getMatchingDevices__SWIG_3(lua_State* L) { int SWIG_arg = 0;
  ofSoundStream *arg1 = (ofSoundStream *) 0 ; std::string *arg2 = 0 ; std::string temp2 ;
  SwigValueWrapper< std::vector< ofSoundDevice > > result; SWIG_check_num_args("ofSoundStream::getMatchingDevices",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSoundStream::getMatchingDevices",1,"ofSoundStream const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofSoundStream::getMatchingDevices",2,"std::string const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSoundStream,0))){
    SWIG_fail_ptr("SoundStream_getMatchingDevices",1,SWIGTYPE_p_ofSoundStream); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  result = ((ofSoundStream const *)arg1)->getMatchingDevices((std::string const &)*arg2); {
    std::vector< ofSoundDevice > * resultptr = new std::vector< ofSoundDevice >((const std::vector< ofSoundDevice > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_std__vectorT_ofSoundDevice_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_SoundStream_getMatchingDevices(lua_State* L) { int argc; int argv[6]={ 1,2,3,4,5,6} ; argc = lua_gettop(L);
  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofSoundStream, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L,argv[1]); }  if (_v) {
        return _wrap_SoundStream_getMatchingDevices__SWIG_3(L);}  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofSoundStream, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_SoundStream_getMatchingDevices__SWIG_2(L);}  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofSoundStream, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          { _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_SoundStream_getMatchingDevices__SWIG_1(L);}  }  }  }  } 
  if (argc == 5) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofSoundStream, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) {
              return _wrap_SoundStream_getMatchingDevices__SWIG_0(L);}  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'SoundStream_getMatchingDevices'\n"
  "  Possible C/C++ prototypes are:\n"
  "    ofSoundStream::getMatchingDevices(std::string const &,unsigned int,unsigned int,ofSoundDevice::Api) const\n"
  "    ofSoundStream::getMatchingDevices(std::string const &,unsigned int,unsigned int) const\n"
  "    ofSoundStream::getMatchingDevices(std::string const &,unsigned int) const\n"
  "    ofSoundStream::getMatchingDevices(std::string const &) const\n"); lua_error(L);return 0; }
static int _wrap_SoundStream_setup(lua_State* L) { int SWIG_arg = 0; ofSoundStream *arg1 = (ofSoundStream *) 0 ;
  ofSoundStreamSettings *arg2 = 0 ; bool result; SWIG_check_num_args("ofSoundStream::setup",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSoundStream::setup",1,"ofSoundStream *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofSoundStream::setup",2,"ofSoundStreamSettings const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSoundStream,0))){
    SWIG_fail_ptr("SoundStream_setup",1,SWIGTYPE_p_ofSoundStream); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofSoundStreamSettings,0))){
    SWIG_fail_ptr("SoundStream_setup",2,SWIGTYPE_p_ofSoundStreamSettings); } 
  result = (bool)(arg1)->setup((ofSoundStreamSettings const &)*arg2); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_SoundStream_setInput(lua_State* L) { int SWIG_arg = 0; ofSoundStream *arg1 = (ofSoundStream *) 0 ;
  ofBaseSoundInput *arg2 = (ofBaseSoundInput *) 0 ; SWIG_check_num_args("ofSoundStream::setInput",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSoundStream::setInput",1,"ofSoundStream *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofSoundStream::setInput",2,"ofBaseSoundInput *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSoundStream,0))){
    SWIG_fail_ptr("SoundStream_setInput",1,SWIGTYPE_p_ofSoundStream); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofBaseSoundInput,0))){
    SWIG_fail_ptr("SoundStream_setInput",2,SWIGTYPE_p_ofBaseSoundInput); }  (arg1)->setInput(arg2); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_SoundStream_setOutput(lua_State* L) { int SWIG_arg = 0; ofSoundStream *arg1 = (ofSoundStream *) 0 ;
  ofBaseSoundOutput *arg2 = (ofBaseSoundOutput *) 0 ; SWIG_check_num_args("ofSoundStream::setOutput",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSoundStream::setOutput",1,"ofSoundStream *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofSoundStream::setOutput",2,"ofBaseSoundOutput *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSoundStream,0))){
    SWIG_fail_ptr("SoundStream_setOutput",1,SWIGTYPE_p_ofSoundStream); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofBaseSoundOutput,0))){
    SWIG_fail_ptr("SoundStream_setOutput",2,SWIGTYPE_p_ofBaseSoundOutput); }  (arg1)->setOutput(arg2); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_SoundStream_start(lua_State* L) { int SWIG_arg = 0; ofSoundStream *arg1 = (ofSoundStream *) 0 ;
  SWIG_check_num_args("ofSoundStream::start",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSoundStream::start",1,"ofSoundStream *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSoundStream,0))){
    SWIG_fail_ptr("SoundStream_start",1,SWIGTYPE_p_ofSoundStream); }  (arg1)->start(); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_SoundStream_stop(lua_State* L) { int SWIG_arg = 0; ofSoundStream *arg1 = (ofSoundStream *) 0 ;
  SWIG_check_num_args("ofSoundStream::stop",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSoundStream::stop",1,"ofSoundStream *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSoundStream,0))){
    SWIG_fail_ptr("SoundStream_stop",1,SWIGTYPE_p_ofSoundStream); }  (arg1)->stop(); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_SoundStream_close(lua_State* L) { int SWIG_arg = 0; ofSoundStream *arg1 = (ofSoundStream *) 0 ;
  SWIG_check_num_args("ofSoundStream::close",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSoundStream::close",1,"ofSoundStream *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSoundStream,0))){
    SWIG_fail_ptr("SoundStream_close",1,SWIGTYPE_p_ofSoundStream); }  (arg1)->close(); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_SoundStream_getTickCount(lua_State* L) { int SWIG_arg = 0; ofSoundStream *arg1 = (ofSoundStream *) 0 ;
  uint64_t result; SWIG_check_num_args("ofSoundStream::getTickCount",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSoundStream::getTickCount",1,"ofSoundStream const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSoundStream,0))){
    SWIG_fail_ptr("SoundStream_getTickCount",1,SWIGTYPE_p_ofSoundStream); } 
  result = (uint64_t)((ofSoundStream const *)arg1)->getTickCount(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_SoundStream_getNumInputChannels(lua_State* L) { int SWIG_arg = 0; ofSoundStream *arg1 = (ofSoundStream *) 0 ;
  int result; SWIG_check_num_args("ofSoundStream::getNumInputChannels",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSoundStream::getNumInputChannels",1,"ofSoundStream const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSoundStream,0))){
    SWIG_fail_ptr("SoundStream_getNumInputChannels",1,SWIGTYPE_p_ofSoundStream); } 
  result = (int)((ofSoundStream const *)arg1)->getNumInputChannels(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_SoundStream_getNumOutputChannels(lua_State* L) { int SWIG_arg = 0; ofSoundStream *arg1 = (ofSoundStream *) 0 ;
  int result; SWIG_check_num_args("ofSoundStream::getNumOutputChannels",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSoundStream::getNumOutputChannels",1,"ofSoundStream const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSoundStream,0))){
    SWIG_fail_ptr("SoundStream_getNumOutputChannels",1,SWIGTYPE_p_ofSoundStream); } 
  result = (int)((ofSoundStream const *)arg1)->getNumOutputChannels(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_SoundStream_getSampleRate(lua_State* L) { int SWIG_arg = 0; ofSoundStream *arg1 = (ofSoundStream *) 0 ;
  int result; SWIG_check_num_args("ofSoundStream::getSampleRate",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSoundStream::getSampleRate",1,"ofSoundStream const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSoundStream,0))){
    SWIG_fail_ptr("SoundStream_getSampleRate",1,SWIGTYPE_p_ofSoundStream); } 
  result = (int)((ofSoundStream const *)arg1)->getSampleRate(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_SoundStream_getBufferSize(lua_State* L) { int SWIG_arg = 0; ofSoundStream *arg1 = (ofSoundStream *) 0 ;
  int result; SWIG_check_num_args("ofSoundStream::getBufferSize",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSoundStream::getBufferSize",1,"ofSoundStream const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSoundStream,0))){
    SWIG_fail_ptr("SoundStream_getBufferSize",1,SWIGTYPE_p_ofSoundStream); } 
  result = (int)((ofSoundStream const *)arg1)->getBufferSize(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static void swig_delete_SoundStream(void *obj) {
ofSoundStream *arg1 = (ofSoundStream *) obj;
delete arg1;
}
static int _proxy__wrap_new_SoundStream(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_SoundStream);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_SoundStream_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_SoundStream_methods[]= {
    { "setSoundStream", _wrap_SoundStream_setSoundStream},
    { "getSoundStream", _wrap_SoundStream_getSoundStream},
    { "printDeviceList", _wrap_SoundStream_printDeviceList},
    { "getDeviceList", _wrap_SoundStream_getDeviceList},
    { "getMatchingDevices", _wrap_SoundStream_getMatchingDevices},
    { "setup", _wrap_SoundStream_setup},
    { "setInput", _wrap_SoundStream_setInput},
    { "setOutput", _wrap_SoundStream_setOutput},
    { "start", _wrap_SoundStream_start},
    { "stop", _wrap_SoundStream_stop},
    { "close", _wrap_SoundStream_close},
    { "getTickCount", _wrap_SoundStream_getTickCount},
    { "getNumInputChannels", _wrap_SoundStream_getNumInputChannels},
    { "getNumOutputChannels", _wrap_SoundStream_getNumOutputChannels},
    { "getSampleRate", _wrap_SoundStream_getSampleRate},
    { "getBufferSize", _wrap_SoundStream_getBufferSize},
    {0,0}
};
static swig_lua_method swig_SoundStream_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_SoundStream_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_SoundStream_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_SoundStream_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_SoundStream_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_SoundStream_Sf_SwigStatic = {
    "SoundStream",
    swig_SoundStream_Sf_SwigStatic_methods,
    swig_SoundStream_Sf_SwigStatic_attributes,
    swig_SoundStream_Sf_SwigStatic_constants,
    swig_SoundStream_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_SoundStream_bases[] = {0};
static const char *swig_SoundStream_base_names[] = {0};
static swig_lua_class _wrap_class_SoundStream = { "SoundStream", "SoundStream", &SWIGTYPE_p_ofSoundStream,_proxy__wrap_new_SoundStream, swig_delete_SoundStream, swig_SoundStream_methods, swig_SoundStream_attributes, &swig_SoundStream_Sf_SwigStatic, swig_SoundStream_meta, swig_SoundStream_bases, swig_SoundStream_base_names };

static int _wrap_new_SoundPlayer(lua_State* L) { int SWIG_arg = 0; ofSoundPlayer *result = 0 ;
  SWIG_check_num_args("ofSoundPlayer::ofSoundPlayer",0,0) result = (ofSoundPlayer *)new ofSoundPlayer();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofSoundPlayer,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_SoundPlayer_setPlayer(lua_State* L) { int SWIG_arg = 0; ofSoundPlayer *arg1 = (ofSoundPlayer *) 0 ;
  SwigValueWrapper< std::shared_ptr< ofBaseSoundPlayer > > arg2 ; std::shared_ptr< ofBaseSoundPlayer > *argp2 ;
  SWIG_check_num_args("ofSoundPlayer::setPlayer",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSoundPlayer::setPlayer",1,"ofSoundPlayer *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofSoundPlayer::setPlayer",2,"std::shared_ptr< ofBaseSoundPlayer >");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSoundPlayer,0))){
    SWIG_fail_ptr("SoundPlayer_setPlayer",1,SWIGTYPE_p_ofSoundPlayer); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_std__shared_ptrT_ofBaseSoundPlayer_t,0))){
    SWIG_fail_ptr("SoundPlayer_setPlayer",2,SWIGTYPE_p_std__shared_ptrT_ofBaseSoundPlayer_t); }  arg2 = *argp2;
  (arg1)->setPlayer(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_SoundPlayer_getPlayer(lua_State* L) { int SWIG_arg = 0; ofSoundPlayer *arg1 = (ofSoundPlayer *) 0 ;
  SwigValueWrapper< std::shared_ptr< ofBaseSoundPlayer > > result; SWIG_check_num_args("ofSoundPlayer::getPlayer",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSoundPlayer::getPlayer",1,"ofSoundPlayer *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSoundPlayer,0))){
    SWIG_fail_ptr("SoundPlayer_getPlayer",1,SWIGTYPE_p_ofSoundPlayer); }  result = (arg1)->getPlayer(); {
    std::shared_ptr< ofBaseSoundPlayer > * resultptr = new std::shared_ptr< ofBaseSoundPlayer >((const std::shared_ptr< ofBaseSoundPlayer > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_std__shared_ptrT_ofBaseSoundPlayer_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_SoundPlayer_load__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofSoundPlayer *arg1 = (ofSoundPlayer *) 0 ;
  std::filesystem::path *arg2 = 0 ; bool arg3 ; std::filesystem::path temp2 ; bool result;
  SWIG_check_num_args("ofSoundPlayer::load",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSoundPlayer::load",1,"ofSoundPlayer *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofSoundPlayer::load",2,"std::filesystem::path const &");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("ofSoundPlayer::load",3,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSoundPlayer,0))){
    SWIG_fail_ptr("SoundPlayer_load",1,SWIGTYPE_p_ofSoundPlayer); }  { size_t len = lua_rawlen(L, 2);
    temp2 = lua_tolstring(L, 2, &len); arg2 = &temp2; }  arg3 = (lua_toboolean(L, 3)!=0);
  result = (bool)(arg1)->load((std::filesystem::path const &)*arg2,arg3); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_SoundPlayer_load__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofSoundPlayer *arg1 = (ofSoundPlayer *) 0 ;
  std::filesystem::path *arg2 = 0 ; std::filesystem::path temp2 ; bool result; SWIG_check_num_args("ofSoundPlayer::load",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofSoundPlayer::load",1,"ofSoundPlayer *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofSoundPlayer::load",2,"std::filesystem::path const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofSoundPlayer,0))){
    SWIG_fail_ptr("SoundPlayer_load",1,SWIGTYPE_p_ofSoundPlayer); }  { size_t len = lua_rawlen(L, 2);
    temp2 = lua_tolstring(L, 2, &len); arg2 = &temp2; }  result = (bool)(arg1)->load((std::filesystem::path const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_SoundPlayer_load(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofSoundPlayer, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L, argv[1]); }  if (_v) { return _wrap_SoundPlayer_load__SWIG_1(L);}  }
     }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofSoundPlayer, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L, argv[1]); }  if (_v) { { _v = lua_isboolean(L,argv[2]); } 
        if (_v) { return _wrap_SoundPlayer_load__SWIG_0(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'SoundPlayer_load'\n" "  Possible C/C++ prototypes are:\n"
  "    ofSoundPlayer::load(std::filesystem::path const &,bool)\n" "    ofSoundPlayer::load(std::filesystem::path const &)\n");
  lua_error(L);return 0; }
static void swig_delete_SoundPlayer(void *obj) {
ofSoundPlayer *arg1 = (ofSoundPlayer *) obj;
delete arg1;
}
static int _proxy__wrap_new_SoundPlayer(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_SoundPlayer);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_SoundPlayer_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_SoundPlayer_methods[]= {
    { "setPlayer", _wrap_SoundPlayer_setPlayer},
    { "getPlayer", _wrap_SoundPlayer_getPlayer},
    { "load", _wrap_SoundPlayer_load},
    {0,0}
};
static swig_lua_method swig_SoundPlayer_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_SoundPlayer_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_SoundPlayer_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_SoundPlayer_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_SoundPlayer_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_SoundPlayer_Sf_SwigStatic = {
    "SoundPlayer",
    swig_SoundPlayer_Sf_SwigStatic_methods,
    swig_SoundPlayer_Sf_SwigStatic_attributes,
    swig_SoundPlayer_Sf_SwigStatic_constants,
    swig_SoundPlayer_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_SoundPlayer_bases[] = {0,0};
static const char *swig_SoundPlayer_base_names[] = {"ofBaseSoundPlayer *",0};
static swig_lua_class _wrap_class_SoundPlayer = { "SoundPlayer", "SoundPlayer", &SWIGTYPE_p_ofSoundPlayer,_proxy__wrap_new_SoundPlayer, swig_delete_SoundPlayer, swig_SoundPlayer_methods, swig_SoundPlayer_attributes, &swig_SoundPlayer_Sf_SwigStatic, swig_SoundPlayer_meta, swig_SoundPlayer_bases, swig_SoundPlayer_base_names };

static int _wrap_new_Color__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::ofColor_",0,0)
  result = (ofColor_< unsigned char > *)new ofColor_< unsigned char >();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_Color__SWIG_1(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ; float arg4 ;
  ofColor_< unsigned char > *result = 0 ; SWIG_check_num_args("ofColor_< unsigned char >::ofColor_",4,4)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofColor_< unsigned char >::ofColor_",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< unsigned char >::ofColor_",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofColor_< unsigned char >::ofColor_",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofColor_< unsigned char >::ofColor_",4,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  result = (ofColor_< unsigned char > *)new ofColor_< unsigned char >(arg1,arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_Color__SWIG_2(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ;
  ofColor_< unsigned char > *result = 0 ; SWIG_check_num_args("ofColor_< unsigned char >::ofColor_",3,3)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofColor_< unsigned char >::ofColor_",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< unsigned char >::ofColor_",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofColor_< unsigned char >::ofColor_",3,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3);
  result = (ofColor_< unsigned char > *)new ofColor_< unsigned char >(arg1,arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_Color__SWIG_3(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ;
  ofColor_< unsigned char > *result = 0 ; SWIG_check_num_args("ofColor_< unsigned char >::ofColor_",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofColor_< unsigned char >::ofColor_",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< unsigned char >::ofColor_",2,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); result = (ofColor_< unsigned char > *)new ofColor_< unsigned char >(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_Color__SWIG_4(lua_State* L) { int SWIG_arg = 0; float arg1 ; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::ofColor_",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofColor_< unsigned char >::ofColor_",1,"float"); arg1 = (float)lua_tonumber(L, 1);
  result = (ofColor_< unsigned char > *)new ofColor_< unsigned char >(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_Color__SWIG_5(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *arg1 = 0 ; float arg2 ;
  ofColor_< unsigned char > *result = 0 ; SWIG_check_num_args("ofColor_< unsigned char >::ofColor_",2,2)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofColor_< unsigned char >::ofColor_",1,"ofColor_< unsigned char > const &");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< unsigned char >::ofColor_",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("new_Color",1,SWIGTYPE_p_ofColor_T_unsigned_char_t); }  arg2 = (float)lua_tonumber(L, 2);
  result = (ofColor_< unsigned char > *)new ofColor_< unsigned char >((ofColor_< unsigned char > const &)*arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_Color(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L); if (argc == 0) {
    return _wrap_new_Color__SWIG_0(L);}  if (argc == 1) { int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) {
      return _wrap_new_Color__SWIG_4(L);}  }  if (argc == 2) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofColor_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_new_Color__SWIG_5(L);}  }  }  if (argc == 2) { int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { {
        _v = lua_isnumber(L,argv[1]); }  if (_v) { return _wrap_new_Color__SWIG_3(L);}  }  }  if (argc == 3) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); } 
        if (_v) { return _wrap_new_Color__SWIG_2(L);}  }  }  }  if (argc == 4) { int _v; { _v = lua_isnumber(L,argv[0]); } 
    if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { {
            _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_new_Color__SWIG_1(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_Color'\n" "  Possible C/C++ prototypes are:\n"
  "    ofColor_< unsigned char >::ofColor_()\n" "    ofColor_< unsigned char >::ofColor_(float,float,float,float)\n"
  "    ofColor_< unsigned char >::ofColor_(float,float,float)\n" "    ofColor_< unsigned char >::ofColor_(float,float)\n"
  "    ofColor_< unsigned char >::ofColor_(float)\n"
  "    ofColor_< unsigned char >::ofColor_(ofColor_< unsigned char > const &,float)\n"); lua_error(L);return 0; }
static int _wrap_Color_fromHsb__SWIG_0(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ; float arg4 ;
  ofColor_< unsigned char > result; SWIG_check_num_args("ofColor_< unsigned char >::fromHsb",4,4)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofColor_< unsigned char >::fromHsb",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< unsigned char >::fromHsb",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofColor_< unsigned char >::fromHsb",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofColor_< unsigned char >::fromHsb",4,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  result = ofColor_< unsigned char >::SWIGTEMPLATEDISAMBIGUATOR fromHsb(arg1,arg2,arg3,arg4); {
    ofColor_< unsigned char > * resultptr = new ofColor_< unsigned char >((const ofColor_< unsigned char > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofColor_T_unsigned_char_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Color_fromHsb__SWIG_1(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ;
  ofColor_< unsigned char > result; SWIG_check_num_args("ofColor_< unsigned char >::fromHsb",3,3)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofColor_< unsigned char >::fromHsb",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< unsigned char >::fromHsb",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofColor_< unsigned char >::fromHsb",3,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3);
  result = ofColor_< unsigned char >::SWIGTEMPLATEDISAMBIGUATOR fromHsb(arg1,arg2,arg3); {
    ofColor_< unsigned char > * resultptr = new ofColor_< unsigned char >((const ofColor_< unsigned char > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofColor_T_unsigned_char_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Color_fromHsb(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L); if (argc == 3) {
    int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { {
          _v = lua_isnumber(L,argv[2]); }  if (_v) { return _wrap_Color_fromHsb__SWIG_1(L);}  }  }  }  if (argc == 4) { int _v;
    { _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); } 
        if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_Color_fromHsb__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Color_fromHsb'\n" "  Possible C/C++ prototypes are:\n"
  "    ofColor_< unsigned char >::fromHsb(float,float,float,float)\n"
  "    ofColor_< unsigned char >::fromHsb(float,float,float)\n"); lua_error(L);return 0; }
static int _wrap_Color_fromHex__SWIG_0(lua_State* L) { int SWIG_arg = 0; int arg1 ; float arg2 ;
  ofColor_< unsigned char > result; SWIG_check_num_args("ofColor_< unsigned char >::fromHex",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofColor_< unsigned char >::fromHex",1,"int");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< unsigned char >::fromHex",2,"float"); arg1 = (int)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); result = ofColor_< unsigned char >::SWIGTEMPLATEDISAMBIGUATOR fromHex(arg1,arg2); {
    ofColor_< unsigned char > * resultptr = new ofColor_< unsigned char >((const ofColor_< unsigned char > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofColor_T_unsigned_char_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Color_fromHex__SWIG_1(lua_State* L) { int SWIG_arg = 0; int arg1 ; ofColor_< unsigned char > result;
  SWIG_check_num_args("ofColor_< unsigned char >::fromHex",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofColor_< unsigned char >::fromHex",1,"int"); arg1 = (int)lua_tonumber(L, 1);
  result = ofColor_< unsigned char >::SWIGTEMPLATEDISAMBIGUATOR fromHex(arg1); {
    ofColor_< unsigned char > * resultptr = new ofColor_< unsigned char >((const ofColor_< unsigned char > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofColor_T_unsigned_char_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Color_fromHex(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 1) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { return _wrap_Color_fromHex__SWIG_1(L);}  }  if (argc == 2) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_Color_fromHex__SWIG_0(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Color_fromHex'\n" "  Possible C/C++ prototypes are:\n"
  "    ofColor_< unsigned char >::fromHex(int,float)\n" "    ofColor_< unsigned char >::fromHex(int)\n");
  lua_error(L);return 0; }
static int _wrap_Color_set__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned char > *arg1 = (ofColor_< unsigned char > *) 0 ; float arg2 ; float arg3 ; float arg4 ; float arg5 ;
  SWIG_check_num_args("ofColor_< unsigned char >::set",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned char >::set",1,"ofColor_< unsigned char > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< unsigned char >::set",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofColor_< unsigned char >::set",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofColor_< unsigned char >::set",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofColor_< unsigned char >::set",5,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Color_set",1,SWIGTYPE_p_ofColor_T_unsigned_char_t); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); arg5 = (float)lua_tonumber(L, 5);
  (arg1)->set(arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Color_set__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned char > *arg1 = (ofColor_< unsigned char > *) 0 ; float arg2 ; float arg3 ; float arg4 ;
  SWIG_check_num_args("ofColor_< unsigned char >::set",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned char >::set",1,"ofColor_< unsigned char > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< unsigned char >::set",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofColor_< unsigned char >::set",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofColor_< unsigned char >::set",4,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Color_set",1,SWIGTYPE_p_ofColor_T_unsigned_char_t); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); (arg1)->set(arg2,arg3,arg4); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Color_set__SWIG_2(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned char > *arg1 = (ofColor_< unsigned char > *) 0 ; float arg2 ; float arg3 ;
  SWIG_check_num_args("ofColor_< unsigned char >::set",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned char >::set",1,"ofColor_< unsigned char > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< unsigned char >::set",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofColor_< unsigned char >::set",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Color_set",1,SWIGTYPE_p_ofColor_T_unsigned_char_t); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); (arg1)->set(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Color_set__SWIG_3(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned char > *arg1 = (ofColor_< unsigned char > *) 0 ; float arg2 ;
  SWIG_check_num_args("ofColor_< unsigned char >::set",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned char >::set",1,"ofColor_< unsigned char > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< unsigned char >::set",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Color_set",1,SWIGTYPE_p_ofColor_T_unsigned_char_t); }  arg2 = (float)lua_tonumber(L, 2); (arg1)->set(arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Color_set__SWIG_4(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned char > *arg1 = (ofColor_< unsigned char > *) 0 ; ofColor_< unsigned char > *arg2 = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::set",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned char >::set",1,"ofColor_< unsigned char > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofColor_< unsigned char >::set",2,"ofColor_< unsigned char > const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Color_set",1,SWIGTYPE_p_ofColor_T_unsigned_char_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Color_set",2,SWIGTYPE_p_ofColor_T_unsigned_char_t); }  (arg1)->set((ofColor_< unsigned char > const &)*arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Color_set(lua_State* L) { int argc; int argv[6]={ 1,2,3,4,5,6} ; argc = lua_gettop(L); if (argc == 2) { int _v;
    { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofColor_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofColor_T_unsigned_char_t, 0)) {
          _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Color_set__SWIG_4(L);}  }  }  if (argc == 2) { int _v; {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofColor_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_Color_set__SWIG_3(L);}  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofColor_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { return _wrap_Color_set__SWIG_2(L);}  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofColor_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_Color_set__SWIG_1(L);}  }  }  }  } 
  if (argc == 5) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofColor_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) {
              return _wrap_Color_set__SWIG_0(L);}  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Color_set'\n" "  Possible C/C++ prototypes are:\n"
  "    ofColor_< unsigned char >::set(float,float,float,float)\n" "    ofColor_< unsigned char >::set(float,float,float)\n"
  "    ofColor_< unsigned char >::set(float,float)\n" "    ofColor_< unsigned char >::set(float)\n"
  "    ofColor_< unsigned char >::set(ofColor_< unsigned char > const &)\n"); lua_error(L);return 0; }
static int _wrap_Color_setHex__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned char > *arg1 = (ofColor_< unsigned char > *) 0 ; int arg2 ; float arg3 ;
  SWIG_check_num_args("ofColor_< unsigned char >::setHex",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned char >::setHex",1,"ofColor_< unsigned char > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< unsigned char >::setHex",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofColor_< unsigned char >::setHex",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Color_setHex",1,SWIGTYPE_p_ofColor_T_unsigned_char_t); }  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); (arg1)->setHex(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Color_setHex__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned char > *arg1 = (ofColor_< unsigned char > *) 0 ; int arg2 ;
  SWIG_check_num_args("ofColor_< unsigned char >::setHex",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned char >::setHex",1,"ofColor_< unsigned char > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< unsigned char >::setHex",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Color_setHex",1,SWIGTYPE_p_ofColor_T_unsigned_char_t); }  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setHex(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Color_setHex(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 2) { int _v;
    { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofColor_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_Color_setHex__SWIG_1(L);}  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofColor_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { return _wrap_Color_setHex__SWIG_0(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Color_setHex'\n" "  Possible C/C++ prototypes are:\n"
  "    ofColor_< unsigned char >::setHex(int,float)\n" "    ofColor_< unsigned char >::setHex(int)\n"); lua_error(L);return 0; }
static int _wrap_Color_setHue(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned char > *arg1 = (ofColor_< unsigned char > *) 0 ; float arg2 ;
  SWIG_check_num_args("ofColor_< unsigned char >::setHue",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned char >::setHue",1,"ofColor_< unsigned char > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< unsigned char >::setHue",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Color_setHue",1,SWIGTYPE_p_ofColor_T_unsigned_char_t); }  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setHue(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Color_setHueAngle(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned char > *arg1 = (ofColor_< unsigned char > *) 0 ; float arg2 ;
  SWIG_check_num_args("ofColor_< unsigned char >::setHueAngle",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned char >::setHueAngle",1,"ofColor_< unsigned char > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< unsigned char >::setHueAngle",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Color_setHueAngle",1,SWIGTYPE_p_ofColor_T_unsigned_char_t); }  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setHueAngle(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Color_setSaturation(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned char > *arg1 = (ofColor_< unsigned char > *) 0 ; float arg2 ;
  SWIG_check_num_args("ofColor_< unsigned char >::setSaturation",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned char >::setSaturation",1,"ofColor_< unsigned char > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< unsigned char >::setSaturation",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Color_setSaturation",1,SWIGTYPE_p_ofColor_T_unsigned_char_t); }  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setSaturation(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Color_setBrightness(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned char > *arg1 = (ofColor_< unsigned char > *) 0 ; float arg2 ;
  SWIG_check_num_args("ofColor_< unsigned char >::setBrightness",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned char >::setBrightness",1,"ofColor_< unsigned char > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< unsigned char >::setBrightness",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Color_setBrightness",1,SWIGTYPE_p_ofColor_T_unsigned_char_t); }  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setBrightness(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Color_setHsb__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned char > *arg1 = (ofColor_< unsigned char > *) 0 ; float arg2 ; float arg3 ; float arg4 ; float arg5 ;
  SWIG_check_num_args("ofColor_< unsigned char >::setHsb",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned char >::setHsb",1,"ofColor_< unsigned char > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< unsigned char >::setHsb",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofColor_< unsigned char >::setHsb",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofColor_< unsigned char >::setHsb",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofColor_< unsigned char >::setHsb",5,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Color_setHsb",1,SWIGTYPE_p_ofColor_T_unsigned_char_t); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); arg5 = (float)lua_tonumber(L, 5);
  (arg1)->setHsb(arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Color_setHsb__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned char > *arg1 = (ofColor_< unsigned char > *) 0 ; float arg2 ; float arg3 ; float arg4 ;
  SWIG_check_num_args("ofColor_< unsigned char >::setHsb",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned char >::setHsb",1,"ofColor_< unsigned char > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< unsigned char >::setHsb",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofColor_< unsigned char >::setHsb",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofColor_< unsigned char >::setHsb",4,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Color_setHsb",1,SWIGTYPE_p_ofColor_T_unsigned_char_t); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); (arg1)->setHsb(arg2,arg3,arg4); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Color_setHsb(lua_State* L) { int argc; int argv[6]={ 1,2,3,4,5,6} ; argc = lua_gettop(L); if (argc == 4) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofColor_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_Color_setHsb__SWIG_1(L);}  }  }  }  } 
  if (argc == 5) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofColor_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) {
              return _wrap_Color_setHsb__SWIG_0(L);}  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Color_setHsb'\n" "  Possible C/C++ prototypes are:\n"
  "    ofColor_< unsigned char >::setHsb(float,float,float,float)\n"
  "    ofColor_< unsigned char >::setHsb(float,float,float)\n"); lua_error(L);return 0; }
static int _wrap_Color_clamp(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned char > *arg1 = (ofColor_< unsigned char > *) 0 ; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::clamp",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned char >::clamp",1,"ofColor_< unsigned char > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Color_clamp",1,SWIGTYPE_p_ofColor_T_unsigned_char_t); } 
  result = (ofColor_< unsigned char > *) &(arg1)->clamp();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_invert(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned char > *arg1 = (ofColor_< unsigned char > *) 0 ; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::invert",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned char >::invert",1,"ofColor_< unsigned char > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Color_invert",1,SWIGTYPE_p_ofColor_T_unsigned_char_t); } 
  result = (ofColor_< unsigned char > *) &(arg1)->invert();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_normalize(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned char > *arg1 = (ofColor_< unsigned char > *) 0 ; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::normalize",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned char >::normalize",1,"ofColor_< unsigned char > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Color_normalize",1,SWIGTYPE_p_ofColor_T_unsigned_char_t); } 
  result = (ofColor_< unsigned char > *) &(arg1)->normalize();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_lerp(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned char > *arg1 = (ofColor_< unsigned char > *) 0 ; ofColor_< unsigned char > *arg2 = 0 ; float arg3 ;
  ofColor_< unsigned char > *result = 0 ; SWIG_check_num_args("ofColor_< unsigned char >::lerp",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned char >::lerp",1,"ofColor_< unsigned char > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofColor_< unsigned char >::lerp",2,"ofColor_< unsigned char > const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofColor_< unsigned char >::lerp",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Color_lerp",1,SWIGTYPE_p_ofColor_T_unsigned_char_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Color_lerp",2,SWIGTYPE_p_ofColor_T_unsigned_char_t); }  arg3 = (float)lua_tonumber(L, 3);
  result = (ofColor_< unsigned char > *) &(arg1)->lerp((ofColor_< unsigned char > const &)*arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_getClamped(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned char > *arg1 = (ofColor_< unsigned char > *) 0 ; ofColor_< unsigned char > result;
  SWIG_check_num_args("ofColor_< unsigned char >::getClamped",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned char >::getClamped",1,"ofColor_< unsigned char > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Color_getClamped",1,SWIGTYPE_p_ofColor_T_unsigned_char_t); } 
  result = ((ofColor_< unsigned char > const *)arg1)->getClamped(); {
    ofColor_< unsigned char > * resultptr = new ofColor_< unsigned char >((const ofColor_< unsigned char > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofColor_T_unsigned_char_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Color_getInverted(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned char > *arg1 = (ofColor_< unsigned char > *) 0 ; ofColor_< unsigned char > result;
  SWIG_check_num_args("ofColor_< unsigned char >::getInverted",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned char >::getInverted",1,"ofColor_< unsigned char > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Color_getInverted",1,SWIGTYPE_p_ofColor_T_unsigned_char_t); } 
  result = ((ofColor_< unsigned char > const *)arg1)->getInverted(); {
    ofColor_< unsigned char > * resultptr = new ofColor_< unsigned char >((const ofColor_< unsigned char > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofColor_T_unsigned_char_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Color_getNormalized(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned char > *arg1 = (ofColor_< unsigned char > *) 0 ; ofColor_< unsigned char > result;
  SWIG_check_num_args("ofColor_< unsigned char >::getNormalized",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned char >::getNormalized",1,"ofColor_< unsigned char > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Color_getNormalized",1,SWIGTYPE_p_ofColor_T_unsigned_char_t); } 
  result = ((ofColor_< unsigned char > const *)arg1)->getNormalized(); {
    ofColor_< unsigned char > * resultptr = new ofColor_< unsigned char >((const ofColor_< unsigned char > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofColor_T_unsigned_char_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Color_getLerped(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned char > *arg1 = (ofColor_< unsigned char > *) 0 ; ofColor_< unsigned char > *arg2 = 0 ; float arg3 ;
  ofColor_< unsigned char > result; SWIG_check_num_args("ofColor_< unsigned char >::getLerped",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned char >::getLerped",1,"ofColor_< unsigned char > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofColor_< unsigned char >::getLerped",2,"ofColor_< unsigned char > const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofColor_< unsigned char >::getLerped",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Color_getLerped",1,SWIGTYPE_p_ofColor_T_unsigned_char_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Color_getLerped",2,SWIGTYPE_p_ofColor_T_unsigned_char_t); }  arg3 = (float)lua_tonumber(L, 3);
  result = ((ofColor_< unsigned char > const *)arg1)->getLerped((ofColor_< unsigned char > const &)*arg2,arg3); {
    ofColor_< unsigned char > * resultptr = new ofColor_< unsigned char >((const ofColor_< unsigned char > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofColor_T_unsigned_char_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Color_getHex(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned char > *arg1 = (ofColor_< unsigned char > *) 0 ; int result;
  SWIG_check_num_args("ofColor_< unsigned char >::getHex",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned char >::getHex",1,"ofColor_< unsigned char > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Color_getHex",1,SWIGTYPE_p_ofColor_T_unsigned_char_t); } 
  result = (int)((ofColor_< unsigned char > const *)arg1)->getHex(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Color_getHue(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned char > *arg1 = (ofColor_< unsigned char > *) 0 ; float result;
  SWIG_check_num_args("ofColor_< unsigned char >::getHue",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned char >::getHue",1,"ofColor_< unsigned char > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Color_getHue",1,SWIGTYPE_p_ofColor_T_unsigned_char_t); } 
  result = (float)((ofColor_< unsigned char > const *)arg1)->getHue(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Color_getHueAngle(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned char > *arg1 = (ofColor_< unsigned char > *) 0 ; float result;
  SWIG_check_num_args("ofColor_< unsigned char >::getHueAngle",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned char >::getHueAngle",1,"ofColor_< unsigned char > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Color_getHueAngle",1,SWIGTYPE_p_ofColor_T_unsigned_char_t); } 
  result = (float)((ofColor_< unsigned char > const *)arg1)->getHueAngle(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Color_getSaturation(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned char > *arg1 = (ofColor_< unsigned char > *) 0 ; float result;
  SWIG_check_num_args("ofColor_< unsigned char >::getSaturation",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned char >::getSaturation",1,"ofColor_< unsigned char > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Color_getSaturation",1,SWIGTYPE_p_ofColor_T_unsigned_char_t); } 
  result = (float)((ofColor_< unsigned char > const *)arg1)->getSaturation();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Color_getBrightness(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned char > *arg1 = (ofColor_< unsigned char > *) 0 ; float result;
  SWIG_check_num_args("ofColor_< unsigned char >::getBrightness",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned char >::getBrightness",1,"ofColor_< unsigned char > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Color_getBrightness",1,SWIGTYPE_p_ofColor_T_unsigned_char_t); } 
  result = (float)((ofColor_< unsigned char > const *)arg1)->getBrightness();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Color_getLightness(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned char > *arg1 = (ofColor_< unsigned char > *) 0 ; float result;
  SWIG_check_num_args("ofColor_< unsigned char >::getLightness",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned char >::getLightness",1,"ofColor_< unsigned char > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Color_getLightness",1,SWIGTYPE_p_ofColor_T_unsigned_char_t); } 
  result = (float)((ofColor_< unsigned char > const *)arg1)->getLightness(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Color_getHsb(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned char > *arg1 = (ofColor_< unsigned char > *) 0 ; float *arg2 = 0 ; float *arg3 = 0 ; float *arg4 = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::getHsb",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned char >::getHsb",1,"ofColor_< unsigned char > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofColor_< unsigned char >::getHsb",2,"float &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofColor_< unsigned char >::getHsb",3,"float &");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("ofColor_< unsigned char >::getHsb",4,"float &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Color_getHsb",1,SWIGTYPE_p_ofColor_T_unsigned_char_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_float,0))){ SWIG_fail_ptr("Color_getHsb",2,SWIGTYPE_p_float); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_float,0))){ SWIG_fail_ptr("Color_getHsb",3,SWIGTYPE_p_float); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_float,0))){ SWIG_fail_ptr("Color_getHsb",4,SWIGTYPE_p_float); } 
  ((ofColor_< unsigned char > const *)arg1)->getHsb(*arg2,*arg3,*arg4); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Color_limit(lua_State* L) { int SWIG_arg = 0; float result;
  SWIG_check_num_args("ofColor_< unsigned char >::limit",0,0)
  result = (float)ofColor_< unsigned char >::SWIGTEMPLATEDISAMBIGUATOR limit();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Color___eq(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned char > *arg1 = (ofColor_< unsigned char > *) 0 ; ofColor_< unsigned char > *arg2 = 0 ; bool result;
  SWIG_check_num_args("ofColor_< unsigned char >::operator ==",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned char >::operator ==",1,"ofColor_< unsigned char > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofColor_< unsigned char >::operator ==",2,"ofColor_< unsigned char > const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Color___eq",1,SWIGTYPE_p_ofColor_T_unsigned_char_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Color___eq",2,SWIGTYPE_p_ofColor_T_unsigned_char_t); } 
  result = (bool)((ofColor_< unsigned char > const *)arg1)->operator ==((ofColor_< unsigned char > const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Color___add__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned char > *arg1 = (ofColor_< unsigned char > *) 0 ; ofColor_< unsigned char > *arg2 = 0 ;
  ofColor_< unsigned char > result; SWIG_check_num_args("ofColor_< unsigned char >::operator +",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned char >::operator +",1,"ofColor_< unsigned char > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofColor_< unsigned char >::operator +",2,"ofColor_< unsigned char > const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Color___add",1,SWIGTYPE_p_ofColor_T_unsigned_char_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Color___add",2,SWIGTYPE_p_ofColor_T_unsigned_char_t); } 
  result = ((ofColor_< unsigned char > const *)arg1)->operator +((ofColor_< unsigned char > const &)*arg2); {
    ofColor_< unsigned char > * resultptr = new ofColor_< unsigned char >((const ofColor_< unsigned char > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofColor_T_unsigned_char_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Color___add__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned char > *arg1 = (ofColor_< unsigned char > *) 0 ; float arg2 ; ofColor_< unsigned char > result;
  SWIG_check_num_args("ofColor_< unsigned char >::operator +",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned char >::operator +",1,"ofColor_< unsigned char > const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< unsigned char >::operator +",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Color___add",1,SWIGTYPE_p_ofColor_T_unsigned_char_t); }  arg2 = (float)lua_tonumber(L, 2);
  result = ((ofColor_< unsigned char > const *)arg1)->operator +(arg2); {
    ofColor_< unsigned char > * resultptr = new ofColor_< unsigned char >((const ofColor_< unsigned char > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofColor_T_unsigned_char_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Color___add(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 2) { int _v; {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofColor_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofColor_T_unsigned_char_t, 0)) {
          _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Color___add__SWIG_0(L);}  }  }  if (argc == 2) { int _v; {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofColor_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_Color___add__SWIG_1(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Color___add'\n" "  Possible C/C++ prototypes are:\n"
  "    ofColor_< unsigned char >::operator +(ofColor_< unsigned char > const &) const\n"
  "    ofColor_< unsigned char >::operator +(float) const\n"); lua_error(L);return 0; }
static int _wrap_Color___sub__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned char > *arg1 = (ofColor_< unsigned char > *) 0 ; ofColor_< unsigned char > *arg2 = 0 ;
  ofColor_< unsigned char > result; SWIG_check_num_args("ofColor_< unsigned char >::operator -",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned char >::operator -",1,"ofColor_< unsigned char > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofColor_< unsigned char >::operator -",2,"ofColor_< unsigned char > const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Color___sub",1,SWIGTYPE_p_ofColor_T_unsigned_char_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Color___sub",2,SWIGTYPE_p_ofColor_T_unsigned_char_t); } 
  result = ((ofColor_< unsigned char > const *)arg1)->operator -((ofColor_< unsigned char > const &)*arg2); {
    ofColor_< unsigned char > * resultptr = new ofColor_< unsigned char >((const ofColor_< unsigned char > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofColor_T_unsigned_char_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Color___sub__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned char > *arg1 = (ofColor_< unsigned char > *) 0 ; float arg2 ; ofColor_< unsigned char > result;
  SWIG_check_num_args("ofColor_< unsigned char >::operator -",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned char >::operator -",1,"ofColor_< unsigned char > const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< unsigned char >::operator -",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Color___sub",1,SWIGTYPE_p_ofColor_T_unsigned_char_t); }  arg2 = (float)lua_tonumber(L, 2);
  result = ((ofColor_< unsigned char > const *)arg1)->operator -(arg2); {
    ofColor_< unsigned char > * resultptr = new ofColor_< unsigned char >((const ofColor_< unsigned char > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofColor_T_unsigned_char_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Color___sub(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 2) { int _v; {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofColor_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofColor_T_unsigned_char_t, 0)) {
          _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Color___sub__SWIG_0(L);}  }  }  if (argc == 2) { int _v; {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofColor_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_Color___sub__SWIG_1(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Color___sub'\n" "  Possible C/C++ prototypes are:\n"
  "    ofColor_< unsigned char >::operator -(ofColor_< unsigned char > const &) const\n"
  "    ofColor_< unsigned char >::operator -(float) const\n"); lua_error(L);return 0; }
static int _wrap_Color___mul__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned char > *arg1 = (ofColor_< unsigned char > *) 0 ; ofColor_< unsigned char > *arg2 = 0 ;
  ofColor_< unsigned char > result; SWIG_check_num_args("ofColor_< unsigned char >::operator *",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned char >::operator *",1,"ofColor_< unsigned char > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofColor_< unsigned char >::operator *",2,"ofColor_< unsigned char > const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Color___mul",1,SWIGTYPE_p_ofColor_T_unsigned_char_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Color___mul",2,SWIGTYPE_p_ofColor_T_unsigned_char_t); } 
  result = ((ofColor_< unsigned char > const *)arg1)->operator *((ofColor_< unsigned char > const &)*arg2); {
    ofColor_< unsigned char > * resultptr = new ofColor_< unsigned char >((const ofColor_< unsigned char > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofColor_T_unsigned_char_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Color___mul__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned char > *arg1 = (ofColor_< unsigned char > *) 0 ; float arg2 ; ofColor_< unsigned char > result;
  SWIG_check_num_args("ofColor_< unsigned char >::operator *",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned char >::operator *",1,"ofColor_< unsigned char > const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< unsigned char >::operator *",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Color___mul",1,SWIGTYPE_p_ofColor_T_unsigned_char_t); }  arg2 = (float)lua_tonumber(L, 2);
  result = ((ofColor_< unsigned char > const *)arg1)->operator *(arg2); {
    ofColor_< unsigned char > * resultptr = new ofColor_< unsigned char >((const ofColor_< unsigned char > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofColor_T_unsigned_char_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Color___mul(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 2) { int _v; {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofColor_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofColor_T_unsigned_char_t, 0)) {
          _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Color___mul__SWIG_0(L);}  }  }  if (argc == 2) { int _v; {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofColor_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_Color___mul__SWIG_1(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Color___mul'\n" "  Possible C/C++ prototypes are:\n"
  "    ofColor_< unsigned char >::operator *(ofColor_< unsigned char > const &) const\n"
  "    ofColor_< unsigned char >::operator *(float) const\n"); lua_error(L);return 0; }
static int _wrap_Color___div__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned char > *arg1 = (ofColor_< unsigned char > *) 0 ; ofColor_< unsigned char > *arg2 = 0 ;
  ofColor_< unsigned char > result; SWIG_check_num_args("ofColor_< unsigned char >::operator /",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned char >::operator /",1,"ofColor_< unsigned char > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofColor_< unsigned char >::operator /",2,"ofColor_< unsigned char > const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Color___div",1,SWIGTYPE_p_ofColor_T_unsigned_char_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Color___div",2,SWIGTYPE_p_ofColor_T_unsigned_char_t); } 
  result = ((ofColor_< unsigned char > const *)arg1)->operator /((ofColor_< unsigned char > const &)*arg2); {
    ofColor_< unsigned char > * resultptr = new ofColor_< unsigned char >((const ofColor_< unsigned char > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofColor_T_unsigned_char_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Color___div__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned char > *arg1 = (ofColor_< unsigned char > *) 0 ; float arg2 ; ofColor_< unsigned char > result;
  SWIG_check_num_args("ofColor_< unsigned char >::operator /",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned char >::operator /",1,"ofColor_< unsigned char > const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< unsigned char >::operator /",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Color___div",1,SWIGTYPE_p_ofColor_T_unsigned_char_t); }  arg2 = (float)lua_tonumber(L, 2);
  result = ((ofColor_< unsigned char > const *)arg1)->operator /(arg2); {
    ofColor_< unsigned char > * resultptr = new ofColor_< unsigned char >((const ofColor_< unsigned char > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofColor_T_unsigned_char_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Color___div(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 2) { int _v; {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofColor_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofColor_T_unsigned_char_t, 0)) {
          _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Color___div__SWIG_0(L);}  }  }  if (argc == 2) { int _v; {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofColor_T_unsigned_char_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_Color___div__SWIG_1(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Color___div'\n" "  Possible C/C++ prototypes are:\n"
  "    ofColor_< unsigned char >::operator /(ofColor_< unsigned char > const &) const\n"
  "    ofColor_< unsigned char >::operator /(float) const\n"); lua_error(L);return 0; }
static int _wrap_Color_white_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::white",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::white;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_gray_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::gray",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::gray;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_black_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::black",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::black;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_red_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::red",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::red;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_green_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::green",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::green;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_blue_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::blue",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::blue;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_cyan_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::cyan",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::cyan;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_magenta_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::magenta",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::magenta;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_yellow_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::yellow",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::yellow;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_aliceBlue_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::aliceBlue",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::aliceBlue;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_antiqueWhite_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::antiqueWhite",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::antiqueWhite;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_aqua_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::aqua",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::aqua;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_aquamarine_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::aquamarine",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::aquamarine;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_azure_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::azure",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::azure;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_beige_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::beige",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::beige;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_bisque_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::bisque",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::bisque;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_blanchedAlmond_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::blanchedAlmond",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::blanchedAlmond;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_blueViolet_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::blueViolet",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::blueViolet;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_brown_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::brown",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::brown;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_burlyWood_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::burlyWood",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::burlyWood;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_cadetBlue_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::cadetBlue",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::cadetBlue;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_chartreuse_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::chartreuse",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::chartreuse;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_chocolate_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::chocolate",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::chocolate;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_coral_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::coral",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::coral;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_cornflowerBlue_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::cornflowerBlue",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::cornflowerBlue;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_cornsilk_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::cornsilk",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::cornsilk;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_crimson_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::crimson",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::crimson;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_darkBlue_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::darkBlue",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::darkBlue;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_darkCyan_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::darkCyan",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::darkCyan;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_darkGoldenRod_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::darkGoldenRod",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::darkGoldenRod;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_darkGray_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::darkGray",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::darkGray;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_darkGrey_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::darkGrey",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::darkGrey;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_darkGreen_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::darkGreen",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::darkGreen;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_darkKhaki_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::darkKhaki",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::darkKhaki;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_darkMagenta_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::darkMagenta",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::darkMagenta;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_darkOliveGreen_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::darkOliveGreen",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::darkOliveGreen;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_darkorange_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::darkorange",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::darkorange;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_darkOrchid_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::darkOrchid",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::darkOrchid;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_darkRed_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::darkRed",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::darkRed;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_darkSalmon_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::darkSalmon",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::darkSalmon;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_darkSeaGreen_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::darkSeaGreen",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::darkSeaGreen;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_darkSlateBlue_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::darkSlateBlue",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::darkSlateBlue;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_darkSlateGray_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::darkSlateGray",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::darkSlateGray;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_darkSlateGrey_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::darkSlateGrey",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::darkSlateGrey;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_darkTurquoise_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::darkTurquoise",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::darkTurquoise;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_darkViolet_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::darkViolet",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::darkViolet;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_deepPink_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::deepPink",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::deepPink;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_deepSkyBlue_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::deepSkyBlue",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::deepSkyBlue;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_dimGray_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::dimGray",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::dimGray;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_dimGrey_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::dimGrey",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::dimGrey;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_dodgerBlue_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::dodgerBlue",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::dodgerBlue;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_fireBrick_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::fireBrick",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::fireBrick;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_floralWhite_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::floralWhite",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::floralWhite;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_forestGreen_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::forestGreen",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::forestGreen;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_fuchsia_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::fuchsia",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::fuchsia;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_gainsboro_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::gainsboro",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::gainsboro;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_ghostWhite_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::ghostWhite",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::ghostWhite;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_gold_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::gold",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::gold;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_goldenRod_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::goldenRod",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::goldenRod;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_grey_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::grey",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::grey;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_greenYellow_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::greenYellow",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::greenYellow;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_honeyDew_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::honeyDew",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::honeyDew;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_hotPink_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::hotPink",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::hotPink;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_indianRed_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::indianRed",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::indianRed;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_indigo_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::indigo",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::indigo;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_ivory_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::ivory",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::ivory;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_khaki_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::khaki",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::khaki;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_lavender_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::lavender",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::lavender;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_lavenderBlush_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::lavenderBlush",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::lavenderBlush;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_lawnGreen_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::lawnGreen",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::lawnGreen;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_lemonChiffon_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::lemonChiffon",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::lemonChiffon;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_lightBlue_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::lightBlue",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::lightBlue;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_lightCoral_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::lightCoral",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::lightCoral;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_lightCyan_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::lightCyan",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::lightCyan;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_lightGoldenRodYellow_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::lightGoldenRodYellow",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::lightGoldenRodYellow;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_lightGray_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::lightGray",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::lightGray;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_lightGrey_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::lightGrey",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::lightGrey;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_lightGreen_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::lightGreen",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::lightGreen;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_lightPink_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::lightPink",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::lightPink;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_lightSalmon_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::lightSalmon",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::lightSalmon;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_lightSeaGreen_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::lightSeaGreen",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::lightSeaGreen;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_lightSkyBlue_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::lightSkyBlue",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::lightSkyBlue;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_lightSlateGray_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::lightSlateGray",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::lightSlateGray;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_lightSlateGrey_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::lightSlateGrey",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::lightSlateGrey;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_lightSteelBlue_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::lightSteelBlue",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::lightSteelBlue;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_lightYellow_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::lightYellow",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::lightYellow;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_lime_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::lime",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::lime;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_limeGreen_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::limeGreen",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::limeGreen;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_linen_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::linen",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::linen;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_maroon_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::maroon",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::maroon;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_mediumAquaMarine_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::mediumAquaMarine",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::mediumAquaMarine;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_mediumBlue_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::mediumBlue",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::mediumBlue;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_mediumOrchid_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::mediumOrchid",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::mediumOrchid;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_mediumPurple_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::mediumPurple",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::mediumPurple;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_mediumSeaGreen_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::mediumSeaGreen",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::mediumSeaGreen;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_mediumSlateBlue_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::mediumSlateBlue",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::mediumSlateBlue;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_mediumSpringGreen_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::mediumSpringGreen",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::mediumSpringGreen;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_mediumTurquoise_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::mediumTurquoise",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::mediumTurquoise;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_mediumVioletRed_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::mediumVioletRed",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::mediumVioletRed;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_midnightBlue_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::midnightBlue",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::midnightBlue;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_mintCream_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::mintCream",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::mintCream;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_mistyRose_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::mistyRose",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::mistyRose;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_moccasin_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::moccasin",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::moccasin;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_navajoWhite_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::navajoWhite",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::navajoWhite;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_navy_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::navy",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::navy;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_oldLace_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::oldLace",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::oldLace;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_olive_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::olive",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::olive;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_oliveDrab_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::oliveDrab",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::oliveDrab;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_orange_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::orange",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::orange;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_orangeRed_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::orangeRed",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::orangeRed;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_orchid_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::orchid",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::orchid;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_paleGoldenRod_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::paleGoldenRod",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::paleGoldenRod;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_paleGreen_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::paleGreen",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::paleGreen;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_paleTurquoise_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::paleTurquoise",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::paleTurquoise;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_paleVioletRed_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::paleVioletRed",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::paleVioletRed;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_papayaWhip_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::papayaWhip",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::papayaWhip;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_peachPuff_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::peachPuff",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::peachPuff;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_peru_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::peru",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::peru;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_pink_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::pink",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::pink;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_plum_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::plum",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::plum;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_powderBlue_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::powderBlue",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::powderBlue;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_purple_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::purple",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::purple;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_rosyBrown_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::rosyBrown",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::rosyBrown;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_royalBlue_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::royalBlue",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::royalBlue;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_saddleBrown_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::saddleBrown",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::saddleBrown;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_salmon_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::salmon",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::salmon;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_sandyBrown_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::sandyBrown",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::sandyBrown;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_seaGreen_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::seaGreen",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::seaGreen;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_seaShell_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::seaShell",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::seaShell;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_sienna_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::sienna",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::sienna;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_silver_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::silver",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::silver;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_skyBlue_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::skyBlue",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::skyBlue;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_slateBlue_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::slateBlue",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::slateBlue;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_slateGray_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::slateGray",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::slateGray;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_slateGrey_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::slateGrey",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::slateGrey;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_snow_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::snow",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::snow;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_springGreen_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::springGreen",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::springGreen;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_steelBlue_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::steelBlue",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::steelBlue;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_blueSteel_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::blueSteel",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::blueSteel;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_tan_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::tan",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::tan;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_teal_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::teal",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::teal;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_thistle_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::thistle",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::thistle;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_tomato_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::tomato",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::tomato;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_turquoise_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::turquoise",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::turquoise;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_violet_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::violet",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::violet;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_wheat_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::wheat",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::wheat;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_whiteSmoke_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::whiteSmoke",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::whiteSmoke;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_yellowGreen_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned char > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::yellowGreen",0,0)
  result = (ofColor_< unsigned char > *)&ofColor_< unsigned char >::yellowGreen;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Color_getR(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned char > *arg1 = (ofColor_< unsigned char > *) 0 ; unsigned char result;
  SWIG_check_num_args("ofColor_< unsigned char >::getR",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned char >::getR",1,"ofColor_< unsigned char > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Color_getR",1,SWIGTYPE_p_ofColor_T_unsigned_char_t); } 
  result = (unsigned char)ofColor__Sl_unsigned_SS_char_Sg__getR(arg1); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Color_getG(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned char > *arg1 = (ofColor_< unsigned char > *) 0 ; unsigned char result;
  SWIG_check_num_args("ofColor_< unsigned char >::getG",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned char >::getG",1,"ofColor_< unsigned char > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Color_getG",1,SWIGTYPE_p_ofColor_T_unsigned_char_t); } 
  result = (unsigned char)ofColor__Sl_unsigned_SS_char_Sg__getG(arg1); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Color_getB(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned char > *arg1 = (ofColor_< unsigned char > *) 0 ; unsigned char result;
  SWIG_check_num_args("ofColor_< unsigned char >::getB",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned char >::getB",1,"ofColor_< unsigned char > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Color_getB",1,SWIGTYPE_p_ofColor_T_unsigned_char_t); } 
  result = (unsigned char)ofColor__Sl_unsigned_SS_char_Sg__getB(arg1); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Color_getA(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned char > *arg1 = (ofColor_< unsigned char > *) 0 ; unsigned char result;
  SWIG_check_num_args("ofColor_< unsigned char >::getA",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned char >::getA",1,"ofColor_< unsigned char > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Color_getA",1,SWIGTYPE_p_ofColor_T_unsigned_char_t); } 
  result = (unsigned char)ofColor__Sl_unsigned_SS_char_Sg__getA(arg1); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Color_setR(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned char > *arg1 = (ofColor_< unsigned char > *) 0 ; unsigned char arg2 ;
  SWIG_check_num_args("ofColor_< unsigned char >::setR",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned char >::setR",1,"ofColor_< unsigned char > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< unsigned char >::setR",2,"unsigned char");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Color_setR",1,SWIGTYPE_p_ofColor_T_unsigned_char_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (unsigned char)lua_tonumber(L, 2);
  ofColor__Sl_unsigned_SS_char_Sg__setR(arg1,arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Color_setG(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned char > *arg1 = (ofColor_< unsigned char > *) 0 ; unsigned char arg2 ;
  SWIG_check_num_args("ofColor_< unsigned char >::setG",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned char >::setG",1,"ofColor_< unsigned char > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< unsigned char >::setG",2,"unsigned char");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Color_setG",1,SWIGTYPE_p_ofColor_T_unsigned_char_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (unsigned char)lua_tonumber(L, 2);
  ofColor__Sl_unsigned_SS_char_Sg__setG(arg1,arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Color_setB(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned char > *arg1 = (ofColor_< unsigned char > *) 0 ; unsigned char arg2 ;
  SWIG_check_num_args("ofColor_< unsigned char >::setB",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned char >::setB",1,"ofColor_< unsigned char > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< unsigned char >::setB",2,"unsigned char");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Color_setB",1,SWIGTYPE_p_ofColor_T_unsigned_char_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (unsigned char)lua_tonumber(L, 2);
  ofColor__Sl_unsigned_SS_char_Sg__setB(arg1,arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Color_setA(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned char > *arg1 = (ofColor_< unsigned char > *) 0 ; unsigned char arg2 ;
  SWIG_check_num_args("ofColor_< unsigned char >::setA",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned char >::setA",1,"ofColor_< unsigned char > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< unsigned char >::setA",2,"unsigned char");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Color_setA",1,SWIGTYPE_p_ofColor_T_unsigned_char_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (unsigned char)lua_tonumber(L, 2);
  ofColor__Sl_unsigned_SS_char_Sg__setA(arg1,arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Color___tostring(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned char > *arg1 = (ofColor_< unsigned char > *) 0 ; char *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned char >::__str__",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned char >::__str__",1,"ofColor_< unsigned char > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Color___tostring",1,SWIGTYPE_p_ofColor_T_unsigned_char_t); } 
  result = (char *)ofColor__Sl_unsigned_SS_char_Sg____str__(arg1); lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Color_r_set(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned char > *arg1 = (ofColor_< unsigned char > *) 0 ; unsigned char arg2 ;
  SWIG_check_num_args("ofColor_< unsigned char >::r",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned char >::r",1,"ofColor_< unsigned char > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< unsigned char >::r",2,"unsigned char");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Color_r_set",1,SWIGTYPE_p_ofColor_T_unsigned_char_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (unsigned char)lua_tonumber(L, 2);
  ofColor__Sl_unsigned_SS_char_Sg__r_set(arg1,arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Color_r_get(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned char > *arg1 = (ofColor_< unsigned char > *) 0 ; unsigned char result;
  SWIG_check_num_args("ofColor_< unsigned char >::r",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned char >::r",1,"ofColor_< unsigned char > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Color_r_get",1,SWIGTYPE_p_ofColor_T_unsigned_char_t); } 
  result = (unsigned char)ofColor__Sl_unsigned_SS_char_Sg__r_get(arg1); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Color_g_set(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned char > *arg1 = (ofColor_< unsigned char > *) 0 ; unsigned char arg2 ;
  SWIG_check_num_args("ofColor_< unsigned char >::g",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned char >::g",1,"ofColor_< unsigned char > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< unsigned char >::g",2,"unsigned char");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Color_g_set",1,SWIGTYPE_p_ofColor_T_unsigned_char_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (unsigned char)lua_tonumber(L, 2);
  ofColor__Sl_unsigned_SS_char_Sg__g_set(arg1,arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Color_g_get(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned char > *arg1 = (ofColor_< unsigned char > *) 0 ; unsigned char result;
  SWIG_check_num_args("ofColor_< unsigned char >::g",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned char >::g",1,"ofColor_< unsigned char > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Color_g_get",1,SWIGTYPE_p_ofColor_T_unsigned_char_t); } 
  result = (unsigned char)ofColor__Sl_unsigned_SS_char_Sg__g_get(arg1); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Color_b_set(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned char > *arg1 = (ofColor_< unsigned char > *) 0 ; unsigned char arg2 ;
  SWIG_check_num_args("ofColor_< unsigned char >::b",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned char >::b",1,"ofColor_< unsigned char > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< unsigned char >::b",2,"unsigned char");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Color_b_set",1,SWIGTYPE_p_ofColor_T_unsigned_char_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (unsigned char)lua_tonumber(L, 2);
  ofColor__Sl_unsigned_SS_char_Sg__b_set(arg1,arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Color_b_get(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned char > *arg1 = (ofColor_< unsigned char > *) 0 ; unsigned char result;
  SWIG_check_num_args("ofColor_< unsigned char >::b",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned char >::b",1,"ofColor_< unsigned char > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Color_b_get",1,SWIGTYPE_p_ofColor_T_unsigned_char_t); } 
  result = (unsigned char)ofColor__Sl_unsigned_SS_char_Sg__b_get(arg1); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Color_a_set(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned char > *arg1 = (ofColor_< unsigned char > *) 0 ; unsigned char arg2 ;
  SWIG_check_num_args("ofColor_< unsigned char >::a",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned char >::a",1,"ofColor_< unsigned char > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< unsigned char >::a",2,"unsigned char");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Color_a_set",1,SWIGTYPE_p_ofColor_T_unsigned_char_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (unsigned char)lua_tonumber(L, 2);
  ofColor__Sl_unsigned_SS_char_Sg__a_set(arg1,arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Color_a_get(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned char > *arg1 = (ofColor_< unsigned char > *) 0 ; unsigned char result;
  SWIG_check_num_args("ofColor_< unsigned char >::a",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned char >::a",1,"ofColor_< unsigned char > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_char_t,0))){
    SWIG_fail_ptr("Color_a_get",1,SWIGTYPE_p_ofColor_T_unsigned_char_t); } 
  result = (unsigned char)ofColor__Sl_unsigned_SS_char_Sg__a_get(arg1); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static void swig_delete_Color(void *obj) {
ofColor_< unsigned char > *arg1 = (ofColor_< unsigned char > *) obj;
delete arg1;
}
static int _proxy__wrap_new_Color(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_Color);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_Color_attributes[] = {
    { "r", _wrap_Color_r_get, _wrap_Color_r_set },
    { "g", _wrap_Color_g_get, _wrap_Color_g_set },
    { "b", _wrap_Color_b_get, _wrap_Color_b_set },
    { "a", _wrap_Color_a_get, _wrap_Color_a_set },
    {0,0,0}
};
static swig_lua_method swig_Color_methods[]= {
    { "set", _wrap_Color_set},
    { "setHex", _wrap_Color_setHex},
    { "setHue", _wrap_Color_setHue},
    { "setHueAngle", _wrap_Color_setHueAngle},
    { "setSaturation", _wrap_Color_setSaturation},
    { "setBrightness", _wrap_Color_setBrightness},
    { "setHsb", _wrap_Color_setHsb},
    { "clamp", _wrap_Color_clamp},
    { "invert", _wrap_Color_invert},
    { "normalize", _wrap_Color_normalize},
    { "lerp", _wrap_Color_lerp},
    { "getClamped", _wrap_Color_getClamped},
    { "getInverted", _wrap_Color_getInverted},
    { "getNormalized", _wrap_Color_getNormalized},
    { "getLerped", _wrap_Color_getLerped},
    { "getHex", _wrap_Color_getHex},
    { "getHue", _wrap_Color_getHue},
    { "getHueAngle", _wrap_Color_getHueAngle},
    { "getSaturation", _wrap_Color_getSaturation},
    { "getBrightness", _wrap_Color_getBrightness},
    { "getLightness", _wrap_Color_getLightness},
    { "getHsb", _wrap_Color_getHsb},
    { "__eq", _wrap_Color___eq},
    { "__add", _wrap_Color___add},
    { "__sub", _wrap_Color___sub},
    { "__mul", _wrap_Color___mul},
    { "__div", _wrap_Color___div},
    { "getR", _wrap_Color_getR},
    { "getG", _wrap_Color_getG},
    { "getB", _wrap_Color_getB},
    { "getA", _wrap_Color_getA},
    { "setR", _wrap_Color_setR},
    { "setG", _wrap_Color_setG},
    { "setB", _wrap_Color_setB},
    { "setA", _wrap_Color_setA},
    { "__tostring", _wrap_Color___tostring},
    {0,0}
};
static swig_lua_method swig_Color_meta[] = {
    { "__eq", _wrap_Color___eq},
    { "__add", _wrap_Color___add},
    { "__sub", _wrap_Color___sub},
    { "__mul", _wrap_Color___mul},
    { "__div", _wrap_Color___div},
    { "__tostring", _wrap_Color___tostring},
    {0,0}
};

static swig_lua_attribute swig_Color_Sf_SwigStatic_attributes[] = {
    { "white", _wrap_Color_white_get, SWIG_Lua_set_immutable },
    { "gray", _wrap_Color_gray_get, SWIG_Lua_set_immutable },
    { "black", _wrap_Color_black_get, SWIG_Lua_set_immutable },
    { "red", _wrap_Color_red_get, SWIG_Lua_set_immutable },
    { "green", _wrap_Color_green_get, SWIG_Lua_set_immutable },
    { "blue", _wrap_Color_blue_get, SWIG_Lua_set_immutable },
    { "cyan", _wrap_Color_cyan_get, SWIG_Lua_set_immutable },
    { "magenta", _wrap_Color_magenta_get, SWIG_Lua_set_immutable },
    { "yellow", _wrap_Color_yellow_get, SWIG_Lua_set_immutable },
    { "aliceBlue", _wrap_Color_aliceBlue_get, SWIG_Lua_set_immutable },
    { "antiqueWhite", _wrap_Color_antiqueWhite_get, SWIG_Lua_set_immutable },
    { "aqua", _wrap_Color_aqua_get, SWIG_Lua_set_immutable },
    { "aquamarine", _wrap_Color_aquamarine_get, SWIG_Lua_set_immutable },
    { "azure", _wrap_Color_azure_get, SWIG_Lua_set_immutable },
    { "beige", _wrap_Color_beige_get, SWIG_Lua_set_immutable },
    { "bisque", _wrap_Color_bisque_get, SWIG_Lua_set_immutable },
    { "blanchedAlmond", _wrap_Color_blanchedAlmond_get, SWIG_Lua_set_immutable },
    { "blueViolet", _wrap_Color_blueViolet_get, SWIG_Lua_set_immutable },
    { "brown", _wrap_Color_brown_get, SWIG_Lua_set_immutable },
    { "burlyWood", _wrap_Color_burlyWood_get, SWIG_Lua_set_immutable },
    { "cadetBlue", _wrap_Color_cadetBlue_get, SWIG_Lua_set_immutable },
    { "chartreuse", _wrap_Color_chartreuse_get, SWIG_Lua_set_immutable },
    { "chocolate", _wrap_Color_chocolate_get, SWIG_Lua_set_immutable },
    { "coral", _wrap_Color_coral_get, SWIG_Lua_set_immutable },
    { "cornflowerBlue", _wrap_Color_cornflowerBlue_get, SWIG_Lua_set_immutable },
    { "cornsilk", _wrap_Color_cornsilk_get, SWIG_Lua_set_immutable },
    { "crimson", _wrap_Color_crimson_get, SWIG_Lua_set_immutable },
    { "darkBlue", _wrap_Color_darkBlue_get, SWIG_Lua_set_immutable },
    { "darkCyan", _wrap_Color_darkCyan_get, SWIG_Lua_set_immutable },
    { "darkGoldenRod", _wrap_Color_darkGoldenRod_get, SWIG_Lua_set_immutable },
    { "darkGray", _wrap_Color_darkGray_get, SWIG_Lua_set_immutable },
    { "darkGrey", _wrap_Color_darkGrey_get, SWIG_Lua_set_immutable },
    { "darkGreen", _wrap_Color_darkGreen_get, SWIG_Lua_set_immutable },
    { "darkKhaki", _wrap_Color_darkKhaki_get, SWIG_Lua_set_immutable },
    { "darkMagenta", _wrap_Color_darkMagenta_get, SWIG_Lua_set_immutable },
    { "darkOliveGreen", _wrap_Color_darkOliveGreen_get, SWIG_Lua_set_immutable },
    { "darkorange", _wrap_Color_darkorange_get, SWIG_Lua_set_immutable },
    { "darkOrchid", _wrap_Color_darkOrchid_get, SWIG_Lua_set_immutable },
    { "darkRed", _wrap_Color_darkRed_get, SWIG_Lua_set_immutable },
    { "darkSalmon", _wrap_Color_darkSalmon_get, SWIG_Lua_set_immutable },
    { "darkSeaGreen", _wrap_Color_darkSeaGreen_get, SWIG_Lua_set_immutable },
    { "darkSlateBlue", _wrap_Color_darkSlateBlue_get, SWIG_Lua_set_immutable },
    { "darkSlateGray", _wrap_Color_darkSlateGray_get, SWIG_Lua_set_immutable },
    { "darkSlateGrey", _wrap_Color_darkSlateGrey_get, SWIG_Lua_set_immutable },
    { "darkTurquoise", _wrap_Color_darkTurquoise_get, SWIG_Lua_set_immutable },
    { "darkViolet", _wrap_Color_darkViolet_get, SWIG_Lua_set_immutable },
    { "deepPink", _wrap_Color_deepPink_get, SWIG_Lua_set_immutable },
    { "deepSkyBlue", _wrap_Color_deepSkyBlue_get, SWIG_Lua_set_immutable },
    { "dimGray", _wrap_Color_dimGray_get, SWIG_Lua_set_immutable },
    { "dimGrey", _wrap_Color_dimGrey_get, SWIG_Lua_set_immutable },
    { "dodgerBlue", _wrap_Color_dodgerBlue_get, SWIG_Lua_set_immutable },
    { "fireBrick", _wrap_Color_fireBrick_get, SWIG_Lua_set_immutable },
    { "floralWhite", _wrap_Color_floralWhite_get, SWIG_Lua_set_immutable },
    { "forestGreen", _wrap_Color_forestGreen_get, SWIG_Lua_set_immutable },
    { "fuchsia", _wrap_Color_fuchsia_get, SWIG_Lua_set_immutable },
    { "gainsboro", _wrap_Color_gainsboro_get, SWIG_Lua_set_immutable },
    { "ghostWhite", _wrap_Color_ghostWhite_get, SWIG_Lua_set_immutable },
    { "gold", _wrap_Color_gold_get, SWIG_Lua_set_immutable },
    { "goldenRod", _wrap_Color_goldenRod_get, SWIG_Lua_set_immutable },
    { "grey", _wrap_Color_grey_get, SWIG_Lua_set_immutable },
    { "greenYellow", _wrap_Color_greenYellow_get, SWIG_Lua_set_immutable },
    { "honeyDew", _wrap_Color_honeyDew_get, SWIG_Lua_set_immutable },
    { "hotPink", _wrap_Color_hotPink_get, SWIG_Lua_set_immutable },
    { "indianRed", _wrap_Color_indianRed_get, SWIG_Lua_set_immutable },
    { "indigo", _wrap_Color_indigo_get, SWIG_Lua_set_immutable },
    { "ivory", _wrap_Color_ivory_get, SWIG_Lua_set_immutable },
    { "khaki", _wrap_Color_khaki_get, SWIG_Lua_set_immutable },
    { "lavender", _wrap_Color_lavender_get, SWIG_Lua_set_immutable },
    { "lavenderBlush", _wrap_Color_lavenderBlush_get, SWIG_Lua_set_immutable },
    { "lawnGreen", _wrap_Color_lawnGreen_get, SWIG_Lua_set_immutable },
    { "lemonChiffon", _wrap_Color_lemonChiffon_get, SWIG_Lua_set_immutable },
    { "lightBlue", _wrap_Color_lightBlue_get, SWIG_Lua_set_immutable },
    { "lightCoral", _wrap_Color_lightCoral_get, SWIG_Lua_set_immutable },
    { "lightCyan", _wrap_Color_lightCyan_get, SWIG_Lua_set_immutable },
    { "lightGoldenRodYellow", _wrap_Color_lightGoldenRodYellow_get, SWIG_Lua_set_immutable },
    { "lightGray", _wrap_Color_lightGray_get, SWIG_Lua_set_immutable },
    { "lightGrey", _wrap_Color_lightGrey_get, SWIG_Lua_set_immutable },
    { "lightGreen", _wrap_Color_lightGreen_get, SWIG_Lua_set_immutable },
    { "lightPink", _wrap_Color_lightPink_get, SWIG_Lua_set_immutable },
    { "lightSalmon", _wrap_Color_lightSalmon_get, SWIG_Lua_set_immutable },
    { "lightSeaGreen", _wrap_Color_lightSeaGreen_get, SWIG_Lua_set_immutable },
    { "lightSkyBlue", _wrap_Color_lightSkyBlue_get, SWIG_Lua_set_immutable },
    { "lightSlateGray", _wrap_Color_lightSlateGray_get, SWIG_Lua_set_immutable },
    { "lightSlateGrey", _wrap_Color_lightSlateGrey_get, SWIG_Lua_set_immutable },
    { "lightSteelBlue", _wrap_Color_lightSteelBlue_get, SWIG_Lua_set_immutable },
    { "lightYellow", _wrap_Color_lightYellow_get, SWIG_Lua_set_immutable },
    { "lime", _wrap_Color_lime_get, SWIG_Lua_set_immutable },
    { "limeGreen", _wrap_Color_limeGreen_get, SWIG_Lua_set_immutable },
    { "linen", _wrap_Color_linen_get, SWIG_Lua_set_immutable },
    { "maroon", _wrap_Color_maroon_get, SWIG_Lua_set_immutable },
    { "mediumAquaMarine", _wrap_Color_mediumAquaMarine_get, SWIG_Lua_set_immutable },
    { "mediumBlue", _wrap_Color_mediumBlue_get, SWIG_Lua_set_immutable },
    { "mediumOrchid", _wrap_Color_mediumOrchid_get, SWIG_Lua_set_immutable },
    { "mediumPurple", _wrap_Color_mediumPurple_get, SWIG_Lua_set_immutable },
    { "mediumSeaGreen", _wrap_Color_mediumSeaGreen_get, SWIG_Lua_set_immutable },
    { "mediumSlateBlue", _wrap_Color_mediumSlateBlue_get, SWIG_Lua_set_immutable },
    { "mediumSpringGreen", _wrap_Color_mediumSpringGreen_get, SWIG_Lua_set_immutable },
    { "mediumTurquoise", _wrap_Color_mediumTurquoise_get, SWIG_Lua_set_immutable },
    { "mediumVioletRed", _wrap_Color_mediumVioletRed_get, SWIG_Lua_set_immutable },
    { "midnightBlue", _wrap_Color_midnightBlue_get, SWIG_Lua_set_immutable },
    { "mintCream", _wrap_Color_mintCream_get, SWIG_Lua_set_immutable },
    { "mistyRose", _wrap_Color_mistyRose_get, SWIG_Lua_set_immutable },
    { "moccasin", _wrap_Color_moccasin_get, SWIG_Lua_set_immutable },
    { "navajoWhite", _wrap_Color_navajoWhite_get, SWIG_Lua_set_immutable },
    { "navy", _wrap_Color_navy_get, SWIG_Lua_set_immutable },
    { "oldLace", _wrap_Color_oldLace_get, SWIG_Lua_set_immutable },
    { "olive", _wrap_Color_olive_get, SWIG_Lua_set_immutable },
    { "oliveDrab", _wrap_Color_oliveDrab_get, SWIG_Lua_set_immutable },
    { "orange", _wrap_Color_orange_get, SWIG_Lua_set_immutable },
    { "orangeRed", _wrap_Color_orangeRed_get, SWIG_Lua_set_immutable },
    { "orchid", _wrap_Color_orchid_get, SWIG_Lua_set_immutable },
    { "paleGoldenRod", _wrap_Color_paleGoldenRod_get, SWIG_Lua_set_immutable },
    { "paleGreen", _wrap_Color_paleGreen_get, SWIG_Lua_set_immutable },
    { "paleTurquoise", _wrap_Color_paleTurquoise_get, SWIG_Lua_set_immutable },
    { "paleVioletRed", _wrap_Color_paleVioletRed_get, SWIG_Lua_set_immutable },
    { "papayaWhip", _wrap_Color_papayaWhip_get, SWIG_Lua_set_immutable },
    { "peachPuff", _wrap_Color_peachPuff_get, SWIG_Lua_set_immutable },
    { "peru", _wrap_Color_peru_get, SWIG_Lua_set_immutable },
    { "pink", _wrap_Color_pink_get, SWIG_Lua_set_immutable },
    { "plum", _wrap_Color_plum_get, SWIG_Lua_set_immutable },
    { "powderBlue", _wrap_Color_powderBlue_get, SWIG_Lua_set_immutable },
    { "purple", _wrap_Color_purple_get, SWIG_Lua_set_immutable },
    { "rosyBrown", _wrap_Color_rosyBrown_get, SWIG_Lua_set_immutable },
    { "royalBlue", _wrap_Color_royalBlue_get, SWIG_Lua_set_immutable },
    { "saddleBrown", _wrap_Color_saddleBrown_get, SWIG_Lua_set_immutable },
    { "salmon", _wrap_Color_salmon_get, SWIG_Lua_set_immutable },
    { "sandyBrown", _wrap_Color_sandyBrown_get, SWIG_Lua_set_immutable },
    { "seaGreen", _wrap_Color_seaGreen_get, SWIG_Lua_set_immutable },
    { "seaShell", _wrap_Color_seaShell_get, SWIG_Lua_set_immutable },
    { "sienna", _wrap_Color_sienna_get, SWIG_Lua_set_immutable },
    { "silver", _wrap_Color_silver_get, SWIG_Lua_set_immutable },
    { "skyBlue", _wrap_Color_skyBlue_get, SWIG_Lua_set_immutable },
    { "slateBlue", _wrap_Color_slateBlue_get, SWIG_Lua_set_immutable },
    { "slateGray", _wrap_Color_slateGray_get, SWIG_Lua_set_immutable },
    { "slateGrey", _wrap_Color_slateGrey_get, SWIG_Lua_set_immutable },
    { "snow", _wrap_Color_snow_get, SWIG_Lua_set_immutable },
    { "springGreen", _wrap_Color_springGreen_get, SWIG_Lua_set_immutable },
    { "steelBlue", _wrap_Color_steelBlue_get, SWIG_Lua_set_immutable },
    { "blueSteel", _wrap_Color_blueSteel_get, SWIG_Lua_set_immutable },
    { "tan", _wrap_Color_tan_get, SWIG_Lua_set_immutable },
    { "teal", _wrap_Color_teal_get, SWIG_Lua_set_immutable },
    { "thistle", _wrap_Color_thistle_get, SWIG_Lua_set_immutable },
    { "tomato", _wrap_Color_tomato_get, SWIG_Lua_set_immutable },
    { "turquoise", _wrap_Color_turquoise_get, SWIG_Lua_set_immutable },
    { "violet", _wrap_Color_violet_get, SWIG_Lua_set_immutable },
    { "wheat", _wrap_Color_wheat_get, SWIG_Lua_set_immutable },
    { "whiteSmoke", _wrap_Color_whiteSmoke_get, SWIG_Lua_set_immutable },
    { "yellowGreen", _wrap_Color_yellowGreen_get, SWIG_Lua_set_immutable },
    {0,0,0}
};
static swig_lua_const_info swig_Color_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_Color_Sf_SwigStatic_methods[]= {
    { "fromHsb", _wrap_Color_fromHsb},
    { "fromHex", _wrap_Color_fromHex},
    { "limit", _wrap_Color_limit},
    {0,0}
};
static swig_lua_class* swig_Color_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_Color_Sf_SwigStatic = {
    "Color",
    swig_Color_Sf_SwigStatic_methods,
    swig_Color_Sf_SwigStatic_attributes,
    swig_Color_Sf_SwigStatic_constants,
    swig_Color_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_Color_bases[] = {0};
static const char *swig_Color_base_names[] = {0};
static swig_lua_class _wrap_class_Color = { "Color", "Color", &SWIGTYPE_p_ofColor_T_unsigned_char_t,_proxy__wrap_new_Color, swig_delete_Color, swig_Color_methods, swig_Color_attributes, &swig_Color_Sf_SwigStatic, swig_Color_meta, swig_Color_bases, swig_Color_base_names };

static int _wrap_new_FloatColor__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::ofColor_",0,0) result = (ofColor_< float > *)new ofColor_< float >();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_FloatColor__SWIG_1(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ; float arg4 ;
  ofColor_< float > *result = 0 ; SWIG_check_num_args("ofColor_< float >::ofColor_",4,4)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofColor_< float >::ofColor_",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< float >::ofColor_",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofColor_< float >::ofColor_",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofColor_< float >::ofColor_",4,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  result = (ofColor_< float > *)new ofColor_< float >(arg1,arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_FloatColor__SWIG_2(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ;
  ofColor_< float > *result = 0 ; SWIG_check_num_args("ofColor_< float >::ofColor_",3,3)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofColor_< float >::ofColor_",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< float >::ofColor_",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofColor_< float >::ofColor_",3,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3);
  result = (ofColor_< float > *)new ofColor_< float >(arg1,arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_FloatColor__SWIG_3(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ;
  ofColor_< float > *result = 0 ; SWIG_check_num_args("ofColor_< float >::ofColor_",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofColor_< float >::ofColor_",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< float >::ofColor_",2,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); result = (ofColor_< float > *)new ofColor_< float >(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_FloatColor__SWIG_4(lua_State* L) { int SWIG_arg = 0; float arg1 ; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::ofColor_",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofColor_< float >::ofColor_",1,"float"); arg1 = (float)lua_tonumber(L, 1);
  result = (ofColor_< float > *)new ofColor_< float >(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_FloatColor__SWIG_5(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *arg1 = 0 ; float arg2 ;
  ofColor_< float > *result = 0 ; SWIG_check_num_args("ofColor_< float >::ofColor_",2,2)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofColor_< float >::ofColor_",1,"ofColor_< float > const &");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< float >::ofColor_",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("new_FloatColor",1,SWIGTYPE_p_ofColor_T_float_t); }  arg2 = (float)lua_tonumber(L, 2);
  result = (ofColor_< float > *)new ofColor_< float >((ofColor_< float > const &)*arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_FloatColor(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L); if (argc == 0) {
    return _wrap_new_FloatColor__SWIG_0(L);}  if (argc == 1) { int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) {
      return _wrap_new_FloatColor__SWIG_4(L);}  }  if (argc == 2) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofColor_T_float_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_new_FloatColor__SWIG_5(L);}  }  }  if (argc == 2) { int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { {
        _v = lua_isnumber(L,argv[1]); }  if (_v) { return _wrap_new_FloatColor__SWIG_3(L);}  }  }  if (argc == 3) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); } 
        if (_v) { return _wrap_new_FloatColor__SWIG_2(L);}  }  }  }  if (argc == 4) { int _v; { _v = lua_isnumber(L,argv[0]); } 
    if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { {
            _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_new_FloatColor__SWIG_1(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_FloatColor'\n" "  Possible C/C++ prototypes are:\n"
  "    ofColor_< float >::ofColor_()\n" "    ofColor_< float >::ofColor_(float,float,float,float)\n"
  "    ofColor_< float >::ofColor_(float,float,float)\n" "    ofColor_< float >::ofColor_(float,float)\n"
  "    ofColor_< float >::ofColor_(float)\n" "    ofColor_< float >::ofColor_(ofColor_< float > const &,float)\n");
  lua_error(L);return 0; }
static int _wrap_FloatColor_fromHsb__SWIG_0(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ;
  float arg4 ; ofColor_< float > result; SWIG_check_num_args("ofColor_< float >::fromHsb",4,4)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofColor_< float >::fromHsb",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< float >::fromHsb",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofColor_< float >::fromHsb",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofColor_< float >::fromHsb",4,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  result = ofColor_< float >::SWIGTEMPLATEDISAMBIGUATOR fromHsb(arg1,arg2,arg3,arg4); {
    ofColor_< float > * resultptr = new ofColor_< float >((const ofColor_< float > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofColor_T_float_t,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_fromHsb__SWIG_1(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ;
  ofColor_< float > result; SWIG_check_num_args("ofColor_< float >::fromHsb",3,3)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofColor_< float >::fromHsb",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< float >::fromHsb",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofColor_< float >::fromHsb",3,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3);
  result = ofColor_< float >::SWIGTEMPLATEDISAMBIGUATOR fromHsb(arg1,arg2,arg3); {
    ofColor_< float > * resultptr = new ofColor_< float >((const ofColor_< float > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofColor_T_float_t,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_fromHsb(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L); if (argc == 3) {
    int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { {
          _v = lua_isnumber(L,argv[2]); }  if (_v) { return _wrap_FloatColor_fromHsb__SWIG_1(L);}  }  }  }  if (argc == 4) {
    int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { {
          _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) {
            return _wrap_FloatColor_fromHsb__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'FloatColor_fromHsb'\n" "  Possible C/C++ prototypes are:\n"
  "    ofColor_< float >::fromHsb(float,float,float,float)\n" "    ofColor_< float >::fromHsb(float,float,float)\n");
  lua_error(L);return 0; }
static int _wrap_FloatColor_fromHex__SWIG_0(lua_State* L) { int SWIG_arg = 0; int arg1 ; float arg2 ; ofColor_< float > result;
  SWIG_check_num_args("ofColor_< float >::fromHex",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofColor_< float >::fromHex",1,"int");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< float >::fromHex",2,"float"); arg1 = (int)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); result = ofColor_< float >::SWIGTEMPLATEDISAMBIGUATOR fromHex(arg1,arg2); {
    ofColor_< float > * resultptr = new ofColor_< float >((const ofColor_< float > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofColor_T_float_t,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_fromHex__SWIG_1(lua_State* L) { int SWIG_arg = 0; int arg1 ; ofColor_< float > result;
  SWIG_check_num_args("ofColor_< float >::fromHex",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofColor_< float >::fromHex",1,"int"); arg1 = (int)lua_tonumber(L, 1);
  result = ofColor_< float >::SWIGTEMPLATEDISAMBIGUATOR fromHex(arg1); {
    ofColor_< float > * resultptr = new ofColor_< float >((const ofColor_< float > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofColor_T_float_t,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_fromHex(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 1) {
    int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { return _wrap_FloatColor_fromHex__SWIG_1(L);}  }  if (argc == 2) {
    int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_FloatColor_fromHex__SWIG_0(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'FloatColor_fromHex'\n" "  Possible C/C++ prototypes are:\n"
  "    ofColor_< float >::fromHex(int,float)\n" "    ofColor_< float >::fromHex(int)\n"); lua_error(L);return 0; }
static int _wrap_FloatColor_set__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *arg1 = (ofColor_< float > *) 0 ;
  float arg2 ; float arg3 ; float arg4 ; float arg5 ; SWIG_check_num_args("ofColor_< float >::set",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< float >::set",1,"ofColor_< float > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< float >::set",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofColor_< float >::set",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofColor_< float >::set",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofColor_< float >::set",5,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("FloatColor_set",1,SWIGTYPE_p_ofColor_T_float_t); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); arg5 = (float)lua_tonumber(L, 5);
  (arg1)->set(arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_set__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *arg1 = (ofColor_< float > *) 0 ;
  float arg2 ; float arg3 ; float arg4 ; SWIG_check_num_args("ofColor_< float >::set",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< float >::set",1,"ofColor_< float > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< float >::set",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofColor_< float >::set",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofColor_< float >::set",4,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("FloatColor_set",1,SWIGTYPE_p_ofColor_T_float_t); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); (arg1)->set(arg2,arg3,arg4); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_set__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *arg1 = (ofColor_< float > *) 0 ;
  float arg2 ; float arg3 ; SWIG_check_num_args("ofColor_< float >::set",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< float >::set",1,"ofColor_< float > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< float >::set",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofColor_< float >::set",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("FloatColor_set",1,SWIGTYPE_p_ofColor_T_float_t); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); (arg1)->set(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_FloatColor_set__SWIG_3(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *arg1 = (ofColor_< float > *) 0 ;
  float arg2 ; SWIG_check_num_args("ofColor_< float >::set",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< float >::set",1,"ofColor_< float > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< float >::set",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("FloatColor_set",1,SWIGTYPE_p_ofColor_T_float_t); }  arg2 = (float)lua_tonumber(L, 2); (arg1)->set(arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_set__SWIG_4(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *arg1 = (ofColor_< float > *) 0 ;
  ofColor_< float > *arg2 = 0 ; SWIG_check_num_args("ofColor_< float >::set",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< float >::set",1,"ofColor_< float > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofColor_< float >::set",2,"ofColor_< float > const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("FloatColor_set",1,SWIGTYPE_p_ofColor_T_float_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("FloatColor_set",2,SWIGTYPE_p_ofColor_T_float_t); }  (arg1)->set((ofColor_< float > const &)*arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_set(lua_State* L) { int argc; int argv[6]={ 1,2,3,4,5,6} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofColor_T_float_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofColor_T_float_t, 0)) {
          _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_FloatColor_set__SWIG_4(L);}  }  }  if (argc == 2) { int _v; {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofColor_T_float_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_FloatColor_set__SWIG_3(L);}  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofColor_T_float_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { return _wrap_FloatColor_set__SWIG_2(L);}  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofColor_T_float_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_FloatColor_set__SWIG_1(L);}  }  }  }  } 
  if (argc == 5) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofColor_T_float_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) {
              return _wrap_FloatColor_set__SWIG_0(L);}  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'FloatColor_set'\n" "  Possible C/C++ prototypes are:\n"
  "    ofColor_< float >::set(float,float,float,float)\n" "    ofColor_< float >::set(float,float,float)\n"
  "    ofColor_< float >::set(float,float)\n" "    ofColor_< float >::set(float)\n"
  "    ofColor_< float >::set(ofColor_< float > const &)\n"); lua_error(L);return 0; }
static int _wrap_FloatColor_setHex__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *arg1 = (ofColor_< float > *) 0 ;
  int arg2 ; float arg3 ; SWIG_check_num_args("ofColor_< float >::setHex",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< float >::setHex",1,"ofColor_< float > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< float >::setHex",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofColor_< float >::setHex",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("FloatColor_setHex",1,SWIGTYPE_p_ofColor_T_float_t); }  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); (arg1)->setHex(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_FloatColor_setHex__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *arg1 = (ofColor_< float > *) 0 ;
  int arg2 ; SWIG_check_num_args("ofColor_< float >::setHex",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< float >::setHex",1,"ofColor_< float > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< float >::setHex",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("FloatColor_setHex",1,SWIGTYPE_p_ofColor_T_float_t); }  arg2 = (int)lua_tonumber(L, 2); (arg1)->setHex(arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_setHex(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofColor_T_float_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_FloatColor_setHex__SWIG_1(L);}  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofColor_T_float_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { return _wrap_FloatColor_setHex__SWIG_0(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'FloatColor_setHex'\n" "  Possible C/C++ prototypes are:\n"
  "    ofColor_< float >::setHex(int,float)\n" "    ofColor_< float >::setHex(int)\n"); lua_error(L);return 0; }
static int _wrap_FloatColor_setHue(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *arg1 = (ofColor_< float > *) 0 ;
  float arg2 ; SWIG_check_num_args("ofColor_< float >::setHue",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< float >::setHue",1,"ofColor_< float > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< float >::setHue",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("FloatColor_setHue",1,SWIGTYPE_p_ofColor_T_float_t); }  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setHue(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_setHueAngle(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *arg1 = (ofColor_< float > *) 0 ;
  float arg2 ; SWIG_check_num_args("ofColor_< float >::setHueAngle",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< float >::setHueAngle",1,"ofColor_< float > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< float >::setHueAngle",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("FloatColor_setHueAngle",1,SWIGTYPE_p_ofColor_T_float_t); }  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setHueAngle(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_setSaturation(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *arg1 = (ofColor_< float > *) 0 ;
  float arg2 ; SWIG_check_num_args("ofColor_< float >::setSaturation",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< float >::setSaturation",1,"ofColor_< float > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< float >::setSaturation",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("FloatColor_setSaturation",1,SWIGTYPE_p_ofColor_T_float_t); }  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setSaturation(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_setBrightness(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *arg1 = (ofColor_< float > *) 0 ;
  float arg2 ; SWIG_check_num_args("ofColor_< float >::setBrightness",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< float >::setBrightness",1,"ofColor_< float > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< float >::setBrightness",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("FloatColor_setBrightness",1,SWIGTYPE_p_ofColor_T_float_t); }  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setBrightness(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_setHsb__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *arg1 = (ofColor_< float > *) 0 ;
  float arg2 ; float arg3 ; float arg4 ; float arg5 ; SWIG_check_num_args("ofColor_< float >::setHsb",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< float >::setHsb",1,"ofColor_< float > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< float >::setHsb",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofColor_< float >::setHsb",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofColor_< float >::setHsb",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofColor_< float >::setHsb",5,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("FloatColor_setHsb",1,SWIGTYPE_p_ofColor_T_float_t); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); arg5 = (float)lua_tonumber(L, 5);
  (arg1)->setHsb(arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_setHsb__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *arg1 = (ofColor_< float > *) 0 ;
  float arg2 ; float arg3 ; float arg4 ; SWIG_check_num_args("ofColor_< float >::setHsb",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< float >::setHsb",1,"ofColor_< float > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< float >::setHsb",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofColor_< float >::setHsb",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofColor_< float >::setHsb",4,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("FloatColor_setHsb",1,SWIGTYPE_p_ofColor_T_float_t); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); (arg1)->setHsb(arg2,arg3,arg4); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_setHsb(lua_State* L) { int argc; int argv[6]={ 1,2,3,4,5,6} ; argc = lua_gettop(L); if (argc == 4) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofColor_T_float_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_FloatColor_setHsb__SWIG_1(L);}  }  }  }  } 
  if (argc == 5) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofColor_T_float_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) {
              return _wrap_FloatColor_setHsb__SWIG_0(L);}  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'FloatColor_setHsb'\n" "  Possible C/C++ prototypes are:\n"
  "    ofColor_< float >::setHsb(float,float,float,float)\n" "    ofColor_< float >::setHsb(float,float,float)\n");
  lua_error(L);return 0; }
static int _wrap_FloatColor_clamp(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *arg1 = (ofColor_< float > *) 0 ;
  ofColor_< float > *result = 0 ; SWIG_check_num_args("ofColor_< float >::clamp",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< float >::clamp",1,"ofColor_< float > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("FloatColor_clamp",1,SWIGTYPE_p_ofColor_T_float_t); }  result = (ofColor_< float > *) &(arg1)->clamp();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_invert(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *arg1 = (ofColor_< float > *) 0 ;
  ofColor_< float > *result = 0 ; SWIG_check_num_args("ofColor_< float >::invert",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< float >::invert",1,"ofColor_< float > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("FloatColor_invert",1,SWIGTYPE_p_ofColor_T_float_t); }  result = (ofColor_< float > *) &(arg1)->invert();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_normalize(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *arg1 = (ofColor_< float > *) 0 ;
  ofColor_< float > *result = 0 ; SWIG_check_num_args("ofColor_< float >::normalize",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< float >::normalize",1,"ofColor_< float > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("FloatColor_normalize",1,SWIGTYPE_p_ofColor_T_float_t); } 
  result = (ofColor_< float > *) &(arg1)->normalize(); SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++; 
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_lerp(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *arg1 = (ofColor_< float > *) 0 ;
  ofColor_< float > *arg2 = 0 ; float arg3 ; ofColor_< float > *result = 0 ; SWIG_check_num_args("ofColor_< float >::lerp",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< float >::lerp",1,"ofColor_< float > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofColor_< float >::lerp",2,"ofColor_< float > const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofColor_< float >::lerp",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("FloatColor_lerp",1,SWIGTYPE_p_ofColor_T_float_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("FloatColor_lerp",2,SWIGTYPE_p_ofColor_T_float_t); }  arg3 = (float)lua_tonumber(L, 3);
  result = (ofColor_< float > *) &(arg1)->lerp((ofColor_< float > const &)*arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_getClamped(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *arg1 = (ofColor_< float > *) 0 ;
  ofColor_< float > result; SWIG_check_num_args("ofColor_< float >::getClamped",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< float >::getClamped",1,"ofColor_< float > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("FloatColor_getClamped",1,SWIGTYPE_p_ofColor_T_float_t); } 
  result = ((ofColor_< float > const *)arg1)->getClamped(); {
    ofColor_< float > * resultptr = new ofColor_< float >((const ofColor_< float > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofColor_T_float_t,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_getInverted(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *arg1 = (ofColor_< float > *) 0 ;
  ofColor_< float > result; SWIG_check_num_args("ofColor_< float >::getInverted",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< float >::getInverted",1,"ofColor_< float > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("FloatColor_getInverted",1,SWIGTYPE_p_ofColor_T_float_t); } 
  result = ((ofColor_< float > const *)arg1)->getInverted(); {
    ofColor_< float > * resultptr = new ofColor_< float >((const ofColor_< float > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofColor_T_float_t,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_getNormalized(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *arg1 = (ofColor_< float > *) 0 ;
  ofColor_< float > result; SWIG_check_num_args("ofColor_< float >::getNormalized",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< float >::getNormalized",1,"ofColor_< float > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("FloatColor_getNormalized",1,SWIGTYPE_p_ofColor_T_float_t); } 
  result = ((ofColor_< float > const *)arg1)->getNormalized(); {
    ofColor_< float > * resultptr = new ofColor_< float >((const ofColor_< float > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofColor_T_float_t,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_getLerped(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *arg1 = (ofColor_< float > *) 0 ;
  ofColor_< float > *arg2 = 0 ; float arg3 ; ofColor_< float > result; SWIG_check_num_args("ofColor_< float >::getLerped",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< float >::getLerped",1,"ofColor_< float > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofColor_< float >::getLerped",2,"ofColor_< float > const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofColor_< float >::getLerped",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("FloatColor_getLerped",1,SWIGTYPE_p_ofColor_T_float_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("FloatColor_getLerped",2,SWIGTYPE_p_ofColor_T_float_t); }  arg3 = (float)lua_tonumber(L, 3);
  result = ((ofColor_< float > const *)arg1)->getLerped((ofColor_< float > const &)*arg2,arg3); {
    ofColor_< float > * resultptr = new ofColor_< float >((const ofColor_< float > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofColor_T_float_t,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_getHex(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *arg1 = (ofColor_< float > *) 0 ;
  int result; SWIG_check_num_args("ofColor_< float >::getHex",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< float >::getHex",1,"ofColor_< float > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("FloatColor_getHex",1,SWIGTYPE_p_ofColor_T_float_t); } 
  result = (int)((ofColor_< float > const *)arg1)->getHex(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_getHue(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *arg1 = (ofColor_< float > *) 0 ;
  float result; SWIG_check_num_args("ofColor_< float >::getHue",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< float >::getHue",1,"ofColor_< float > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("FloatColor_getHue",1,SWIGTYPE_p_ofColor_T_float_t); } 
  result = (float)((ofColor_< float > const *)arg1)->getHue(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_getHueAngle(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *arg1 = (ofColor_< float > *) 0 ;
  float result; SWIG_check_num_args("ofColor_< float >::getHueAngle",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< float >::getHueAngle",1,"ofColor_< float > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("FloatColor_getHueAngle",1,SWIGTYPE_p_ofColor_T_float_t); } 
  result = (float)((ofColor_< float > const *)arg1)->getHueAngle(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_getSaturation(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *arg1 = (ofColor_< float > *) 0 ;
  float result; SWIG_check_num_args("ofColor_< float >::getSaturation",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< float >::getSaturation",1,"ofColor_< float > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("FloatColor_getSaturation",1,SWIGTYPE_p_ofColor_T_float_t); } 
  result = (float)((ofColor_< float > const *)arg1)->getSaturation(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_getBrightness(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *arg1 = (ofColor_< float > *) 0 ;
  float result; SWIG_check_num_args("ofColor_< float >::getBrightness",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< float >::getBrightness",1,"ofColor_< float > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("FloatColor_getBrightness",1,SWIGTYPE_p_ofColor_T_float_t); } 
  result = (float)((ofColor_< float > const *)arg1)->getBrightness(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_getLightness(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *arg1 = (ofColor_< float > *) 0 ;
  float result; SWIG_check_num_args("ofColor_< float >::getLightness",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< float >::getLightness",1,"ofColor_< float > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("FloatColor_getLightness",1,SWIGTYPE_p_ofColor_T_float_t); } 
  result = (float)((ofColor_< float > const *)arg1)->getLightness(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_getHsb(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *arg1 = (ofColor_< float > *) 0 ;
  float *arg2 = 0 ; float *arg3 = 0 ; float *arg4 = 0 ; SWIG_check_num_args("ofColor_< float >::getHsb",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< float >::getHsb",1,"ofColor_< float > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofColor_< float >::getHsb",2,"float &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofColor_< float >::getHsb",3,"float &");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("ofColor_< float >::getHsb",4,"float &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("FloatColor_getHsb",1,SWIGTYPE_p_ofColor_T_float_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("FloatColor_getHsb",2,SWIGTYPE_p_float); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("FloatColor_getHsb",3,SWIGTYPE_p_float); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("FloatColor_getHsb",4,SWIGTYPE_p_float); }  ((ofColor_< float > const *)arg1)->getHsb(*arg2,*arg3,*arg4);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_limit(lua_State* L) { int SWIG_arg = 0; float result;
  SWIG_check_num_args("ofColor_< float >::limit",0,0) result = (float)ofColor_< float >::SWIGTEMPLATEDISAMBIGUATOR limit();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor___eq(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *arg1 = (ofColor_< float > *) 0 ;
  ofColor_< float > *arg2 = 0 ; bool result; SWIG_check_num_args("ofColor_< float >::operator ==",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< float >::operator ==",1,"ofColor_< float > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofColor_< float >::operator ==",2,"ofColor_< float > const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("FloatColor___eq",1,SWIGTYPE_p_ofColor_T_float_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("FloatColor___eq",2,SWIGTYPE_p_ofColor_T_float_t); } 
  result = (bool)((ofColor_< float > const *)arg1)->operator ==((ofColor_< float > const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor___add__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *arg1 = (ofColor_< float > *) 0 ;
  ofColor_< float > *arg2 = 0 ; ofColor_< float > result; SWIG_check_num_args("ofColor_< float >::operator +",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< float >::operator +",1,"ofColor_< float > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofColor_< float >::operator +",2,"ofColor_< float > const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("FloatColor___add",1,SWIGTYPE_p_ofColor_T_float_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("FloatColor___add",2,SWIGTYPE_p_ofColor_T_float_t); } 
  result = ((ofColor_< float > const *)arg1)->operator +((ofColor_< float > const &)*arg2); {
    ofColor_< float > * resultptr = new ofColor_< float >((const ofColor_< float > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofColor_T_float_t,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor___add__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *arg1 = (ofColor_< float > *) 0 ;
  float arg2 ; ofColor_< float > result; SWIG_check_num_args("ofColor_< float >::operator +",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< float >::operator +",1,"ofColor_< float > const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< float >::operator +",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("FloatColor___add",1,SWIGTYPE_p_ofColor_T_float_t); }  arg2 = (float)lua_tonumber(L, 2);
  result = ((ofColor_< float > const *)arg1)->operator +(arg2); {
    ofColor_< float > * resultptr = new ofColor_< float >((const ofColor_< float > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofColor_T_float_t,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor___add(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofColor_T_float_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofColor_T_float_t, 0)) {
          _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_FloatColor___add__SWIG_0(L);}  }  }  if (argc == 2) { int _v; {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofColor_T_float_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_FloatColor___add__SWIG_1(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'FloatColor___add'\n" "  Possible C/C++ prototypes are:\n"
  "    ofColor_< float >::operator +(ofColor_< float > const &) const\n" "    ofColor_< float >::operator +(float) const\n");
  lua_error(L);return 0; }
static int _wrap_FloatColor___sub__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *arg1 = (ofColor_< float > *) 0 ;
  ofColor_< float > *arg2 = 0 ; ofColor_< float > result; SWIG_check_num_args("ofColor_< float >::operator -",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< float >::operator -",1,"ofColor_< float > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofColor_< float >::operator -",2,"ofColor_< float > const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("FloatColor___sub",1,SWIGTYPE_p_ofColor_T_float_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("FloatColor___sub",2,SWIGTYPE_p_ofColor_T_float_t); } 
  result = ((ofColor_< float > const *)arg1)->operator -((ofColor_< float > const &)*arg2); {
    ofColor_< float > * resultptr = new ofColor_< float >((const ofColor_< float > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofColor_T_float_t,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor___sub__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *arg1 = (ofColor_< float > *) 0 ;
  float arg2 ; ofColor_< float > result; SWIG_check_num_args("ofColor_< float >::operator -",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< float >::operator -",1,"ofColor_< float > const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< float >::operator -",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("FloatColor___sub",1,SWIGTYPE_p_ofColor_T_float_t); }  arg2 = (float)lua_tonumber(L, 2);
  result = ((ofColor_< float > const *)arg1)->operator -(arg2); {
    ofColor_< float > * resultptr = new ofColor_< float >((const ofColor_< float > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofColor_T_float_t,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor___sub(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofColor_T_float_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofColor_T_float_t, 0)) {
          _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_FloatColor___sub__SWIG_0(L);}  }  }  if (argc == 2) { int _v; {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofColor_T_float_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_FloatColor___sub__SWIG_1(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'FloatColor___sub'\n" "  Possible C/C++ prototypes are:\n"
  "    ofColor_< float >::operator -(ofColor_< float > const &) const\n" "    ofColor_< float >::operator -(float) const\n");
  lua_error(L);return 0; }
static int _wrap_FloatColor___mul__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *arg1 = (ofColor_< float > *) 0 ;
  ofColor_< float > *arg2 = 0 ; ofColor_< float > result; SWIG_check_num_args("ofColor_< float >::operator *",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< float >::operator *",1,"ofColor_< float > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofColor_< float >::operator *",2,"ofColor_< float > const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("FloatColor___mul",1,SWIGTYPE_p_ofColor_T_float_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("FloatColor___mul",2,SWIGTYPE_p_ofColor_T_float_t); } 
  result = ((ofColor_< float > const *)arg1)->operator *((ofColor_< float > const &)*arg2); {
    ofColor_< float > * resultptr = new ofColor_< float >((const ofColor_< float > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofColor_T_float_t,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor___mul__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *arg1 = (ofColor_< float > *) 0 ;
  float arg2 ; ofColor_< float > result; SWIG_check_num_args("ofColor_< float >::operator *",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< float >::operator *",1,"ofColor_< float > const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< float >::operator *",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("FloatColor___mul",1,SWIGTYPE_p_ofColor_T_float_t); }  arg2 = (float)lua_tonumber(L, 2);
  result = ((ofColor_< float > const *)arg1)->operator *(arg2); {
    ofColor_< float > * resultptr = new ofColor_< float >((const ofColor_< float > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofColor_T_float_t,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor___mul(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofColor_T_float_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofColor_T_float_t, 0)) {
          _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_FloatColor___mul__SWIG_0(L);}  }  }  if (argc == 2) { int _v; {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofColor_T_float_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_FloatColor___mul__SWIG_1(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'FloatColor___mul'\n" "  Possible C/C++ prototypes are:\n"
  "    ofColor_< float >::operator *(ofColor_< float > const &) const\n" "    ofColor_< float >::operator *(float) const\n");
  lua_error(L);return 0; }
static int _wrap_FloatColor___div__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *arg1 = (ofColor_< float > *) 0 ;
  ofColor_< float > *arg2 = 0 ; ofColor_< float > result; SWIG_check_num_args("ofColor_< float >::operator /",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< float >::operator /",1,"ofColor_< float > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofColor_< float >::operator /",2,"ofColor_< float > const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("FloatColor___div",1,SWIGTYPE_p_ofColor_T_float_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("FloatColor___div",2,SWIGTYPE_p_ofColor_T_float_t); } 
  result = ((ofColor_< float > const *)arg1)->operator /((ofColor_< float > const &)*arg2); {
    ofColor_< float > * resultptr = new ofColor_< float >((const ofColor_< float > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofColor_T_float_t,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor___div__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *arg1 = (ofColor_< float > *) 0 ;
  float arg2 ; ofColor_< float > result; SWIG_check_num_args("ofColor_< float >::operator /",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< float >::operator /",1,"ofColor_< float > const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< float >::operator /",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("FloatColor___div",1,SWIGTYPE_p_ofColor_T_float_t); }  arg2 = (float)lua_tonumber(L, 2);
  result = ((ofColor_< float > const *)arg1)->operator /(arg2); {
    ofColor_< float > * resultptr = new ofColor_< float >((const ofColor_< float > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofColor_T_float_t,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor___div(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofColor_T_float_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofColor_T_float_t, 0)) {
          _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_FloatColor___div__SWIG_0(L);}  }  }  if (argc == 2) { int _v; {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofColor_T_float_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_FloatColor___div__SWIG_1(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'FloatColor___div'\n" "  Possible C/C++ prototypes are:\n"
  "    ofColor_< float >::operator /(ofColor_< float > const &) const\n" "    ofColor_< float >::operator /(float) const\n");
  lua_error(L);return 0; }
static int _wrap_FloatColor_white_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::white",0,0) result = (ofColor_< float > *)&ofColor_< float >::white;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_gray_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::gray",0,0) result = (ofColor_< float > *)&ofColor_< float >::gray;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_black_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::black",0,0) result = (ofColor_< float > *)&ofColor_< float >::black;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_red_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::red",0,0) result = (ofColor_< float > *)&ofColor_< float >::red;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_green_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::green",0,0) result = (ofColor_< float > *)&ofColor_< float >::green;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_blue_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::blue",0,0) result = (ofColor_< float > *)&ofColor_< float >::blue;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_cyan_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::cyan",0,0) result = (ofColor_< float > *)&ofColor_< float >::cyan;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_magenta_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::magenta",0,0) result = (ofColor_< float > *)&ofColor_< float >::magenta;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_yellow_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::yellow",0,0) result = (ofColor_< float > *)&ofColor_< float >::yellow;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_aliceBlue_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::aliceBlue",0,0) result = (ofColor_< float > *)&ofColor_< float >::aliceBlue;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_antiqueWhite_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::antiqueWhite",0,0) result = (ofColor_< float > *)&ofColor_< float >::antiqueWhite;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_aqua_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::aqua",0,0) result = (ofColor_< float > *)&ofColor_< float >::aqua;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_aquamarine_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::aquamarine",0,0) result = (ofColor_< float > *)&ofColor_< float >::aquamarine;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_azure_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::azure",0,0) result = (ofColor_< float > *)&ofColor_< float >::azure;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_beige_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::beige",0,0) result = (ofColor_< float > *)&ofColor_< float >::beige;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_bisque_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::bisque",0,0) result = (ofColor_< float > *)&ofColor_< float >::bisque;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_blanchedAlmond_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::blanchedAlmond",0,0) result = (ofColor_< float > *)&ofColor_< float >::blanchedAlmond;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_blueViolet_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::blueViolet",0,0) result = (ofColor_< float > *)&ofColor_< float >::blueViolet;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_brown_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::brown",0,0) result = (ofColor_< float > *)&ofColor_< float >::brown;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_burlyWood_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::burlyWood",0,0) result = (ofColor_< float > *)&ofColor_< float >::burlyWood;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_cadetBlue_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::cadetBlue",0,0) result = (ofColor_< float > *)&ofColor_< float >::cadetBlue;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_chartreuse_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::chartreuse",0,0) result = (ofColor_< float > *)&ofColor_< float >::chartreuse;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_chocolate_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::chocolate",0,0) result = (ofColor_< float > *)&ofColor_< float >::chocolate;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_coral_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::coral",0,0) result = (ofColor_< float > *)&ofColor_< float >::coral;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_cornflowerBlue_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::cornflowerBlue",0,0) result = (ofColor_< float > *)&ofColor_< float >::cornflowerBlue;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_cornsilk_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::cornsilk",0,0) result = (ofColor_< float > *)&ofColor_< float >::cornsilk;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_crimson_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::crimson",0,0) result = (ofColor_< float > *)&ofColor_< float >::crimson;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_darkBlue_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::darkBlue",0,0) result = (ofColor_< float > *)&ofColor_< float >::darkBlue;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_darkCyan_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::darkCyan",0,0) result = (ofColor_< float > *)&ofColor_< float >::darkCyan;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_darkGoldenRod_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::darkGoldenRod",0,0) result = (ofColor_< float > *)&ofColor_< float >::darkGoldenRod;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_darkGray_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::darkGray",0,0) result = (ofColor_< float > *)&ofColor_< float >::darkGray;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_darkGrey_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::darkGrey",0,0) result = (ofColor_< float > *)&ofColor_< float >::darkGrey;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_darkGreen_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::darkGreen",0,0) result = (ofColor_< float > *)&ofColor_< float >::darkGreen;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_darkKhaki_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::darkKhaki",0,0) result = (ofColor_< float > *)&ofColor_< float >::darkKhaki;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_darkMagenta_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::darkMagenta",0,0) result = (ofColor_< float > *)&ofColor_< float >::darkMagenta;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_darkOliveGreen_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::darkOliveGreen",0,0) result = (ofColor_< float > *)&ofColor_< float >::darkOliveGreen;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_darkorange_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::darkorange",0,0) result = (ofColor_< float > *)&ofColor_< float >::darkorange;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_darkOrchid_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::darkOrchid",0,0) result = (ofColor_< float > *)&ofColor_< float >::darkOrchid;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_darkRed_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::darkRed",0,0) result = (ofColor_< float > *)&ofColor_< float >::darkRed;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_darkSalmon_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::darkSalmon",0,0) result = (ofColor_< float > *)&ofColor_< float >::darkSalmon;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_darkSeaGreen_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::darkSeaGreen",0,0) result = (ofColor_< float > *)&ofColor_< float >::darkSeaGreen;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_darkSlateBlue_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::darkSlateBlue",0,0) result = (ofColor_< float > *)&ofColor_< float >::darkSlateBlue;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_darkSlateGray_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::darkSlateGray",0,0) result = (ofColor_< float > *)&ofColor_< float >::darkSlateGray;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_darkSlateGrey_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::darkSlateGrey",0,0) result = (ofColor_< float > *)&ofColor_< float >::darkSlateGrey;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_darkTurquoise_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::darkTurquoise",0,0) result = (ofColor_< float > *)&ofColor_< float >::darkTurquoise;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_darkViolet_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::darkViolet",0,0) result = (ofColor_< float > *)&ofColor_< float >::darkViolet;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_deepPink_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::deepPink",0,0) result = (ofColor_< float > *)&ofColor_< float >::deepPink;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_deepSkyBlue_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::deepSkyBlue",0,0) result = (ofColor_< float > *)&ofColor_< float >::deepSkyBlue;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_dimGray_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::dimGray",0,0) result = (ofColor_< float > *)&ofColor_< float >::dimGray;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_dimGrey_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::dimGrey",0,0) result = (ofColor_< float > *)&ofColor_< float >::dimGrey;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_dodgerBlue_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::dodgerBlue",0,0) result = (ofColor_< float > *)&ofColor_< float >::dodgerBlue;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_fireBrick_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::fireBrick",0,0) result = (ofColor_< float > *)&ofColor_< float >::fireBrick;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_floralWhite_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::floralWhite",0,0) result = (ofColor_< float > *)&ofColor_< float >::floralWhite;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_forestGreen_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::forestGreen",0,0) result = (ofColor_< float > *)&ofColor_< float >::forestGreen;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_fuchsia_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::fuchsia",0,0) result = (ofColor_< float > *)&ofColor_< float >::fuchsia;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_gainsboro_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::gainsboro",0,0) result = (ofColor_< float > *)&ofColor_< float >::gainsboro;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_ghostWhite_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::ghostWhite",0,0) result = (ofColor_< float > *)&ofColor_< float >::ghostWhite;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_gold_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::gold",0,0) result = (ofColor_< float > *)&ofColor_< float >::gold;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_goldenRod_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::goldenRod",0,0) result = (ofColor_< float > *)&ofColor_< float >::goldenRod;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_grey_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::grey",0,0) result = (ofColor_< float > *)&ofColor_< float >::grey;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_greenYellow_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::greenYellow",0,0) result = (ofColor_< float > *)&ofColor_< float >::greenYellow;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_honeyDew_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::honeyDew",0,0) result = (ofColor_< float > *)&ofColor_< float >::honeyDew;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_hotPink_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::hotPink",0,0) result = (ofColor_< float > *)&ofColor_< float >::hotPink;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_indianRed_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::indianRed",0,0) result = (ofColor_< float > *)&ofColor_< float >::indianRed;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_indigo_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::indigo",0,0) result = (ofColor_< float > *)&ofColor_< float >::indigo;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_ivory_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::ivory",0,0) result = (ofColor_< float > *)&ofColor_< float >::ivory;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_khaki_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::khaki",0,0) result = (ofColor_< float > *)&ofColor_< float >::khaki;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_lavender_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::lavender",0,0) result = (ofColor_< float > *)&ofColor_< float >::lavender;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_lavenderBlush_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::lavenderBlush",0,0) result = (ofColor_< float > *)&ofColor_< float >::lavenderBlush;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_lawnGreen_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::lawnGreen",0,0) result = (ofColor_< float > *)&ofColor_< float >::lawnGreen;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_lemonChiffon_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::lemonChiffon",0,0) result = (ofColor_< float > *)&ofColor_< float >::lemonChiffon;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_lightBlue_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::lightBlue",0,0) result = (ofColor_< float > *)&ofColor_< float >::lightBlue;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_lightCoral_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::lightCoral",0,0) result = (ofColor_< float > *)&ofColor_< float >::lightCoral;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_lightCyan_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::lightCyan",0,0) result = (ofColor_< float > *)&ofColor_< float >::lightCyan;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_lightGoldenRodYellow_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::lightGoldenRodYellow",0,0)
  result = (ofColor_< float > *)&ofColor_< float >::lightGoldenRodYellow;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_lightGray_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::lightGray",0,0) result = (ofColor_< float > *)&ofColor_< float >::lightGray;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_lightGrey_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::lightGrey",0,0) result = (ofColor_< float > *)&ofColor_< float >::lightGrey;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_lightGreen_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::lightGreen",0,0) result = (ofColor_< float > *)&ofColor_< float >::lightGreen;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_lightPink_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::lightPink",0,0) result = (ofColor_< float > *)&ofColor_< float >::lightPink;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_lightSalmon_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::lightSalmon",0,0) result = (ofColor_< float > *)&ofColor_< float >::lightSalmon;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_lightSeaGreen_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::lightSeaGreen",0,0) result = (ofColor_< float > *)&ofColor_< float >::lightSeaGreen;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_lightSkyBlue_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::lightSkyBlue",0,0) result = (ofColor_< float > *)&ofColor_< float >::lightSkyBlue;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_lightSlateGray_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::lightSlateGray",0,0) result = (ofColor_< float > *)&ofColor_< float >::lightSlateGray;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_lightSlateGrey_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::lightSlateGrey",0,0) result = (ofColor_< float > *)&ofColor_< float >::lightSlateGrey;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_lightSteelBlue_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::lightSteelBlue",0,0) result = (ofColor_< float > *)&ofColor_< float >::lightSteelBlue;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_lightYellow_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::lightYellow",0,0) result = (ofColor_< float > *)&ofColor_< float >::lightYellow;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_lime_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::lime",0,0) result = (ofColor_< float > *)&ofColor_< float >::lime;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_limeGreen_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::limeGreen",0,0) result = (ofColor_< float > *)&ofColor_< float >::limeGreen;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_linen_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::linen",0,0) result = (ofColor_< float > *)&ofColor_< float >::linen;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_maroon_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::maroon",0,0) result = (ofColor_< float > *)&ofColor_< float >::maroon;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_mediumAquaMarine_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::mediumAquaMarine",0,0)
  result = (ofColor_< float > *)&ofColor_< float >::mediumAquaMarine;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_mediumBlue_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::mediumBlue",0,0) result = (ofColor_< float > *)&ofColor_< float >::mediumBlue;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_mediumOrchid_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::mediumOrchid",0,0) result = (ofColor_< float > *)&ofColor_< float >::mediumOrchid;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_mediumPurple_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::mediumPurple",0,0) result = (ofColor_< float > *)&ofColor_< float >::mediumPurple;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_mediumSeaGreen_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::mediumSeaGreen",0,0) result = (ofColor_< float > *)&ofColor_< float >::mediumSeaGreen;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_mediumSlateBlue_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::mediumSlateBlue",0,0)
  result = (ofColor_< float > *)&ofColor_< float >::mediumSlateBlue;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_mediumSpringGreen_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::mediumSpringGreen",0,0)
  result = (ofColor_< float > *)&ofColor_< float >::mediumSpringGreen;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_mediumTurquoise_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::mediumTurquoise",0,0)
  result = (ofColor_< float > *)&ofColor_< float >::mediumTurquoise;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_mediumVioletRed_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::mediumVioletRed",0,0)
  result = (ofColor_< float > *)&ofColor_< float >::mediumVioletRed;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_midnightBlue_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::midnightBlue",0,0) result = (ofColor_< float > *)&ofColor_< float >::midnightBlue;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_mintCream_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::mintCream",0,0) result = (ofColor_< float > *)&ofColor_< float >::mintCream;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_mistyRose_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::mistyRose",0,0) result = (ofColor_< float > *)&ofColor_< float >::mistyRose;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_moccasin_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::moccasin",0,0) result = (ofColor_< float > *)&ofColor_< float >::moccasin;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_navajoWhite_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::navajoWhite",0,0) result = (ofColor_< float > *)&ofColor_< float >::navajoWhite;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_navy_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::navy",0,0) result = (ofColor_< float > *)&ofColor_< float >::navy;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_oldLace_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::oldLace",0,0) result = (ofColor_< float > *)&ofColor_< float >::oldLace;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_olive_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::olive",0,0) result = (ofColor_< float > *)&ofColor_< float >::olive;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_oliveDrab_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::oliveDrab",0,0) result = (ofColor_< float > *)&ofColor_< float >::oliveDrab;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_orange_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::orange",0,0) result = (ofColor_< float > *)&ofColor_< float >::orange;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_orangeRed_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::orangeRed",0,0) result = (ofColor_< float > *)&ofColor_< float >::orangeRed;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_orchid_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::orchid",0,0) result = (ofColor_< float > *)&ofColor_< float >::orchid;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_paleGoldenRod_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::paleGoldenRod",0,0) result = (ofColor_< float > *)&ofColor_< float >::paleGoldenRod;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_paleGreen_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::paleGreen",0,0) result = (ofColor_< float > *)&ofColor_< float >::paleGreen;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_paleTurquoise_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::paleTurquoise",0,0) result = (ofColor_< float > *)&ofColor_< float >::paleTurquoise;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_paleVioletRed_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::paleVioletRed",0,0) result = (ofColor_< float > *)&ofColor_< float >::paleVioletRed;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_papayaWhip_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::papayaWhip",0,0) result = (ofColor_< float > *)&ofColor_< float >::papayaWhip;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_peachPuff_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::peachPuff",0,0) result = (ofColor_< float > *)&ofColor_< float >::peachPuff;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_peru_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::peru",0,0) result = (ofColor_< float > *)&ofColor_< float >::peru;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_pink_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::pink",0,0) result = (ofColor_< float > *)&ofColor_< float >::pink;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_plum_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::plum",0,0) result = (ofColor_< float > *)&ofColor_< float >::plum;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_powderBlue_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::powderBlue",0,0) result = (ofColor_< float > *)&ofColor_< float >::powderBlue;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_purple_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::purple",0,0) result = (ofColor_< float > *)&ofColor_< float >::purple;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_rosyBrown_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::rosyBrown",0,0) result = (ofColor_< float > *)&ofColor_< float >::rosyBrown;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_royalBlue_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::royalBlue",0,0) result = (ofColor_< float > *)&ofColor_< float >::royalBlue;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_saddleBrown_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::saddleBrown",0,0) result = (ofColor_< float > *)&ofColor_< float >::saddleBrown;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_salmon_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::salmon",0,0) result = (ofColor_< float > *)&ofColor_< float >::salmon;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_sandyBrown_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::sandyBrown",0,0) result = (ofColor_< float > *)&ofColor_< float >::sandyBrown;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_seaGreen_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::seaGreen",0,0) result = (ofColor_< float > *)&ofColor_< float >::seaGreen;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_seaShell_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::seaShell",0,0) result = (ofColor_< float > *)&ofColor_< float >::seaShell;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_sienna_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::sienna",0,0) result = (ofColor_< float > *)&ofColor_< float >::sienna;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_silver_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::silver",0,0) result = (ofColor_< float > *)&ofColor_< float >::silver;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_skyBlue_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::skyBlue",0,0) result = (ofColor_< float > *)&ofColor_< float >::skyBlue;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_slateBlue_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::slateBlue",0,0) result = (ofColor_< float > *)&ofColor_< float >::slateBlue;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_slateGray_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::slateGray",0,0) result = (ofColor_< float > *)&ofColor_< float >::slateGray;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_slateGrey_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::slateGrey",0,0) result = (ofColor_< float > *)&ofColor_< float >::slateGrey;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_snow_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::snow",0,0) result = (ofColor_< float > *)&ofColor_< float >::snow;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_springGreen_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::springGreen",0,0) result = (ofColor_< float > *)&ofColor_< float >::springGreen;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_steelBlue_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::steelBlue",0,0) result = (ofColor_< float > *)&ofColor_< float >::steelBlue;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_blueSteel_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::blueSteel",0,0) result = (ofColor_< float > *)&ofColor_< float >::blueSteel;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_tan_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::tan",0,0) result = (ofColor_< float > *)&ofColor_< float >::tan;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_teal_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::teal",0,0) result = (ofColor_< float > *)&ofColor_< float >::teal;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_thistle_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::thistle",0,0) result = (ofColor_< float > *)&ofColor_< float >::thistle;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_tomato_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::tomato",0,0) result = (ofColor_< float > *)&ofColor_< float >::tomato;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_turquoise_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::turquoise",0,0) result = (ofColor_< float > *)&ofColor_< float >::turquoise;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_violet_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::violet",0,0) result = (ofColor_< float > *)&ofColor_< float >::violet;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_wheat_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::wheat",0,0) result = (ofColor_< float > *)&ofColor_< float >::wheat;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_whiteSmoke_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::whiteSmoke",0,0) result = (ofColor_< float > *)&ofColor_< float >::whiteSmoke;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_yellowGreen_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *result = 0 ;
  SWIG_check_num_args("ofColor_< float >::yellowGreen",0,0) result = (ofColor_< float > *)&ofColor_< float >::yellowGreen;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_float_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_getR(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *arg1 = (ofColor_< float > *) 0 ;
  float result; SWIG_check_num_args("ofColor_< float >::getR",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< float >::getR",1,"ofColor_< float > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("FloatColor_getR",1,SWIGTYPE_p_ofColor_T_float_t); }  result = (float)ofColor__Sl_float_Sg__getR(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_getG(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *arg1 = (ofColor_< float > *) 0 ;
  float result; SWIG_check_num_args("ofColor_< float >::getG",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< float >::getG",1,"ofColor_< float > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("FloatColor_getG",1,SWIGTYPE_p_ofColor_T_float_t); }  result = (float)ofColor__Sl_float_Sg__getG(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_getB(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *arg1 = (ofColor_< float > *) 0 ;
  float result; SWIG_check_num_args("ofColor_< float >::getB",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< float >::getB",1,"ofColor_< float > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("FloatColor_getB",1,SWIGTYPE_p_ofColor_T_float_t); }  result = (float)ofColor__Sl_float_Sg__getB(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_getA(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *arg1 = (ofColor_< float > *) 0 ;
  float result; SWIG_check_num_args("ofColor_< float >::getA",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< float >::getA",1,"ofColor_< float > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("FloatColor_getA",1,SWIGTYPE_p_ofColor_T_float_t); }  result = (float)ofColor__Sl_float_Sg__getA(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_setR(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *arg1 = (ofColor_< float > *) 0 ;
  float arg2 ; SWIG_check_num_args("ofColor_< float >::setR",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< float >::setR",1,"ofColor_< float > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< float >::setR",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("FloatColor_setR",1,SWIGTYPE_p_ofColor_T_float_t); }  arg2 = (float)lua_tonumber(L, 2);
  ofColor__Sl_float_Sg__setR(arg1,arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_setG(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *arg1 = (ofColor_< float > *) 0 ;
  float arg2 ; SWIG_check_num_args("ofColor_< float >::setG",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< float >::setG",1,"ofColor_< float > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< float >::setG",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("FloatColor_setG",1,SWIGTYPE_p_ofColor_T_float_t); }  arg2 = (float)lua_tonumber(L, 2);
  ofColor__Sl_float_Sg__setG(arg1,arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_setB(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *arg1 = (ofColor_< float > *) 0 ;
  float arg2 ; SWIG_check_num_args("ofColor_< float >::setB",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< float >::setB",1,"ofColor_< float > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< float >::setB",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("FloatColor_setB",1,SWIGTYPE_p_ofColor_T_float_t); }  arg2 = (float)lua_tonumber(L, 2);
  ofColor__Sl_float_Sg__setB(arg1,arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_setA(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *arg1 = (ofColor_< float > *) 0 ;
  float arg2 ; SWIG_check_num_args("ofColor_< float >::setA",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< float >::setA",1,"ofColor_< float > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< float >::setA",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("FloatColor_setA",1,SWIGTYPE_p_ofColor_T_float_t); }  arg2 = (float)lua_tonumber(L, 2);
  ofColor__Sl_float_Sg__setA(arg1,arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor___tostring(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *arg1 = (ofColor_< float > *) 0 ;
  char *result = 0 ; SWIG_check_num_args("ofColor_< float >::__str__",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< float >::__str__",1,"ofColor_< float > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("FloatColor___tostring",1,SWIGTYPE_p_ofColor_T_float_t); } 
  result = (char *)ofColor__Sl_float_Sg____str__(arg1); lua_pushstring(L,(const char *)result); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_r_set(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *arg1 = (ofColor_< float > *) 0 ;
  float arg2 ; SWIG_check_num_args("ofColor_< float >::r",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< float >::r",1,"ofColor_< float > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< float >::r",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("FloatColor_r_set",1,SWIGTYPE_p_ofColor_T_float_t); }  arg2 = (float)lua_tonumber(L, 2);
  ofColor__Sl_float_Sg__r_set(arg1,arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_r_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *arg1 = (ofColor_< float > *) 0 ;
  float result; SWIG_check_num_args("ofColor_< float >::r",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< float >::r",1,"ofColor_< float > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("FloatColor_r_get",1,SWIGTYPE_p_ofColor_T_float_t); }  result = (float)ofColor__Sl_float_Sg__r_get(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_g_set(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *arg1 = (ofColor_< float > *) 0 ;
  float arg2 ; SWIG_check_num_args("ofColor_< float >::g",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< float >::g",1,"ofColor_< float > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< float >::g",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("FloatColor_g_set",1,SWIGTYPE_p_ofColor_T_float_t); }  arg2 = (float)lua_tonumber(L, 2);
  ofColor__Sl_float_Sg__g_set(arg1,arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_g_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *arg1 = (ofColor_< float > *) 0 ;
  float result; SWIG_check_num_args("ofColor_< float >::g",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< float >::g",1,"ofColor_< float > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("FloatColor_g_get",1,SWIGTYPE_p_ofColor_T_float_t); }  result = (float)ofColor__Sl_float_Sg__g_get(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_b_set(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *arg1 = (ofColor_< float > *) 0 ;
  float arg2 ; SWIG_check_num_args("ofColor_< float >::b",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< float >::b",1,"ofColor_< float > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< float >::b",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("FloatColor_b_set",1,SWIGTYPE_p_ofColor_T_float_t); }  arg2 = (float)lua_tonumber(L, 2);
  ofColor__Sl_float_Sg__b_set(arg1,arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_b_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *arg1 = (ofColor_< float > *) 0 ;
  float result; SWIG_check_num_args("ofColor_< float >::b",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< float >::b",1,"ofColor_< float > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("FloatColor_b_get",1,SWIGTYPE_p_ofColor_T_float_t); }  result = (float)ofColor__Sl_float_Sg__b_get(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_a_set(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *arg1 = (ofColor_< float > *) 0 ;
  float arg2 ; SWIG_check_num_args("ofColor_< float >::a",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< float >::a",1,"ofColor_< float > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< float >::a",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("FloatColor_a_set",1,SWIGTYPE_p_ofColor_T_float_t); }  arg2 = (float)lua_tonumber(L, 2);
  ofColor__Sl_float_Sg__a_set(arg1,arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FloatColor_a_get(lua_State* L) { int SWIG_arg = 0; ofColor_< float > *arg1 = (ofColor_< float > *) 0 ;
  float result; SWIG_check_num_args("ofColor_< float >::a",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< float >::a",1,"ofColor_< float > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_float_t,0))){
    SWIG_fail_ptr("FloatColor_a_get",1,SWIGTYPE_p_ofColor_T_float_t); }  result = (float)ofColor__Sl_float_Sg__a_get(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static void swig_delete_FloatColor(void *obj) {
ofColor_< float > *arg1 = (ofColor_< float > *) obj;
delete arg1;
}
static int _proxy__wrap_new_FloatColor(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_FloatColor);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_FloatColor_attributes[] = {
    { "r", _wrap_FloatColor_r_get, _wrap_FloatColor_r_set },
    { "g", _wrap_FloatColor_g_get, _wrap_FloatColor_g_set },
    { "b", _wrap_FloatColor_b_get, _wrap_FloatColor_b_set },
    { "a", _wrap_FloatColor_a_get, _wrap_FloatColor_a_set },
    {0,0,0}
};
static swig_lua_method swig_FloatColor_methods[]= {
    { "set", _wrap_FloatColor_set},
    { "setHex", _wrap_FloatColor_setHex},
    { "setHue", _wrap_FloatColor_setHue},
    { "setHueAngle", _wrap_FloatColor_setHueAngle},
    { "setSaturation", _wrap_FloatColor_setSaturation},
    { "setBrightness", _wrap_FloatColor_setBrightness},
    { "setHsb", _wrap_FloatColor_setHsb},
    { "clamp", _wrap_FloatColor_clamp},
    { "invert", _wrap_FloatColor_invert},
    { "normalize", _wrap_FloatColor_normalize},
    { "lerp", _wrap_FloatColor_lerp},
    { "getClamped", _wrap_FloatColor_getClamped},
    { "getInverted", _wrap_FloatColor_getInverted},
    { "getNormalized", _wrap_FloatColor_getNormalized},
    { "getLerped", _wrap_FloatColor_getLerped},
    { "getHex", _wrap_FloatColor_getHex},
    { "getHue", _wrap_FloatColor_getHue},
    { "getHueAngle", _wrap_FloatColor_getHueAngle},
    { "getSaturation", _wrap_FloatColor_getSaturation},
    { "getBrightness", _wrap_FloatColor_getBrightness},
    { "getLightness", _wrap_FloatColor_getLightness},
    { "getHsb", _wrap_FloatColor_getHsb},
    { "__eq", _wrap_FloatColor___eq},
    { "__add", _wrap_FloatColor___add},
    { "__sub", _wrap_FloatColor___sub},
    { "__mul", _wrap_FloatColor___mul},
    { "__div", _wrap_FloatColor___div},
    { "getR", _wrap_FloatColor_getR},
    { "getG", _wrap_FloatColor_getG},
    { "getB", _wrap_FloatColor_getB},
    { "getA", _wrap_FloatColor_getA},
    { "setR", _wrap_FloatColor_setR},
    { "setG", _wrap_FloatColor_setG},
    { "setB", _wrap_FloatColor_setB},
    { "setA", _wrap_FloatColor_setA},
    { "__tostring", _wrap_FloatColor___tostring},
    {0,0}
};
static swig_lua_method swig_FloatColor_meta[] = {
    { "__eq", _wrap_FloatColor___eq},
    { "__add", _wrap_FloatColor___add},
    { "__sub", _wrap_FloatColor___sub},
    { "__mul", _wrap_FloatColor___mul},
    { "__div", _wrap_FloatColor___div},
    { "__tostring", _wrap_FloatColor___tostring},
    {0,0}
};

static swig_lua_attribute swig_FloatColor_Sf_SwigStatic_attributes[] = {
    { "white", _wrap_FloatColor_white_get, SWIG_Lua_set_immutable },
    { "gray", _wrap_FloatColor_gray_get, SWIG_Lua_set_immutable },
    { "black", _wrap_FloatColor_black_get, SWIG_Lua_set_immutable },
    { "red", _wrap_FloatColor_red_get, SWIG_Lua_set_immutable },
    { "green", _wrap_FloatColor_green_get, SWIG_Lua_set_immutable },
    { "blue", _wrap_FloatColor_blue_get, SWIG_Lua_set_immutable },
    { "cyan", _wrap_FloatColor_cyan_get, SWIG_Lua_set_immutable },
    { "magenta", _wrap_FloatColor_magenta_get, SWIG_Lua_set_immutable },
    { "yellow", _wrap_FloatColor_yellow_get, SWIG_Lua_set_immutable },
    { "aliceBlue", _wrap_FloatColor_aliceBlue_get, SWIG_Lua_set_immutable },
    { "antiqueWhite", _wrap_FloatColor_antiqueWhite_get, SWIG_Lua_set_immutable },
    { "aqua", _wrap_FloatColor_aqua_get, SWIG_Lua_set_immutable },
    { "aquamarine", _wrap_FloatColor_aquamarine_get, SWIG_Lua_set_immutable },
    { "azure", _wrap_FloatColor_azure_get, SWIG_Lua_set_immutable },
    { "beige", _wrap_FloatColor_beige_get, SWIG_Lua_set_immutable },
    { "bisque", _wrap_FloatColor_bisque_get, SWIG_Lua_set_immutable },
    { "blanchedAlmond", _wrap_FloatColor_blanchedAlmond_get, SWIG_Lua_set_immutable },
    { "blueViolet", _wrap_FloatColor_blueViolet_get, SWIG_Lua_set_immutable },
    { "brown", _wrap_FloatColor_brown_get, SWIG_Lua_set_immutable },
    { "burlyWood", _wrap_FloatColor_burlyWood_get, SWIG_Lua_set_immutable },
    { "cadetBlue", _wrap_FloatColor_cadetBlue_get, SWIG_Lua_set_immutable },
    { "chartreuse", _wrap_FloatColor_chartreuse_get, SWIG_Lua_set_immutable },
    { "chocolate", _wrap_FloatColor_chocolate_get, SWIG_Lua_set_immutable },
    { "coral", _wrap_FloatColor_coral_get, SWIG_Lua_set_immutable },
    { "cornflowerBlue", _wrap_FloatColor_cornflowerBlue_get, SWIG_Lua_set_immutable },
    { "cornsilk", _wrap_FloatColor_cornsilk_get, SWIG_Lua_set_immutable },
    { "crimson", _wrap_FloatColor_crimson_get, SWIG_Lua_set_immutable },
    { "darkBlue", _wrap_FloatColor_darkBlue_get, SWIG_Lua_set_immutable },
    { "darkCyan", _wrap_FloatColor_darkCyan_get, SWIG_Lua_set_immutable },
    { "darkGoldenRod", _wrap_FloatColor_darkGoldenRod_get, SWIG_Lua_set_immutable },
    { "darkGray", _wrap_FloatColor_darkGray_get, SWIG_Lua_set_immutable },
    { "darkGrey", _wrap_FloatColor_darkGrey_get, SWIG_Lua_set_immutable },
    { "darkGreen", _wrap_FloatColor_darkGreen_get, SWIG_Lua_set_immutable },
    { "darkKhaki", _wrap_FloatColor_darkKhaki_get, SWIG_Lua_set_immutable },
    { "darkMagenta", _wrap_FloatColor_darkMagenta_get, SWIG_Lua_set_immutable },
    { "darkOliveGreen", _wrap_FloatColor_darkOliveGreen_get, SWIG_Lua_set_immutable },
    { "darkorange", _wrap_FloatColor_darkorange_get, SWIG_Lua_set_immutable },
    { "darkOrchid", _wrap_FloatColor_darkOrchid_get, SWIG_Lua_set_immutable },
    { "darkRed", _wrap_FloatColor_darkRed_get, SWIG_Lua_set_immutable },
    { "darkSalmon", _wrap_FloatColor_darkSalmon_get, SWIG_Lua_set_immutable },
    { "darkSeaGreen", _wrap_FloatColor_darkSeaGreen_get, SWIG_Lua_set_immutable },
    { "darkSlateBlue", _wrap_FloatColor_darkSlateBlue_get, SWIG_Lua_set_immutable },
    { "darkSlateGray", _wrap_FloatColor_darkSlateGray_get, SWIG_Lua_set_immutable },
    { "darkSlateGrey", _wrap_FloatColor_darkSlateGrey_get, SWIG_Lua_set_immutable },
    { "darkTurquoise", _wrap_FloatColor_darkTurquoise_get, SWIG_Lua_set_immutable },
    { "darkViolet", _wrap_FloatColor_darkViolet_get, SWIG_Lua_set_immutable },
    { "deepPink", _wrap_FloatColor_deepPink_get, SWIG_Lua_set_immutable },
    { "deepSkyBlue", _wrap_FloatColor_deepSkyBlue_get, SWIG_Lua_set_immutable },
    { "dimGray", _wrap_FloatColor_dimGray_get, SWIG_Lua_set_immutable },
    { "dimGrey", _wrap_FloatColor_dimGrey_get, SWIG_Lua_set_immutable },
    { "dodgerBlue", _wrap_FloatColor_dodgerBlue_get, SWIG_Lua_set_immutable },
    { "fireBrick", _wrap_FloatColor_fireBrick_get, SWIG_Lua_set_immutable },
    { "floralWhite", _wrap_FloatColor_floralWhite_get, SWIG_Lua_set_immutable },
    { "forestGreen", _wrap_FloatColor_forestGreen_get, SWIG_Lua_set_immutable },
    { "fuchsia", _wrap_FloatColor_fuchsia_get, SWIG_Lua_set_immutable },
    { "gainsboro", _wrap_FloatColor_gainsboro_get, SWIG_Lua_set_immutable },
    { "ghostWhite", _wrap_FloatColor_ghostWhite_get, SWIG_Lua_set_immutable },
    { "gold", _wrap_FloatColor_gold_get, SWIG_Lua_set_immutable },
    { "goldenRod", _wrap_FloatColor_goldenRod_get, SWIG_Lua_set_immutable },
    { "grey", _wrap_FloatColor_grey_get, SWIG_Lua_set_immutable },
    { "greenYellow", _wrap_FloatColor_greenYellow_get, SWIG_Lua_set_immutable },
    { "honeyDew", _wrap_FloatColor_honeyDew_get, SWIG_Lua_set_immutable },
    { "hotPink", _wrap_FloatColor_hotPink_get, SWIG_Lua_set_immutable },
    { "indianRed", _wrap_FloatColor_indianRed_get, SWIG_Lua_set_immutable },
    { "indigo", _wrap_FloatColor_indigo_get, SWIG_Lua_set_immutable },
    { "ivory", _wrap_FloatColor_ivory_get, SWIG_Lua_set_immutable },
    { "khaki", _wrap_FloatColor_khaki_get, SWIG_Lua_set_immutable },
    { "lavender", _wrap_FloatColor_lavender_get, SWIG_Lua_set_immutable },
    { "lavenderBlush", _wrap_FloatColor_lavenderBlush_get, SWIG_Lua_set_immutable },
    { "lawnGreen", _wrap_FloatColor_lawnGreen_get, SWIG_Lua_set_immutable },
    { "lemonChiffon", _wrap_FloatColor_lemonChiffon_get, SWIG_Lua_set_immutable },
    { "lightBlue", _wrap_FloatColor_lightBlue_get, SWIG_Lua_set_immutable },
    { "lightCoral", _wrap_FloatColor_lightCoral_get, SWIG_Lua_set_immutable },
    { "lightCyan", _wrap_FloatColor_lightCyan_get, SWIG_Lua_set_immutable },
    { "lightGoldenRodYellow", _wrap_FloatColor_lightGoldenRodYellow_get, SWIG_Lua_set_immutable },
    { "lightGray", _wrap_FloatColor_lightGray_get, SWIG_Lua_set_immutable },
    { "lightGrey", _wrap_FloatColor_lightGrey_get, SWIG_Lua_set_immutable },
    { "lightGreen", _wrap_FloatColor_lightGreen_get, SWIG_Lua_set_immutable },
    { "lightPink", _wrap_FloatColor_lightPink_get, SWIG_Lua_set_immutable },
    { "lightSalmon", _wrap_FloatColor_lightSalmon_get, SWIG_Lua_set_immutable },
    { "lightSeaGreen", _wrap_FloatColor_lightSeaGreen_get, SWIG_Lua_set_immutable },
    { "lightSkyBlue", _wrap_FloatColor_lightSkyBlue_get, SWIG_Lua_set_immutable },
    { "lightSlateGray", _wrap_FloatColor_lightSlateGray_get, SWIG_Lua_set_immutable },
    { "lightSlateGrey", _wrap_FloatColor_lightSlateGrey_get, SWIG_Lua_set_immutable },
    { "lightSteelBlue", _wrap_FloatColor_lightSteelBlue_get, SWIG_Lua_set_immutable },
    { "lightYellow", _wrap_FloatColor_lightYellow_get, SWIG_Lua_set_immutable },
    { "lime", _wrap_FloatColor_lime_get, SWIG_Lua_set_immutable },
    { "limeGreen", _wrap_FloatColor_limeGreen_get, SWIG_Lua_set_immutable },
    { "linen", _wrap_FloatColor_linen_get, SWIG_Lua_set_immutable },
    { "maroon", _wrap_FloatColor_maroon_get, SWIG_Lua_set_immutable },
    { "mediumAquaMarine", _wrap_FloatColor_mediumAquaMarine_get, SWIG_Lua_set_immutable },
    { "mediumBlue", _wrap_FloatColor_mediumBlue_get, SWIG_Lua_set_immutable },
    { "mediumOrchid", _wrap_FloatColor_mediumOrchid_get, SWIG_Lua_set_immutable },
    { "mediumPurple", _wrap_FloatColor_mediumPurple_get, SWIG_Lua_set_immutable },
    { "mediumSeaGreen", _wrap_FloatColor_mediumSeaGreen_get, SWIG_Lua_set_immutable },
    { "mediumSlateBlue", _wrap_FloatColor_mediumSlateBlue_get, SWIG_Lua_set_immutable },
    { "mediumSpringGreen", _wrap_FloatColor_mediumSpringGreen_get, SWIG_Lua_set_immutable },
    { "mediumTurquoise", _wrap_FloatColor_mediumTurquoise_get, SWIG_Lua_set_immutable },
    { "mediumVioletRed", _wrap_FloatColor_mediumVioletRed_get, SWIG_Lua_set_immutable },
    { "midnightBlue", _wrap_FloatColor_midnightBlue_get, SWIG_Lua_set_immutable },
    { "mintCream", _wrap_FloatColor_mintCream_get, SWIG_Lua_set_immutable },
    { "mistyRose", _wrap_FloatColor_mistyRose_get, SWIG_Lua_set_immutable },
    { "moccasin", _wrap_FloatColor_moccasin_get, SWIG_Lua_set_immutable },
    { "navajoWhite", _wrap_FloatColor_navajoWhite_get, SWIG_Lua_set_immutable },
    { "navy", _wrap_FloatColor_navy_get, SWIG_Lua_set_immutable },
    { "oldLace", _wrap_FloatColor_oldLace_get, SWIG_Lua_set_immutable },
    { "olive", _wrap_FloatColor_olive_get, SWIG_Lua_set_immutable },
    { "oliveDrab", _wrap_FloatColor_oliveDrab_get, SWIG_Lua_set_immutable },
    { "orange", _wrap_FloatColor_orange_get, SWIG_Lua_set_immutable },
    { "orangeRed", _wrap_FloatColor_orangeRed_get, SWIG_Lua_set_immutable },
    { "orchid", _wrap_FloatColor_orchid_get, SWIG_Lua_set_immutable },
    { "paleGoldenRod", _wrap_FloatColor_paleGoldenRod_get, SWIG_Lua_set_immutable },
    { "paleGreen", _wrap_FloatColor_paleGreen_get, SWIG_Lua_set_immutable },
    { "paleTurquoise", _wrap_FloatColor_paleTurquoise_get, SWIG_Lua_set_immutable },
    { "paleVioletRed", _wrap_FloatColor_paleVioletRed_get, SWIG_Lua_set_immutable },
    { "papayaWhip", _wrap_FloatColor_papayaWhip_get, SWIG_Lua_set_immutable },
    { "peachPuff", _wrap_FloatColor_peachPuff_get, SWIG_Lua_set_immutable },
    { "peru", _wrap_FloatColor_peru_get, SWIG_Lua_set_immutable },
    { "pink", _wrap_FloatColor_pink_get, SWIG_Lua_set_immutable },
    { "plum", _wrap_FloatColor_plum_get, SWIG_Lua_set_immutable },
    { "powderBlue", _wrap_FloatColor_powderBlue_get, SWIG_Lua_set_immutable },
    { "purple", _wrap_FloatColor_purple_get, SWIG_Lua_set_immutable },
    { "rosyBrown", _wrap_FloatColor_rosyBrown_get, SWIG_Lua_set_immutable },
    { "royalBlue", _wrap_FloatColor_royalBlue_get, SWIG_Lua_set_immutable },
    { "saddleBrown", _wrap_FloatColor_saddleBrown_get, SWIG_Lua_set_immutable },
    { "salmon", _wrap_FloatColor_salmon_get, SWIG_Lua_set_immutable },
    { "sandyBrown", _wrap_FloatColor_sandyBrown_get, SWIG_Lua_set_immutable },
    { "seaGreen", _wrap_FloatColor_seaGreen_get, SWIG_Lua_set_immutable },
    { "seaShell", _wrap_FloatColor_seaShell_get, SWIG_Lua_set_immutable },
    { "sienna", _wrap_FloatColor_sienna_get, SWIG_Lua_set_immutable },
    { "silver", _wrap_FloatColor_silver_get, SWIG_Lua_set_immutable },
    { "skyBlue", _wrap_FloatColor_skyBlue_get, SWIG_Lua_set_immutable },
    { "slateBlue", _wrap_FloatColor_slateBlue_get, SWIG_Lua_set_immutable },
    { "slateGray", _wrap_FloatColor_slateGray_get, SWIG_Lua_set_immutable },
    { "slateGrey", _wrap_FloatColor_slateGrey_get, SWIG_Lua_set_immutable },
    { "snow", _wrap_FloatColor_snow_get, SWIG_Lua_set_immutable },
    { "springGreen", _wrap_FloatColor_springGreen_get, SWIG_Lua_set_immutable },
    { "steelBlue", _wrap_FloatColor_steelBlue_get, SWIG_Lua_set_immutable },
    { "blueSteel", _wrap_FloatColor_blueSteel_get, SWIG_Lua_set_immutable },
    { "tan", _wrap_FloatColor_tan_get, SWIG_Lua_set_immutable },
    { "teal", _wrap_FloatColor_teal_get, SWIG_Lua_set_immutable },
    { "thistle", _wrap_FloatColor_thistle_get, SWIG_Lua_set_immutable },
    { "tomato", _wrap_FloatColor_tomato_get, SWIG_Lua_set_immutable },
    { "turquoise", _wrap_FloatColor_turquoise_get, SWIG_Lua_set_immutable },
    { "violet", _wrap_FloatColor_violet_get, SWIG_Lua_set_immutable },
    { "wheat", _wrap_FloatColor_wheat_get, SWIG_Lua_set_immutable },
    { "whiteSmoke", _wrap_FloatColor_whiteSmoke_get, SWIG_Lua_set_immutable },
    { "yellowGreen", _wrap_FloatColor_yellowGreen_get, SWIG_Lua_set_immutable },
    {0,0,0}
};
static swig_lua_const_info swig_FloatColor_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_FloatColor_Sf_SwigStatic_methods[]= {
    { "fromHsb", _wrap_FloatColor_fromHsb},
    { "fromHex", _wrap_FloatColor_fromHex},
    { "limit", _wrap_FloatColor_limit},
    {0,0}
};
static swig_lua_class* swig_FloatColor_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_FloatColor_Sf_SwigStatic = {
    "FloatColor",
    swig_FloatColor_Sf_SwigStatic_methods,
    swig_FloatColor_Sf_SwigStatic_attributes,
    swig_FloatColor_Sf_SwigStatic_constants,
    swig_FloatColor_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_FloatColor_bases[] = {0};
static const char *swig_FloatColor_base_names[] = {0};
static swig_lua_class _wrap_class_FloatColor = { "FloatColor", "FloatColor", &SWIGTYPE_p_ofColor_T_float_t,_proxy__wrap_new_FloatColor, swig_delete_FloatColor, swig_FloatColor_methods, swig_FloatColor_attributes, &swig_FloatColor_Sf_SwigStatic, swig_FloatColor_meta, swig_FloatColor_bases, swig_FloatColor_base_names };

static int _wrap_new_ShortColor__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::ofColor_",0,0)
  result = (ofColor_< unsigned short > *)new ofColor_< unsigned short >();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_ShortColor__SWIG_1(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ; float arg4 ;
  ofColor_< unsigned short > *result = 0 ; SWIG_check_num_args("ofColor_< unsigned short >::ofColor_",4,4)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofColor_< unsigned short >::ofColor_",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< unsigned short >::ofColor_",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofColor_< unsigned short >::ofColor_",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofColor_< unsigned short >::ofColor_",4,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  result = (ofColor_< unsigned short > *)new ofColor_< unsigned short >(arg1,arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_ShortColor__SWIG_2(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ;
  ofColor_< unsigned short > *result = 0 ; SWIG_check_num_args("ofColor_< unsigned short >::ofColor_",3,3)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofColor_< unsigned short >::ofColor_",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< unsigned short >::ofColor_",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofColor_< unsigned short >::ofColor_",3,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3);
  result = (ofColor_< unsigned short > *)new ofColor_< unsigned short >(arg1,arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_ShortColor__SWIG_3(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ;
  ofColor_< unsigned short > *result = 0 ; SWIG_check_num_args("ofColor_< unsigned short >::ofColor_",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofColor_< unsigned short >::ofColor_",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< unsigned short >::ofColor_",2,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); result = (ofColor_< unsigned short > *)new ofColor_< unsigned short >(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_ShortColor__SWIG_4(lua_State* L) { int SWIG_arg = 0; float arg1 ; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::ofColor_",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofColor_< unsigned short >::ofColor_",1,"float"); arg1 = (float)lua_tonumber(L, 1);
  result = (ofColor_< unsigned short > *)new ofColor_< unsigned short >(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_ShortColor__SWIG_5(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *arg1 = 0 ; float arg2 ;
  ofColor_< unsigned short > *result = 0 ; SWIG_check_num_args("ofColor_< unsigned short >::ofColor_",2,2)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofColor_< unsigned short >::ofColor_",1,"ofColor_< unsigned short > const &");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< unsigned short >::ofColor_",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_short_t,0))){
    SWIG_fail_ptr("new_ShortColor",1,SWIGTYPE_p_ofColor_T_unsigned_short_t); }  arg2 = (float)lua_tonumber(L, 2);
  result = (ofColor_< unsigned short > *)new ofColor_< unsigned short >((ofColor_< unsigned short > const &)*arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_new_ShortColor(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L); if (argc == 0) {
    return _wrap_new_ShortColor__SWIG_0(L);}  if (argc == 1) { int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) {
      return _wrap_new_ShortColor__SWIG_4(L);}  }  if (argc == 2) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofColor_T_unsigned_short_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_new_ShortColor__SWIG_5(L);}  }  }  if (argc == 2) { int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { {
        _v = lua_isnumber(L,argv[1]); }  if (_v) { return _wrap_new_ShortColor__SWIG_3(L);}  }  }  if (argc == 3) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); } 
        if (_v) { return _wrap_new_ShortColor__SWIG_2(L);}  }  }  }  if (argc == 4) { int _v; { _v = lua_isnumber(L,argv[0]); } 
    if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { {
            _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_new_ShortColor__SWIG_1(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_ShortColor'\n" "  Possible C/C++ prototypes are:\n"
  "    ofColor_< unsigned short >::ofColor_()\n" "    ofColor_< unsigned short >::ofColor_(float,float,float,float)\n"
  "    ofColor_< unsigned short >::ofColor_(float,float,float)\n" "    ofColor_< unsigned short >::ofColor_(float,float)\n"
  "    ofColor_< unsigned short >::ofColor_(float)\n"
  "    ofColor_< unsigned short >::ofColor_(ofColor_< unsigned short > const &,float)\n"); lua_error(L);return 0; }
static int _wrap_ShortColor_fromHsb__SWIG_0(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ;
  float arg4 ; ofColor_< unsigned short > result; SWIG_check_num_args("ofColor_< unsigned short >::fromHsb",4,4)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofColor_< unsigned short >::fromHsb",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< unsigned short >::fromHsb",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofColor_< unsigned short >::fromHsb",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofColor_< unsigned short >::fromHsb",4,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  result = ofColor_< unsigned short >::SWIGTEMPLATEDISAMBIGUATOR fromHsb(arg1,arg2,arg3,arg4); {
    ofColor_< unsigned short > * resultptr = new ofColor_< unsigned short >((const ofColor_< unsigned short > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofColor_T_unsigned_short_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_fromHsb__SWIG_1(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ;
  ofColor_< unsigned short > result; SWIG_check_num_args("ofColor_< unsigned short >::fromHsb",3,3)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofColor_< unsigned short >::fromHsb",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< unsigned short >::fromHsb",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofColor_< unsigned short >::fromHsb",3,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3);
  result = ofColor_< unsigned short >::SWIGTEMPLATEDISAMBIGUATOR fromHsb(arg1,arg2,arg3); {
    ofColor_< unsigned short > * resultptr = new ofColor_< unsigned short >((const ofColor_< unsigned short > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofColor_T_unsigned_short_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_fromHsb(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L); if (argc == 3) {
    int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { {
          _v = lua_isnumber(L,argv[2]); }  if (_v) { return _wrap_ShortColor_fromHsb__SWIG_1(L);}  }  }  }  if (argc == 4) {
    int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { {
          _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) {
            return _wrap_ShortColor_fromHsb__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'ShortColor_fromHsb'\n" "  Possible C/C++ prototypes are:\n"
  "    ofColor_< unsigned short >::fromHsb(float,float,float,float)\n"
  "    ofColor_< unsigned short >::fromHsb(float,float,float)\n"); lua_error(L);return 0; }
static int _wrap_ShortColor_fromHex__SWIG_0(lua_State* L) { int SWIG_arg = 0; int arg1 ; float arg2 ;
  ofColor_< unsigned short > result; SWIG_check_num_args("ofColor_< unsigned short >::fromHex",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofColor_< unsigned short >::fromHex",1,"int");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< unsigned short >::fromHex",2,"float"); arg1 = (int)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); result = ofColor_< unsigned short >::SWIGTEMPLATEDISAMBIGUATOR fromHex(arg1,arg2); {
    ofColor_< unsigned short > * resultptr = new ofColor_< unsigned short >((const ofColor_< unsigned short > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofColor_T_unsigned_short_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_fromHex__SWIG_1(lua_State* L) { int SWIG_arg = 0; int arg1 ; ofColor_< unsigned short > result;
  SWIG_check_num_args("ofColor_< unsigned short >::fromHex",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofColor_< unsigned short >::fromHex",1,"int"); arg1 = (int)lua_tonumber(L, 1);
  result = ofColor_< unsigned short >::SWIGTEMPLATEDISAMBIGUATOR fromHex(arg1); {
    ofColor_< unsigned short > * resultptr = new ofColor_< unsigned short >((const ofColor_< unsigned short > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofColor_T_unsigned_short_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_fromHex(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 1) {
    int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { return _wrap_ShortColor_fromHex__SWIG_1(L);}  }  if (argc == 2) {
    int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_ShortColor_fromHex__SWIG_0(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'ShortColor_fromHex'\n" "  Possible C/C++ prototypes are:\n"
  "    ofColor_< unsigned short >::fromHex(int,float)\n" "    ofColor_< unsigned short >::fromHex(int)\n");
  lua_error(L);return 0; }
static int _wrap_ShortColor_set__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned short > *arg1 = (ofColor_< unsigned short > *) 0 ; float arg2 ; float arg3 ; float arg4 ; float arg5 ;
  SWIG_check_num_args("ofColor_< unsigned short >::set",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned short >::set",1,"ofColor_< unsigned short > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< unsigned short >::set",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofColor_< unsigned short >::set",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofColor_< unsigned short >::set",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofColor_< unsigned short >::set",5,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortColor_set",1,SWIGTYPE_p_ofColor_T_unsigned_short_t); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); arg5 = (float)lua_tonumber(L, 5);
  (arg1)->set(arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_set__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned short > *arg1 = (ofColor_< unsigned short > *) 0 ; float arg2 ; float arg3 ; float arg4 ;
  SWIG_check_num_args("ofColor_< unsigned short >::set",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned short >::set",1,"ofColor_< unsigned short > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< unsigned short >::set",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofColor_< unsigned short >::set",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofColor_< unsigned short >::set",4,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortColor_set",1,SWIGTYPE_p_ofColor_T_unsigned_short_t); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); (arg1)->set(arg2,arg3,arg4); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_set__SWIG_2(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned short > *arg1 = (ofColor_< unsigned short > *) 0 ; float arg2 ; float arg3 ;
  SWIG_check_num_args("ofColor_< unsigned short >::set",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned short >::set",1,"ofColor_< unsigned short > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< unsigned short >::set",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofColor_< unsigned short >::set",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortColor_set",1,SWIGTYPE_p_ofColor_T_unsigned_short_t); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); (arg1)->set(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_ShortColor_set__SWIG_3(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned short > *arg1 = (ofColor_< unsigned short > *) 0 ; float arg2 ;
  SWIG_check_num_args("ofColor_< unsigned short >::set",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned short >::set",1,"ofColor_< unsigned short > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< unsigned short >::set",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortColor_set",1,SWIGTYPE_p_ofColor_T_unsigned_short_t); }  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->set(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_set__SWIG_4(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned short > *arg1 = (ofColor_< unsigned short > *) 0 ; ofColor_< unsigned short > *arg2 = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::set",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned short >::set",1,"ofColor_< unsigned short > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofColor_< unsigned short >::set",2,"ofColor_< unsigned short > const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortColor_set",1,SWIGTYPE_p_ofColor_T_unsigned_short_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofColor_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortColor_set",2,SWIGTYPE_p_ofColor_T_unsigned_short_t); } 
  (arg1)->set((ofColor_< unsigned short > const &)*arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_ShortColor_set(lua_State* L) { int argc; int argv[6]={ 1,2,3,4,5,6} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofColor_T_unsigned_short_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofColor_T_unsigned_short_t, 0)) {
          _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_ShortColor_set__SWIG_4(L);}  }  }  if (argc == 2) { int _v; {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofColor_T_unsigned_short_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_ShortColor_set__SWIG_3(L);}  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofColor_T_unsigned_short_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { return _wrap_ShortColor_set__SWIG_2(L);}  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofColor_T_unsigned_short_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_ShortColor_set__SWIG_1(L);}  }  }  }  } 
  if (argc == 5) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofColor_T_unsigned_short_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) {
              return _wrap_ShortColor_set__SWIG_0(L);}  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'ShortColor_set'\n" "  Possible C/C++ prototypes are:\n"
  "    ofColor_< unsigned short >::set(float,float,float,float)\n" "    ofColor_< unsigned short >::set(float,float,float)\n"
  "    ofColor_< unsigned short >::set(float,float)\n" "    ofColor_< unsigned short >::set(float)\n"
  "    ofColor_< unsigned short >::set(ofColor_< unsigned short > const &)\n"); lua_error(L);return 0; }
static int _wrap_ShortColor_setHex__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned short > *arg1 = (ofColor_< unsigned short > *) 0 ; int arg2 ; float arg3 ;
  SWIG_check_num_args("ofColor_< unsigned short >::setHex",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned short >::setHex",1,"ofColor_< unsigned short > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< unsigned short >::setHex",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofColor_< unsigned short >::setHex",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortColor_setHex",1,SWIGTYPE_p_ofColor_T_unsigned_short_t); }  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); (arg1)->setHex(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_ShortColor_setHex__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned short > *arg1 = (ofColor_< unsigned short > *) 0 ; int arg2 ;
  SWIG_check_num_args("ofColor_< unsigned short >::setHex",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned short >::setHex",1,"ofColor_< unsigned short > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< unsigned short >::setHex",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortColor_setHex",1,SWIGTYPE_p_ofColor_T_unsigned_short_t); }  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setHex(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_setHex(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofColor_T_unsigned_short_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_ShortColor_setHex__SWIG_1(L);}  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofColor_T_unsigned_short_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { return _wrap_ShortColor_setHex__SWIG_0(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'ShortColor_setHex'\n" "  Possible C/C++ prototypes are:\n"
  "    ofColor_< unsigned short >::setHex(int,float)\n" "    ofColor_< unsigned short >::setHex(int)\n");
  lua_error(L);return 0; }
static int _wrap_ShortColor_setHue(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned short > *arg1 = (ofColor_< unsigned short > *) 0 ; float arg2 ;
  SWIG_check_num_args("ofColor_< unsigned short >::setHue",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned short >::setHue",1,"ofColor_< unsigned short > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< unsigned short >::setHue",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortColor_setHue",1,SWIGTYPE_p_ofColor_T_unsigned_short_t); }  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setHue(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_setHueAngle(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned short > *arg1 = (ofColor_< unsigned short > *) 0 ; float arg2 ;
  SWIG_check_num_args("ofColor_< unsigned short >::setHueAngle",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned short >::setHueAngle",1,"ofColor_< unsigned short > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< unsigned short >::setHueAngle",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortColor_setHueAngle",1,SWIGTYPE_p_ofColor_T_unsigned_short_t); }  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setHueAngle(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_setSaturation(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned short > *arg1 = (ofColor_< unsigned short > *) 0 ; float arg2 ;
  SWIG_check_num_args("ofColor_< unsigned short >::setSaturation",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned short >::setSaturation",1,"ofColor_< unsigned short > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< unsigned short >::setSaturation",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortColor_setSaturation",1,SWIGTYPE_p_ofColor_T_unsigned_short_t); }  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setSaturation(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_setBrightness(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned short > *arg1 = (ofColor_< unsigned short > *) 0 ; float arg2 ;
  SWIG_check_num_args("ofColor_< unsigned short >::setBrightness",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned short >::setBrightness",1,"ofColor_< unsigned short > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< unsigned short >::setBrightness",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortColor_setBrightness",1,SWIGTYPE_p_ofColor_T_unsigned_short_t); }  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setBrightness(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_setHsb__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned short > *arg1 = (ofColor_< unsigned short > *) 0 ; float arg2 ; float arg3 ; float arg4 ; float arg5 ;
  SWIG_check_num_args("ofColor_< unsigned short >::setHsb",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned short >::setHsb",1,"ofColor_< unsigned short > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< unsigned short >::setHsb",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofColor_< unsigned short >::setHsb",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofColor_< unsigned short >::setHsb",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofColor_< unsigned short >::setHsb",5,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortColor_setHsb",1,SWIGTYPE_p_ofColor_T_unsigned_short_t); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); arg5 = (float)lua_tonumber(L, 5);
  (arg1)->setHsb(arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_setHsb__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned short > *arg1 = (ofColor_< unsigned short > *) 0 ; float arg2 ; float arg3 ; float arg4 ;
  SWIG_check_num_args("ofColor_< unsigned short >::setHsb",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned short >::setHsb",1,"ofColor_< unsigned short > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< unsigned short >::setHsb",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofColor_< unsigned short >::setHsb",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofColor_< unsigned short >::setHsb",4,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortColor_setHsb",1,SWIGTYPE_p_ofColor_T_unsigned_short_t); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); (arg1)->setHsb(arg2,arg3,arg4); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_setHsb(lua_State* L) { int argc; int argv[6]={ 1,2,3,4,5,6} ; argc = lua_gettop(L); if (argc == 4) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofColor_T_unsigned_short_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_ShortColor_setHsb__SWIG_1(L);}  }  }  }  } 
  if (argc == 5) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofColor_T_unsigned_short_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) {
              return _wrap_ShortColor_setHsb__SWIG_0(L);}  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'ShortColor_setHsb'\n" "  Possible C/C++ prototypes are:\n"
  "    ofColor_< unsigned short >::setHsb(float,float,float,float)\n"
  "    ofColor_< unsigned short >::setHsb(float,float,float)\n"); lua_error(L);return 0; }
static int _wrap_ShortColor_clamp(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned short > *arg1 = (ofColor_< unsigned short > *) 0 ; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::clamp",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned short >::clamp",1,"ofColor_< unsigned short > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortColor_clamp",1,SWIGTYPE_p_ofColor_T_unsigned_short_t); } 
  result = (ofColor_< unsigned short > *) &(arg1)->clamp();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_invert(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned short > *arg1 = (ofColor_< unsigned short > *) 0 ; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::invert",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned short >::invert",1,"ofColor_< unsigned short > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortColor_invert",1,SWIGTYPE_p_ofColor_T_unsigned_short_t); } 
  result = (ofColor_< unsigned short > *) &(arg1)->invert();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_normalize(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned short > *arg1 = (ofColor_< unsigned short > *) 0 ; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::normalize",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned short >::normalize",1,"ofColor_< unsigned short > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortColor_normalize",1,SWIGTYPE_p_ofColor_T_unsigned_short_t); } 
  result = (ofColor_< unsigned short > *) &(arg1)->normalize();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_lerp(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned short > *arg1 = (ofColor_< unsigned short > *) 0 ; ofColor_< unsigned short > *arg2 = 0 ; float arg3 ;
  ofColor_< unsigned short > *result = 0 ; SWIG_check_num_args("ofColor_< unsigned short >::lerp",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned short >::lerp",1,"ofColor_< unsigned short > *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofColor_< unsigned short >::lerp",2,"ofColor_< unsigned short > const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofColor_< unsigned short >::lerp",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortColor_lerp",1,SWIGTYPE_p_ofColor_T_unsigned_short_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofColor_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortColor_lerp",2,SWIGTYPE_p_ofColor_T_unsigned_short_t); }  arg3 = (float)lua_tonumber(L, 3);
  result = (ofColor_< unsigned short > *) &(arg1)->lerp((ofColor_< unsigned short > const &)*arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_getClamped(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned short > *arg1 = (ofColor_< unsigned short > *) 0 ; ofColor_< unsigned short > result;
  SWIG_check_num_args("ofColor_< unsigned short >::getClamped",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned short >::getClamped",1,"ofColor_< unsigned short > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortColor_getClamped",1,SWIGTYPE_p_ofColor_T_unsigned_short_t); } 
  result = ((ofColor_< unsigned short > const *)arg1)->getClamped(); {
    ofColor_< unsigned short > * resultptr = new ofColor_< unsigned short >((const ofColor_< unsigned short > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofColor_T_unsigned_short_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_getInverted(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned short > *arg1 = (ofColor_< unsigned short > *) 0 ; ofColor_< unsigned short > result;
  SWIG_check_num_args("ofColor_< unsigned short >::getInverted",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned short >::getInverted",1,"ofColor_< unsigned short > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortColor_getInverted",1,SWIGTYPE_p_ofColor_T_unsigned_short_t); } 
  result = ((ofColor_< unsigned short > const *)arg1)->getInverted(); {
    ofColor_< unsigned short > * resultptr = new ofColor_< unsigned short >((const ofColor_< unsigned short > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofColor_T_unsigned_short_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_getNormalized(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned short > *arg1 = (ofColor_< unsigned short > *) 0 ; ofColor_< unsigned short > result;
  SWIG_check_num_args("ofColor_< unsigned short >::getNormalized",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned short >::getNormalized",1,"ofColor_< unsigned short > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortColor_getNormalized",1,SWIGTYPE_p_ofColor_T_unsigned_short_t); } 
  result = ((ofColor_< unsigned short > const *)arg1)->getNormalized(); {
    ofColor_< unsigned short > * resultptr = new ofColor_< unsigned short >((const ofColor_< unsigned short > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofColor_T_unsigned_short_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_getLerped(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned short > *arg1 = (ofColor_< unsigned short > *) 0 ; ofColor_< unsigned short > *arg2 = 0 ; float arg3 ;
  ofColor_< unsigned short > result; SWIG_check_num_args("ofColor_< unsigned short >::getLerped",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned short >::getLerped",1,"ofColor_< unsigned short > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofColor_< unsigned short >::getLerped",2,"ofColor_< unsigned short > const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofColor_< unsigned short >::getLerped",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortColor_getLerped",1,SWIGTYPE_p_ofColor_T_unsigned_short_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofColor_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortColor_getLerped",2,SWIGTYPE_p_ofColor_T_unsigned_short_t); }  arg3 = (float)lua_tonumber(L, 3);
  result = ((ofColor_< unsigned short > const *)arg1)->getLerped((ofColor_< unsigned short > const &)*arg2,arg3); {
    ofColor_< unsigned short > * resultptr = new ofColor_< unsigned short >((const ofColor_< unsigned short > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofColor_T_unsigned_short_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_getHex(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned short > *arg1 = (ofColor_< unsigned short > *) 0 ; int result;
  SWIG_check_num_args("ofColor_< unsigned short >::getHex",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned short >::getHex",1,"ofColor_< unsigned short > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortColor_getHex",1,SWIGTYPE_p_ofColor_T_unsigned_short_t); } 
  result = (int)((ofColor_< unsigned short > const *)arg1)->getHex(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_getHue(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned short > *arg1 = (ofColor_< unsigned short > *) 0 ; float result;
  SWIG_check_num_args("ofColor_< unsigned short >::getHue",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned short >::getHue",1,"ofColor_< unsigned short > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortColor_getHue",1,SWIGTYPE_p_ofColor_T_unsigned_short_t); } 
  result = (float)((ofColor_< unsigned short > const *)arg1)->getHue(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_getHueAngle(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned short > *arg1 = (ofColor_< unsigned short > *) 0 ; float result;
  SWIG_check_num_args("ofColor_< unsigned short >::getHueAngle",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned short >::getHueAngle",1,"ofColor_< unsigned short > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortColor_getHueAngle",1,SWIGTYPE_p_ofColor_T_unsigned_short_t); } 
  result = (float)((ofColor_< unsigned short > const *)arg1)->getHueAngle(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_getSaturation(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned short > *arg1 = (ofColor_< unsigned short > *) 0 ; float result;
  SWIG_check_num_args("ofColor_< unsigned short >::getSaturation",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned short >::getSaturation",1,"ofColor_< unsigned short > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortColor_getSaturation",1,SWIGTYPE_p_ofColor_T_unsigned_short_t); } 
  result = (float)((ofColor_< unsigned short > const *)arg1)->getSaturation();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_getBrightness(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned short > *arg1 = (ofColor_< unsigned short > *) 0 ; float result;
  SWIG_check_num_args("ofColor_< unsigned short >::getBrightness",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned short >::getBrightness",1,"ofColor_< unsigned short > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortColor_getBrightness",1,SWIGTYPE_p_ofColor_T_unsigned_short_t); } 
  result = (float)((ofColor_< unsigned short > const *)arg1)->getBrightness();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_getLightness(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned short > *arg1 = (ofColor_< unsigned short > *) 0 ; float result;
  SWIG_check_num_args("ofColor_< unsigned short >::getLightness",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned short >::getLightness",1,"ofColor_< unsigned short > const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortColor_getLightness",1,SWIGTYPE_p_ofColor_T_unsigned_short_t); } 
  result = (float)((ofColor_< unsigned short > const *)arg1)->getLightness();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_getHsb(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned short > *arg1 = (ofColor_< unsigned short > *) 0 ; float *arg2 = 0 ; float *arg3 = 0 ; float *arg4 = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::getHsb",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned short >::getHsb",1,"ofColor_< unsigned short > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofColor_< unsigned short >::getHsb",2,"float &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofColor_< unsigned short >::getHsb",3,"float &");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("ofColor_< unsigned short >::getHsb",4,"float &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortColor_getHsb",1,SWIGTYPE_p_ofColor_T_unsigned_short_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("ShortColor_getHsb",2,SWIGTYPE_p_float); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("ShortColor_getHsb",3,SWIGTYPE_p_float); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("ShortColor_getHsb",4,SWIGTYPE_p_float); } 
  ((ofColor_< unsigned short > const *)arg1)->getHsb(*arg2,*arg3,*arg4); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_ShortColor_limit(lua_State* L) { int SWIG_arg = 0; float result;
  SWIG_check_num_args("ofColor_< unsigned short >::limit",0,0)
  result = (float)ofColor_< unsigned short >::SWIGTEMPLATEDISAMBIGUATOR limit();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor___eq(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned short > *arg1 = (ofColor_< unsigned short > *) 0 ; ofColor_< unsigned short > *arg2 = 0 ; bool result;
  SWIG_check_num_args("ofColor_< unsigned short >::operator ==",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned short >::operator ==",1,"ofColor_< unsigned short > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofColor_< unsigned short >::operator ==",2,"ofColor_< unsigned short > const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortColor___eq",1,SWIGTYPE_p_ofColor_T_unsigned_short_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofColor_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortColor___eq",2,SWIGTYPE_p_ofColor_T_unsigned_short_t); } 
  result = (bool)((ofColor_< unsigned short > const *)arg1)->operator ==((ofColor_< unsigned short > const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor___add__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned short > *arg1 = (ofColor_< unsigned short > *) 0 ; ofColor_< unsigned short > *arg2 = 0 ;
  ofColor_< unsigned short > result; SWIG_check_num_args("ofColor_< unsigned short >::operator +",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned short >::operator +",1,"ofColor_< unsigned short > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofColor_< unsigned short >::operator +",2,"ofColor_< unsigned short > const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortColor___add",1,SWIGTYPE_p_ofColor_T_unsigned_short_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofColor_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortColor___add",2,SWIGTYPE_p_ofColor_T_unsigned_short_t); } 
  result = ((ofColor_< unsigned short > const *)arg1)->operator +((ofColor_< unsigned short > const &)*arg2); {
    ofColor_< unsigned short > * resultptr = new ofColor_< unsigned short >((const ofColor_< unsigned short > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofColor_T_unsigned_short_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor___add__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned short > *arg1 = (ofColor_< unsigned short > *) 0 ; float arg2 ; ofColor_< unsigned short > result;
  SWIG_check_num_args("ofColor_< unsigned short >::operator +",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned short >::operator +",1,"ofColor_< unsigned short > const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< unsigned short >::operator +",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortColor___add",1,SWIGTYPE_p_ofColor_T_unsigned_short_t); }  arg2 = (float)lua_tonumber(L, 2);
  result = ((ofColor_< unsigned short > const *)arg1)->operator +(arg2); {
    ofColor_< unsigned short > * resultptr = new ofColor_< unsigned short >((const ofColor_< unsigned short > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofColor_T_unsigned_short_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor___add(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofColor_T_unsigned_short_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofColor_T_unsigned_short_t, 0)) {
          _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_ShortColor___add__SWIG_0(L);}  }  }  if (argc == 2) { int _v; {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofColor_T_unsigned_short_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_ShortColor___add__SWIG_1(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'ShortColor___add'\n" "  Possible C/C++ prototypes are:\n"
  "    ofColor_< unsigned short >::operator +(ofColor_< unsigned short > const &) const\n"
  "    ofColor_< unsigned short >::operator +(float) const\n"); lua_error(L);return 0; }
static int _wrap_ShortColor___sub__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned short > *arg1 = (ofColor_< unsigned short > *) 0 ; ofColor_< unsigned short > *arg2 = 0 ;
  ofColor_< unsigned short > result; SWIG_check_num_args("ofColor_< unsigned short >::operator -",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned short >::operator -",1,"ofColor_< unsigned short > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofColor_< unsigned short >::operator -",2,"ofColor_< unsigned short > const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortColor___sub",1,SWIGTYPE_p_ofColor_T_unsigned_short_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofColor_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortColor___sub",2,SWIGTYPE_p_ofColor_T_unsigned_short_t); } 
  result = ((ofColor_< unsigned short > const *)arg1)->operator -((ofColor_< unsigned short > const &)*arg2); {
    ofColor_< unsigned short > * resultptr = new ofColor_< unsigned short >((const ofColor_< unsigned short > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofColor_T_unsigned_short_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor___sub__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned short > *arg1 = (ofColor_< unsigned short > *) 0 ; float arg2 ; ofColor_< unsigned short > result;
  SWIG_check_num_args("ofColor_< unsigned short >::operator -",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned short >::operator -",1,"ofColor_< unsigned short > const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< unsigned short >::operator -",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortColor___sub",1,SWIGTYPE_p_ofColor_T_unsigned_short_t); }  arg2 = (float)lua_tonumber(L, 2);
  result = ((ofColor_< unsigned short > const *)arg1)->operator -(arg2); {
    ofColor_< unsigned short > * resultptr = new ofColor_< unsigned short >((const ofColor_< unsigned short > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofColor_T_unsigned_short_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor___sub(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofColor_T_unsigned_short_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofColor_T_unsigned_short_t, 0)) {
          _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_ShortColor___sub__SWIG_0(L);}  }  }  if (argc == 2) { int _v; {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofColor_T_unsigned_short_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_ShortColor___sub__SWIG_1(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'ShortColor___sub'\n" "  Possible C/C++ prototypes are:\n"
  "    ofColor_< unsigned short >::operator -(ofColor_< unsigned short > const &) const\n"
  "    ofColor_< unsigned short >::operator -(float) const\n"); lua_error(L);return 0; }
static int _wrap_ShortColor___mul__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned short > *arg1 = (ofColor_< unsigned short > *) 0 ; ofColor_< unsigned short > *arg2 = 0 ;
  ofColor_< unsigned short > result; SWIG_check_num_args("ofColor_< unsigned short >::operator *",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned short >::operator *",1,"ofColor_< unsigned short > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofColor_< unsigned short >::operator *",2,"ofColor_< unsigned short > const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortColor___mul",1,SWIGTYPE_p_ofColor_T_unsigned_short_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofColor_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortColor___mul",2,SWIGTYPE_p_ofColor_T_unsigned_short_t); } 
  result = ((ofColor_< unsigned short > const *)arg1)->operator *((ofColor_< unsigned short > const &)*arg2); {
    ofColor_< unsigned short > * resultptr = new ofColor_< unsigned short >((const ofColor_< unsigned short > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofColor_T_unsigned_short_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor___mul__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned short > *arg1 = (ofColor_< unsigned short > *) 0 ; float arg2 ; ofColor_< unsigned short > result;
  SWIG_check_num_args("ofColor_< unsigned short >::operator *",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned short >::operator *",1,"ofColor_< unsigned short > const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< unsigned short >::operator *",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortColor___mul",1,SWIGTYPE_p_ofColor_T_unsigned_short_t); }  arg2 = (float)lua_tonumber(L, 2);
  result = ((ofColor_< unsigned short > const *)arg1)->operator *(arg2); {
    ofColor_< unsigned short > * resultptr = new ofColor_< unsigned short >((const ofColor_< unsigned short > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofColor_T_unsigned_short_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor___mul(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofColor_T_unsigned_short_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofColor_T_unsigned_short_t, 0)) {
          _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_ShortColor___mul__SWIG_0(L);}  }  }  if (argc == 2) { int _v; {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofColor_T_unsigned_short_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_ShortColor___mul__SWIG_1(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'ShortColor___mul'\n" "  Possible C/C++ prototypes are:\n"
  "    ofColor_< unsigned short >::operator *(ofColor_< unsigned short > const &) const\n"
  "    ofColor_< unsigned short >::operator *(float) const\n"); lua_error(L);return 0; }
static int _wrap_ShortColor___div__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned short > *arg1 = (ofColor_< unsigned short > *) 0 ; ofColor_< unsigned short > *arg2 = 0 ;
  ofColor_< unsigned short > result; SWIG_check_num_args("ofColor_< unsigned short >::operator /",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned short >::operator /",1,"ofColor_< unsigned short > const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofColor_< unsigned short >::operator /",2,"ofColor_< unsigned short > const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortColor___div",1,SWIGTYPE_p_ofColor_T_unsigned_short_t); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofColor_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortColor___div",2,SWIGTYPE_p_ofColor_T_unsigned_short_t); } 
  result = ((ofColor_< unsigned short > const *)arg1)->operator /((ofColor_< unsigned short > const &)*arg2); {
    ofColor_< unsigned short > * resultptr = new ofColor_< unsigned short >((const ofColor_< unsigned short > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofColor_T_unsigned_short_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor___div__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned short > *arg1 = (ofColor_< unsigned short > *) 0 ; float arg2 ; ofColor_< unsigned short > result;
  SWIG_check_num_args("ofColor_< unsigned short >::operator /",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned short >::operator /",1,"ofColor_< unsigned short > const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< unsigned short >::operator /",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortColor___div",1,SWIGTYPE_p_ofColor_T_unsigned_short_t); }  arg2 = (float)lua_tonumber(L, 2);
  result = ((ofColor_< unsigned short > const *)arg1)->operator /(arg2); {
    ofColor_< unsigned short > * resultptr = new ofColor_< unsigned short >((const ofColor_< unsigned short > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofColor_T_unsigned_short_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor___div(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofColor_T_unsigned_short_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofColor_T_unsigned_short_t, 0)) {
          _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_ShortColor___div__SWIG_0(L);}  }  }  if (argc == 2) { int _v; {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofColor_T_unsigned_short_t, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_ShortColor___div__SWIG_1(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'ShortColor___div'\n" "  Possible C/C++ prototypes are:\n"
  "    ofColor_< unsigned short >::operator /(ofColor_< unsigned short > const &) const\n"
  "    ofColor_< unsigned short >::operator /(float) const\n"); lua_error(L);return 0; }
static int _wrap_ShortColor_white_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::white",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::white;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_gray_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::gray",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::gray;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_black_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::black",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::black;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_red_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::red",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::red;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_green_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::green",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::green;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_blue_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::blue",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::blue;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_cyan_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::cyan",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::cyan;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_magenta_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::magenta",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::magenta;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_yellow_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::yellow",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::yellow;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_aliceBlue_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::aliceBlue",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::aliceBlue;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_antiqueWhite_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::antiqueWhite",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::antiqueWhite;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_aqua_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::aqua",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::aqua;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_aquamarine_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::aquamarine",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::aquamarine;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_azure_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::azure",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::azure;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_beige_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::beige",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::beige;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_bisque_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::bisque",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::bisque;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_blanchedAlmond_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::blanchedAlmond",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::blanchedAlmond;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_blueViolet_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::blueViolet",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::blueViolet;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_brown_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::brown",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::brown;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_burlyWood_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::burlyWood",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::burlyWood;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_cadetBlue_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::cadetBlue",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::cadetBlue;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_chartreuse_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::chartreuse",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::chartreuse;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_chocolate_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::chocolate",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::chocolate;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_coral_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::coral",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::coral;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_cornflowerBlue_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::cornflowerBlue",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::cornflowerBlue;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_cornsilk_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::cornsilk",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::cornsilk;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_crimson_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::crimson",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::crimson;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_darkBlue_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::darkBlue",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::darkBlue;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_darkCyan_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::darkCyan",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::darkCyan;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_darkGoldenRod_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::darkGoldenRod",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::darkGoldenRod;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_darkGray_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::darkGray",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::darkGray;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_darkGrey_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::darkGrey",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::darkGrey;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_darkGreen_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::darkGreen",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::darkGreen;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_darkKhaki_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::darkKhaki",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::darkKhaki;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_darkMagenta_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::darkMagenta",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::darkMagenta;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_darkOliveGreen_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::darkOliveGreen",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::darkOliveGreen;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_darkorange_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::darkorange",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::darkorange;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_darkOrchid_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::darkOrchid",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::darkOrchid;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_darkRed_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::darkRed",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::darkRed;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_darkSalmon_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::darkSalmon",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::darkSalmon;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_darkSeaGreen_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::darkSeaGreen",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::darkSeaGreen;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_darkSlateBlue_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::darkSlateBlue",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::darkSlateBlue;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_darkSlateGray_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::darkSlateGray",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::darkSlateGray;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_darkSlateGrey_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::darkSlateGrey",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::darkSlateGrey;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_darkTurquoise_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::darkTurquoise",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::darkTurquoise;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_darkViolet_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::darkViolet",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::darkViolet;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_deepPink_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::deepPink",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::deepPink;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_deepSkyBlue_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::deepSkyBlue",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::deepSkyBlue;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_dimGray_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::dimGray",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::dimGray;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_dimGrey_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::dimGrey",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::dimGrey;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_dodgerBlue_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::dodgerBlue",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::dodgerBlue;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_fireBrick_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::fireBrick",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::fireBrick;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_floralWhite_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::floralWhite",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::floralWhite;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_forestGreen_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::forestGreen",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::forestGreen;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_fuchsia_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::fuchsia",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::fuchsia;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_gainsboro_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::gainsboro",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::gainsboro;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_ghostWhite_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::ghostWhite",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::ghostWhite;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_gold_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::gold",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::gold;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_goldenRod_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::goldenRod",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::goldenRod;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_grey_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::grey",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::grey;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_greenYellow_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::greenYellow",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::greenYellow;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_honeyDew_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::honeyDew",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::honeyDew;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_hotPink_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::hotPink",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::hotPink;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_indianRed_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::indianRed",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::indianRed;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_indigo_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::indigo",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::indigo;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_ivory_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::ivory",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::ivory;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_khaki_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::khaki",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::khaki;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_lavender_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::lavender",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::lavender;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_lavenderBlush_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::lavenderBlush",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::lavenderBlush;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_lawnGreen_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::lawnGreen",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::lawnGreen;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_lemonChiffon_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::lemonChiffon",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::lemonChiffon;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_lightBlue_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::lightBlue",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::lightBlue;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_lightCoral_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::lightCoral",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::lightCoral;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_lightCyan_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::lightCyan",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::lightCyan;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_lightGoldenRodYellow_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::lightGoldenRodYellow",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::lightGoldenRodYellow;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_lightGray_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::lightGray",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::lightGray;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_lightGrey_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::lightGrey",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::lightGrey;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_lightGreen_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::lightGreen",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::lightGreen;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_lightPink_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::lightPink",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::lightPink;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_lightSalmon_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::lightSalmon",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::lightSalmon;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_lightSeaGreen_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::lightSeaGreen",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::lightSeaGreen;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_lightSkyBlue_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::lightSkyBlue",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::lightSkyBlue;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_lightSlateGray_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::lightSlateGray",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::lightSlateGray;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_lightSlateGrey_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::lightSlateGrey",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::lightSlateGrey;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_lightSteelBlue_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::lightSteelBlue",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::lightSteelBlue;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_lightYellow_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::lightYellow",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::lightYellow;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_lime_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::lime",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::lime;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_limeGreen_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::limeGreen",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::limeGreen;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_linen_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::linen",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::linen;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_maroon_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::maroon",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::maroon;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_mediumAquaMarine_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::mediumAquaMarine",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::mediumAquaMarine;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_mediumBlue_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::mediumBlue",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::mediumBlue;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_mediumOrchid_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::mediumOrchid",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::mediumOrchid;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_mediumPurple_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::mediumPurple",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::mediumPurple;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_mediumSeaGreen_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::mediumSeaGreen",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::mediumSeaGreen;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_mediumSlateBlue_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::mediumSlateBlue",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::mediumSlateBlue;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_mediumSpringGreen_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::mediumSpringGreen",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::mediumSpringGreen;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_mediumTurquoise_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::mediumTurquoise",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::mediumTurquoise;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_mediumVioletRed_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::mediumVioletRed",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::mediumVioletRed;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_midnightBlue_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::midnightBlue",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::midnightBlue;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_mintCream_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::mintCream",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::mintCream;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_mistyRose_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::mistyRose",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::mistyRose;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_moccasin_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::moccasin",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::moccasin;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_navajoWhite_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::navajoWhite",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::navajoWhite;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_navy_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::navy",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::navy;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_oldLace_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::oldLace",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::oldLace;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_olive_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::olive",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::olive;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_oliveDrab_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::oliveDrab",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::oliveDrab;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_orange_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::orange",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::orange;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_orangeRed_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::orangeRed",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::orangeRed;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_orchid_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::orchid",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::orchid;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_paleGoldenRod_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::paleGoldenRod",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::paleGoldenRod;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_paleGreen_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::paleGreen",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::paleGreen;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_paleTurquoise_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::paleTurquoise",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::paleTurquoise;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_paleVioletRed_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::paleVioletRed",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::paleVioletRed;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_papayaWhip_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::papayaWhip",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::papayaWhip;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_peachPuff_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::peachPuff",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::peachPuff;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_peru_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::peru",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::peru;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_pink_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::pink",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::pink;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_plum_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::plum",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::plum;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_powderBlue_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::powderBlue",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::powderBlue;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_purple_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::purple",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::purple;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_rosyBrown_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::rosyBrown",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::rosyBrown;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_royalBlue_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::royalBlue",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::royalBlue;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_saddleBrown_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::saddleBrown",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::saddleBrown;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_salmon_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::salmon",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::salmon;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_sandyBrown_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::sandyBrown",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::sandyBrown;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_seaGreen_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::seaGreen",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::seaGreen;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_seaShell_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::seaShell",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::seaShell;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_sienna_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::sienna",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::sienna;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_silver_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::silver",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::silver;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_skyBlue_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::skyBlue",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::skyBlue;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_slateBlue_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::slateBlue",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::slateBlue;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_slateGray_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::slateGray",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::slateGray;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_slateGrey_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::slateGrey",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::slateGrey;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_snow_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::snow",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::snow;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_springGreen_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::springGreen",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::springGreen;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_steelBlue_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::steelBlue",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::steelBlue;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_blueSteel_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::blueSteel",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::blueSteel;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_tan_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::tan",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::tan;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_teal_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::teal",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::teal;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_thistle_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::thistle",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::thistle;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_tomato_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::tomato",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::tomato;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_turquoise_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::turquoise",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::turquoise;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_violet_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::violet",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::violet;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_wheat_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::wheat",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::wheat;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_whiteSmoke_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::whiteSmoke",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::whiteSmoke;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_yellowGreen_get(lua_State* L) { int SWIG_arg = 0; ofColor_< unsigned short > *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::yellowGreen",0,0)
  result = (ofColor_< unsigned short > *)&ofColor_< unsigned short >::yellowGreen;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofColor_T_unsigned_short_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_getR(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned short > *arg1 = (ofColor_< unsigned short > *) 0 ; unsigned short result;
  SWIG_check_num_args("ofColor_< unsigned short >::getR",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned short >::getR",1,"ofColor_< unsigned short > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortColor_getR",1,SWIGTYPE_p_ofColor_T_unsigned_short_t); } 
  result = (unsigned short)ofColor__Sl_unsigned_SS_short_Sg__getR(arg1); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_getG(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned short > *arg1 = (ofColor_< unsigned short > *) 0 ; unsigned short result;
  SWIG_check_num_args("ofColor_< unsigned short >::getG",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned short >::getG",1,"ofColor_< unsigned short > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortColor_getG",1,SWIGTYPE_p_ofColor_T_unsigned_short_t); } 
  result = (unsigned short)ofColor__Sl_unsigned_SS_short_Sg__getG(arg1); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_getB(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned short > *arg1 = (ofColor_< unsigned short > *) 0 ; unsigned short result;
  SWIG_check_num_args("ofColor_< unsigned short >::getB",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned short >::getB",1,"ofColor_< unsigned short > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortColor_getB",1,SWIGTYPE_p_ofColor_T_unsigned_short_t); } 
  result = (unsigned short)ofColor__Sl_unsigned_SS_short_Sg__getB(arg1); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_getA(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned short > *arg1 = (ofColor_< unsigned short > *) 0 ; unsigned short result;
  SWIG_check_num_args("ofColor_< unsigned short >::getA",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned short >::getA",1,"ofColor_< unsigned short > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortColor_getA",1,SWIGTYPE_p_ofColor_T_unsigned_short_t); } 
  result = (unsigned short)ofColor__Sl_unsigned_SS_short_Sg__getA(arg1); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_setR(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned short > *arg1 = (ofColor_< unsigned short > *) 0 ; unsigned short arg2 ;
  SWIG_check_num_args("ofColor_< unsigned short >::setR",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned short >::setR",1,"ofColor_< unsigned short > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< unsigned short >::setR",2,"unsigned short");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortColor_setR",1,SWIGTYPE_p_ofColor_T_unsigned_short_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (unsigned short)lua_tonumber(L, 2);
  ofColor__Sl_unsigned_SS_short_Sg__setR(arg1,arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_setG(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned short > *arg1 = (ofColor_< unsigned short > *) 0 ; unsigned short arg2 ;
  SWIG_check_num_args("ofColor_< unsigned short >::setG",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned short >::setG",1,"ofColor_< unsigned short > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< unsigned short >::setG",2,"unsigned short");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortColor_setG",1,SWIGTYPE_p_ofColor_T_unsigned_short_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (unsigned short)lua_tonumber(L, 2);
  ofColor__Sl_unsigned_SS_short_Sg__setG(arg1,arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_setB(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned short > *arg1 = (ofColor_< unsigned short > *) 0 ; unsigned short arg2 ;
  SWIG_check_num_args("ofColor_< unsigned short >::setB",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned short >::setB",1,"ofColor_< unsigned short > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< unsigned short >::setB",2,"unsigned short");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortColor_setB",1,SWIGTYPE_p_ofColor_T_unsigned_short_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (unsigned short)lua_tonumber(L, 2);
  ofColor__Sl_unsigned_SS_short_Sg__setB(arg1,arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_setA(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned short > *arg1 = (ofColor_< unsigned short > *) 0 ; unsigned short arg2 ;
  SWIG_check_num_args("ofColor_< unsigned short >::setA",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned short >::setA",1,"ofColor_< unsigned short > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< unsigned short >::setA",2,"unsigned short");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortColor_setA",1,SWIGTYPE_p_ofColor_T_unsigned_short_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (unsigned short)lua_tonumber(L, 2);
  ofColor__Sl_unsigned_SS_short_Sg__setA(arg1,arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor___tostring(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned short > *arg1 = (ofColor_< unsigned short > *) 0 ; char *result = 0 ;
  SWIG_check_num_args("ofColor_< unsigned short >::__str__",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned short >::__str__",1,"ofColor_< unsigned short > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortColor___tostring",1,SWIGTYPE_p_ofColor_T_unsigned_short_t); } 
  result = (char *)ofColor__Sl_unsigned_SS_short_Sg____str__(arg1); lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_r_set(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned short > *arg1 = (ofColor_< unsigned short > *) 0 ; unsigned short arg2 ;
  SWIG_check_num_args("ofColor_< unsigned short >::r",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned short >::r",1,"ofColor_< unsigned short > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< unsigned short >::r",2,"unsigned short");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortColor_r_set",1,SWIGTYPE_p_ofColor_T_unsigned_short_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (unsigned short)lua_tonumber(L, 2);
  ofColor__Sl_unsigned_SS_short_Sg__r_set(arg1,arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_r_get(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned short > *arg1 = (ofColor_< unsigned short > *) 0 ; unsigned short result;
  SWIG_check_num_args("ofColor_< unsigned short >::r",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned short >::r",1,"ofColor_< unsigned short > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortColor_r_get",1,SWIGTYPE_p_ofColor_T_unsigned_short_t); } 
  result = (unsigned short)ofColor__Sl_unsigned_SS_short_Sg__r_get(arg1); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_g_set(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned short > *arg1 = (ofColor_< unsigned short > *) 0 ; unsigned short arg2 ;
  SWIG_check_num_args("ofColor_< unsigned short >::g",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned short >::g",1,"ofColor_< unsigned short > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< unsigned short >::g",2,"unsigned short");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortColor_g_set",1,SWIGTYPE_p_ofColor_T_unsigned_short_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (unsigned short)lua_tonumber(L, 2);
  ofColor__Sl_unsigned_SS_short_Sg__g_set(arg1,arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_g_get(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned short > *arg1 = (ofColor_< unsigned short > *) 0 ; unsigned short result;
  SWIG_check_num_args("ofColor_< unsigned short >::g",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned short >::g",1,"ofColor_< unsigned short > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortColor_g_get",1,SWIGTYPE_p_ofColor_T_unsigned_short_t); } 
  result = (unsigned short)ofColor__Sl_unsigned_SS_short_Sg__g_get(arg1); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_b_set(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned short > *arg1 = (ofColor_< unsigned short > *) 0 ; unsigned short arg2 ;
  SWIG_check_num_args("ofColor_< unsigned short >::b",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned short >::b",1,"ofColor_< unsigned short > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< unsigned short >::b",2,"unsigned short");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortColor_b_set",1,SWIGTYPE_p_ofColor_T_unsigned_short_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (unsigned short)lua_tonumber(L, 2);
  ofColor__Sl_unsigned_SS_short_Sg__b_set(arg1,arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_b_get(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned short > *arg1 = (ofColor_< unsigned short > *) 0 ; unsigned short result;
  SWIG_check_num_args("ofColor_< unsigned short >::b",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned short >::b",1,"ofColor_< unsigned short > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortColor_b_get",1,SWIGTYPE_p_ofColor_T_unsigned_short_t); } 
  result = (unsigned short)ofColor__Sl_unsigned_SS_short_Sg__b_get(arg1); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_a_set(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned short > *arg1 = (ofColor_< unsigned short > *) 0 ; unsigned short arg2 ;
  SWIG_check_num_args("ofColor_< unsigned short >::a",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned short >::a",1,"ofColor_< unsigned short > *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofColor_< unsigned short >::a",2,"unsigned short");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortColor_a_set",1,SWIGTYPE_p_ofColor_T_unsigned_short_t); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (unsigned short)lua_tonumber(L, 2);
  ofColor__Sl_unsigned_SS_short_Sg__a_set(arg1,arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_ShortColor_a_get(lua_State* L) { int SWIG_arg = 0;
  ofColor_< unsigned short > *arg1 = (ofColor_< unsigned short > *) 0 ; unsigned short result;
  SWIG_check_num_args("ofColor_< unsigned short >::a",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofColor_< unsigned short >::a",1,"ofColor_< unsigned short > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofColor_T_unsigned_short_t,0))){
    SWIG_fail_ptr("ShortColor_a_get",1,SWIGTYPE_p_ofColor_T_unsigned_short_t); } 
  result = (unsigned short)ofColor__Sl_unsigned_SS_short_Sg__a_get(arg1); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static void swig_delete_ShortColor(void *obj) {
ofColor_< unsigned short > *arg1 = (ofColor_< unsigned short > *) obj;
delete arg1;
}
static int _proxy__wrap_new_ShortColor(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_ShortColor);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_ShortColor_attributes[] = {
    { "r", _wrap_ShortColor_r_get, _wrap_ShortColor_r_set },
    { "g", _wrap_ShortColor_g_get, _wrap_ShortColor_g_set },
    { "b", _wrap_ShortColor_b_get, _wrap_ShortColor_b_set },
    { "a", _wrap_ShortColor_a_get, _wrap_ShortColor_a_set },
    {0,0,0}
};
static swig_lua_method swig_ShortColor_methods[]= {
    { "set", _wrap_ShortColor_set},
    { "setHex", _wrap_ShortColor_setHex},
    { "setHue", _wrap_ShortColor_setHue},
    { "setHueAngle", _wrap_ShortColor_setHueAngle},
    { "setSaturation", _wrap_ShortColor_setSaturation},
    { "setBrightness", _wrap_ShortColor_setBrightness},
    { "setHsb", _wrap_ShortColor_setHsb},
    { "clamp", _wrap_ShortColor_clamp},
    { "invert", _wrap_ShortColor_invert},
    { "normalize", _wrap_ShortColor_normalize},
    { "lerp", _wrap_ShortColor_lerp},
    { "getClamped", _wrap_ShortColor_getClamped},
    { "getInverted", _wrap_ShortColor_getInverted},
    { "getNormalized", _wrap_ShortColor_getNormalized},
    { "getLerped", _wrap_ShortColor_getLerped},
    { "getHex", _wrap_ShortColor_getHex},
    { "getHue", _wrap_ShortColor_getHue},
    { "getHueAngle", _wrap_ShortColor_getHueAngle},
    { "getSaturation", _wrap_ShortColor_getSaturation},
    { "getBrightness", _wrap_ShortColor_getBrightness},
    { "getLightness", _wrap_ShortColor_getLightness},
    { "getHsb", _wrap_ShortColor_getHsb},
    { "__eq", _wrap_ShortColor___eq},
    { "__add", _wrap_ShortColor___add},
    { "__sub", _wrap_ShortColor___sub},
    { "__mul", _wrap_ShortColor___mul},
    { "__div", _wrap_ShortColor___div},
    { "getR", _wrap_ShortColor_getR},
    { "getG", _wrap_ShortColor_getG},
    { "getB", _wrap_ShortColor_getB},
    { "getA", _wrap_ShortColor_getA},
    { "setR", _wrap_ShortColor_setR},
    { "setG", _wrap_ShortColor_setG},
    { "setB", _wrap_ShortColor_setB},
    { "setA", _wrap_ShortColor_setA},
    { "__tostring", _wrap_ShortColor___tostring},
    {0,0}
};
static swig_lua_method swig_ShortColor_meta[] = {
    { "__eq", _wrap_ShortColor___eq},
    { "__add", _wrap_ShortColor___add},
    { "__sub", _wrap_ShortColor___sub},
    { "__mul", _wrap_ShortColor___mul},
    { "__div", _wrap_ShortColor___div},
    { "__tostring", _wrap_ShortColor___tostring},
    {0,0}
};

static swig_lua_attribute swig_ShortColor_Sf_SwigStatic_attributes[] = {
    { "white", _wrap_ShortColor_white_get, SWIG_Lua_set_immutable },
    { "gray", _wrap_ShortColor_gray_get, SWIG_Lua_set_immutable },
    { "black", _wrap_ShortColor_black_get, SWIG_Lua_set_immutable },
    { "red", _wrap_ShortColor_red_get, SWIG_Lua_set_immutable },
    { "green", _wrap_ShortColor_green_get, SWIG_Lua_set_immutable },
    { "blue", _wrap_ShortColor_blue_get, SWIG_Lua_set_immutable },
    { "cyan", _wrap_ShortColor_cyan_get, SWIG_Lua_set_immutable },
    { "magenta", _wrap_ShortColor_magenta_get, SWIG_Lua_set_immutable },
    { "yellow", _wrap_ShortColor_yellow_get, SWIG_Lua_set_immutable },
    { "aliceBlue", _wrap_ShortColor_aliceBlue_get, SWIG_Lua_set_immutable },
    { "antiqueWhite", _wrap_ShortColor_antiqueWhite_get, SWIG_Lua_set_immutable },
    { "aqua", _wrap_ShortColor_aqua_get, SWIG_Lua_set_immutable },
    { "aquamarine", _wrap_ShortColor_aquamarine_get, SWIG_Lua_set_immutable },
    { "azure", _wrap_ShortColor_azure_get, SWIG_Lua_set_immutable },
    { "beige", _wrap_ShortColor_beige_get, SWIG_Lua_set_immutable },
    { "bisque", _wrap_ShortColor_bisque_get, SWIG_Lua_set_immutable },
    { "blanchedAlmond", _wrap_ShortColor_blanchedAlmond_get, SWIG_Lua_set_immutable },
    { "blueViolet", _wrap_ShortColor_blueViolet_get, SWIG_Lua_set_immutable },
    { "brown", _wrap_ShortColor_brown_get, SWIG_Lua_set_immutable },
    { "burlyWood", _wrap_ShortColor_burlyWood_get, SWIG_Lua_set_immutable },
    { "cadetBlue", _wrap_ShortColor_cadetBlue_get, SWIG_Lua_set_immutable },
    { "chartreuse", _wrap_ShortColor_chartreuse_get, SWIG_Lua_set_immutable },
    { "chocolate", _wrap_ShortColor_chocolate_get, SWIG_Lua_set_immutable },
    { "coral", _wrap_ShortColor_coral_get, SWIG_Lua_set_immutable },
    { "cornflowerBlue", _wrap_ShortColor_cornflowerBlue_get, SWIG_Lua_set_immutable },
    { "cornsilk", _wrap_ShortColor_cornsilk_get, SWIG_Lua_set_immutable },
    { "crimson", _wrap_ShortColor_crimson_get, SWIG_Lua_set_immutable },
    { "darkBlue", _wrap_ShortColor_darkBlue_get, SWIG_Lua_set_immutable },
    { "darkCyan", _wrap_ShortColor_darkCyan_get, SWIG_Lua_set_immutable },
    { "darkGoldenRod", _wrap_ShortColor_darkGoldenRod_get, SWIG_Lua_set_immutable },
    { "darkGray", _wrap_ShortColor_darkGray_get, SWIG_Lua_set_immutable },
    { "darkGrey", _wrap_ShortColor_darkGrey_get, SWIG_Lua_set_immutable },
    { "darkGreen", _wrap_ShortColor_darkGreen_get, SWIG_Lua_set_immutable },
    { "darkKhaki", _wrap_ShortColor_darkKhaki_get, SWIG_Lua_set_immutable },
    { "darkMagenta", _wrap_ShortColor_darkMagenta_get, SWIG_Lua_set_immutable },
    { "darkOliveGreen", _wrap_ShortColor_darkOliveGreen_get, SWIG_Lua_set_immutable },
    { "darkorange", _wrap_ShortColor_darkorange_get, SWIG_Lua_set_immutable },
    { "darkOrchid", _wrap_ShortColor_darkOrchid_get, SWIG_Lua_set_immutable },
    { "darkRed", _wrap_ShortColor_darkRed_get, SWIG_Lua_set_immutable },
    { "darkSalmon", _wrap_ShortColor_darkSalmon_get, SWIG_Lua_set_immutable },
    { "darkSeaGreen", _wrap_ShortColor_darkSeaGreen_get, SWIG_Lua_set_immutable },
    { "darkSlateBlue", _wrap_ShortColor_darkSlateBlue_get, SWIG_Lua_set_immutable },
    { "darkSlateGray", _wrap_ShortColor_darkSlateGray_get, SWIG_Lua_set_immutable },
    { "darkSlateGrey", _wrap_ShortColor_darkSlateGrey_get, SWIG_Lua_set_immutable },
    { "darkTurquoise", _wrap_ShortColor_darkTurquoise_get, SWIG_Lua_set_immutable },
    { "darkViolet", _wrap_ShortColor_darkViolet_get, SWIG_Lua_set_immutable },
    { "deepPink", _wrap_ShortColor_deepPink_get, SWIG_Lua_set_immutable },
    { "deepSkyBlue", _wrap_ShortColor_deepSkyBlue_get, SWIG_Lua_set_immutable },
    { "dimGray", _wrap_ShortColor_dimGray_get, SWIG_Lua_set_immutable },
    { "dimGrey", _wrap_ShortColor_dimGrey_get, SWIG_Lua_set_immutable },
    { "dodgerBlue", _wrap_ShortColor_dodgerBlue_get, SWIG_Lua_set_immutable },
    { "fireBrick", _wrap_ShortColor_fireBrick_get, SWIG_Lua_set_immutable },
    { "floralWhite", _wrap_ShortColor_floralWhite_get, SWIG_Lua_set_immutable },
    { "forestGreen", _wrap_ShortColor_forestGreen_get, SWIG_Lua_set_immutable },
    { "fuchsia", _wrap_ShortColor_fuchsia_get, SWIG_Lua_set_immutable },
    { "gainsboro", _wrap_ShortColor_gainsboro_get, SWIG_Lua_set_immutable },
    { "ghostWhite", _wrap_ShortColor_ghostWhite_get, SWIG_Lua_set_immutable },
    { "gold", _wrap_ShortColor_gold_get, SWIG_Lua_set_immutable },
    { "goldenRod", _wrap_ShortColor_goldenRod_get, SWIG_Lua_set_immutable },
    { "grey", _wrap_ShortColor_grey_get, SWIG_Lua_set_immutable },
    { "greenYellow", _wrap_ShortColor_greenYellow_get, SWIG_Lua_set_immutable },
    { "honeyDew", _wrap_ShortColor_honeyDew_get, SWIG_Lua_set_immutable },
    { "hotPink", _wrap_ShortColor_hotPink_get, SWIG_Lua_set_immutable },
    { "indianRed", _wrap_ShortColor_indianRed_get, SWIG_Lua_set_immutable },
    { "indigo", _wrap_ShortColor_indigo_get, SWIG_Lua_set_immutable },
    { "ivory", _wrap_ShortColor_ivory_get, SWIG_Lua_set_immutable },
    { "khaki", _wrap_ShortColor_khaki_get, SWIG_Lua_set_immutable },
    { "lavender", _wrap_ShortColor_lavender_get, SWIG_Lua_set_immutable },
    { "lavenderBlush", _wrap_ShortColor_lavenderBlush_get, SWIG_Lua_set_immutable },
    { "lawnGreen", _wrap_ShortColor_lawnGreen_get, SWIG_Lua_set_immutable },
    { "lemonChiffon", _wrap_ShortColor_lemonChiffon_get, SWIG_Lua_set_immutable },
    { "lightBlue", _wrap_ShortColor_lightBlue_get, SWIG_Lua_set_immutable },
    { "lightCoral", _wrap_ShortColor_lightCoral_get, SWIG_Lua_set_immutable },
    { "lightCyan", _wrap_ShortColor_lightCyan_get, SWIG_Lua_set_immutable },
    { "lightGoldenRodYellow", _wrap_ShortColor_lightGoldenRodYellow_get, SWIG_Lua_set_immutable },
    { "lightGray", _wrap_ShortColor_lightGray_get, SWIG_Lua_set_immutable },
    { "lightGrey", _wrap_ShortColor_lightGrey_get, SWIG_Lua_set_immutable },
    { "lightGreen", _wrap_ShortColor_lightGreen_get, SWIG_Lua_set_immutable },
    { "lightPink", _wrap_ShortColor_lightPink_get, SWIG_Lua_set_immutable },
    { "lightSalmon", _wrap_ShortColor_lightSalmon_get, SWIG_Lua_set_immutable },
    { "lightSeaGreen", _wrap_ShortColor_lightSeaGreen_get, SWIG_Lua_set_immutable },
    { "lightSkyBlue", _wrap_ShortColor_lightSkyBlue_get, SWIG_Lua_set_immutable },
    { "lightSlateGray", _wrap_ShortColor_lightSlateGray_get, SWIG_Lua_set_immutable },
    { "lightSlateGrey", _wrap_ShortColor_lightSlateGrey_get, SWIG_Lua_set_immutable },
    { "lightSteelBlue", _wrap_ShortColor_lightSteelBlue_get, SWIG_Lua_set_immutable },
    { "lightYellow", _wrap_ShortColor_lightYellow_get, SWIG_Lua_set_immutable },
    { "lime", _wrap_ShortColor_lime_get, SWIG_Lua_set_immutable },
    { "limeGreen", _wrap_ShortColor_limeGreen_get, SWIG_Lua_set_immutable },
    { "linen", _wrap_ShortColor_linen_get, SWIG_Lua_set_immutable },
    { "maroon", _wrap_ShortColor_maroon_get, SWIG_Lua_set_immutable },
    { "mediumAquaMarine", _wrap_ShortColor_mediumAquaMarine_get, SWIG_Lua_set_immutable },
    { "mediumBlue", _wrap_ShortColor_mediumBlue_get, SWIG_Lua_set_immutable },
    { "mediumOrchid", _wrap_ShortColor_mediumOrchid_get, SWIG_Lua_set_immutable },
    { "mediumPurple", _wrap_ShortColor_mediumPurple_get, SWIG_Lua_set_immutable },
    { "mediumSeaGreen", _wrap_ShortColor_mediumSeaGreen_get, SWIG_Lua_set_immutable },
    { "mediumSlateBlue", _wrap_ShortColor_mediumSlateBlue_get, SWIG_Lua_set_immutable },
    { "mediumSpringGreen", _wrap_ShortColor_mediumSpringGreen_get, SWIG_Lua_set_immutable },
    { "mediumTurquoise", _wrap_ShortColor_mediumTurquoise_get, SWIG_Lua_set_immutable },
    { "mediumVioletRed", _wrap_ShortColor_mediumVioletRed_get, SWIG_Lua_set_immutable },
    { "midnightBlue", _wrap_ShortColor_midnightBlue_get, SWIG_Lua_set_immutable },
    { "mintCream", _wrap_ShortColor_mintCream_get, SWIG_Lua_set_immutable },
    { "mistyRose", _wrap_ShortColor_mistyRose_get, SWIG_Lua_set_immutable },
    { "moccasin", _wrap_ShortColor_moccasin_get, SWIG_Lua_set_immutable },
    { "navajoWhite", _wrap_ShortColor_navajoWhite_get, SWIG_Lua_set_immutable },
    { "navy", _wrap_ShortColor_navy_get, SWIG_Lua_set_immutable },
    { "oldLace", _wrap_ShortColor_oldLace_get, SWIG_Lua_set_immutable },
    { "olive", _wrap_ShortColor_olive_get, SWIG_Lua_set_immutable },
    { "oliveDrab", _wrap_ShortColor_oliveDrab_get, SWIG_Lua_set_immutable },
    { "orange", _wrap_ShortColor_orange_get, SWIG_Lua_set_immutable },
    { "orangeRed", _wrap_ShortColor_orangeRed_get, SWIG_Lua_set_immutable },
    { "orchid", _wrap_ShortColor_orchid_get, SWIG_Lua_set_immutable },
    { "paleGoldenRod", _wrap_ShortColor_paleGoldenRod_get, SWIG_Lua_set_immutable },
    { "paleGreen", _wrap_ShortColor_paleGreen_get, SWIG_Lua_set_immutable },
    { "paleTurquoise", _wrap_ShortColor_paleTurquoise_get, SWIG_Lua_set_immutable },
    { "paleVioletRed", _wrap_ShortColor_paleVioletRed_get, SWIG_Lua_set_immutable },
    { "papayaWhip", _wrap_ShortColor_papayaWhip_get, SWIG_Lua_set_immutable },
    { "peachPuff", _wrap_ShortColor_peachPuff_get, SWIG_Lua_set_immutable },
    { "peru", _wrap_ShortColor_peru_get, SWIG_Lua_set_immutable },
    { "pink", _wrap_ShortColor_pink_get, SWIG_Lua_set_immutable },
    { "plum", _wrap_ShortColor_plum_get, SWIG_Lua_set_immutable },
    { "powderBlue", _wrap_ShortColor_powderBlue_get, SWIG_Lua_set_immutable },
    { "purple", _wrap_ShortColor_purple_get, SWIG_Lua_set_immutable },
    { "rosyBrown", _wrap_ShortColor_rosyBrown_get, SWIG_Lua_set_immutable },
    { "royalBlue", _wrap_ShortColor_royalBlue_get, SWIG_Lua_set_immutable },
    { "saddleBrown", _wrap_ShortColor_saddleBrown_get, SWIG_Lua_set_immutable },
    { "salmon", _wrap_ShortColor_salmon_get, SWIG_Lua_set_immutable },
    { "sandyBrown", _wrap_ShortColor_sandyBrown_get, SWIG_Lua_set_immutable },
    { "seaGreen", _wrap_ShortColor_seaGreen_get, SWIG_Lua_set_immutable },
    { "seaShell", _wrap_ShortColor_seaShell_get, SWIG_Lua_set_immutable },
    { "sienna", _wrap_ShortColor_sienna_get, SWIG_Lua_set_immutable },
    { "silver", _wrap_ShortColor_silver_get, SWIG_Lua_set_immutable },
    { "skyBlue", _wrap_ShortColor_skyBlue_get, SWIG_Lua_set_immutable },
    { "slateBlue", _wrap_ShortColor_slateBlue_get, SWIG_Lua_set_immutable },
    { "slateGray", _wrap_ShortColor_slateGray_get, SWIG_Lua_set_immutable },
    { "slateGrey", _wrap_ShortColor_slateGrey_get, SWIG_Lua_set_immutable },
    { "snow", _wrap_ShortColor_snow_get, SWIG_Lua_set_immutable },
    { "springGreen", _wrap_ShortColor_springGreen_get, SWIG_Lua_set_immutable },
    { "steelBlue", _wrap_ShortColor_steelBlue_get, SWIG_Lua_set_immutable },
    { "blueSteel", _wrap_ShortColor_blueSteel_get, SWIG_Lua_set_immutable },
    { "tan", _wrap_ShortColor_tan_get, SWIG_Lua_set_immutable },
    { "teal", _wrap_ShortColor_teal_get, SWIG_Lua_set_immutable },
    { "thistle", _wrap_ShortColor_thistle_get, SWIG_Lua_set_immutable },
    { "tomato", _wrap_ShortColor_tomato_get, SWIG_Lua_set_immutable },
    { "turquoise", _wrap_ShortColor_turquoise_get, SWIG_Lua_set_immutable },
    { "violet", _wrap_ShortColor_violet_get, SWIG_Lua_set_immutable },
    { "wheat", _wrap_ShortColor_wheat_get, SWIG_Lua_set_immutable },
    { "whiteSmoke", _wrap_ShortColor_whiteSmoke_get, SWIG_Lua_set_immutable },
    { "yellowGreen", _wrap_ShortColor_yellowGreen_get, SWIG_Lua_set_immutable },
    {0,0,0}
};
static swig_lua_const_info swig_ShortColor_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_ShortColor_Sf_SwigStatic_methods[]= {
    { "fromHsb", _wrap_ShortColor_fromHsb},
    { "fromHex", _wrap_ShortColor_fromHex},
    { "limit", _wrap_ShortColor_limit},
    {0,0}
};
static swig_lua_class* swig_ShortColor_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_ShortColor_Sf_SwigStatic = {
    "ShortColor",
    swig_ShortColor_Sf_SwigStatic_methods,
    swig_ShortColor_Sf_SwigStatic_attributes,
    swig_ShortColor_Sf_SwigStatic_constants,
    swig_ShortColor_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_ShortColor_bases[] = {0};
static const char *swig_ShortColor_base_names[] = {0};
static swig_lua_class _wrap_class_ShortColor = { "ShortColor", "ShortColor", &SWIGTYPE_p_ofColor_T_unsigned_short_t,_proxy__wrap_new_ShortColor, swig_delete_ShortColor, swig_ShortColor_methods, swig_ShortColor_attributes, &swig_ShortColor_Sf_SwigStatic, swig_ShortColor_meta, swig_ShortColor_bases, swig_ShortColor_base_names };

static int _wrap_new_Rectangle__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofRectangle *result = 0 ;
  SWIG_check_num_args("ofRectangle::ofRectangle",0,0) result = (ofRectangle *)new ofRectangle();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofRectangle,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_Rectangle__SWIG_1(lua_State* L) { int SWIG_arg = 0; float arg1 ; float arg2 ; float arg3 ; float arg4 ;
  ofRectangle *result = 0 ; SWIG_check_num_args("ofRectangle::ofRectangle",4,4)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofRectangle::ofRectangle",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofRectangle::ofRectangle",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofRectangle::ofRectangle",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofRectangle::ofRectangle",4,"float"); arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2); arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4);
  result = (ofRectangle *)new ofRectangle(arg1,arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofRectangle,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_Rectangle__SWIG_2(lua_State* L) { int SWIG_arg = 0; glm::vec3 *arg1 = 0 ; float arg2 ; float arg3 ;
  ofRectangle *result = 0 ; SWIG_check_num_args("ofRectangle::ofRectangle",3,3)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofRectangle::ofRectangle",1,"glm::vec3 const &");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofRectangle::ofRectangle",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofRectangle::ofRectangle",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("new_Rectangle",1,SWIGTYPE_p_glm__vec3); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); result = (ofRectangle *)new ofRectangle((glm::vec3 const &)*arg1,arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofRectangle,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_Rectangle__SWIG_3(lua_State* L) { int SWIG_arg = 0; glm::vec2 *arg1 = 0 ; float arg2 ; float arg3 ;
  ofRectangle *result = 0 ; SWIG_check_num_args("ofRectangle::ofRectangle",3,3)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofRectangle::ofRectangle",1,"glm::vec2 const &");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofRectangle::ofRectangle",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofRectangle::ofRectangle",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glm__vec2,0))){
    SWIG_fail_ptr("new_Rectangle",1,SWIGTYPE_p_glm__vec2); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); result = (ofRectangle *)new ofRectangle((glm::vec2 const &)*arg1,arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofRectangle,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_Rectangle__SWIG_4(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = 0 ; ofRectangle *result = 0 ;
  SWIG_check_num_args("ofRectangle::ofRectangle",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofRectangle::ofRectangle",1,"ofRectangle const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("new_Rectangle",1,SWIGTYPE_p_ofRectangle); } 
  result = (ofRectangle *)new ofRectangle((ofRectangle const &)*arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofRectangle,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_Rectangle__SWIG_5(lua_State* L) { int SWIG_arg = 0; glm::vec3 *arg1 = 0 ; glm::vec3 *arg2 = 0 ;
  ofRectangle *result = 0 ; SWIG_check_num_args("ofRectangle::ofRectangle",2,2)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofRectangle::ofRectangle",1,"glm::vec3 const &");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofRectangle::ofRectangle",2,"glm::vec3 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("new_Rectangle",1,SWIGTYPE_p_glm__vec3); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("new_Rectangle",2,SWIGTYPE_p_glm__vec3); } 
  result = (ofRectangle *)new ofRectangle((glm::vec3 const &)*arg1,(glm::vec3 const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofRectangle,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_Rectangle__SWIG_6(lua_State* L) { int SWIG_arg = 0; glm::vec2 *arg1 = 0 ; glm::vec2 *arg2 = 0 ;
  ofRectangle *result = 0 ; SWIG_check_num_args("ofRectangle::ofRectangle",2,2)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofRectangle::ofRectangle",1,"glm::vec2 const &");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofRectangle::ofRectangle",2,"glm::vec2 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glm__vec2,0))){
    SWIG_fail_ptr("new_Rectangle",1,SWIGTYPE_p_glm__vec2); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec2,0))){
    SWIG_fail_ptr("new_Rectangle",2,SWIGTYPE_p_glm__vec2); } 
  result = (ofRectangle *)new ofRectangle((glm::vec2 const &)*arg1,(glm::vec2 const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofRectangle,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_Rectangle(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L); if (argc == 0) {
    return _wrap_new_Rectangle__SWIG_0(L);}  if (argc == 1) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { return _wrap_new_Rectangle__SWIG_4(L);}  }  if (argc == 2) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_new_Rectangle__SWIG_5(L);}  }  }  if (argc == 2) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_glm__vec2, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec2, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_new_Rectangle__SWIG_6(L);}  }  }  if (argc == 3) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_glm__vec2, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_new_Rectangle__SWIG_3(L);}  }  }  }  if (argc == 3) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_new_Rectangle__SWIG_2(L);}  }  }  }  if (argc == 4) { int _v; { _v = lua_isnumber(L,argv[0]); } 
    if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { {
            _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_new_Rectangle__SWIG_1(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_Rectangle'\n" "  Possible C/C++ prototypes are:\n"
  "    ofRectangle::ofRectangle()\n" "    ofRectangle::ofRectangle(float,float,float,float)\n"
  "    ofRectangle::ofRectangle(glm::vec3 const &,float,float)\n"
  "    ofRectangle::ofRectangle(glm::vec2 const &,float,float)\n" "    ofRectangle::ofRectangle(ofRectangle const &)\n"
  "    ofRectangle::ofRectangle(glm::vec3 const &,glm::vec3 const &)\n"
  "    ofRectangle::ofRectangle(glm::vec2 const &,glm::vec2 const &)\n"); lua_error(L);return 0; }
static int _wrap_Rectangle_set__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ; float arg2 ;
  float arg3 ; float arg4 ; float arg5 ; SWIG_check_num_args("ofRectangle::set",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::set",1,"ofRectangle *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofRectangle::set",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofRectangle::set",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofRectangle::set",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofRectangle::set",5,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_set",1,SWIGTYPE_p_ofRectangle); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); arg5 = (float)lua_tonumber(L, 5);
  (arg1)->set(arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_set__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  glm::vec3 *arg2 = 0 ; float arg3 ; float arg4 ; SWIG_check_num_args("ofRectangle::set",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::set",1,"ofRectangle *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofRectangle::set",2,"glm::vec3 const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofRectangle::set",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofRectangle::set",4,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_set",1,SWIGTYPE_p_ofRectangle); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("Rectangle_set",2,SWIGTYPE_p_glm__vec3); }  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4); (arg1)->set((glm::vec3 const &)*arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_set__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  glm::vec2 *arg2 = 0 ; float arg3 ; float arg4 ; SWIG_check_num_args("ofRectangle::set",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::set",1,"ofRectangle *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofRectangle::set",2,"glm::vec2 const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofRectangle::set",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofRectangle::set",4,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_set",1,SWIGTYPE_p_ofRectangle); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec2,0))){
    SWIG_fail_ptr("Rectangle_set",2,SWIGTYPE_p_glm__vec2); }  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4); (arg1)->set((glm::vec2 const &)*arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_set__SWIG_3(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  ofRectangle *arg2 = 0 ; SWIG_check_num_args("ofRectangle::set",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::set",1,"ofRectangle *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofRectangle::set",2,"ofRectangle const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_set",1,SWIGTYPE_p_ofRectangle); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_set",2,SWIGTYPE_p_ofRectangle); }  (arg1)->set((ofRectangle const &)*arg2); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_set__SWIG_4(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  glm::vec3 *arg2 = 0 ; glm::vec3 *arg3 = 0 ; SWIG_check_num_args("ofRectangle::set",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::set",1,"ofRectangle *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofRectangle::set",2,"glm::vec3 const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofRectangle::set",3,"glm::vec3 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_set",1,SWIGTYPE_p_ofRectangle); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("Rectangle_set",2,SWIGTYPE_p_glm__vec3); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("Rectangle_set",3,SWIGTYPE_p_glm__vec3); }  (arg1)->set((glm::vec3 const &)*arg2,(glm::vec3 const &)*arg3);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_set__SWIG_5(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  glm::vec2 *arg2 = 0 ; glm::vec2 *arg3 = 0 ; SWIG_check_num_args("ofRectangle::set",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::set",1,"ofRectangle *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofRectangle::set",2,"glm::vec2 const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofRectangle::set",3,"glm::vec2 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_set",1,SWIGTYPE_p_ofRectangle); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec2,0))){
    SWIG_fail_ptr("Rectangle_set",2,SWIGTYPE_p_glm__vec2); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_glm__vec2,0))){
    SWIG_fail_ptr("Rectangle_set",3,SWIGTYPE_p_glm__vec2); }  (arg1)->set((glm::vec2 const &)*arg2,(glm::vec2 const &)*arg3);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_set(lua_State* L) { int argc; int argv[6]={ 1,2,3,4,5,6} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Rectangle_set__SWIG_3(L);}  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
           else { _v = 1; }  }  if (_v) { return _wrap_Rectangle_set__SWIG_4(L);}  }  }  }  if (argc == 3) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec2, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_glm__vec2, 0)) { _v = 0; }
           else { _v = 1; }  }  if (_v) { return _wrap_Rectangle_set__SWIG_5(L);}  }  }  }  if (argc == 4) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec2, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); } 
          if (_v) { return _wrap_Rectangle_set__SWIG_2(L);}  }  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); } 
          if (_v) { return _wrap_Rectangle_set__SWIG_1(L);}  }  }  }  }  if (argc == 5) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) {
              return _wrap_Rectangle_set__SWIG_0(L);}  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Rectangle_set'\n" "  Possible C/C++ prototypes are:\n"
  "    ofRectangle::set(float,float,float,float)\n" "    ofRectangle::set(glm::vec3 const &,float,float)\n"
  "    ofRectangle::set(glm::vec2 const &,float,float)\n" "    ofRectangle::set(ofRectangle const &)\n"
  "    ofRectangle::set(glm::vec3 const &,glm::vec3 const &)\n" "    ofRectangle::set(glm::vec2 const &,glm::vec2 const &)\n");
  lua_error(L);return 0; }
static int _wrap_Rectangle_setX(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ; float arg2 ;
  SWIG_check_num_args("ofRectangle::setX",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::setX",1,"ofRectangle *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofRectangle::setX",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_setX",1,SWIGTYPE_p_ofRectangle); }  arg2 = (float)lua_tonumber(L, 2); (arg1)->setX(arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_setY(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ; float arg2 ;
  SWIG_check_num_args("ofRectangle::setY",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::setY",1,"ofRectangle *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofRectangle::setY",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_setY",1,SWIGTYPE_p_ofRectangle); }  arg2 = (float)lua_tonumber(L, 2); (arg1)->setY(arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_setWidth(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ; float arg2 ;
  SWIG_check_num_args("ofRectangle::setWidth",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::setWidth",1,"ofRectangle *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofRectangle::setWidth",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_setWidth",1,SWIGTYPE_p_ofRectangle); }  arg2 = (float)lua_tonumber(L, 2); (arg1)->setWidth(arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_setHeight(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ; float arg2 ;
  SWIG_check_num_args("ofRectangle::setHeight",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::setHeight",1,"ofRectangle *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofRectangle::setHeight",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_setHeight",1,SWIGTYPE_p_ofRectangle); }  arg2 = (float)lua_tonumber(L, 2); (arg1)->setHeight(arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_setPosition__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  float arg2 ; float arg3 ; SWIG_check_num_args("ofRectangle::setPosition",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::setPosition",1,"ofRectangle *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofRectangle::setPosition",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofRectangle::setPosition",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_setPosition",1,SWIGTYPE_p_ofRectangle); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); (arg1)->setPosition(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Rectangle_setPosition__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  glm::vec3 *arg2 = 0 ; SWIG_check_num_args("ofRectangle::setPosition",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::setPosition",1,"ofRectangle *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofRectangle::setPosition",2,"glm::vec3 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_setPosition",1,SWIGTYPE_p_ofRectangle); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("Rectangle_setPosition",2,SWIGTYPE_p_glm__vec3); }  (arg1)->setPosition((glm::vec3 const &)*arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_setPosition(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Rectangle_setPosition__SWIG_1(L);}  }  }  if (argc == 3) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { return _wrap_Rectangle_setPosition__SWIG_0(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Rectangle_setPosition'\n"
  "  Possible C/C++ prototypes are:\n" "    ofRectangle::setPosition(float,float)\n"
  "    ofRectangle::setPosition(glm::vec3 const &)\n"); lua_error(L);return 0; }
static int _wrap_Rectangle_setSize(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ; float arg2 ;
  float arg3 ; SWIG_check_num_args("ofRectangle::setSize",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::setSize",1,"ofRectangle *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofRectangle::setSize",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofRectangle::setSize",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_setSize",1,SWIGTYPE_p_ofRectangle); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); (arg1)->setSize(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Rectangle_setFromCenter__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  float arg2 ; float arg3 ; float arg4 ; float arg5 ; SWIG_check_num_args("ofRectangle::setFromCenter",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::setFromCenter",1,"ofRectangle *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofRectangle::setFromCenter",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofRectangle::setFromCenter",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofRectangle::setFromCenter",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofRectangle::setFromCenter",5,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_setFromCenter",1,SWIGTYPE_p_ofRectangle); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); arg5 = (float)lua_tonumber(L, 5);
  (arg1)->setFromCenter(arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_setFromCenter__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  glm::vec3 *arg2 = 0 ; float arg3 ; float arg4 ; SWIG_check_num_args("ofRectangle::setFromCenter",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::setFromCenter",1,"ofRectangle *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofRectangle::setFromCenter",2,"glm::vec3 const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofRectangle::setFromCenter",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofRectangle::setFromCenter",4,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_setFromCenter",1,SWIGTYPE_p_ofRectangle); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("Rectangle_setFromCenter",2,SWIGTYPE_p_glm__vec3); }  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4); (arg1)->setFromCenter((glm::vec3 const &)*arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_setFromCenter__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  glm::vec2 *arg2 = 0 ; float arg3 ; float arg4 ; SWIG_check_num_args("ofRectangle::setFromCenter",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::setFromCenter",1,"ofRectangle *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofRectangle::setFromCenter",2,"glm::vec2 const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofRectangle::setFromCenter",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofRectangle::setFromCenter",4,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_setFromCenter",1,SWIGTYPE_p_ofRectangle); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec2,0))){
    SWIG_fail_ptr("Rectangle_setFromCenter",2,SWIGTYPE_p_glm__vec2); }  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4); (arg1)->setFromCenter((glm::vec2 const &)*arg2,arg3,arg4); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_setFromCenter(lua_State* L) { int argc; int argv[6]={ 1,2,3,4,5,6} ; argc = lua_gettop(L);
  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); } 
          if (_v) { return _wrap_Rectangle_setFromCenter__SWIG_1(L);}  }  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec2, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); } 
          if (_v) { return _wrap_Rectangle_setFromCenter__SWIG_2(L);}  }  }  }  }  if (argc == 5) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) {
              return _wrap_Rectangle_setFromCenter__SWIG_0(L);}  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Rectangle_setFromCenter'\n"
  "  Possible C/C++ prototypes are:\n" "    ofRectangle::setFromCenter(float,float,float,float)\n"
  "    ofRectangle::setFromCenter(glm::vec3 const &,float,float)\n"
  "    ofRectangle::setFromCenter(glm::vec2 const &,float,float)\n"); lua_error(L);return 0; }
static int _wrap_Rectangle_translate__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  float arg2 ; float arg3 ; SWIG_check_num_args("ofRectangle::translate",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::translate",1,"ofRectangle *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofRectangle::translate",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofRectangle::translate",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_translate",1,SWIGTYPE_p_ofRectangle); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); (arg1)->translate(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Rectangle_translate__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  glm::vec3 *arg2 = 0 ; SWIG_check_num_args("ofRectangle::translate",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::translate",1,"ofRectangle *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofRectangle::translate",2,"glm::vec3 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_translate",1,SWIGTYPE_p_ofRectangle); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("Rectangle_translate",2,SWIGTYPE_p_glm__vec3); }  (arg1)->translate((glm::vec3 const &)*arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_translate__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  glm::vec2 *arg2 = 0 ; SWIG_check_num_args("ofRectangle::translate",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::translate",1,"ofRectangle *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofRectangle::translate",2,"glm::vec2 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_translate",1,SWIGTYPE_p_ofRectangle); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec2,0))){
    SWIG_fail_ptr("Rectangle_translate",2,SWIGTYPE_p_glm__vec2); }  (arg1)->translate((glm::vec2 const &)*arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_translate(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Rectangle_translate__SWIG_1(L);}  }  }  if (argc == 2) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec2, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Rectangle_translate__SWIG_2(L);}  }  }  if (argc == 3) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { return _wrap_Rectangle_translate__SWIG_0(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Rectangle_translate'\n"
  "  Possible C/C++ prototypes are:\n" "    ofRectangle::translate(float,float)\n"
  "    ofRectangle::translate(glm::vec3 const &)\n" "    ofRectangle::translate(glm::vec2 const &)\n"); lua_error(L);return 0; }
static int _wrap_Rectangle_translateX(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ; float arg2 ;
  SWIG_check_num_args("ofRectangle::translateX",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::translateX",1,"ofRectangle *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofRectangle::translateX",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_translateX",1,SWIGTYPE_p_ofRectangle); }  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->translateX(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_translateY(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ; float arg2 ;
  SWIG_check_num_args("ofRectangle::translateY",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::translateY",1,"ofRectangle *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofRectangle::translateY",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_translateY",1,SWIGTYPE_p_ofRectangle); }  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->translateY(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_scale__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ; float arg2 ;
  SWIG_check_num_args("ofRectangle::scale",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::scale",1,"ofRectangle *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofRectangle::scale",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_scale",1,SWIGTYPE_p_ofRectangle); }  arg2 = (float)lua_tonumber(L, 2); (arg1)->scale(arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_scale__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ; float arg2 ;
  float arg3 ; SWIG_check_num_args("ofRectangle::scale",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::scale",1,"ofRectangle *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofRectangle::scale",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofRectangle::scale",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_scale",1,SWIGTYPE_p_ofRectangle); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); (arg1)->scale(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Rectangle_scale__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  glm::vec3 *arg2 = 0 ; SWIG_check_num_args("ofRectangle::scale",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::scale",1,"ofRectangle *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofRectangle::scale",2,"glm::vec3 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_scale",1,SWIGTYPE_p_ofRectangle); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("Rectangle_scale",2,SWIGTYPE_p_glm__vec3); }  (arg1)->scale((glm::vec3 const &)*arg2); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_scale__SWIG_3(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  glm::vec2 *arg2 = 0 ; SWIG_check_num_args("ofRectangle::scale",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::scale",1,"ofRectangle *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofRectangle::scale",2,"glm::vec2 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_scale",1,SWIGTYPE_p_ofRectangle); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec2,0))){
    SWIG_fail_ptr("Rectangle_scale",2,SWIGTYPE_p_glm__vec2); }  (arg1)->scale((glm::vec2 const &)*arg2); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_scale(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Rectangle_scale__SWIG_2(L);}  }  }  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec2, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Rectangle_scale__SWIG_3(L);}  }  }  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { return _wrap_Rectangle_scale__SWIG_0(L);}  }
     }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_Rectangle_scale__SWIG_1(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Rectangle_scale'\n" "  Possible C/C++ prototypes are:\n"
  "    ofRectangle::scale(float)\n" "    ofRectangle::scale(float,float)\n" "    ofRectangle::scale(glm::vec3 const &)\n"
  "    ofRectangle::scale(glm::vec2 const &)\n"); lua_error(L);return 0; }
static int _wrap_Rectangle_scaleWidth(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ; float arg2 ;
  SWIG_check_num_args("ofRectangle::scaleWidth",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::scaleWidth",1,"ofRectangle *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofRectangle::scaleWidth",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_scaleWidth",1,SWIGTYPE_p_ofRectangle); }  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->scaleWidth(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_scaleHeight(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ; float arg2 ;
  SWIG_check_num_args("ofRectangle::scaleHeight",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::scaleHeight",1,"ofRectangle *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofRectangle::scaleHeight",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_scaleHeight",1,SWIGTYPE_p_ofRectangle); }  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->scaleHeight(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_scaleFromCenter__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  float arg2 ; SWIG_check_num_args("ofRectangle::scaleFromCenter",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::scaleFromCenter",1,"ofRectangle *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofRectangle::scaleFromCenter",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_scaleFromCenter",1,SWIGTYPE_p_ofRectangle); }  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->scaleFromCenter(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_scaleFromCenter__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  float arg2 ; float arg3 ; SWIG_check_num_args("ofRectangle::scaleFromCenter",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::scaleFromCenter",1,"ofRectangle *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofRectangle::scaleFromCenter",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofRectangle::scaleFromCenter",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_scaleFromCenter",1,SWIGTYPE_p_ofRectangle); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); (arg1)->scaleFromCenter(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Rectangle_scaleFromCenter__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  glm::vec3 *arg2 = 0 ; SWIG_check_num_args("ofRectangle::scaleFromCenter",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::scaleFromCenter",1,"ofRectangle *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofRectangle::scaleFromCenter",2,"glm::vec3 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_scaleFromCenter",1,SWIGTYPE_p_ofRectangle); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("Rectangle_scaleFromCenter",2,SWIGTYPE_p_glm__vec3); }  (arg1)->scaleFromCenter((glm::vec3 const &)*arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_scaleFromCenter__SWIG_3(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  glm::vec2 *arg2 = 0 ; SWIG_check_num_args("ofRectangle::scaleFromCenter",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::scaleFromCenter",1,"ofRectangle *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofRectangle::scaleFromCenter",2,"glm::vec2 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_scaleFromCenter",1,SWIGTYPE_p_ofRectangle); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec2,0))){
    SWIG_fail_ptr("Rectangle_scaleFromCenter",2,SWIGTYPE_p_glm__vec2); }  (arg1)->scaleFromCenter((glm::vec2 const &)*arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_scaleFromCenter(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L);
  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Rectangle_scaleFromCenter__SWIG_2(L);}  }  }  if (argc == 2) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec2, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Rectangle_scaleFromCenter__SWIG_3(L);}  }  }  if (argc == 2) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_Rectangle_scaleFromCenter__SWIG_0(L);}  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_Rectangle_scaleFromCenter__SWIG_1(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Rectangle_scaleFromCenter'\n"
  "  Possible C/C++ prototypes are:\n" "    ofRectangle::scaleFromCenter(float)\n"
  "    ofRectangle::scaleFromCenter(float,float)\n" "    ofRectangle::scaleFromCenter(glm::vec3 const &)\n"
  "    ofRectangle::scaleFromCenter(glm::vec2 const &)\n"); lua_error(L);return 0; }
static int _wrap_Rectangle_scaleToScaleMode(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  ofRectangle *arg2 = 0 ; ofScaleMode arg3 ; SWIG_check_num_args("ofRectangle::scaleTo",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::scaleTo",1,"ofRectangle *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofRectangle::scaleTo",2,"ofRectangle const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofRectangle::scaleTo",3,"ofScaleMode");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_scaleToScaleMode",1,SWIGTYPE_p_ofRectangle); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_scaleToScaleMode",2,SWIGTYPE_p_ofRectangle); }  arg3 = (ofScaleMode)(int)lua_tonumber(L, 3);
  (arg1)->scaleTo((ofRectangle const &)*arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_scaleTo__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  ofRectangle *arg2 = 0 ; SWIG_check_num_args("ofRectangle::scaleTo",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::scaleTo",1,"ofRectangle *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofRectangle::scaleTo",2,"ofRectangle const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_scaleTo",1,SWIGTYPE_p_ofRectangle); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_scaleTo",2,SWIGTYPE_p_ofRectangle); }  (arg1)->scaleTo((ofRectangle const &)*arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_scaleTo__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  ofRectangle *arg2 = 0 ; ofAspectRatioMode arg3 ; ofAlignHorz arg4 ; ofAlignVert arg5 ;
  SWIG_check_num_args("ofRectangle::scaleTo",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::scaleTo",1,"ofRectangle *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofRectangle::scaleTo",2,"ofRectangle const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofRectangle::scaleTo",3,"ofAspectRatioMode");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofRectangle::scaleTo",4,"ofAlignHorz");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofRectangle::scaleTo",5,"ofAlignVert");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_scaleTo",1,SWIGTYPE_p_ofRectangle); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_scaleTo",2,SWIGTYPE_p_ofRectangle); }  arg3 = (ofAspectRatioMode)(int)lua_tonumber(L, 3);
  arg4 = (ofAlignHorz)(int)lua_tonumber(L, 4); arg5 = (ofAlignVert)(int)lua_tonumber(L, 5);
  (arg1)->scaleTo((ofRectangle const &)*arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Rectangle_scaleTo__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  ofRectangle *arg2 = 0 ; ofAspectRatioMode arg3 ; ofAlignHorz arg4 ; SWIG_check_num_args("ofRectangle::scaleTo",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::scaleTo",1,"ofRectangle *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofRectangle::scaleTo",2,"ofRectangle const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofRectangle::scaleTo",3,"ofAspectRatioMode");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofRectangle::scaleTo",4,"ofAlignHorz");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_scaleTo",1,SWIGTYPE_p_ofRectangle); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_scaleTo",2,SWIGTYPE_p_ofRectangle); }  arg3 = (ofAspectRatioMode)(int)lua_tonumber(L, 3);
  arg4 = (ofAlignHorz)(int)lua_tonumber(L, 4); (arg1)->scaleTo((ofRectangle const &)*arg2,arg3,arg4); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_scaleToAspectRatio(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  ofRectangle *arg2 = 0 ; ofAspectRatioMode arg3 ; SWIG_check_num_args("ofRectangle::scaleTo",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::scaleTo",1,"ofRectangle *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofRectangle::scaleTo",2,"ofRectangle const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofRectangle::scaleTo",3,"ofAspectRatioMode");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_scaleToAspectRatio",1,SWIGTYPE_p_ofRectangle); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_scaleToAspectRatio",2,SWIGTYPE_p_ofRectangle); } 
  arg3 = (ofAspectRatioMode)(int)lua_tonumber(L, 3); (arg1)->scaleTo((ofRectangle const &)*arg2,arg3); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_scaleTo__SWIG_3(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  ofRectangle *arg2 = 0 ; ofAspectRatioMode arg3 ; ofAlignHorz arg4 ; ofAlignVert arg5 ; ofAlignHorz arg6 ; ofAlignVert arg7 ;
  SWIG_check_num_args("ofRectangle::scaleTo",7,7)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::scaleTo",1,"ofRectangle *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofRectangle::scaleTo",2,"ofRectangle const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofRectangle::scaleTo",3,"ofAspectRatioMode");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofRectangle::scaleTo",4,"ofAlignHorz");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofRectangle::scaleTo",5,"ofAlignVert");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofRectangle::scaleTo",6,"ofAlignHorz");
  if(!lua_isnumber(L,7)) SWIG_fail_arg("ofRectangle::scaleTo",7,"ofAlignVert");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_scaleTo",1,SWIGTYPE_p_ofRectangle); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_scaleTo",2,SWIGTYPE_p_ofRectangle); }  arg3 = (ofAspectRatioMode)(int)lua_tonumber(L, 3);
  arg4 = (ofAlignHorz)(int)lua_tonumber(L, 4); arg5 = (ofAlignVert)(int)lua_tonumber(L, 5);
  arg6 = (ofAlignHorz)(int)lua_tonumber(L, 6); arg7 = (ofAlignVert)(int)lua_tonumber(L, 7);
  (arg1)->scaleTo((ofRectangle const &)*arg2,arg3,arg4,arg5,arg6,arg7); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Rectangle_scaleTo(lua_State* L) { int argc; int argv[8]={ 1,2,3,4,5,6,7,8} ; argc = lua_gettop(L);
  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Rectangle_scaleTo__SWIG_0(L);}  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); } 
          if (_v) { return _wrap_Rectangle_scaleTo__SWIG_2(L);}  }  }  }  }  if (argc == 5) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); } 
          if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) { return _wrap_Rectangle_scaleTo__SWIG_1(L);}  }  }  }  }  } 
  if (argc == 7) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); } 
          if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) { { _v = lua_isnumber(L,argv[5]); }  if (_v) { {
                  _v = lua_isnumber(L,argv[6]); }  if (_v) { return _wrap_Rectangle_scaleTo__SWIG_3(L);}  }  }  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Rectangle_scaleTo'\n" "  Possible C/C++ prototypes are:\n"
  "    ofRectangle::scaleTo(ofRectangle const &)\n"
  "    ofRectangle::scaleTo(ofRectangle const &,ofAspectRatioMode,ofAlignHorz,ofAlignVert)\n"
  "    ofRectangle::scaleTo(ofRectangle const &,ofAspectRatioMode,ofAlignHorz)\n"
  "    ofRectangle::scaleTo(ofRectangle const &,ofAspectRatioMode,ofAlignHorz,ofAlignVert,ofAlignHorz,ofAlignVert)\n");
  lua_error(L);return 0; }
static int _wrap_Rectangle_alignToHorz__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  float *arg2 = 0 ; ofAlignHorz arg3 ; float temp2 ; SWIG_check_num_args("ofRectangle::alignToHorz",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::alignToHorz",1,"ofRectangle *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofRectangle::alignToHorz",2,"float const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofRectangle::alignToHorz",3,"ofAlignHorz");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_alignToHorz",1,SWIGTYPE_p_ofRectangle); }  temp2=(float)lua_tonumber(L,2); arg2=&temp2;
  arg3 = (ofAlignHorz)(int)lua_tonumber(L, 3); (arg1)->alignToHorz((float const &)*arg2,arg3); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_alignToHorz__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  float *arg2 = 0 ; float temp2 ; SWIG_check_num_args("ofRectangle::alignToHorz",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::alignToHorz",1,"ofRectangle *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofRectangle::alignToHorz",2,"float const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_alignToHorz",1,SWIGTYPE_p_ofRectangle); }  temp2=(float)lua_tonumber(L,2); arg2=&temp2;
  (arg1)->alignToHorz((float const &)*arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_alignToHorz__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  ofRectangle *arg2 = 0 ; ofAlignHorz arg3 ; SWIG_check_num_args("ofRectangle::alignToHorz",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::alignToHorz",1,"ofRectangle *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofRectangle::alignToHorz",2,"ofRectangle const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofRectangle::alignToHorz",3,"ofAlignHorz");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_alignToHorz",1,SWIGTYPE_p_ofRectangle); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_alignToHorz",2,SWIGTYPE_p_ofRectangle); }  arg3 = (ofAlignHorz)(int)lua_tonumber(L, 3);
  (arg1)->alignToHorz((ofRectangle const &)*arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_alignToHorz__SWIG_3(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  ofRectangle *arg2 = 0 ; SWIG_check_num_args("ofRectangle::alignToHorz",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::alignToHorz",1,"ofRectangle *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofRectangle::alignToHorz",2,"ofRectangle const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_alignToHorz",1,SWIGTYPE_p_ofRectangle); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_alignToHorz",2,SWIGTYPE_p_ofRectangle); }  (arg1)->alignToHorz((ofRectangle const &)*arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_alignToHorz__SWIG_4(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  ofRectangle *arg2 = 0 ; ofAlignHorz arg3 ; ofAlignHorz arg4 ; SWIG_check_num_args("ofRectangle::alignToHorz",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::alignToHorz",1,"ofRectangle *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofRectangle::alignToHorz",2,"ofRectangle const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofRectangle::alignToHorz",3,"ofAlignHorz");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofRectangle::alignToHorz",4,"ofAlignHorz");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_alignToHorz",1,SWIGTYPE_p_ofRectangle); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_alignToHorz",2,SWIGTYPE_p_ofRectangle); }  arg3 = (ofAlignHorz)(int)lua_tonumber(L, 3);
  arg4 = (ofAlignHorz)(int)lua_tonumber(L, 4); (arg1)->alignToHorz((ofRectangle const &)*arg2,arg3,arg4); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_alignToHorz(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L);
  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Rectangle_alignToHorz__SWIG_3(L);}  }  }  if (argc == 2) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_Rectangle_alignToHorz__SWIG_1(L);}  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_Rectangle_alignToHorz__SWIG_2(L);}  }  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_Rectangle_alignToHorz__SWIG_0(L);}  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); } 
          if (_v) { return _wrap_Rectangle_alignToHorz__SWIG_4(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Rectangle_alignToHorz'\n"
  "  Possible C/C++ prototypes are:\n" "    ofRectangle::alignToHorz(float const &,ofAlignHorz)\n"
  "    ofRectangle::alignToHorz(float const &)\n" "    ofRectangle::alignToHorz(ofRectangle const &,ofAlignHorz)\n"
  "    ofRectangle::alignToHorz(ofRectangle const &)\n"
  "    ofRectangle::alignToHorz(ofRectangle const &,ofAlignHorz,ofAlignHorz)\n"); lua_error(L);return 0; }
static int _wrap_Rectangle_alignToVert__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  float *arg2 = 0 ; ofAlignVert arg3 ; float temp2 ; SWIG_check_num_args("ofRectangle::alignToVert",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::alignToVert",1,"ofRectangle *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofRectangle::alignToVert",2,"float const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofRectangle::alignToVert",3,"ofAlignVert");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_alignToVert",1,SWIGTYPE_p_ofRectangle); }  temp2=(float)lua_tonumber(L,2); arg2=&temp2;
  arg3 = (ofAlignVert)(int)lua_tonumber(L, 3); (arg1)->alignToVert((float const &)*arg2,arg3); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_alignToVert__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  float *arg2 = 0 ; float temp2 ; SWIG_check_num_args("ofRectangle::alignToVert",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::alignToVert",1,"ofRectangle *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofRectangle::alignToVert",2,"float const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_alignToVert",1,SWIGTYPE_p_ofRectangle); }  temp2=(float)lua_tonumber(L,2); arg2=&temp2;
  (arg1)->alignToVert((float const &)*arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_alignToVert__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  ofRectangle *arg2 = 0 ; ofAlignVert arg3 ; SWIG_check_num_args("ofRectangle::alignToVert",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::alignToVert",1,"ofRectangle *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofRectangle::alignToVert",2,"ofRectangle const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofRectangle::alignToVert",3,"ofAlignVert");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_alignToVert",1,SWIGTYPE_p_ofRectangle); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_alignToVert",2,SWIGTYPE_p_ofRectangle); }  arg3 = (ofAlignVert)(int)lua_tonumber(L, 3);
  (arg1)->alignToVert((ofRectangle const &)*arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_alignToVert__SWIG_3(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  ofRectangle *arg2 = 0 ; SWIG_check_num_args("ofRectangle::alignToVert",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::alignToVert",1,"ofRectangle *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofRectangle::alignToVert",2,"ofRectangle const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_alignToVert",1,SWIGTYPE_p_ofRectangle); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_alignToVert",2,SWIGTYPE_p_ofRectangle); }  (arg1)->alignToVert((ofRectangle const &)*arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_alignToVert__SWIG_4(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  ofRectangle *arg2 = 0 ; ofAlignVert arg3 ; ofAlignVert arg4 ; SWIG_check_num_args("ofRectangle::alignToVert",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::alignToVert",1,"ofRectangle *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofRectangle::alignToVert",2,"ofRectangle const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofRectangle::alignToVert",3,"ofAlignVert");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofRectangle::alignToVert",4,"ofAlignVert");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_alignToVert",1,SWIGTYPE_p_ofRectangle); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_alignToVert",2,SWIGTYPE_p_ofRectangle); }  arg3 = (ofAlignVert)(int)lua_tonumber(L, 3);
  arg4 = (ofAlignVert)(int)lua_tonumber(L, 4); (arg1)->alignToVert((ofRectangle const &)*arg2,arg3,arg4); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_alignToVert(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L);
  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Rectangle_alignToVert__SWIG_3(L);}  }  }  if (argc == 2) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_Rectangle_alignToVert__SWIG_1(L);}  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_Rectangle_alignToVert__SWIG_2(L);}  }  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_Rectangle_alignToVert__SWIG_0(L);}  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); } 
          if (_v) { return _wrap_Rectangle_alignToVert__SWIG_4(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Rectangle_alignToVert'\n"
  "  Possible C/C++ prototypes are:\n" "    ofRectangle::alignToVert(float const &,ofAlignVert)\n"
  "    ofRectangle::alignToVert(float const &)\n" "    ofRectangle::alignToVert(ofRectangle const &,ofAlignVert)\n"
  "    ofRectangle::alignToVert(ofRectangle const &)\n"
  "    ofRectangle::alignToVert(ofRectangle const &,ofAlignVert,ofAlignVert)\n"); lua_error(L);return 0; }
static int _wrap_Rectangle_alignTo__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  glm::vec3 *arg2 = 0 ; ofAlignHorz arg3 ; ofAlignVert arg4 ; SWIG_check_num_args("ofRectangle::alignTo",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::alignTo",1,"ofRectangle *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofRectangle::alignTo",2,"glm::vec3 const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofRectangle::alignTo",3,"ofAlignHorz");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofRectangle::alignTo",4,"ofAlignVert");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_alignTo",1,SWIGTYPE_p_ofRectangle); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("Rectangle_alignTo",2,SWIGTYPE_p_glm__vec3); }  arg3 = (ofAlignHorz)(int)lua_tonumber(L, 3);
  arg4 = (ofAlignVert)(int)lua_tonumber(L, 4); (arg1)->alignTo((glm::vec3 const &)*arg2,arg3,arg4); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_alignTo__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  glm::vec3 *arg2 = 0 ; ofAlignHorz arg3 ; SWIG_check_num_args("ofRectangle::alignTo",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::alignTo",1,"ofRectangle *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofRectangle::alignTo",2,"glm::vec3 const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofRectangle::alignTo",3,"ofAlignHorz");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_alignTo",1,SWIGTYPE_p_ofRectangle); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("Rectangle_alignTo",2,SWIGTYPE_p_glm__vec3); }  arg3 = (ofAlignHorz)(int)lua_tonumber(L, 3);
  (arg1)->alignTo((glm::vec3 const &)*arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_alignTo__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  glm::vec3 *arg2 = 0 ; SWIG_check_num_args("ofRectangle::alignTo",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::alignTo",1,"ofRectangle *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofRectangle::alignTo",2,"glm::vec3 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_alignTo",1,SWIGTYPE_p_ofRectangle); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("Rectangle_alignTo",2,SWIGTYPE_p_glm__vec3); }  (arg1)->alignTo((glm::vec3 const &)*arg2); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_alignTo__SWIG_3(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  glm::vec2 *arg2 = 0 ; ofAlignHorz arg3 ; ofAlignVert arg4 ; SWIG_check_num_args("ofRectangle::alignTo",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::alignTo",1,"ofRectangle *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofRectangle::alignTo",2,"glm::vec2 const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofRectangle::alignTo",3,"ofAlignHorz");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofRectangle::alignTo",4,"ofAlignVert");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_alignTo",1,SWIGTYPE_p_ofRectangle); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec2,0))){
    SWIG_fail_ptr("Rectangle_alignTo",2,SWIGTYPE_p_glm__vec2); }  arg3 = (ofAlignHorz)(int)lua_tonumber(L, 3);
  arg4 = (ofAlignVert)(int)lua_tonumber(L, 4); (arg1)->alignTo((glm::vec2 const &)*arg2,arg3,arg4); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_alignTo__SWIG_4(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  glm::vec2 *arg2 = 0 ; ofAlignHorz arg3 ; SWIG_check_num_args("ofRectangle::alignTo",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::alignTo",1,"ofRectangle *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofRectangle::alignTo",2,"glm::vec2 const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofRectangle::alignTo",3,"ofAlignHorz");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_alignTo",1,SWIGTYPE_p_ofRectangle); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec2,0))){
    SWIG_fail_ptr("Rectangle_alignTo",2,SWIGTYPE_p_glm__vec2); }  arg3 = (ofAlignHorz)(int)lua_tonumber(L, 3);
  (arg1)->alignTo((glm::vec2 const &)*arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_alignTo__SWIG_5(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  glm::vec2 *arg2 = 0 ; SWIG_check_num_args("ofRectangle::alignTo",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::alignTo",1,"ofRectangle *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofRectangle::alignTo",2,"glm::vec2 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_alignTo",1,SWIGTYPE_p_ofRectangle); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec2,0))){
    SWIG_fail_ptr("Rectangle_alignTo",2,SWIGTYPE_p_glm__vec2); }  (arg1)->alignTo((glm::vec2 const &)*arg2); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_alignTo__SWIG_6(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  ofRectangle *arg2 = 0 ; ofAlignHorz arg3 ; ofAlignVert arg4 ; SWIG_check_num_args("ofRectangle::alignTo",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::alignTo",1,"ofRectangle *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofRectangle::alignTo",2,"ofRectangle const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofRectangle::alignTo",3,"ofAlignHorz");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofRectangle::alignTo",4,"ofAlignVert");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_alignTo",1,SWIGTYPE_p_ofRectangle); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_alignTo",2,SWIGTYPE_p_ofRectangle); }  arg3 = (ofAlignHorz)(int)lua_tonumber(L, 3);
  arg4 = (ofAlignVert)(int)lua_tonumber(L, 4); (arg1)->alignTo((ofRectangle const &)*arg2,arg3,arg4); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_alignTo__SWIG_7(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  ofRectangle *arg2 = 0 ; ofAlignHorz arg3 ; SWIG_check_num_args("ofRectangle::alignTo",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::alignTo",1,"ofRectangle *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofRectangle::alignTo",2,"ofRectangle const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofRectangle::alignTo",3,"ofAlignHorz");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_alignTo",1,SWIGTYPE_p_ofRectangle); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_alignTo",2,SWIGTYPE_p_ofRectangle); }  arg3 = (ofAlignHorz)(int)lua_tonumber(L, 3);
  (arg1)->alignTo((ofRectangle const &)*arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_alignTo__SWIG_8(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  ofRectangle *arg2 = 0 ; SWIG_check_num_args("ofRectangle::alignTo",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::alignTo",1,"ofRectangle *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofRectangle::alignTo",2,"ofRectangle const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_alignTo",1,SWIGTYPE_p_ofRectangle); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_alignTo",2,SWIGTYPE_p_ofRectangle); }  (arg1)->alignTo((ofRectangle const &)*arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_alignTo__SWIG_9(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  ofRectangle *arg2 = 0 ; ofAlignHorz arg3 ; ofAlignVert arg4 ; ofAlignHorz arg5 ; ofAlignVert arg6 ;
  SWIG_check_num_args("ofRectangle::alignTo",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::alignTo",1,"ofRectangle *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofRectangle::alignTo",2,"ofRectangle const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofRectangle::alignTo",3,"ofAlignHorz");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofRectangle::alignTo",4,"ofAlignVert");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofRectangle::alignTo",5,"ofAlignHorz");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ofRectangle::alignTo",6,"ofAlignVert");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_alignTo",1,SWIGTYPE_p_ofRectangle); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_alignTo",2,SWIGTYPE_p_ofRectangle); }  arg3 = (ofAlignHorz)(int)lua_tonumber(L, 3);
  arg4 = (ofAlignVert)(int)lua_tonumber(L, 4); arg5 = (ofAlignHorz)(int)lua_tonumber(L, 5);
  arg6 = (ofAlignVert)(int)lua_tonumber(L, 6); (arg1)->alignTo((ofRectangle const &)*arg2,arg3,arg4,arg5,arg6); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_alignTo(lua_State* L) { int argc; int argv[7]={ 1,2,3,4,5,6,7} ; argc = lua_gettop(L);
  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Rectangle_alignTo__SWIG_2(L);}  }  }  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec2, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Rectangle_alignTo__SWIG_5(L);}  }  }  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Rectangle_alignTo__SWIG_8(L);}  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { return _wrap_Rectangle_alignTo__SWIG_1(L);}
         }  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { return _wrap_Rectangle_alignTo__SWIG_7(L);}
         }  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec2, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { return _wrap_Rectangle_alignTo__SWIG_4(L);}
         }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); } 
          if (_v) { return _wrap_Rectangle_alignTo__SWIG_6(L);}  }  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); } 
          if (_v) { return _wrap_Rectangle_alignTo__SWIG_0(L);}  }  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec2, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); } 
          if (_v) { return _wrap_Rectangle_alignTo__SWIG_3(L);}  }  }  }  }  if (argc == 6) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); } 
          if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) { { _v = lua_isnumber(L,argv[5]); }  if (_v) {
                return _wrap_Rectangle_alignTo__SWIG_9(L);}  }  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Rectangle_alignTo'\n" "  Possible C/C++ prototypes are:\n"
  "    ofRectangle::alignTo(glm::vec3 const &,ofAlignHorz,ofAlignVert)\n"
  "    ofRectangle::alignTo(glm::vec3 const &,ofAlignHorz)\n" "    ofRectangle::alignTo(glm::vec3 const &)\n"
  "    ofRectangle::alignTo(glm::vec2 const &,ofAlignHorz,ofAlignVert)\n"
  "    ofRectangle::alignTo(glm::vec2 const &,ofAlignHorz)\n" "    ofRectangle::alignTo(glm::vec2 const &)\n"
  "    ofRectangle::alignTo(ofRectangle const &,ofAlignHorz,ofAlignVert)\n"
  "    ofRectangle::alignTo(ofRectangle const &,ofAlignHorz)\n" "    ofRectangle::alignTo(ofRectangle const &)\n"
  "    ofRectangle::alignTo(ofRectangle const &,ofAlignHorz,ofAlignVert,ofAlignHorz,ofAlignVert)\n"); lua_error(L);return 0; }
static int _wrap_Rectangle_inside__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ; float arg2 ;
  float arg3 ; bool result; SWIG_check_num_args("ofRectangle::inside",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::inside",1,"ofRectangle const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofRectangle::inside",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofRectangle::inside",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_inside",1,SWIGTYPE_p_ofRectangle); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); result = (bool)((ofRectangle const *)arg1)->inside(arg2,arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_inside__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  glm::vec3 *arg2 = 0 ; bool result; SWIG_check_num_args("ofRectangle::inside",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::inside",1,"ofRectangle const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofRectangle::inside",2,"glm::vec3 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_inside",1,SWIGTYPE_p_ofRectangle); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("Rectangle_inside",2,SWIGTYPE_p_glm__vec3); } 
  result = (bool)((ofRectangle const *)arg1)->inside((glm::vec3 const &)*arg2); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_inside__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  glm::vec2 *arg2 = 0 ; bool result; SWIG_check_num_args("ofRectangle::inside",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::inside",1,"ofRectangle const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofRectangle::inside",2,"glm::vec2 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_inside",1,SWIGTYPE_p_ofRectangle); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec2,0))){
    SWIG_fail_ptr("Rectangle_inside",2,SWIGTYPE_p_glm__vec2); } 
  result = (bool)((ofRectangle const *)arg1)->inside((glm::vec2 const &)*arg2); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_inside__SWIG_3(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  ofRectangle *arg2 = 0 ; bool result; SWIG_check_num_args("ofRectangle::inside",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::inside",1,"ofRectangle const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofRectangle::inside",2,"ofRectangle const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_inside",1,SWIGTYPE_p_ofRectangle); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_inside",2,SWIGTYPE_p_ofRectangle); } 
  result = (bool)((ofRectangle const *)arg1)->inside((ofRectangle const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_inside__SWIG_4(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  glm::vec3 *arg2 = 0 ; glm::vec3 *arg3 = 0 ; bool result; SWIG_check_num_args("ofRectangle::inside",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::inside",1,"ofRectangle const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofRectangle::inside",2,"glm::vec3 const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofRectangle::inside",3,"glm::vec3 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_inside",1,SWIGTYPE_p_ofRectangle); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("Rectangle_inside",2,SWIGTYPE_p_glm__vec3); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("Rectangle_inside",3,SWIGTYPE_p_glm__vec3); } 
  result = (bool)((ofRectangle const *)arg1)->inside((glm::vec3 const &)*arg2,(glm::vec3 const &)*arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_inside__SWIG_5(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  glm::vec2 *arg2 = 0 ; glm::vec2 *arg3 = 0 ; bool result; SWIG_check_num_args("ofRectangle::inside",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::inside",1,"ofRectangle const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofRectangle::inside",2,"glm::vec2 const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofRectangle::inside",3,"glm::vec2 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_inside",1,SWIGTYPE_p_ofRectangle); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec2,0))){
    SWIG_fail_ptr("Rectangle_inside",2,SWIGTYPE_p_glm__vec2); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_glm__vec2,0))){
    SWIG_fail_ptr("Rectangle_inside",3,SWIGTYPE_p_glm__vec2); } 
  result = (bool)((ofRectangle const *)arg1)->inside((glm::vec2 const &)*arg2,(glm::vec2 const &)*arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_inside(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Rectangle_inside__SWIG_1(L);}  }  }  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec2, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Rectangle_inside__SWIG_2(L);}  }  }  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Rectangle_inside__SWIG_3(L);}  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
           else { _v = 1; }  }  if (_v) { return _wrap_Rectangle_inside__SWIG_4(L);}  }  }  }  if (argc == 3) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec2, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_glm__vec2, 0)) { _v = 0; }
           else { _v = 1; }  }  if (_v) { return _wrap_Rectangle_inside__SWIG_5(L);}  }  }  }  if (argc == 3) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { return _wrap_Rectangle_inside__SWIG_0(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Rectangle_inside'\n" "  Possible C/C++ prototypes are:\n"
  "    ofRectangle::inside(float,float) const\n" "    ofRectangle::inside(glm::vec3 const &) const\n"
  "    ofRectangle::inside(glm::vec2 const &) const\n" "    ofRectangle::inside(ofRectangle const &) const\n"
  "    ofRectangle::inside(glm::vec3 const &,glm::vec3 const &) const\n"
  "    ofRectangle::inside(glm::vec2 const &,glm::vec2 const &) const\n"); lua_error(L);return 0; }
static int _wrap_Rectangle_intersects__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  ofRectangle *arg2 = 0 ; bool result; SWIG_check_num_args("ofRectangle::intersects",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::intersects",1,"ofRectangle const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofRectangle::intersects",2,"ofRectangle const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_intersects",1,SWIGTYPE_p_ofRectangle); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_intersects",2,SWIGTYPE_p_ofRectangle); } 
  result = (bool)((ofRectangle const *)arg1)->intersects((ofRectangle const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_intersects__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  glm::vec3 *arg2 = 0 ; glm::vec3 *arg3 = 0 ; bool result; SWIG_check_num_args("ofRectangle::intersects",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::intersects",1,"ofRectangle const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofRectangle::intersects",2,"glm::vec3 const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofRectangle::intersects",3,"glm::vec3 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_intersects",1,SWIGTYPE_p_ofRectangle); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("Rectangle_intersects",2,SWIGTYPE_p_glm__vec3); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("Rectangle_intersects",3,SWIGTYPE_p_glm__vec3); } 
  result = (bool)((ofRectangle const *)arg1)->intersects((glm::vec3 const &)*arg2,(glm::vec3 const &)*arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_intersects__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  glm::vec2 *arg2 = 0 ; glm::vec2 *arg3 = 0 ; bool result; SWIG_check_num_args("ofRectangle::intersects",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::intersects",1,"ofRectangle const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofRectangle::intersects",2,"glm::vec2 const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofRectangle::intersects",3,"glm::vec2 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_intersects",1,SWIGTYPE_p_ofRectangle); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec2,0))){
    SWIG_fail_ptr("Rectangle_intersects",2,SWIGTYPE_p_glm__vec2); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_glm__vec2,0))){
    SWIG_fail_ptr("Rectangle_intersects",3,SWIGTYPE_p_glm__vec2); } 
  result = (bool)((ofRectangle const *)arg1)->intersects((glm::vec2 const &)*arg2,(glm::vec2 const &)*arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_intersects(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Rectangle_intersects__SWIG_0(L);}  }  }  if (argc == 3) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
           else { _v = 1; }  }  if (_v) { return _wrap_Rectangle_intersects__SWIG_1(L);}  }  }  }  if (argc == 3) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec2, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_glm__vec2, 0)) { _v = 0; }
           else { _v = 1; }  }  if (_v) { return _wrap_Rectangle_intersects__SWIG_2(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Rectangle_intersects'\n"
  "  Possible C/C++ prototypes are:\n" "    ofRectangle::intersects(ofRectangle const &) const\n"
  "    ofRectangle::intersects(glm::vec3 const &,glm::vec3 const &) const\n"
  "    ofRectangle::intersects(glm::vec2 const &,glm::vec2 const &) const\n"); lua_error(L);return 0; }
static int _wrap_Rectangle_growToInclude__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  float arg2 ; float arg3 ; SWIG_check_num_args("ofRectangle::growToInclude",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::growToInclude",1,"ofRectangle *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofRectangle::growToInclude",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofRectangle::growToInclude",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_growToInclude",1,SWIGTYPE_p_ofRectangle); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); (arg1)->growToInclude(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Rectangle_growToInclude__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  glm::vec3 *arg2 = 0 ; SWIG_check_num_args("ofRectangle::growToInclude",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::growToInclude",1,"ofRectangle *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofRectangle::growToInclude",2,"glm::vec3 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_growToInclude",1,SWIGTYPE_p_ofRectangle); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("Rectangle_growToInclude",2,SWIGTYPE_p_glm__vec3); }  (arg1)->growToInclude((glm::vec3 const &)*arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_growToInclude__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  glm::vec2 *arg2 = 0 ; SWIG_check_num_args("ofRectangle::growToInclude",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::growToInclude",1,"ofRectangle *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofRectangle::growToInclude",2,"glm::vec2 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_growToInclude",1,SWIGTYPE_p_ofRectangle); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec2,0))){
    SWIG_fail_ptr("Rectangle_growToInclude",2,SWIGTYPE_p_glm__vec2); }  (arg1)->growToInclude((glm::vec2 const &)*arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_growToInclude__SWIG_3(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  ofRectangle *arg2 = 0 ; SWIG_check_num_args("ofRectangle::growToInclude",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::growToInclude",1,"ofRectangle *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofRectangle::growToInclude",2,"ofRectangle const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_growToInclude",1,SWIGTYPE_p_ofRectangle); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_growToInclude",2,SWIGTYPE_p_ofRectangle); }  (arg1)->growToInclude((ofRectangle const &)*arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_growToInclude__SWIG_4(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  glm::vec3 *arg2 = 0 ; glm::vec3 *arg3 = 0 ; SWIG_check_num_args("ofRectangle::growToInclude",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::growToInclude",1,"ofRectangle *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofRectangle::growToInclude",2,"glm::vec3 const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofRectangle::growToInclude",3,"glm::vec3 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_growToInclude",1,SWIGTYPE_p_ofRectangle); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("Rectangle_growToInclude",2,SWIGTYPE_p_glm__vec3); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("Rectangle_growToInclude",3,SWIGTYPE_p_glm__vec3); } 
  (arg1)->growToInclude((glm::vec3 const &)*arg2,(glm::vec3 const &)*arg3); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_growToInclude__SWIG_5(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  glm::vec2 *arg2 = 0 ; glm::vec2 *arg3 = 0 ; SWIG_check_num_args("ofRectangle::growToInclude",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::growToInclude",1,"ofRectangle *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofRectangle::growToInclude",2,"glm::vec2 const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofRectangle::growToInclude",3,"glm::vec2 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_growToInclude",1,SWIGTYPE_p_ofRectangle); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec2,0))){
    SWIG_fail_ptr("Rectangle_growToInclude",2,SWIGTYPE_p_glm__vec2); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_glm__vec2,0))){
    SWIG_fail_ptr("Rectangle_growToInclude",3,SWIGTYPE_p_glm__vec2); } 
  (arg1)->growToInclude((glm::vec2 const &)*arg2,(glm::vec2 const &)*arg3); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_growToInclude(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L);
  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Rectangle_growToInclude__SWIG_1(L);}  }  }  if (argc == 2) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec2, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Rectangle_growToInclude__SWIG_2(L);}  }  }  if (argc == 2) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Rectangle_growToInclude__SWIG_3(L);}  }  }  if (argc == 3) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
           else { _v = 1; }  }  if (_v) { return _wrap_Rectangle_growToInclude__SWIG_4(L);}  }  }  }  if (argc == 3) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec2, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_glm__vec2, 0)) { _v = 0; }
           else { _v = 1; }  }  if (_v) { return _wrap_Rectangle_growToInclude__SWIG_5(L);}  }  }  }  if (argc == 3) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { return _wrap_Rectangle_growToInclude__SWIG_0(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Rectangle_growToInclude'\n"
  "  Possible C/C++ prototypes are:\n" "    ofRectangle::growToInclude(float,float)\n"
  "    ofRectangle::growToInclude(glm::vec3 const &)\n" "    ofRectangle::growToInclude(glm::vec2 const &)\n"
  "    ofRectangle::growToInclude(ofRectangle const &)\n"
  "    ofRectangle::growToInclude(glm::vec3 const &,glm::vec3 const &)\n"
  "    ofRectangle::growToInclude(glm::vec2 const &,glm::vec2 const &)\n"); lua_error(L);return 0; }
static int _wrap_Rectangle_getIntersection(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  ofRectangle *arg2 = 0 ; ofRectangle result; SWIG_check_num_args("ofRectangle::getIntersection",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::getIntersection",1,"ofRectangle const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofRectangle::getIntersection",2,"ofRectangle const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_getIntersection",1,SWIGTYPE_p_ofRectangle); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_getIntersection",2,SWIGTYPE_p_ofRectangle); } 
  result = ((ofRectangle const *)arg1)->getIntersection((ofRectangle const &)*arg2); {
    ofRectangle * resultptr = new ofRectangle((const ofRectangle &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofRectangle,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_getUnion(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  ofRectangle *arg2 = 0 ; ofRectangle result; SWIG_check_num_args("ofRectangle::getUnion",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::getUnion",1,"ofRectangle const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofRectangle::getUnion",2,"ofRectangle const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_getUnion",1,SWIGTYPE_p_ofRectangle); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_getUnion",2,SWIGTYPE_p_ofRectangle); } 
  result = ((ofRectangle const *)arg1)->getUnion((ofRectangle const &)*arg2); {
    ofRectangle * resultptr = new ofRectangle((const ofRectangle &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofRectangle,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_standardize(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  SWIG_check_num_args("ofRectangle::standardize",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::standardize",1,"ofRectangle *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_standardize",1,SWIGTYPE_p_ofRectangle); }  (arg1)->standardize(); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_getStandardized(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  ofRectangle result; SWIG_check_num_args("ofRectangle::getStandardized",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::getStandardized",1,"ofRectangle const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_getStandardized",1,SWIGTYPE_p_ofRectangle); } 
  result = ((ofRectangle const *)arg1)->getStandardized(); {
    ofRectangle * resultptr = new ofRectangle((const ofRectangle &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofRectangle,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_isStandardized(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ; bool result;
  SWIG_check_num_args("ofRectangle::isStandardized",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::isStandardized",1,"ofRectangle const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_isStandardized",1,SWIGTYPE_p_ofRectangle); } 
  result = (bool)((ofRectangle const *)arg1)->isStandardized(); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_getArea(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ; float result;
  SWIG_check_num_args("ofRectangle::getArea",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::getArea",1,"ofRectangle const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_getArea",1,SWIGTYPE_p_ofRectangle); }  result = (float)((ofRectangle const *)arg1)->getArea();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_getPerimeter(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ; float result;
  SWIG_check_num_args("ofRectangle::getPerimeter",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::getPerimeter",1,"ofRectangle const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_getPerimeter",1,SWIGTYPE_p_ofRectangle); } 
  result = (float)((ofRectangle const *)arg1)->getPerimeter(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_getAspectRatio(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  float result; SWIG_check_num_args("ofRectangle::getAspectRatio",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::getAspectRatio",1,"ofRectangle const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_getAspectRatio",1,SWIGTYPE_p_ofRectangle); } 
  result = (float)((ofRectangle const *)arg1)->getAspectRatio(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_isEmpty(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ; bool result;
  SWIG_check_num_args("ofRectangle::isEmpty",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::isEmpty",1,"ofRectangle const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_isEmpty",1,SWIGTYPE_p_ofRectangle); }  result = (bool)((ofRectangle const *)arg1)->isEmpty();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_getMin(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ; glm::vec3 result;
  SWIG_check_num_args("ofRectangle::getMin",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::getMin",1,"ofRectangle const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_getMin",1,SWIGTYPE_p_ofRectangle); }  result = ((ofRectangle const *)arg1)->getMin(); {
    glm::vec3 * resultptr = new glm::vec3((const glm::vec3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_glm__vec3,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_getMax(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ; glm::vec3 result;
  SWIG_check_num_args("ofRectangle::getMax",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::getMax",1,"ofRectangle const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_getMax",1,SWIGTYPE_p_ofRectangle); }  result = ((ofRectangle const *)arg1)->getMax(); {
    glm::vec3 * resultptr = new glm::vec3((const glm::vec3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_glm__vec3,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_getMinX(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ; float result;
  SWIG_check_num_args("ofRectangle::getMinX",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::getMinX",1,"ofRectangle const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_getMinX",1,SWIGTYPE_p_ofRectangle); }  result = (float)((ofRectangle const *)arg1)->getMinX();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_getMaxX(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ; float result;
  SWIG_check_num_args("ofRectangle::getMaxX",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::getMaxX",1,"ofRectangle const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_getMaxX",1,SWIGTYPE_p_ofRectangle); }  result = (float)((ofRectangle const *)arg1)->getMaxX();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_getMinY(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ; float result;
  SWIG_check_num_args("ofRectangle::getMinY",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::getMinY",1,"ofRectangle const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_getMinY",1,SWIGTYPE_p_ofRectangle); }  result = (float)((ofRectangle const *)arg1)->getMinY();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_getMaxY(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ; float result;
  SWIG_check_num_args("ofRectangle::getMaxY",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::getMaxY",1,"ofRectangle const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_getMaxY",1,SWIGTYPE_p_ofRectangle); }  result = (float)((ofRectangle const *)arg1)->getMaxY();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_getLeft(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ; float result;
  SWIG_check_num_args("ofRectangle::getLeft",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::getLeft",1,"ofRectangle const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_getLeft",1,SWIGTYPE_p_ofRectangle); }  result = (float)((ofRectangle const *)arg1)->getLeft();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_getRight(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ; float result;
  SWIG_check_num_args("ofRectangle::getRight",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::getRight",1,"ofRectangle const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_getRight",1,SWIGTYPE_p_ofRectangle); }  result = (float)((ofRectangle const *)arg1)->getRight();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_getTop(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ; float result;
  SWIG_check_num_args("ofRectangle::getTop",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::getTop",1,"ofRectangle const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_getTop",1,SWIGTYPE_p_ofRectangle); }  result = (float)((ofRectangle const *)arg1)->getTop();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_getBottom(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ; float result;
  SWIG_check_num_args("ofRectangle::getBottom",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::getBottom",1,"ofRectangle const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_getBottom",1,SWIGTYPE_p_ofRectangle); }  result = (float)((ofRectangle const *)arg1)->getBottom();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_getTopLeft(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  glm::vec3 result; SWIG_check_num_args("ofRectangle::getTopLeft",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::getTopLeft",1,"ofRectangle const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_getTopLeft",1,SWIGTYPE_p_ofRectangle); }  result = ((ofRectangle const *)arg1)->getTopLeft(); {
    glm::vec3 * resultptr = new glm::vec3((const glm::vec3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_glm__vec3,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_getTopRight(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  glm::vec3 result; SWIG_check_num_args("ofRectangle::getTopRight",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::getTopRight",1,"ofRectangle const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_getTopRight",1,SWIGTYPE_p_ofRectangle); }  result = ((ofRectangle const *)arg1)->getTopRight(); {
    glm::vec3 * resultptr = new glm::vec3((const glm::vec3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_glm__vec3,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_getBottomLeft(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  glm::vec3 result; SWIG_check_num_args("ofRectangle::getBottomLeft",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::getBottomLeft",1,"ofRectangle const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_getBottomLeft",1,SWIGTYPE_p_ofRectangle); }  result = ((ofRectangle const *)arg1)->getBottomLeft();
  { glm::vec3 * resultptr = new glm::vec3((const glm::vec3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_glm__vec3,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_getBottomRight(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  glm::vec3 result; SWIG_check_num_args("ofRectangle::getBottomRight",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::getBottomRight",1,"ofRectangle const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_getBottomRight",1,SWIGTYPE_p_ofRectangle); } 
  result = ((ofRectangle const *)arg1)->getBottomRight(); { glm::vec3 * resultptr = new glm::vec3((const glm::vec3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_glm__vec3,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_getHorzAnchor(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  ofAlignHorz arg2 ; float result; SWIG_check_num_args("ofRectangle::getHorzAnchor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::getHorzAnchor",1,"ofRectangle const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofRectangle::getHorzAnchor",2,"ofAlignHorz");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_getHorzAnchor",1,SWIGTYPE_p_ofRectangle); }  arg2 = (ofAlignHorz)(int)lua_tonumber(L, 2);
  result = (float)((ofRectangle const *)arg1)->getHorzAnchor(arg2); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_getVertAnchor(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  ofAlignVert arg2 ; float result; SWIG_check_num_args("ofRectangle::getVertAnchor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::getVertAnchor",1,"ofRectangle const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofRectangle::getVertAnchor",2,"ofAlignVert");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_getVertAnchor",1,SWIGTYPE_p_ofRectangle); }  arg2 = (ofAlignVert)(int)lua_tonumber(L, 2);
  result = (float)((ofRectangle const *)arg1)->getVertAnchor(arg2); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_getPosition(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  glm::vec3 *result = 0 ; SWIG_check_num_args("ofRectangle::getPosition",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::getPosition",1,"ofRectangle const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_getPosition",1,SWIGTYPE_p_ofRectangle); } 
  result = (glm::vec3 *) &((ofRectangle const *)arg1)->getPosition();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_glm__vec3,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Rectangle_getCenter(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ; glm::vec3 result;
  SWIG_check_num_args("ofRectangle::getCenter",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::getCenter",1,"ofRectangle const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_getCenter",1,SWIGTYPE_p_ofRectangle); }  result = ((ofRectangle const *)arg1)->getCenter(); {
    glm::vec3 * resultptr = new glm::vec3((const glm::vec3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_glm__vec3,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_getX(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ; float result;
  SWIG_check_num_args("ofRectangle::getX",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::getX",1,"ofRectangle const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_getX",1,SWIGTYPE_p_ofRectangle); }  result = (float)((ofRectangle const *)arg1)->getX();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_getY(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ; float result;
  SWIG_check_num_args("ofRectangle::getY",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::getY",1,"ofRectangle const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_getY",1,SWIGTYPE_p_ofRectangle); }  result = (float)((ofRectangle const *)arg1)->getY();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_getWidth(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ; float result;
  SWIG_check_num_args("ofRectangle::getWidth",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::getWidth",1,"ofRectangle const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_getWidth",1,SWIGTYPE_p_ofRectangle); }  result = (float)((ofRectangle const *)arg1)->getWidth();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_getHeight(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ; float result;
  SWIG_check_num_args("ofRectangle::getHeight",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::getHeight",1,"ofRectangle const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_getHeight",1,SWIGTYPE_p_ofRectangle); }  result = (float)((ofRectangle const *)arg1)->getHeight();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_map__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  glm::vec2 *arg2 = 0 ; glm::vec2 result; SWIG_check_num_args("ofRectangle::map",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::map",1,"ofRectangle const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofRectangle::map",2,"glm::vec2 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_map",1,SWIGTYPE_p_ofRectangle); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec2,0))){
    SWIG_fail_ptr("Rectangle_map",2,SWIGTYPE_p_glm__vec2); } 
  result = ((ofRectangle const *)arg1)->map((glm::vec2 const &)*arg2); {
    glm::vec2 * resultptr = new glm::vec2((const glm::vec2 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_glm__vec2,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_map__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  ofRectangle *arg2 = 0 ; ofRectangle result; SWIG_check_num_args("ofRectangle::map",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::map",1,"ofRectangle const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofRectangle::map",2,"ofRectangle const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_map",1,SWIGTYPE_p_ofRectangle); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_map",2,SWIGTYPE_p_ofRectangle); } 
  result = ((ofRectangle const *)arg1)->map((ofRectangle const &)*arg2); {
    ofRectangle * resultptr = new ofRectangle((const ofRectangle &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofRectangle,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_map(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 2) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec2, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Rectangle_map__SWIG_0(L);}  }  }  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Rectangle_map__SWIG_1(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Rectangle_map'\n" "  Possible C/C++ prototypes are:\n"
  "    ofRectangle::map(glm::vec2 const &) const\n" "    ofRectangle::map(ofRectangle const &) const\n");
  lua_error(L);return 0; }
static int _wrap_Rectangle_mapClamp__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  glm::vec2 *arg2 = 0 ; glm::vec2 result; SWIG_check_num_args("ofRectangle::mapClamp",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::mapClamp",1,"ofRectangle const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofRectangle::mapClamp",2,"glm::vec2 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_mapClamp",1,SWIGTYPE_p_ofRectangle); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec2,0))){
    SWIG_fail_ptr("Rectangle_mapClamp",2,SWIGTYPE_p_glm__vec2); } 
  result = ((ofRectangle const *)arg1)->mapClamp((glm::vec2 const &)*arg2); {
    glm::vec2 * resultptr = new glm::vec2((const glm::vec2 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_glm__vec2,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_mapClamp__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  ofRectangle *arg2 = 0 ; ofRectangle result; SWIG_check_num_args("ofRectangle::mapClamp",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::mapClamp",1,"ofRectangle const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofRectangle::mapClamp",2,"ofRectangle const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_mapClamp",1,SWIGTYPE_p_ofRectangle); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_mapClamp",2,SWIGTYPE_p_ofRectangle); } 
  result = ((ofRectangle const *)arg1)->mapClamp((ofRectangle const &)*arg2); {
    ofRectangle * resultptr = new ofRectangle((const ofRectangle &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofRectangle,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_mapClamp(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec2, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Rectangle_mapClamp__SWIG_0(L);}  }  }  if (argc == 2) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Rectangle_mapClamp__SWIG_1(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Rectangle_mapClamp'\n" "  Possible C/C++ prototypes are:\n"
  "    ofRectangle::mapClamp(glm::vec2 const &) const\n" "    ofRectangle::mapClamp(ofRectangle const &) const\n");
  lua_error(L);return 0; }
static int _wrap_Rectangle___add__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  glm::vec3 *arg2 = 0 ; ofRectangle result; SWIG_check_num_args("ofRectangle::operator +",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::operator +",1,"ofRectangle *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofRectangle::operator +",2,"glm::vec3 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle___add",1,SWIGTYPE_p_ofRectangle); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("Rectangle___add",2,SWIGTYPE_p_glm__vec3); }  result = (arg1)->operator +((glm::vec3 const &)*arg2); {
    ofRectangle * resultptr = new ofRectangle((const ofRectangle &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofRectangle,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle___add__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  glm::vec2 *arg2 = 0 ; ofRectangle result; SWIG_check_num_args("ofRectangle::operator +",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::operator +",1,"ofRectangle *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofRectangle::operator +",2,"glm::vec2 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle___add",1,SWIGTYPE_p_ofRectangle); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec2,0))){
    SWIG_fail_ptr("Rectangle___add",2,SWIGTYPE_p_glm__vec2); }  result = (arg1)->operator +((glm::vec2 const &)*arg2); {
    ofRectangle * resultptr = new ofRectangle((const ofRectangle &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofRectangle,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle___add(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 2) { int _v;
    { void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Rectangle___add__SWIG_0(L);}  }  }  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec2, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Rectangle___add__SWIG_1(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Rectangle___add'\n" "  Possible C/C++ prototypes are:\n"
  "    ofRectangle::operator +(glm::vec3 const &)\n" "    ofRectangle::operator +(glm::vec2 const &)\n");
  lua_error(L);return 0; }
static int _wrap_Rectangle___sub__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  glm::vec3 *arg2 = 0 ; ofRectangle result; SWIG_check_num_args("ofRectangle::operator -",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::operator -",1,"ofRectangle *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofRectangle::operator -",2,"glm::vec3 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle___sub",1,SWIGTYPE_p_ofRectangle); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("Rectangle___sub",2,SWIGTYPE_p_glm__vec3); }  result = (arg1)->operator -((glm::vec3 const &)*arg2); {
    ofRectangle * resultptr = new ofRectangle((const ofRectangle &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofRectangle,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle___sub__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  glm::vec2 *arg2 = 0 ; ofRectangle result; SWIG_check_num_args("ofRectangle::operator -",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::operator -",1,"ofRectangle *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofRectangle::operator -",2,"glm::vec2 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle___sub",1,SWIGTYPE_p_ofRectangle); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec2,0))){
    SWIG_fail_ptr("Rectangle___sub",2,SWIGTYPE_p_glm__vec2); }  result = (arg1)->operator -((glm::vec2 const &)*arg2); {
    ofRectangle * resultptr = new ofRectangle((const ofRectangle &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofRectangle,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle___sub(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 2) { int _v;
    { void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec3, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Rectangle___sub__SWIG_0(L);}  }  }  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec2, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Rectangle___sub__SWIG_1(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Rectangle___sub'\n" "  Possible C/C++ prototypes are:\n"
  "    ofRectangle::operator -(glm::vec3 const &)\n" "    ofRectangle::operator -(glm::vec2 const &)\n");
  lua_error(L);return 0; }
static int _wrap_Rectangle___eq(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  ofRectangle *arg2 = 0 ; bool result; SWIG_check_num_args("ofRectangle::operator ==",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::operator ==",1,"ofRectangle const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofRectangle::operator ==",2,"ofRectangle const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle___eq",1,SWIGTYPE_p_ofRectangle); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle___eq",2,SWIGTYPE_p_ofRectangle); } 
  result = (bool)((ofRectangle const *)arg1)->operator ==((ofRectangle const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_isZero(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ; bool result;
  SWIG_check_num_args("ofRectangle::isZero",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::isZero",1,"ofRectangle const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_isZero",1,SWIGTYPE_p_ofRectangle); }  result = (bool)((ofRectangle const *)arg1)->isZero();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_position_set(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  glm::vec3 arg2 ; glm::vec3 *argp2 ; SWIG_check_num_args("ofRectangle::position",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::position",1,"ofRectangle *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofRectangle::position",2,"glm::vec3");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_position_set",1,SWIGTYPE_p_ofRectangle); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_glm__vec3,0))){
    SWIG_fail_ptr("Rectangle_position_set",2,SWIGTYPE_p_glm__vec3); }  arg2 = *argp2; if (arg1) (arg1)->position = arg2;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_position_get(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  glm::vec3 result; SWIG_check_num_args("ofRectangle::position",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::position",1,"ofRectangle *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_position_get",1,SWIGTYPE_p_ofRectangle); }  result =  ((arg1)->position); {
    glm::vec3 * resultptr = new glm::vec3((const glm::vec3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_glm__vec3,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_width_set(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ; float arg2 ;
  SWIG_check_num_args("ofRectangle::width",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::width",1,"ofRectangle *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofRectangle::width",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_width_set",1,SWIGTYPE_p_ofRectangle); }  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->width = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_width_get(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ; float result;
  SWIG_check_num_args("ofRectangle::width",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::width",1,"ofRectangle *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_width_get",1,SWIGTYPE_p_ofRectangle); }  result = (float) ((arg1)->width);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_height_set(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ; float arg2 ;
  SWIG_check_num_args("ofRectangle::height",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::height",1,"ofRectangle *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofRectangle::height",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_height_set",1,SWIGTYPE_p_ofRectangle); }  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->height = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_height_get(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ; float result;
  SWIG_check_num_args("ofRectangle::height",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::height",1,"ofRectangle *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_height_get",1,SWIGTYPE_p_ofRectangle); }  result = (float) ((arg1)->height);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_x_set(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ; float arg2 ;
  SWIG_check_num_args("ofRectangle::x",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::x",1,"ofRectangle *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofRectangle::x",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_x_set",1,SWIGTYPE_p_ofRectangle); }  arg2 = (float)lua_tonumber(L, 2);
  ofRectangle_x_set(arg1,arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_x_get(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ; float result;
  SWIG_check_num_args("ofRectangle::x",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::x",1,"ofRectangle *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_x_get",1,SWIGTYPE_p_ofRectangle); }  result = (float)ofRectangle_x_get(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_y_set(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ; float arg2 ;
  SWIG_check_num_args("ofRectangle::y",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::y",1,"ofRectangle *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofRectangle::y",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_y_set",1,SWIGTYPE_p_ofRectangle); }  arg2 = (float)lua_tonumber(L, 2);
  ofRectangle_y_set(arg1,arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle_y_get(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ; float result;
  SWIG_check_num_args("ofRectangle::y",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::y",1,"ofRectangle *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle_y_get",1,SWIGTYPE_p_ofRectangle); }  result = (float)ofRectangle_y_get(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Rectangle___tostring(lua_State* L) { int SWIG_arg = 0; ofRectangle *arg1 = (ofRectangle *) 0 ;
  char *result = 0 ; SWIG_check_num_args("ofRectangle::__str__",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofRectangle::__str__",1,"ofRectangle *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("Rectangle___tostring",1,SWIGTYPE_p_ofRectangle); }  result = (char *)ofRectangle___str__(arg1);
  lua_pushstring(L,(const char *)result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static void swig_delete_Rectangle(void *obj) {
ofRectangle *arg1 = (ofRectangle *) obj;
delete arg1;
}
static int _proxy__wrap_new_Rectangle(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_Rectangle);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_Rectangle_attributes[] = {
    { "position", _wrap_Rectangle_position_get, _wrap_Rectangle_position_set },
    { "width", _wrap_Rectangle_width_get, _wrap_Rectangle_width_set },
    { "height", _wrap_Rectangle_height_get, _wrap_Rectangle_height_set },
    { "x", _wrap_Rectangle_x_get, _wrap_Rectangle_x_set },
    { "y", _wrap_Rectangle_y_get, _wrap_Rectangle_y_set },
    {0,0,0}
};
static swig_lua_method swig_Rectangle_methods[]= {
    { "set", _wrap_Rectangle_set},
    { "setX", _wrap_Rectangle_setX},
    { "setY", _wrap_Rectangle_setY},
    { "setWidth", _wrap_Rectangle_setWidth},
    { "setHeight", _wrap_Rectangle_setHeight},
    { "setPosition", _wrap_Rectangle_setPosition},
    { "setSize", _wrap_Rectangle_setSize},
    { "setFromCenter", _wrap_Rectangle_setFromCenter},
    { "translate", _wrap_Rectangle_translate},
    { "translateX", _wrap_Rectangle_translateX},
    { "translateY", _wrap_Rectangle_translateY},
    { "scale", _wrap_Rectangle_scale},
    { "scaleWidth", _wrap_Rectangle_scaleWidth},
    { "scaleHeight", _wrap_Rectangle_scaleHeight},
    { "scaleFromCenter", _wrap_Rectangle_scaleFromCenter},
    { "scaleToScaleMode", _wrap_Rectangle_scaleToScaleMode},
    { "scaleToAspectRatio", _wrap_Rectangle_scaleToAspectRatio},
    { "scaleTo", _wrap_Rectangle_scaleTo},
    { "alignToHorz", _wrap_Rectangle_alignToHorz},
    { "alignToVert", _wrap_Rectangle_alignToVert},
    { "alignTo", _wrap_Rectangle_alignTo},
    { "inside", _wrap_Rectangle_inside},
    { "intersects", _wrap_Rectangle_intersects},
    { "growToInclude", _wrap_Rectangle_growToInclude},
    { "getIntersection", _wrap_Rectangle_getIntersection},
    { "getUnion", _wrap_Rectangle_getUnion},
    { "standardize", _wrap_Rectangle_standardize},
    { "getStandardized", _wrap_Rectangle_getStandardized},
    { "isStandardized", _wrap_Rectangle_isStandardized},
    { "getArea", _wrap_Rectangle_getArea},
    { "getPerimeter", _wrap_Rectangle_getPerimeter},
    { "getAspectRatio", _wrap_Rectangle_getAspectRatio},
    { "isEmpty", _wrap_Rectangle_isEmpty},
    { "getMin", _wrap_Rectangle_getMin},
    { "getMax", _wrap_Rectangle_getMax},
    { "getMinX", _wrap_Rectangle_getMinX},
    { "getMaxX", _wrap_Rectangle_getMaxX},
    { "getMinY", _wrap_Rectangle_getMinY},
    { "getMaxY", _wrap_Rectangle_getMaxY},
    { "getLeft", _wrap_Rectangle_getLeft},
    { "getRight", _wrap_Rectangle_getRight},
    { "getTop", _wrap_Rectangle_getTop},
    { "getBottom", _wrap_Rectangle_getBottom},
    { "getTopLeft", _wrap_Rectangle_getTopLeft},
    { "getTopRight", _wrap_Rectangle_getTopRight},
    { "getBottomLeft", _wrap_Rectangle_getBottomLeft},
    { "getBottomRight", _wrap_Rectangle_getBottomRight},
    { "getHorzAnchor", _wrap_Rectangle_getHorzAnchor},
    { "getVertAnchor", _wrap_Rectangle_getVertAnchor},
    { "getPosition", _wrap_Rectangle_getPosition},
    { "getCenter", _wrap_Rectangle_getCenter},
    { "getX", _wrap_Rectangle_getX},
    { "getY", _wrap_Rectangle_getY},
    { "getWidth", _wrap_Rectangle_getWidth},
    { "getHeight", _wrap_Rectangle_getHeight},
    { "map", _wrap_Rectangle_map},
    { "mapClamp", _wrap_Rectangle_mapClamp},
    { "__add", _wrap_Rectangle___add},
    { "__sub", _wrap_Rectangle___sub},
    { "__eq", _wrap_Rectangle___eq},
    { "isZero", _wrap_Rectangle_isZero},
    { "__tostring", _wrap_Rectangle___tostring},
    {0,0}
};
static swig_lua_method swig_Rectangle_meta[] = {
    { "__add", _wrap_Rectangle___add},
    { "__sub", _wrap_Rectangle___sub},
    { "__eq", _wrap_Rectangle___eq},
    { "__tostring", _wrap_Rectangle___tostring},
    {0,0}
};

static swig_lua_attribute swig_Rectangle_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_Rectangle_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_Rectangle_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_Rectangle_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_Rectangle_Sf_SwigStatic = {
    "Rectangle",
    swig_Rectangle_Sf_SwigStatic_methods,
    swig_Rectangle_Sf_SwigStatic_attributes,
    swig_Rectangle_Sf_SwigStatic_constants,
    swig_Rectangle_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_Rectangle_bases[] = {0};
static const char *swig_Rectangle_base_names[] = {0};
static swig_lua_class _wrap_class_Rectangle = { "Rectangle", "Rectangle", &SWIGTYPE_p_ofRectangle,_proxy__wrap_new_Rectangle, swig_delete_Rectangle, swig_Rectangle_methods, swig_Rectangle_attributes, &swig_Rectangle_Sf_SwigStatic, swig_Rectangle_meta, swig_Rectangle_bases, swig_Rectangle_base_names };

static int _wrap_new_FpsCounter__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofFpsCounter *result = 0 ;
  SWIG_check_num_args("ofFpsCounter::ofFpsCounter",0,0) result = (ofFpsCounter *)new ofFpsCounter();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofFpsCounter,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_FpsCounter__SWIG_1(lua_State* L) { int SWIG_arg = 0; double arg1 ; ofFpsCounter *result = 0 ;
  SWIG_check_num_args("ofFpsCounter::ofFpsCounter",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofFpsCounter::ofFpsCounter",1,"double"); arg1 = (double)lua_tonumber(L, 1);
  result = (ofFpsCounter *)new ofFpsCounter(arg1); SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofFpsCounter,1); SWIG_arg++; 
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_new_FpsCounter(lua_State* L) { int argc; int argv[2]={ 1,2} ; argc = lua_gettop(L); if (argc == 0) {
    return _wrap_new_FpsCounter__SWIG_0(L);}  if (argc == 1) { int _v; { _v = lua_isnumber(L,argv[0]); }  if (_v) {
      return _wrap_new_FpsCounter__SWIG_1(L);}  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_FpsCounter'\n" "  Possible C/C++ prototypes are:\n"
  "    ofFpsCounter::ofFpsCounter()\n" "    ofFpsCounter::ofFpsCounter(double)\n"); lua_error(L);return 0; }
static int _wrap_FpsCounter_newFrame(lua_State* L) { int SWIG_arg = 0; ofFpsCounter *arg1 = (ofFpsCounter *) 0 ;
  SWIG_check_num_args("ofFpsCounter::newFrame",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFpsCounter::newFrame",1,"ofFpsCounter *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFpsCounter,0))){
    SWIG_fail_ptr("FpsCounter_newFrame",1,SWIGTYPE_p_ofFpsCounter); }  (arg1)->newFrame(); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_FpsCounter_update(lua_State* L) { int SWIG_arg = 0; ofFpsCounter *arg1 = (ofFpsCounter *) 0 ;
  SWIG_check_num_args("ofFpsCounter::update",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFpsCounter::update",1,"ofFpsCounter *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFpsCounter,0))){
    SWIG_fail_ptr("FpsCounter_update",1,SWIGTYPE_p_ofFpsCounter); }  (arg1)->update(); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FpsCounter_getFps(lua_State* L) { int SWIG_arg = 0; ofFpsCounter *arg1 = (ofFpsCounter *) 0 ; double result;
  SWIG_check_num_args("ofFpsCounter::getFps",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFpsCounter::getFps",1,"ofFpsCounter const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFpsCounter,0))){
    SWIG_fail_ptr("FpsCounter_getFps",1,SWIGTYPE_p_ofFpsCounter); }  result = (double)((ofFpsCounter const *)arg1)->getFps();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FpsCounter_getNumFrames(lua_State* L) { int SWIG_arg = 0; ofFpsCounter *arg1 = (ofFpsCounter *) 0 ;
  uint64_t result; SWIG_check_num_args("ofFpsCounter::getNumFrames",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFpsCounter::getNumFrames",1,"ofFpsCounter const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFpsCounter,0))){
    SWIG_fail_ptr("FpsCounter_getNumFrames",1,SWIGTYPE_p_ofFpsCounter); } 
  result = (uint64_t)((ofFpsCounter const *)arg1)->getNumFrames(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FpsCounter_getLastFrameNanos(lua_State* L) { int SWIG_arg = 0; ofFpsCounter *arg1 = (ofFpsCounter *) 0 ;
  uint64_t result; SWIG_check_num_args("ofFpsCounter::getLastFrameNanos",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFpsCounter::getLastFrameNanos",1,"ofFpsCounter const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFpsCounter,0))){
    SWIG_fail_ptr("FpsCounter_getLastFrameNanos",1,SWIGTYPE_p_ofFpsCounter); } 
  result = (uint64_t)((ofFpsCounter const *)arg1)->getLastFrameNanos(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FpsCounter_getLastFrameSecs(lua_State* L) { int SWIG_arg = 0; ofFpsCounter *arg1 = (ofFpsCounter *) 0 ;
  double result; SWIG_check_num_args("ofFpsCounter::getLastFrameSecs",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFpsCounter::getLastFrameSecs",1,"ofFpsCounter const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFpsCounter,0))){
    SWIG_fail_ptr("FpsCounter_getLastFrameSecs",1,SWIGTYPE_p_ofFpsCounter); } 
  result = (double)((ofFpsCounter const *)arg1)->getLastFrameSecs(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FpsCounter_getLastFrameFilteredNanos(lua_State* L) { int SWIG_arg = 0;
  ofFpsCounter *arg1 = (ofFpsCounter *) 0 ; uint64_t result; SWIG_check_num_args("ofFpsCounter::getLastFrameFilteredNanos",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFpsCounter::getLastFrameFilteredNanos",1,"ofFpsCounter const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFpsCounter,0))){
    SWIG_fail_ptr("FpsCounter_getLastFrameFilteredNanos",1,SWIGTYPE_p_ofFpsCounter); } 
  result = (uint64_t)((ofFpsCounter const *)arg1)->getLastFrameFilteredNanos();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FpsCounter_getLastFrameFilteredSecs(lua_State* L) { int SWIG_arg = 0; ofFpsCounter *arg1 = (ofFpsCounter *) 0 ;
  double result; SWIG_check_num_args("ofFpsCounter::getLastFrameFilteredSecs",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFpsCounter::getLastFrameFilteredSecs",1,"ofFpsCounter const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFpsCounter,0))){
    SWIG_fail_ptr("FpsCounter_getLastFrameFilteredSecs",1,SWIGTYPE_p_ofFpsCounter); } 
  result = (double)((ofFpsCounter const *)arg1)->getLastFrameFilteredSecs(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FpsCounter_setFilterAlpha(lua_State* L) { int SWIG_arg = 0; ofFpsCounter *arg1 = (ofFpsCounter *) 0 ;
  float arg2 ; SWIG_check_num_args("ofFpsCounter::setFilterAlpha",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFpsCounter::setFilterAlpha",1,"ofFpsCounter *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofFpsCounter::setFilterAlpha",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFpsCounter,0))){
    SWIG_fail_ptr("FpsCounter_setFilterAlpha",1,SWIGTYPE_p_ofFpsCounter); }  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setFilterAlpha(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static void swig_delete_FpsCounter(void *obj) {
ofFpsCounter *arg1 = (ofFpsCounter *) obj;
delete arg1;
}
static int _proxy__wrap_new_FpsCounter(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_FpsCounter);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_FpsCounter_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_FpsCounter_methods[]= {
    { "newFrame", _wrap_FpsCounter_newFrame},
    { "update", _wrap_FpsCounter_update},
    { "getFps", _wrap_FpsCounter_getFps},
    { "getNumFrames", _wrap_FpsCounter_getNumFrames},
    { "getLastFrameNanos", _wrap_FpsCounter_getLastFrameNanos},
    { "getLastFrameSecs", _wrap_FpsCounter_getLastFrameSecs},
    { "getLastFrameFilteredNanos", _wrap_FpsCounter_getLastFrameFilteredNanos},
    { "getLastFrameFilteredSecs", _wrap_FpsCounter_getLastFrameFilteredSecs},
    { "setFilterAlpha", _wrap_FpsCounter_setFilterAlpha},
    {0,0}
};
static swig_lua_method swig_FpsCounter_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_FpsCounter_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_FpsCounter_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_FpsCounter_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_FpsCounter_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_FpsCounter_Sf_SwigStatic = {
    "FpsCounter",
    swig_FpsCounter_Sf_SwigStatic_methods,
    swig_FpsCounter_Sf_SwigStatic_attributes,
    swig_FpsCounter_Sf_SwigStatic_constants,
    swig_FpsCounter_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_FpsCounter_bases[] = {0};
static const char *swig_FpsCounter_base_names[] = {0};
static swig_lua_class _wrap_class_FpsCounter = { "FpsCounter", "FpsCounter", &SWIGTYPE_p_ofFpsCounter,_proxy__wrap_new_FpsCounter, swig_delete_FpsCounter, swig_FpsCounter_methods, swig_FpsCounter_attributes, &swig_FpsCounter_Sf_SwigStatic, swig_FpsCounter_meta, swig_FpsCounter_bases, swig_FpsCounter_base_names };

static int _wrap_new_Xml(lua_State* L) { int SWIG_arg = 0; ofXml *result = 0 ; SWIG_check_num_args("ofXml::ofXml",0,0)
  result = (ofXml *)new ofXml(); SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofXml,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Xml_load__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofXml *arg1 = (ofXml *) 0 ;
  std::filesystem::path *arg2 = 0 ; std::filesystem::path temp2 ; bool result; SWIG_check_num_args("ofXml::load",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofXml::load",1,"ofXml *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofXml::load",2,"std::filesystem::path const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofXml,0))){ SWIG_fail_ptr("Xml_load",1,SWIGTYPE_p_ofXml); }  {
    size_t len = lua_rawlen(L, 2); temp2 = lua_tolstring(L, 2, &len); arg2 = &temp2; } 
  result = (bool)(arg1)->load((std::filesystem::path const &)*arg2); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Xml_load__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofXml *arg1 = (ofXml *) 0 ; ofBuffer *arg2 = 0 ;
  bool result; SWIG_check_num_args("ofXml::load",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofXml::load",1,"ofXml *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofXml::load",2,"ofBuffer const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofXml,0))){ SWIG_fail_ptr("Xml_load",1,SWIGTYPE_p_ofXml); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofBuffer,0))){ SWIG_fail_ptr("Xml_load",2,SWIGTYPE_p_ofBuffer); } 
  result = (bool)(arg1)->load((ofBuffer const &)*arg2); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Xml_load(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 2) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofXml, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofBuffer, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_Xml_load__SWIG_1(L);}  }  }  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofXml, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { _v = lua_isstring(L, argv[1]); }  if (_v) { return _wrap_Xml_load__SWIG_0(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Xml_load'\n" "  Possible C/C++ prototypes are:\n"
  "    ofXml::load(std::filesystem::path const &)\n" "    ofXml::load(ofBuffer const &)\n"); lua_error(L);return 0; }
static int _wrap_Xml_parse(lua_State* L) { int SWIG_arg = 0; ofXml *arg1 = (ofXml *) 0 ; std::string *arg2 = 0 ;
  std::string temp2 ; bool result; SWIG_check_num_args("ofXml::parse",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofXml::parse",1,"ofXml *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofXml::parse",2,"std::string const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofXml,0))){ SWIG_fail_ptr("Xml_parse",1,SWIGTYPE_p_ofXml); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2; result = (bool)(arg1)->parse((std::string const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Xml_save(lua_State* L) { int SWIG_arg = 0; ofXml *arg1 = (ofXml *) 0 ; std::filesystem::path *arg2 = 0 ;
  std::filesystem::path temp2 ; bool result; SWIG_check_num_args("ofXml::save",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofXml::save",1,"ofXml const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofXml::save",2,"std::filesystem::path const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofXml,0))){ SWIG_fail_ptr("Xml_save",1,SWIGTYPE_p_ofXml); }  {
    size_t len = lua_rawlen(L, 2); temp2 = lua_tolstring(L, 2, &len); arg2 = &temp2; } 
  result = (bool)((ofXml const *)arg1)->save((std::filesystem::path const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Xml_toString__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofXml *arg1 = (ofXml *) 0 ; std::string *arg2 = 0 ;
  std::string temp2 ; std::string result; SWIG_check_num_args("ofXml::toString",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofXml::toString",1,"ofXml const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofXml::toString",2,"std::string const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofXml,0))){ SWIG_fail_ptr("Xml_toString",1,SWIGTYPE_p_ofXml); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  result = ((ofXml const *)arg1)->toString((std::string const &)*arg2);
  lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Xml_toString__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofXml *arg1 = (ofXml *) 0 ; std::string result;
  SWIG_check_num_args("ofXml::toString",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofXml::toString",1,"ofXml const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofXml,0))){ SWIG_fail_ptr("Xml_toString",1,SWIGTYPE_p_ofXml); } 
  result = ((ofXml const *)arg1)->toString(); lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Xml_toString(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 1) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofXml, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { return _wrap_Xml_toString__SWIG_1(L);}  }  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofXml, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { _v = lua_isstring(L,argv[1]); }  if (_v) { return _wrap_Xml_toString__SWIG_0(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Xml_toString'\n" "  Possible C/C++ prototypes are:\n"
  "    ofXml::toString(std::string const &) const\n" "    ofXml::toString() const\n"); lua_error(L);return 0; }
static int _wrap_Xml_getChild(lua_State* L) { int SWIG_arg = 0; ofXml *arg1 = (ofXml *) 0 ; std::string *arg2 = 0 ;
  std::string temp2 ; ofXml result; SWIG_check_num_args("ofXml::getChild",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofXml::getChild",1,"ofXml const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofXml::getChild",2,"std::string const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofXml,0))){ SWIG_fail_ptr("Xml_getChild",1,SWIGTYPE_p_ofXml); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  result = ((ofXml const *)arg1)->getChild((std::string const &)*arg2); { ofXml * resultptr = new ofXml((const ofXml &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofXml,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Xml_getChildren__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofXml *arg1 = (ofXml *) 0 ;
  SwigValueWrapper< ofXml::Range< ofXmlIterator< pugi::xml_node_iterator > > > result;
  SWIG_check_num_args("ofXml::getChildren",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofXml::getChildren",1,"ofXml const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofXml,0))){ SWIG_fail_ptr("Xml_getChildren",1,SWIGTYPE_p_ofXml); }
   result = ((ofXml const *)arg1)->getChildren(); {
    ofXml::Range< ofXmlIterator< pugi::xml_node_iterator > > * resultptr = new ofXml::Range< ofXmlIterator< pugi::xml_node_iterator > >((const ofXml::Range< ofXmlIterator< pugi::xml_node_iterator > > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofXml__RangeT_ofXmlIteratorT_pugi__xml_node_iterator_t_t,1); SWIG_arg++; }
   return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Xml_getChildren__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofXml *arg1 = (ofXml *) 0 ; std::string *arg2 = 0 ;
  std::string temp2 ; SwigValueWrapper< ofXml::Range< ofXmlIterator< pugi::xml_named_node_iterator > > > result;
  SWIG_check_num_args("ofXml::getChildren",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofXml::getChildren",1,"ofXml const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofXml::getChildren",2,"std::string const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofXml,0))){ SWIG_fail_ptr("Xml_getChildren",1,SWIGTYPE_p_ofXml); }
   temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  result = ((ofXml const *)arg1)->getChildren((std::string const &)*arg2); {
    ofXml::Range< ofXmlIterator< pugi::xml_named_node_iterator > > * resultptr = new ofXml::Range< ofXmlIterator< pugi::xml_named_node_iterator > >((const ofXml::Range< ofXmlIterator< pugi::xml_named_node_iterator > > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofXml__RangeT_ofXmlIteratorT_pugi__xml_named_node_iterator_t_t,1); SWIG_arg++; }
   return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Xml_getChildren(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 1) { int _v;
    { void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofXml, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { return _wrap_Xml_getChildren__SWIG_0(L);}  }  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofXml, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { _v = lua_isstring(L,argv[1]); }  if (_v) { return _wrap_Xml_getChildren__SWIG_1(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Xml_getChildren'\n" "  Possible C/C++ prototypes are:\n"
  "    ofXml::getChildren() const\n" "    ofXml::getChildren(std::string const &) const\n"); lua_error(L);return 0; }
static int _wrap_Xml_appendChild__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofXml *arg1 = (ofXml *) 0 ; ofXml *arg2 = 0 ;
  ofXml result; SWIG_check_num_args("ofXml::appendChild",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofXml::appendChild",1,"ofXml *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofXml::appendChild",2,"ofXml const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofXml,0))){ SWIG_fail_ptr("Xml_appendChild",1,SWIGTYPE_p_ofXml); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofXml,0))){ SWIG_fail_ptr("Xml_appendChild",2,SWIGTYPE_p_ofXml); }
   result = (arg1)->appendChild((ofXml const &)*arg2); { ofXml * resultptr = new ofXml((const ofXml &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofXml,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Xml_prependChild__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofXml *arg1 = (ofXml *) 0 ; ofXml *arg2 = 0 ;
  ofXml result; SWIG_check_num_args("ofXml::prependChild",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofXml::prependChild",1,"ofXml *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofXml::prependChild",2,"ofXml const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofXml,0))){ SWIG_fail_ptr("Xml_prependChild",1,SWIGTYPE_p_ofXml); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofXml,0))){
    SWIG_fail_ptr("Xml_prependChild",2,SWIGTYPE_p_ofXml); }  result = (arg1)->prependChild((ofXml const &)*arg2); {
    ofXml * resultptr = new ofXml((const ofXml &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofXml,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Xml_appendChild__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofXml *arg1 = (ofXml *) 0 ; std::string *arg2 = 0 ;
  std::string temp2 ; ofXml result; SWIG_check_num_args("ofXml::appendChild",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofXml::appendChild",1,"ofXml *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofXml::appendChild",2,"std::string const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofXml,0))){ SWIG_fail_ptr("Xml_appendChild",1,SWIGTYPE_p_ofXml); }
   temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2; result = (arg1)->appendChild((std::string const &)*arg2); {
    ofXml * resultptr = new ofXml((const ofXml &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofXml,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Xml_appendChild(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 2) { int _v;
    { void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofXml, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofXml, 0)) { _v = 0; }  else {
          _v = 1; }  }  if (_v) { return _wrap_Xml_appendChild__SWIG_0(L);}  }  }  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofXml, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { _v = lua_isstring(L,argv[1]); }  if (_v) { return _wrap_Xml_appendChild__SWIG_1(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Xml_appendChild'\n" "  Possible C/C++ prototypes are:\n"
  "    ofXml::appendChild(ofXml const &)\n" "    ofXml::appendChild(std::string const &)\n"); lua_error(L);return 0; }
static int _wrap_Xml_prependChild__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofXml *arg1 = (ofXml *) 0 ; std::string *arg2 = 0 ;
  std::string temp2 ; ofXml result; SWIG_check_num_args("ofXml::prependChild",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofXml::prependChild",1,"ofXml *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofXml::prependChild",2,"std::string const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofXml,0))){ SWIG_fail_ptr("Xml_prependChild",1,SWIGTYPE_p_ofXml); }
   temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2; result = (arg1)->prependChild((std::string const &)*arg2); {
    ofXml * resultptr = new ofXml((const ofXml &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofXml,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Xml_prependChild(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofXml, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofXml, 0)) { _v = 0; }  else {
          _v = 1; }  }  if (_v) { return _wrap_Xml_prependChild__SWIG_0(L);}  }  }  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofXml, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { _v = lua_isstring(L,argv[1]); }  if (_v) { return _wrap_Xml_prependChild__SWIG_1(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Xml_prependChild'\n" "  Possible C/C++ prototypes are:\n"
  "    ofXml::prependChild(ofXml const &)\n" "    ofXml::prependChild(std::string const &)\n"); lua_error(L);return 0; }
static int _wrap_Xml_removeChild(lua_State* L) { int SWIG_arg = 0; ofXml *arg1 = (ofXml *) 0 ; std::string *arg2 = 0 ;
  std::string temp2 ; bool result; SWIG_check_num_args("ofXml::removeChild",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofXml::removeChild",1,"ofXml *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofXml::removeChild",2,"std::string const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofXml,0))){ SWIG_fail_ptr("Xml_removeChild",1,SWIGTYPE_p_ofXml); }
   temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2; result = (bool)(arg1)->removeChild((std::string const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Xml_insertChildAfter(lua_State* L) { int SWIG_arg = 0; ofXml *arg1 = (ofXml *) 0 ; std::string *arg2 = 0 ;
  ofXml *arg3 = 0 ; std::string temp2 ; ofXml result; SWIG_check_num_args("ofXml::insertChildAfter",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofXml::insertChildAfter",1,"ofXml *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofXml::insertChildAfter",2,"std::string const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofXml::insertChildAfter",3,"ofXml const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofXml,0))){
    SWIG_fail_ptr("Xml_insertChildAfter",1,SWIGTYPE_p_ofXml); }  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_ofXml,0))){
    SWIG_fail_ptr("Xml_insertChildAfter",3,SWIGTYPE_p_ofXml); } 
  result = (arg1)->insertChildAfter((std::string const &)*arg2,(ofXml const &)*arg3); {
    ofXml * resultptr = new ofXml((const ofXml &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofXml,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Xml_insertChildBefore(lua_State* L) { int SWIG_arg = 0; ofXml *arg1 = (ofXml *) 0 ; std::string *arg2 = 0 ;
  ofXml *arg3 = 0 ; std::string temp2 ; ofXml result; SWIG_check_num_args("ofXml::insertChildBefore",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofXml::insertChildBefore",1,"ofXml *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofXml::insertChildBefore",2,"std::string const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("ofXml::insertChildBefore",3,"ofXml const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofXml,0))){
    SWIG_fail_ptr("Xml_insertChildBefore",1,SWIGTYPE_p_ofXml); }  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_ofXml,0))){
    SWIG_fail_ptr("Xml_insertChildBefore",3,SWIGTYPE_p_ofXml); } 
  result = (arg1)->insertChildBefore((std::string const &)*arg2,(ofXml const &)*arg3); {
    ofXml * resultptr = new ofXml((const ofXml &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofXml,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Xml_getNextSibling__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofXml *arg1 = (ofXml *) 0 ; ofXml result;
  SWIG_check_num_args("ofXml::getNextSibling",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofXml::getNextSibling",1,"ofXml const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofXml,0))){
    SWIG_fail_ptr("Xml_getNextSibling",1,SWIGTYPE_p_ofXml); }  result = ((ofXml const *)arg1)->getNextSibling(); {
    ofXml * resultptr = new ofXml((const ofXml &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofXml,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Xml_getPreviousSibling__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofXml *arg1 = (ofXml *) 0 ; ofXml result;
  SWIG_check_num_args("ofXml::getPreviousSibling",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofXml::getPreviousSibling",1,"ofXml const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofXml,0))){
    SWIG_fail_ptr("Xml_getPreviousSibling",1,SWIGTYPE_p_ofXml); }  result = ((ofXml const *)arg1)->getPreviousSibling(); {
    ofXml * resultptr = new ofXml((const ofXml &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofXml,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Xml_getNextSibling__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofXml *arg1 = (ofXml *) 0 ;
  std::string *arg2 = 0 ; std::string temp2 ; ofXml result; SWIG_check_num_args("ofXml::getNextSibling",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofXml::getNextSibling",1,"ofXml const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofXml::getNextSibling",2,"std::string const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofXml,0))){
    SWIG_fail_ptr("Xml_getNextSibling",1,SWIGTYPE_p_ofXml); }  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  result = ((ofXml const *)arg1)->getNextSibling((std::string const &)*arg2); {
    ofXml * resultptr = new ofXml((const ofXml &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofXml,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Xml_getNextSibling(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 1) {
    int _v; { void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofXml, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Xml_getNextSibling__SWIG_0(L);}  }  if (argc == 2) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofXml, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L,argv[1]); }  if (_v) { return _wrap_Xml_getNextSibling__SWIG_1(L);}
       }  }  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Xml_getNextSibling'\n"
  "  Possible C/C++ prototypes are:\n" "    ofXml::getNextSibling() const\n"
  "    ofXml::getNextSibling(std::string const &) const\n"); lua_error(L);return 0; }
static int _wrap_Xml_getPreviousSibling__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofXml *arg1 = (ofXml *) 0 ;
  std::string *arg2 = 0 ; std::string temp2 ; ofXml result; SWIG_check_num_args("ofXml::getPreviousSibling",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofXml::getPreviousSibling",1,"ofXml const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofXml::getPreviousSibling",2,"std::string const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofXml,0))){
    SWIG_fail_ptr("Xml_getPreviousSibling",1,SWIGTYPE_p_ofXml); }  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  result = ((ofXml const *)arg1)->getPreviousSibling((std::string const &)*arg2); {
    ofXml * resultptr = new ofXml((const ofXml &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofXml,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Xml_getPreviousSibling(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 1) {
    int _v; { void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofXml, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_Xml_getPreviousSibling__SWIG_0(L);}  }  if (argc == 2) { int _v;
    { void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofXml, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L,argv[1]); }  if (_v) {
        return _wrap_Xml_getPreviousSibling__SWIG_1(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Xml_getPreviousSibling'\n"
  "  Possible C/C++ prototypes are:\n" "    ofXml::getPreviousSibling() const\n"
  "    ofXml::getPreviousSibling(std::string const &) const\n"); lua_error(L);return 0; }
static int _wrap_Xml_getFirstChild(lua_State* L) { int SWIG_arg = 0; ofXml *arg1 = (ofXml *) 0 ; ofXml result;
  SWIG_check_num_args("ofXml::getFirstChild",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofXml::getFirstChild",1,"ofXml const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofXml,0))){
    SWIG_fail_ptr("Xml_getFirstChild",1,SWIGTYPE_p_ofXml); }  result = ((ofXml const *)arg1)->getFirstChild(); {
    ofXml * resultptr = new ofXml((const ofXml &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofXml,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Xml_getLastChild(lua_State* L) { int SWIG_arg = 0; ofXml *arg1 = (ofXml *) 0 ; ofXml result;
  SWIG_check_num_args("ofXml::getLastChild",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofXml::getLastChild",1,"ofXml const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofXml,0))){ SWIG_fail_ptr("Xml_getLastChild",1,SWIGTYPE_p_ofXml); }
   result = ((ofXml const *)arg1)->getLastChild(); { ofXml * resultptr = new ofXml((const ofXml &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofXml,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Xml_getAttribute(lua_State* L) { int SWIG_arg = 0; ofXml *arg1 = (ofXml *) 0 ; std::string *arg2 = 0 ;
  std::string temp2 ; ofXml::Attribute result; SWIG_check_num_args("ofXml::getAttribute",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofXml::getAttribute",1,"ofXml const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofXml::getAttribute",2,"std::string const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofXml,0))){ SWIG_fail_ptr("Xml_getAttribute",1,SWIGTYPE_p_ofXml); }
   temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  result = ((ofXml const *)arg1)->getAttribute((std::string const &)*arg2); {
    ofXml::Attribute * resultptr = new ofXml::Attribute((const ofXml::Attribute &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofXml__Attribute,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Xml_getAttributes(lua_State* L) { int SWIG_arg = 0; ofXml *arg1 = (ofXml *) 0 ;
  SwigValueWrapper< ofXml::Range< ofXmlIterator< pugi::xml_attribute_iterator > > > result;
  SWIG_check_num_args("ofXml::getAttributes",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofXml::getAttributes",1,"ofXml const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofXml,0))){
    SWIG_fail_ptr("Xml_getAttributes",1,SWIGTYPE_p_ofXml); }  result = ((ofXml const *)arg1)->getAttributes(); {
    ofXml::Range< ofXmlIterator< pugi::xml_attribute_iterator > > * resultptr = new ofXml::Range< ofXmlIterator< pugi::xml_attribute_iterator > >((const ofXml::Range< ofXmlIterator< pugi::xml_attribute_iterator > > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofXml__RangeT_ofXmlIteratorT_pugi__xml_attribute_iterator_t_t,1); SWIG_arg++; }
   return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Xml_getFirstAttribute(lua_State* L) { int SWIG_arg = 0; ofXml *arg1 = (ofXml *) 0 ; ofXml::Attribute result;
  SWIG_check_num_args("ofXml::getFirstAttribute",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofXml::getFirstAttribute",1,"ofXml const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofXml,0))){
    SWIG_fail_ptr("Xml_getFirstAttribute",1,SWIGTYPE_p_ofXml); }  result = ((ofXml const *)arg1)->getFirstAttribute(); {
    ofXml::Attribute * resultptr = new ofXml::Attribute((const ofXml::Attribute &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofXml__Attribute,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Xml_getLastAttribute(lua_State* L) { int SWIG_arg = 0; ofXml *arg1 = (ofXml *) 0 ; ofXml::Attribute result;
  SWIG_check_num_args("ofXml::getLastAttribute",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofXml::getLastAttribute",1,"ofXml const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofXml,0))){
    SWIG_fail_ptr("Xml_getLastAttribute",1,SWIGTYPE_p_ofXml); }  result = ((ofXml const *)arg1)->getLastAttribute(); {
    ofXml::Attribute * resultptr = new ofXml::Attribute((const ofXml::Attribute &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofXml__Attribute,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Xml_appendAttribute(lua_State* L) { int SWIG_arg = 0; ofXml *arg1 = (ofXml *) 0 ; std::string *arg2 = 0 ;
  std::string temp2 ; ofXml::Attribute result; SWIG_check_num_args("ofXml::appendAttribute",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofXml::appendAttribute",1,"ofXml *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofXml::appendAttribute",2,"std::string const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofXml,0))){
    SWIG_fail_ptr("Xml_appendAttribute",1,SWIGTYPE_p_ofXml); }  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  result = (arg1)->appendAttribute((std::string const &)*arg2); {
    ofXml::Attribute * resultptr = new ofXml::Attribute((const ofXml::Attribute &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofXml__Attribute,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Xml_prependAttribute(lua_State* L) { int SWIG_arg = 0; ofXml *arg1 = (ofXml *) 0 ; std::string *arg2 = 0 ;
  std::string temp2 ; ofXml::Attribute result; SWIG_check_num_args("ofXml::prependAttribute",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofXml::prependAttribute",1,"ofXml *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofXml::prependAttribute",2,"std::string const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofXml,0))){
    SWIG_fail_ptr("Xml_prependAttribute",1,SWIGTYPE_p_ofXml); }  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  result = (arg1)->prependAttribute((std::string const &)*arg2); {
    ofXml::Attribute * resultptr = new ofXml::Attribute((const ofXml::Attribute &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofXml__Attribute,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Xml_findFirst(lua_State* L) { int SWIG_arg = 0; ofXml *arg1 = (ofXml *) 0 ; std::string *arg2 = 0 ;
  std::string temp2 ; ofXml result; SWIG_check_num_args("ofXml::findFirst",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofXml::findFirst",1,"ofXml const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofXml::findFirst",2,"std::string const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofXml,0))){ SWIG_fail_ptr("Xml_findFirst",1,SWIGTYPE_p_ofXml); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  result = ((ofXml const *)arg1)->findFirst((std::string const &)*arg2); {
    ofXml * resultptr = new ofXml((const ofXml &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofXml,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Xml_getValue(lua_State* L) { int SWIG_arg = 0; ofXml *arg1 = (ofXml *) 0 ; std::string result;
  SWIG_check_num_args("ofXml::getValue",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofXml::getValue",1,"ofXml const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofXml,0))){ SWIG_fail_ptr("Xml_getValue",1,SWIGTYPE_p_ofXml); } 
  result = ((ofXml const *)arg1)->getValue(); lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Xml_getName(lua_State* L) { int SWIG_arg = 0; ofXml *arg1 = (ofXml *) 0 ; std::string result;
  SWIG_check_num_args("ofXml::getName",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofXml::getName",1,"ofXml const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofXml,0))){ SWIG_fail_ptr("Xml_getName",1,SWIGTYPE_p_ofXml); } 
  result = ((ofXml const *)arg1)->getName(); lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Xml_set(lua_State* L) { int SWIG_arg = 0; ofXml *arg1 = (ofXml *) 0 ; unsigned char *arg2 = 0 ;
  unsigned char temp2 ; SWIG_check_num_args("ofXml::set",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofXml::set",1,"ofXml *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofXml::set",2,"unsigned char const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofXml,0))){ SWIG_fail_ptr("Xml_set",1,SWIGTYPE_p_ofXml); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  temp2=(unsigned char)lua_tonumber(L,2); arg2=&temp2; (arg1)->set((unsigned char const &)*arg2); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Xml_setName(lua_State* L) { int SWIG_arg = 0; ofXml *arg1 = (ofXml *) 0 ; std::string *arg2 = 0 ;
  std::string temp2 ; SWIG_check_num_args("ofXml::setName",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofXml::setName",1,"ofXml *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofXml::setName",2,"std::string const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofXml,0))){ SWIG_fail_ptr("Xml_setName",1,SWIGTYPE_p_ofXml); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2; (arg1)->setName((std::string const &)*arg2); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Xml_getIntValue(lua_State* L) { int SWIG_arg = 0; ofXml *arg1 = (ofXml *) 0 ; int result;
  SWIG_check_num_args("ofXml::getIntValue",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofXml::getIntValue",1,"ofXml const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofXml,0))){ SWIG_fail_ptr("Xml_getIntValue",1,SWIGTYPE_p_ofXml); }
   result = (int)((ofXml const *)arg1)->getIntValue(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Xml_getUintValue(lua_State* L) { int SWIG_arg = 0; ofXml *arg1 = (ofXml *) 0 ; unsigned int result;
  SWIG_check_num_args("ofXml::getUintValue",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofXml::getUintValue",1,"ofXml const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofXml,0))){ SWIG_fail_ptr("Xml_getUintValue",1,SWIGTYPE_p_ofXml); }
   result = (unsigned int)((ofXml const *)arg1)->getUintValue(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Xml_getFloatValue(lua_State* L) { int SWIG_arg = 0; ofXml *arg1 = (ofXml *) 0 ; float result;
  SWIG_check_num_args("ofXml::getFloatValue",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofXml::getFloatValue",1,"ofXml const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofXml,0))){
    SWIG_fail_ptr("Xml_getFloatValue",1,SWIGTYPE_p_ofXml); }  result = (float)((ofXml const *)arg1)->getFloatValue();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Xml_getDoubleValue(lua_State* L) { int SWIG_arg = 0; ofXml *arg1 = (ofXml *) 0 ; double result;
  SWIG_check_num_args("ofXml::getDoubleValue",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofXml::getDoubleValue",1,"ofXml const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofXml,0))){
    SWIG_fail_ptr("Xml_getDoubleValue",1,SWIGTYPE_p_ofXml); }  result = (double)((ofXml const *)arg1)->getDoubleValue();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Xml_getBoolValue(lua_State* L) { int SWIG_arg = 0; ofXml *arg1 = (ofXml *) 0 ; bool result;
  SWIG_check_num_args("ofXml::getBoolValue",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofXml::getBoolValue",1,"ofXml const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofXml,0))){ SWIG_fail_ptr("Xml_getBoolValue",1,SWIGTYPE_p_ofXml); }
   result = (bool)((ofXml const *)arg1)->getBoolValue(); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static void swig_delete_Xml(void *obj) {
ofXml *arg1 = (ofXml *) obj;
delete arg1;
}
static int _proxy__wrap_new_Xml(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_Xml);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_Xml_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_Xml_methods[]= {
    { "load", _wrap_Xml_load},
    { "parse", _wrap_Xml_parse},
    { "save", _wrap_Xml_save},
    { "toString", _wrap_Xml_toString},
    { "getChild", _wrap_Xml_getChild},
    { "getChildren", _wrap_Xml_getChildren},
    { "appendChild", _wrap_Xml_appendChild},
    { "prependChild", _wrap_Xml_prependChild},
    { "removeChild", _wrap_Xml_removeChild},
    { "insertChildAfter", _wrap_Xml_insertChildAfter},
    { "insertChildBefore", _wrap_Xml_insertChildBefore},
    { "getNextSibling", _wrap_Xml_getNextSibling},
    { "getPreviousSibling", _wrap_Xml_getPreviousSibling},
    { "getFirstChild", _wrap_Xml_getFirstChild},
    { "getLastChild", _wrap_Xml_getLastChild},
    { "getAttribute", _wrap_Xml_getAttribute},
    { "getAttributes", _wrap_Xml_getAttributes},
    { "getFirstAttribute", _wrap_Xml_getFirstAttribute},
    { "getLastAttribute", _wrap_Xml_getLastAttribute},
    { "appendAttribute", _wrap_Xml_appendAttribute},
    { "prependAttribute", _wrap_Xml_prependAttribute},
    { "findFirst", _wrap_Xml_findFirst},
    { "getValue", _wrap_Xml_getValue},
    { "getName", _wrap_Xml_getName},
    { "set", _wrap_Xml_set},
    { "setName", _wrap_Xml_setName},
    { "getIntValue", _wrap_Xml_getIntValue},
    { "getUintValue", _wrap_Xml_getUintValue},
    { "getFloatValue", _wrap_Xml_getFloatValue},
    { "getDoubleValue", _wrap_Xml_getDoubleValue},
    { "getBoolValue", _wrap_Xml_getBoolValue},
    {0,0}
};
static swig_lua_method swig_Xml_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_Xml_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_Xml_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_Xml_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_Xml_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_Xml_Sf_SwigStatic = {
    "Xml",
    swig_Xml_Sf_SwigStatic_methods,
    swig_Xml_Sf_SwigStatic_attributes,
    swig_Xml_Sf_SwigStatic_constants,
    swig_Xml_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_Xml_bases[] = {0};
static const char *swig_Xml_base_names[] = {0};
static swig_lua_class _wrap_class_Xml = { "Xml", "Xml", &SWIGTYPE_p_ofXml,_proxy__wrap_new_Xml, swig_delete_Xml, swig_Xml_methods, swig_Xml_attributes, &swig_Xml_Sf_SwigStatic, swig_Xml_meta, swig_Xml_bases, swig_Xml_base_names };

static int _wrap_serialize(lua_State* L) { int SWIG_arg = 0; ofXml *arg1 = 0 ; ofAbstractParameter *arg2 = 0 ;
  SWIG_check_num_args("ofSerialize",2,2) if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofSerialize",1,"ofXml &");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofSerialize",2,"ofAbstractParameter const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofXml,0))){ SWIG_fail_ptr("serialize",1,SWIGTYPE_p_ofXml); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofAbstractParameter,0))){
    SWIG_fail_ptr("serialize",2,SWIGTYPE_p_ofAbstractParameter); }  ofSerialize(*arg1,(ofAbstractParameter const &)*arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_deserialize(lua_State* L) { int SWIG_arg = 0; ofXml *arg1 = 0 ; ofAbstractParameter *arg2 = 0 ;
  SWIG_check_num_args("ofDeserialize",2,2) if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofDeserialize",1,"ofXml const &");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofDeserialize",2,"ofAbstractParameter &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofXml,0))){ SWIG_fail_ptr("deserialize",1,SWIGTYPE_p_ofXml); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofAbstractParameter,0))){
    SWIG_fail_ptr("deserialize",2,SWIGTYPE_p_ofAbstractParameter); }  ofDeserialize((ofXml const &)*arg1,*arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_new_MatrixStack(lua_State* L) { int SWIG_arg = 0; ofAppBaseWindow *arg1 = (ofAppBaseWindow *) 0 ;
  ofMatrixStack *result = 0 ; SWIG_check_num_args("ofMatrixStack::ofMatrixStack",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrixStack::ofMatrixStack",1,"ofAppBaseWindow const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofAppBaseWindow,0))){
    SWIG_fail_ptr("new_MatrixStack",1,SWIGTYPE_p_ofAppBaseWindow); } 
  result = (ofMatrixStack *)new ofMatrixStack((ofAppBaseWindow const *)arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofMatrixStack,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_MatrixStack_setRenderSurface__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofMatrixStack *arg1 = (ofMatrixStack *) 0 ; ofBaseDraws *arg2 = 0 ; SWIG_check_num_args("ofMatrixStack::setRenderSurface",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrixStack::setRenderSurface",1,"ofMatrixStack *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMatrixStack::setRenderSurface",2,"ofBaseDraws const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrixStack,0))){
    SWIG_fail_ptr("MatrixStack_setRenderSurface",1,SWIGTYPE_p_ofMatrixStack); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofBaseDraws,0))){
    SWIG_fail_ptr("MatrixStack_setRenderSurface",2,SWIGTYPE_p_ofBaseDraws); } 
  (arg1)->setRenderSurface((ofBaseDraws const &)*arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_MatrixStack_setRenderSurfaceNoMatrixFlip(lua_State* L) { int SWIG_arg = 0;
  ofMatrixStack *arg1 = (ofMatrixStack *) 0 ; ofBaseDraws *arg2 = 0 ;
  SWIG_check_num_args("ofMatrixStack::setRenderSurfaceNoMatrixFlip",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrixStack::setRenderSurfaceNoMatrixFlip",1,"ofMatrixStack *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMatrixStack::setRenderSurfaceNoMatrixFlip",2,"ofBaseDraws const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrixStack,0))){
    SWIG_fail_ptr("MatrixStack_setRenderSurfaceNoMatrixFlip",1,SWIGTYPE_p_ofMatrixStack); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofBaseDraws,0))){
    SWIG_fail_ptr("MatrixStack_setRenderSurfaceNoMatrixFlip",2,SWIGTYPE_p_ofBaseDraws); } 
  (arg1)->setRenderSurfaceNoMatrixFlip((ofBaseDraws const &)*arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_MatrixStack_setRenderSurface__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofMatrixStack *arg1 = (ofMatrixStack *) 0 ; ofAppBaseWindow *arg2 = 0 ;
  SWIG_check_num_args("ofMatrixStack::setRenderSurface",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrixStack::setRenderSurface",1,"ofMatrixStack *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMatrixStack::setRenderSurface",2,"ofAppBaseWindow const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrixStack,0))){
    SWIG_fail_ptr("MatrixStack_setRenderSurface",1,SWIGTYPE_p_ofMatrixStack); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofAppBaseWindow,0))){
    SWIG_fail_ptr("MatrixStack_setRenderSurface",2,SWIGTYPE_p_ofAppBaseWindow); } 
  (arg1)->setRenderSurface((ofAppBaseWindow const &)*arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_MatrixStack_setRenderSurface(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L);
  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMatrixStack, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofBaseDraws, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_MatrixStack_setRenderSurface__SWIG_0(L);}  }  }  if (argc == 2) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMatrixStack, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofAppBaseWindow, 0)) {
          _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_MatrixStack_setRenderSurface__SWIG_1(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'MatrixStack_setRenderSurface'\n"
  "  Possible C/C++ prototypes are:\n" "    ofMatrixStack::setRenderSurface(ofBaseDraws const &)\n"
  "    ofMatrixStack::setRenderSurface(ofAppBaseWindow const &)\n"); lua_error(L);return 0; }
static int _wrap_MatrixStack_setOrientation(lua_State* L) { int SWIG_arg = 0; ofMatrixStack *arg1 = (ofMatrixStack *) 0 ;
  ofOrientation arg2 ; bool arg3 ; SWIG_check_num_args("ofMatrixStack::setOrientation",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrixStack::setOrientation",1,"ofMatrixStack *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMatrixStack::setOrientation",2,"ofOrientation");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("ofMatrixStack::setOrientation",3,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrixStack,0))){
    SWIG_fail_ptr("MatrixStack_setOrientation",1,SWIGTYPE_p_ofMatrixStack); }  arg2 = (ofOrientation)(int)lua_tonumber(L, 2);
  arg3 = (lua_toboolean(L, 3)!=0); (arg1)->setOrientation(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_MatrixStack_getOrientation(lua_State* L) { int SWIG_arg = 0; ofMatrixStack *arg1 = (ofMatrixStack *) 0 ;
  ofOrientation result; SWIG_check_num_args("ofMatrixStack::getOrientation",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrixStack::getOrientation",1,"ofMatrixStack const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrixStack,0))){
    SWIG_fail_ptr("MatrixStack_getOrientation",1,SWIGTYPE_p_ofMatrixStack); } 
  result = (ofOrientation)((ofMatrixStack const *)arg1)->getOrientation();
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_MatrixStack_viewport(lua_State* L) { int SWIG_arg = 0; ofMatrixStack *arg1 = (ofMatrixStack *) 0 ; float arg2 ;
  float arg3 ; float arg4 ; float arg5 ; bool arg6 ; SWIG_check_num_args("ofMatrixStack::viewport",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrixStack::viewport",1,"ofMatrixStack *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMatrixStack::viewport",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofMatrixStack::viewport",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofMatrixStack::viewport",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofMatrixStack::viewport",5,"float");
  if(!lua_isboolean(L,6)) SWIG_fail_arg("ofMatrixStack::viewport",6,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrixStack,0))){
    SWIG_fail_ptr("MatrixStack_viewport",1,SWIGTYPE_p_ofMatrixStack); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); arg5 = (float)lua_tonumber(L, 5);
  arg6 = (lua_toboolean(L, 6)!=0); (arg1)->viewport(arg2,arg3,arg4,arg5,arg6); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_MatrixStack_nativeViewport(lua_State* L) { int SWIG_arg = 0; ofMatrixStack *arg1 = (ofMatrixStack *) 0 ;
  ofRectangle arg2 ; ofRectangle *argp2 ; SWIG_check_num_args("ofMatrixStack::nativeViewport",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrixStack::nativeViewport",1,"ofMatrixStack *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMatrixStack::nativeViewport",2,"ofRectangle");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrixStack,0))){
    SWIG_fail_ptr("MatrixStack_nativeViewport",1,SWIGTYPE_p_ofMatrixStack); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("MatrixStack_nativeViewport",2,SWIGTYPE_p_ofRectangle); }  arg2 = *argp2; (arg1)->nativeViewport(arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_MatrixStack_getCurrentViewport(lua_State* L) { int SWIG_arg = 0; ofMatrixStack *arg1 = (ofMatrixStack *) 0 ;
  ofRectangle result; SWIG_check_num_args("ofMatrixStack::getCurrentViewport",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrixStack::getCurrentViewport",1,"ofMatrixStack const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrixStack,0))){
    SWIG_fail_ptr("MatrixStack_getCurrentViewport",1,SWIGTYPE_p_ofMatrixStack); } 
  result = ((ofMatrixStack const *)arg1)->getCurrentViewport(); {
    ofRectangle * resultptr = new ofRectangle((const ofRectangle &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofRectangle,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_MatrixStack_getNativeViewport(lua_State* L) { int SWIG_arg = 0; ofMatrixStack *arg1 = (ofMatrixStack *) 0 ;
  ofRectangle result; SWIG_check_num_args("ofMatrixStack::getNativeViewport",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrixStack::getNativeViewport",1,"ofMatrixStack const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrixStack,0))){
    SWIG_fail_ptr("MatrixStack_getNativeViewport",1,SWIGTYPE_p_ofMatrixStack); } 
  result = ((ofMatrixStack const *)arg1)->getNativeViewport(); {
    ofRectangle * resultptr = new ofRectangle((const ofRectangle &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofRectangle,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_MatrixStack_getFullSurfaceViewport(lua_State* L) { int SWIG_arg = 0;
  ofMatrixStack *arg1 = (ofMatrixStack *) 0 ; ofRectangle result;
  SWIG_check_num_args("ofMatrixStack::getFullSurfaceViewport",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrixStack::getFullSurfaceViewport",1,"ofMatrixStack const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrixStack,0))){
    SWIG_fail_ptr("MatrixStack_getFullSurfaceViewport",1,SWIGTYPE_p_ofMatrixStack); } 
  result = ((ofMatrixStack const *)arg1)->getFullSurfaceViewport(); {
    ofRectangle * resultptr = new ofRectangle((const ofRectangle &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofRectangle,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_MatrixStack_getProjectionMatrix(lua_State* L) { int SWIG_arg = 0; ofMatrixStack *arg1 = (ofMatrixStack *) 0 ;
  glm::mat4 *result = 0 ; SWIG_check_num_args("ofMatrixStack::getProjectionMatrix",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrixStack::getProjectionMatrix",1,"ofMatrixStack const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrixStack,0))){
    SWIG_fail_ptr("MatrixStack_getProjectionMatrix",1,SWIGTYPE_p_ofMatrixStack); } 
  result = (glm::mat4 *) &((ofMatrixStack const *)arg1)->getProjectionMatrix();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_glm__mat4,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_MatrixStack_getViewInverse(lua_State* L) { int SWIG_arg = 0; ofMatrixStack *arg1 = (ofMatrixStack *) 0 ;
  glm::mat4 *result = 0 ; SWIG_check_num_args("ofMatrixStack::getViewInverse",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrixStack::getViewInverse",1,"ofMatrixStack const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrixStack,0))){
    SWIG_fail_ptr("MatrixStack_getViewInverse",1,SWIGTYPE_p_ofMatrixStack); } 
  result = (glm::mat4 *) &((ofMatrixStack const *)arg1)->getViewInverse();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_glm__mat4,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_MatrixStack_getViewMatrix(lua_State* L) { int SWIG_arg = 0; ofMatrixStack *arg1 = (ofMatrixStack *) 0 ;
  glm::mat4 *result = 0 ; SWIG_check_num_args("ofMatrixStack::getViewMatrix",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrixStack::getViewMatrix",1,"ofMatrixStack const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrixStack,0))){
    SWIG_fail_ptr("MatrixStack_getViewMatrix",1,SWIGTYPE_p_ofMatrixStack); } 
  result = (glm::mat4 *) &((ofMatrixStack const *)arg1)->getViewMatrix();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_glm__mat4,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_MatrixStack_getModelMatrix(lua_State* L) { int SWIG_arg = 0; ofMatrixStack *arg1 = (ofMatrixStack *) 0 ;
  glm::mat4 *result = 0 ; SWIG_check_num_args("ofMatrixStack::getModelMatrix",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrixStack::getModelMatrix",1,"ofMatrixStack const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrixStack,0))){
    SWIG_fail_ptr("MatrixStack_getModelMatrix",1,SWIGTYPE_p_ofMatrixStack); } 
  result = (glm::mat4 *) &((ofMatrixStack const *)arg1)->getModelMatrix();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_glm__mat4,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_MatrixStack_getModelViewMatrix(lua_State* L) { int SWIG_arg = 0; ofMatrixStack *arg1 = (ofMatrixStack *) 0 ;
  glm::mat4 *result = 0 ; SWIG_check_num_args("ofMatrixStack::getModelViewMatrix",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrixStack::getModelViewMatrix",1,"ofMatrixStack const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrixStack,0))){
    SWIG_fail_ptr("MatrixStack_getModelViewMatrix",1,SWIGTYPE_p_ofMatrixStack); } 
  result = (glm::mat4 *) &((ofMatrixStack const *)arg1)->getModelViewMatrix();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_glm__mat4,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_MatrixStack_getModelViewProjectionMatrix(lua_State* L) { int SWIG_arg = 0;
  ofMatrixStack *arg1 = (ofMatrixStack *) 0 ; glm::mat4 *result = 0 ;
  SWIG_check_num_args("ofMatrixStack::getModelViewProjectionMatrix",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrixStack::getModelViewProjectionMatrix",1,"ofMatrixStack const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrixStack,0))){
    SWIG_fail_ptr("MatrixStack_getModelViewProjectionMatrix",1,SWIGTYPE_p_ofMatrixStack); } 
  result = (glm::mat4 *) &((ofMatrixStack const *)arg1)->getModelViewProjectionMatrix();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_glm__mat4,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_MatrixStack_getTextureMatrix(lua_State* L) { int SWIG_arg = 0; ofMatrixStack *arg1 = (ofMatrixStack *) 0 ;
  glm::mat4 *result = 0 ; SWIG_check_num_args("ofMatrixStack::getTextureMatrix",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrixStack::getTextureMatrix",1,"ofMatrixStack const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrixStack,0))){
    SWIG_fail_ptr("MatrixStack_getTextureMatrix",1,SWIGTYPE_p_ofMatrixStack); } 
  result = (glm::mat4 *) &((ofMatrixStack const *)arg1)->getTextureMatrix();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_glm__mat4,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_MatrixStack_getCurrentMatrix(lua_State* L) { int SWIG_arg = 0; ofMatrixStack *arg1 = (ofMatrixStack *) 0 ;
  glm::mat4 *result = 0 ; SWIG_check_num_args("ofMatrixStack::getCurrentMatrix",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrixStack::getCurrentMatrix",1,"ofMatrixStack const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrixStack,0))){
    SWIG_fail_ptr("MatrixStack_getCurrentMatrix",1,SWIGTYPE_p_ofMatrixStack); } 
  result = (glm::mat4 *) &((ofMatrixStack const *)arg1)->getCurrentMatrix();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_glm__mat4,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_MatrixStack_getProjectionMatrixNoOrientation(lua_State* L) { int SWIG_arg = 0;
  ofMatrixStack *arg1 = (ofMatrixStack *) 0 ; glm::mat4 *result = 0 ;
  SWIG_check_num_args("ofMatrixStack::getProjectionMatrixNoOrientation",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrixStack::getProjectionMatrixNoOrientation",1,"ofMatrixStack const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrixStack,0))){
    SWIG_fail_ptr("MatrixStack_getProjectionMatrixNoOrientation",1,SWIGTYPE_p_ofMatrixStack); } 
  result = (glm::mat4 *) &((ofMatrixStack const *)arg1)->getProjectionMatrixNoOrientation();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_glm__mat4,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_MatrixStack_getOrientationMatrix(lua_State* L) { int SWIG_arg = 0; ofMatrixStack *arg1 = (ofMatrixStack *) 0 ;
  glm::mat4 *result = 0 ; SWIG_check_num_args("ofMatrixStack::getOrientationMatrix",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrixStack::getOrientationMatrix",1,"ofMatrixStack const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrixStack,0))){
    SWIG_fail_ptr("MatrixStack_getOrientationMatrix",1,SWIGTYPE_p_ofMatrixStack); } 
  result = (glm::mat4 *) &((ofMatrixStack const *)arg1)->getOrientationMatrix();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_glm__mat4,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_MatrixStack_getOrientationMatrixInverse(lua_State* L) { int SWIG_arg = 0;
  ofMatrixStack *arg1 = (ofMatrixStack *) 0 ; glm::mat4 *result = 0 ;
  SWIG_check_num_args("ofMatrixStack::getOrientationMatrixInverse",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrixStack::getOrientationMatrixInverse",1,"ofMatrixStack const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrixStack,0))){
    SWIG_fail_ptr("MatrixStack_getOrientationMatrixInverse",1,SWIGTYPE_p_ofMatrixStack); } 
  result = (glm::mat4 *) &((ofMatrixStack const *)arg1)->getOrientationMatrixInverse();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_glm__mat4,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_MatrixStack_getCurrentMatrixMode(lua_State* L) { int SWIG_arg = 0; ofMatrixStack *arg1 = (ofMatrixStack *) 0 ;
  ofMatrixMode result; SWIG_check_num_args("ofMatrixStack::getCurrentMatrixMode",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrixStack::getCurrentMatrixMode",1,"ofMatrixStack const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrixStack,0))){
    SWIG_fail_ptr("MatrixStack_getCurrentMatrixMode",1,SWIGTYPE_p_ofMatrixStack); } 
  result = (ofMatrixMode)((ofMatrixStack const *)arg1)->getCurrentMatrixMode();
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_MatrixStack_getHandedness(lua_State* L) { int SWIG_arg = 0; ofMatrixStack *arg1 = (ofMatrixStack *) 0 ;
  ofHandednessType result; SWIG_check_num_args("ofMatrixStack::getHandedness",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrixStack::getHandedness",1,"ofMatrixStack const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrixStack,0))){
    SWIG_fail_ptr("MatrixStack_getHandedness",1,SWIGTYPE_p_ofMatrixStack); } 
  result = (ofHandednessType)((ofMatrixStack const *)arg1)->getHandedness();
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_MatrixStack_isVFlipped(lua_State* L) { int SWIG_arg = 0; ofMatrixStack *arg1 = (ofMatrixStack *) 0 ;
  bool result; SWIG_check_num_args("ofMatrixStack::isVFlipped",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrixStack::isVFlipped",1,"ofMatrixStack const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrixStack,0))){
    SWIG_fail_ptr("MatrixStack_isVFlipped",1,SWIGTYPE_p_ofMatrixStack); } 
  result = (bool)((ofMatrixStack const *)arg1)->isVFlipped(); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_MatrixStack_customMatrixNeedsFlip(lua_State* L) { int SWIG_arg = 0; ofMatrixStack *arg1 = (ofMatrixStack *) 0 ;
  bool result; SWIG_check_num_args("ofMatrixStack::customMatrixNeedsFlip",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrixStack::customMatrixNeedsFlip",1,"ofMatrixStack const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrixStack,0))){
    SWIG_fail_ptr("MatrixStack_customMatrixNeedsFlip",1,SWIGTYPE_p_ofMatrixStack); } 
  result = (bool)((ofMatrixStack const *)arg1)->customMatrixNeedsFlip(); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_MatrixStack_pushView(lua_State* L) { int SWIG_arg = 0; ofMatrixStack *arg1 = (ofMatrixStack *) 0 ;
  SWIG_check_num_args("ofMatrixStack::pushView",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrixStack::pushView",1,"ofMatrixStack *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrixStack,0))){
    SWIG_fail_ptr("MatrixStack_pushView",1,SWIGTYPE_p_ofMatrixStack); }  (arg1)->pushView(); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_MatrixStack_popView(lua_State* L) { int SWIG_arg = 0; ofMatrixStack *arg1 = (ofMatrixStack *) 0 ;
  SWIG_check_num_args("ofMatrixStack::popView",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrixStack::popView",1,"ofMatrixStack *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrixStack,0))){
    SWIG_fail_ptr("MatrixStack_popView",1,SWIGTYPE_p_ofMatrixStack); }  (arg1)->popView(); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_MatrixStack_pushMatrix(lua_State* L) { int SWIG_arg = 0; ofMatrixStack *arg1 = (ofMatrixStack *) 0 ;
  SWIG_check_num_args("ofMatrixStack::pushMatrix",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrixStack::pushMatrix",1,"ofMatrixStack *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrixStack,0))){
    SWIG_fail_ptr("MatrixStack_pushMatrix",1,SWIGTYPE_p_ofMatrixStack); }  (arg1)->pushMatrix(); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_MatrixStack_popMatrix(lua_State* L) { int SWIG_arg = 0; ofMatrixStack *arg1 = (ofMatrixStack *) 0 ;
  SWIG_check_num_args("ofMatrixStack::popMatrix",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrixStack::popMatrix",1,"ofMatrixStack *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrixStack,0))){
    SWIG_fail_ptr("MatrixStack_popMatrix",1,SWIGTYPE_p_ofMatrixStack); }  (arg1)->popMatrix(); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_MatrixStack_translate__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofMatrixStack *arg1 = (ofMatrixStack *) 0 ;
  float arg2 ; float arg3 ; float arg4 ; SWIG_check_num_args("ofMatrixStack::translate",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrixStack::translate",1,"ofMatrixStack *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMatrixStack::translate",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofMatrixStack::translate",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofMatrixStack::translate",4,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrixStack,0))){
    SWIG_fail_ptr("MatrixStack_translate",1,SWIGTYPE_p_ofMatrixStack); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); (arg1)->translate(arg2,arg3,arg4); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_MatrixStack_translate__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofMatrixStack *arg1 = (ofMatrixStack *) 0 ;
  float arg2 ; float arg3 ; SWIG_check_num_args("ofMatrixStack::translate",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrixStack::translate",1,"ofMatrixStack *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMatrixStack::translate",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofMatrixStack::translate",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrixStack,0))){
    SWIG_fail_ptr("MatrixStack_translate",1,SWIGTYPE_p_ofMatrixStack); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); (arg1)->translate(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_MatrixStack_translate(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L);
  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMatrixStack, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_MatrixStack_translate__SWIG_1(L);}  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMatrixStack, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          { _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_MatrixStack_translate__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'MatrixStack_translate'\n"
  "  Possible C/C++ prototypes are:\n" "    ofMatrixStack::translate(float,float,float)\n"
  "    ofMatrixStack::translate(float,float)\n"); lua_error(L);return 0; }
static int _wrap_MatrixStack_scale__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofMatrixStack *arg1 = (ofMatrixStack *) 0 ;
  float arg2 ; float arg3 ; float arg4 ; SWIG_check_num_args("ofMatrixStack::scale",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrixStack::scale",1,"ofMatrixStack *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMatrixStack::scale",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofMatrixStack::scale",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofMatrixStack::scale",4,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrixStack,0))){
    SWIG_fail_ptr("MatrixStack_scale",1,SWIGTYPE_p_ofMatrixStack); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); (arg1)->scale(arg2,arg3,arg4); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_MatrixStack_scale__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofMatrixStack *arg1 = (ofMatrixStack *) 0 ;
  float arg2 ; float arg3 ; SWIG_check_num_args("ofMatrixStack::scale",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrixStack::scale",1,"ofMatrixStack *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMatrixStack::scale",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofMatrixStack::scale",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrixStack,0))){
    SWIG_fail_ptr("MatrixStack_scale",1,SWIGTYPE_p_ofMatrixStack); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); (arg1)->scale(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_MatrixStack_scale(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L); if (argc == 3) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMatrixStack, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_MatrixStack_scale__SWIG_1(L);}  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofMatrixStack, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          { _v = lua_isnumber(L,argv[3]); }  if (_v) { return _wrap_MatrixStack_scale__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'MatrixStack_scale'\n" "  Possible C/C++ prototypes are:\n"
  "    ofMatrixStack::scale(float,float,float)\n" "    ofMatrixStack::scale(float,float)\n"); lua_error(L);return 0; }
static int _wrap_MatrixStack_rotateRad(lua_State* L) { int SWIG_arg = 0; ofMatrixStack *arg1 = (ofMatrixStack *) 0 ;
  float arg2 ; float arg3 ; float arg4 ; float arg5 ; SWIG_check_num_args("ofMatrixStack::rotateRad",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrixStack::rotateRad",1,"ofMatrixStack *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMatrixStack::rotateRad",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofMatrixStack::rotateRad",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofMatrixStack::rotateRad",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofMatrixStack::rotateRad",5,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrixStack,0))){
    SWIG_fail_ptr("MatrixStack_rotateRad",1,SWIGTYPE_p_ofMatrixStack); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); arg5 = (float)lua_tonumber(L, 5);
  (arg1)->rotateRad(arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_MatrixStack_matrixMode(lua_State* L) { int SWIG_arg = 0; ofMatrixStack *arg1 = (ofMatrixStack *) 0 ;
  ofMatrixMode arg2 ; SWIG_check_num_args("ofMatrixStack::matrixMode",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrixStack::matrixMode",1,"ofMatrixStack *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofMatrixStack::matrixMode",2,"ofMatrixMode");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrixStack,0))){
    SWIG_fail_ptr("MatrixStack_matrixMode",1,SWIGTYPE_p_ofMatrixStack); }  arg2 = (ofMatrixMode)(int)lua_tonumber(L, 2);
  (arg1)->matrixMode(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_MatrixStack_loadIdentityMatrix(lua_State* L) { int SWIG_arg = 0; ofMatrixStack *arg1 = (ofMatrixStack *) 0 ;
  SWIG_check_num_args("ofMatrixStack::loadIdentityMatrix",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrixStack::loadIdentityMatrix",1,"ofMatrixStack *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrixStack,0))){
    SWIG_fail_ptr("MatrixStack_loadIdentityMatrix",1,SWIGTYPE_p_ofMatrixStack); }  (arg1)->loadIdentityMatrix();
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_MatrixStack_loadMatrix(lua_State* L) { int SWIG_arg = 0; ofMatrixStack *arg1 = (ofMatrixStack *) 0 ;
  glm::mat4 *arg2 = 0 ; SWIG_check_num_args("ofMatrixStack::loadMatrix",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrixStack::loadMatrix",1,"ofMatrixStack *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMatrixStack::loadMatrix",2,"glm::mat4 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrixStack,0))){
    SWIG_fail_ptr("MatrixStack_loadMatrix",1,SWIGTYPE_p_ofMatrixStack); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__mat4,0))){
    SWIG_fail_ptr("MatrixStack_loadMatrix",2,SWIGTYPE_p_glm__mat4); }  (arg1)->loadMatrix((glm::mat4 const &)*arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_MatrixStack_multMatrix(lua_State* L) { int SWIG_arg = 0; ofMatrixStack *arg1 = (ofMatrixStack *) 0 ;
  glm::mat4 *arg2 = 0 ; SWIG_check_num_args("ofMatrixStack::multMatrix",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrixStack::multMatrix",1,"ofMatrixStack *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMatrixStack::multMatrix",2,"glm::mat4 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrixStack,0))){
    SWIG_fail_ptr("MatrixStack_multMatrix",1,SWIGTYPE_p_ofMatrixStack); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__mat4,0))){
    SWIG_fail_ptr("MatrixStack_multMatrix",2,SWIGTYPE_p_glm__mat4); }  (arg1)->multMatrix((glm::mat4 const &)*arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_MatrixStack_loadViewMatrix(lua_State* L) { int SWIG_arg = 0; ofMatrixStack *arg1 = (ofMatrixStack *) 0 ;
  glm::mat4 *arg2 = 0 ; SWIG_check_num_args("ofMatrixStack::loadViewMatrix",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrixStack::loadViewMatrix",1,"ofMatrixStack *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMatrixStack::loadViewMatrix",2,"glm::mat4 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrixStack,0))){
    SWIG_fail_ptr("MatrixStack_loadViewMatrix",1,SWIGTYPE_p_ofMatrixStack); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__mat4,0))){
    SWIG_fail_ptr("MatrixStack_loadViewMatrix",2,SWIGTYPE_p_glm__mat4); }  (arg1)->loadViewMatrix((glm::mat4 const &)*arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_MatrixStack_multViewMatrix(lua_State* L) { int SWIG_arg = 0; ofMatrixStack *arg1 = (ofMatrixStack *) 0 ;
  glm::mat4 *arg2 = 0 ; SWIG_check_num_args("ofMatrixStack::multViewMatrix",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrixStack::multViewMatrix",1,"ofMatrixStack *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofMatrixStack::multViewMatrix",2,"glm::mat4 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrixStack,0))){
    SWIG_fail_ptr("MatrixStack_multViewMatrix",1,SWIGTYPE_p_ofMatrixStack); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__mat4,0))){
    SWIG_fail_ptr("MatrixStack_multViewMatrix",2,SWIGTYPE_p_glm__mat4); }  (arg1)->multViewMatrix((glm::mat4 const &)*arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_MatrixStack_clearStacks(lua_State* L) { int SWIG_arg = 0; ofMatrixStack *arg1 = (ofMatrixStack *) 0 ;
  SWIG_check_num_args("ofMatrixStack::clearStacks",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrixStack::clearStacks",1,"ofMatrixStack *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrixStack,0))){
    SWIG_fail_ptr("MatrixStack_clearStacks",1,SWIGTYPE_p_ofMatrixStack); }  (arg1)->clearStacks(); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_MatrixStack_doesHardwareOrientation(lua_State* L) { int SWIG_arg = 0;
  ofMatrixStack *arg1 = (ofMatrixStack *) 0 ; bool result; SWIG_check_num_args("ofMatrixStack::doesHardwareOrientation",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofMatrixStack::doesHardwareOrientation",1,"ofMatrixStack const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofMatrixStack,0))){
    SWIG_fail_ptr("MatrixStack_doesHardwareOrientation",1,SWIGTYPE_p_ofMatrixStack); } 
  result = (bool)((ofMatrixStack const *)arg1)->doesHardwareOrientation(); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static void swig_delete_MatrixStack(void *obj) {
ofMatrixStack *arg1 = (ofMatrixStack *) obj;
delete arg1;
}
static int _proxy__wrap_new_MatrixStack(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_MatrixStack);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_MatrixStack_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_MatrixStack_methods[]= {
    { "setRenderSurfaceNoMatrixFlip", _wrap_MatrixStack_setRenderSurfaceNoMatrixFlip},
    { "setRenderSurface", _wrap_MatrixStack_setRenderSurface},
    { "setOrientation", _wrap_MatrixStack_setOrientation},
    { "getOrientation", _wrap_MatrixStack_getOrientation},
    { "viewport", _wrap_MatrixStack_viewport},
    { "nativeViewport", _wrap_MatrixStack_nativeViewport},
    { "getCurrentViewport", _wrap_MatrixStack_getCurrentViewport},
    { "getNativeViewport", _wrap_MatrixStack_getNativeViewport},
    { "getFullSurfaceViewport", _wrap_MatrixStack_getFullSurfaceViewport},
    { "getProjectionMatrix", _wrap_MatrixStack_getProjectionMatrix},
    { "getViewInverse", _wrap_MatrixStack_getViewInverse},
    { "getViewMatrix", _wrap_MatrixStack_getViewMatrix},
    { "getModelMatrix", _wrap_MatrixStack_getModelMatrix},
    { "getModelViewMatrix", _wrap_MatrixStack_getModelViewMatrix},
    { "getModelViewProjectionMatrix", _wrap_MatrixStack_getModelViewProjectionMatrix},
    { "getTextureMatrix", _wrap_MatrixStack_getTextureMatrix},
    { "getCurrentMatrix", _wrap_MatrixStack_getCurrentMatrix},
    { "getProjectionMatrixNoOrientation", _wrap_MatrixStack_getProjectionMatrixNoOrientation},
    { "getOrientationMatrix", _wrap_MatrixStack_getOrientationMatrix},
    { "getOrientationMatrixInverse", _wrap_MatrixStack_getOrientationMatrixInverse},
    { "getCurrentMatrixMode", _wrap_MatrixStack_getCurrentMatrixMode},
    { "getHandedness", _wrap_MatrixStack_getHandedness},
    { "isVFlipped", _wrap_MatrixStack_isVFlipped},
    { "customMatrixNeedsFlip", _wrap_MatrixStack_customMatrixNeedsFlip},
    { "pushView", _wrap_MatrixStack_pushView},
    { "popView", _wrap_MatrixStack_popView},
    { "pushMatrix", _wrap_MatrixStack_pushMatrix},
    { "popMatrix", _wrap_MatrixStack_popMatrix},
    { "translate", _wrap_MatrixStack_translate},
    { "scale", _wrap_MatrixStack_scale},
    { "rotateRad", _wrap_MatrixStack_rotateRad},
    { "matrixMode", _wrap_MatrixStack_matrixMode},
    { "loadIdentityMatrix", _wrap_MatrixStack_loadIdentityMatrix},
    { "loadMatrix", _wrap_MatrixStack_loadMatrix},
    { "multMatrix", _wrap_MatrixStack_multMatrix},
    { "loadViewMatrix", _wrap_MatrixStack_loadViewMatrix},
    { "multViewMatrix", _wrap_MatrixStack_multViewMatrix},
    { "clearStacks", _wrap_MatrixStack_clearStacks},
    { "doesHardwareOrientation", _wrap_MatrixStack_doesHardwareOrientation},
    {0,0}
};
static swig_lua_method swig_MatrixStack_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_MatrixStack_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_MatrixStack_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_MatrixStack_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_MatrixStack_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_MatrixStack_Sf_SwigStatic = {
    "MatrixStack",
    swig_MatrixStack_Sf_SwigStatic_methods,
    swig_MatrixStack_Sf_SwigStatic_attributes,
    swig_MatrixStack_Sf_SwigStatic_constants,
    swig_MatrixStack_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_MatrixStack_bases[] = {0};
static const char *swig_MatrixStack_base_names[] = {0};
static swig_lua_class _wrap_class_MatrixStack = { "MatrixStack", "MatrixStack", &SWIGTYPE_p_ofMatrixStack,_proxy__wrap_new_MatrixStack, swig_delete_MatrixStack, swig_MatrixStack_methods, swig_MatrixStack_attributes, &swig_MatrixStack_Sf_SwigStatic, swig_MatrixStack_meta, swig_MatrixStack_bases, swig_MatrixStack_base_names };

static int _wrap_new_Buffer__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofBuffer *result = 0 ;
  SWIG_check_num_args("ofBuffer::ofBuffer",0,0) result = (ofBuffer *)new ofBuffer();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofBuffer,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_Buffer__SWIG_1(lua_State* L) { int SWIG_arg = 0; char *arg1 = (char *) 0 ; std::size_t arg2 ;
  ofBuffer *result = 0 ; SWIG_check_num_args("ofBuffer::ofBuffer",1,1) { arg2 = (size_t)lua_tonumber(L, 1+1);
    arg1 = (char *)lua_tolstring(L, 1, &arg2); }  result = (ofBuffer *)new ofBuffer((char const *)arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofBuffer,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_Buffer__SWIG_2(lua_State* L) { int SWIG_arg = 0; std::istream *arg1 = 0 ; std::size_t arg2 ;
  ofBuffer *result = 0 ; SWIG_check_num_args("ofBuffer::ofBuffer",2,2)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofBuffer::ofBuffer",1,"std::istream &");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofBuffer::ofBuffer",2,"std::size_t");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__istream,0))){
    SWIG_fail_ptr("new_Buffer",1,SWIGTYPE_p_std__istream); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (std::size_t)lua_tonumber(L, 2);
  result = (ofBuffer *)new ofBuffer(*arg1,arg2); SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofBuffer,1); SWIG_arg++; 
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_new_Buffer(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 0) {
    return _wrap_new_Buffer__SWIG_0(L);}  if (argc == 1) { int _v; { _v = SWIG_lua_isnilstring(L,argv[0]); }  if (_v) {
      if (argc <= 1) { return _wrap_new_Buffer__SWIG_1(L);}  { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_new_Buffer__SWIG_1(L);}  }  }  if (argc == 2) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_std__istream, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { return _wrap_new_Buffer__SWIG_2(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_Buffer'\n" "  Possible C/C++ prototypes are:\n"
  "    ofBuffer::ofBuffer()\n" "    ofBuffer::ofBuffer(char const *,std::size_t)\n"
  "    ofBuffer::ofBuffer(std::istream &,std::size_t)\n"); lua_error(L);return 0; }
static int _wrap_Buffer_set__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofBuffer *arg1 = (ofBuffer *) 0 ;
  char *arg2 = (char *) 0 ; std::size_t arg3 ; SWIG_check_num_args("ofBuffer::set",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBuffer::set",1,"ofBuffer *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBuffer,0))){ SWIG_fail_ptr("Buffer_set",1,SWIGTYPE_p_ofBuffer); }
   { arg3 = (size_t)lua_tonumber(L, 2+1); arg2 = (char *)lua_tolstring(L, 2, &arg3); }  (arg1)->set((char const *)arg2,arg3);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Buffer_set__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofBuffer *arg1 = (ofBuffer *) 0 ; std::istream *arg2 = 0 ;
  std::size_t arg3 ; bool result; SWIG_check_num_args("ofBuffer::set",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBuffer::set",1,"ofBuffer *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofBuffer::set",2,"std::istream &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofBuffer::set",3,"std::size_t");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBuffer,0))){ SWIG_fail_ptr("Buffer_set",1,SWIGTYPE_p_ofBuffer); }
   if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_std__istream,0))){
    SWIG_fail_ptr("Buffer_set",2,SWIGTYPE_p_std__istream); } 
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative") arg3 = (std::size_t)lua_tonumber(L, 3);
  result = (bool)(arg1)->set(*arg2,arg3); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Buffer_set(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 2) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofBuffer, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = SWIG_lua_isnilstring(L,argv[1]); }  if (_v) { if (argc <= 2) {
          return _wrap_Buffer_set__SWIG_0(L);}  { _v = lua_isnumber(L,argv[2]); }  if (_v) { return _wrap_Buffer_set__SWIG_0(L);}
         }  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofBuffer, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_std__istream, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { return _wrap_Buffer_set__SWIG_1(L);}  }  }
     }  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Buffer_set'\n" "  Possible C/C++ prototypes are:\n"
  "    ofBuffer::set(char const *,std::size_t)\n" "    ofBuffer::set(std::istream &,std::size_t)\n"); lua_error(L);return 0; }
static int _wrap_Buffer_setall(lua_State* L) { int SWIG_arg = 0; ofBuffer *arg1 = (ofBuffer *) 0 ; char arg2 ;
  SWIG_check_num_args("ofBuffer::setall",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBuffer::setall",1,"ofBuffer *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("ofBuffer::setall",2,"char");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBuffer,0))){
    SWIG_fail_ptr("Buffer_setall",1,SWIGTYPE_p_ofBuffer); }  arg2 = (lua_tostring(L, 2))[0]; (arg1)->setall(arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Buffer_append(lua_State* L) { int SWIG_arg = 0; ofBuffer *arg1 = (ofBuffer *) 0 ; char *arg2 = (char *) 0 ;
  std::size_t arg3 ; SWIG_check_num_args("ofBuffer::append",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBuffer::append",1,"ofBuffer *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBuffer,0))){
    SWIG_fail_ptr("Buffer_append",1,SWIGTYPE_p_ofBuffer); }  { arg3 = (size_t)lua_tonumber(L, 2+1);
    arg2 = (char *)lua_tolstring(L, 2, &arg3); }  (arg1)->append((char const *)arg2,arg3); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Buffer_reserve(lua_State* L) { int SWIG_arg = 0; ofBuffer *arg1 = (ofBuffer *) 0 ; std::size_t arg2 ;
  SWIG_check_num_args("ofBuffer::reserve",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBuffer::reserve",1,"ofBuffer *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofBuffer::reserve",2,"std::size_t");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBuffer,0))){
    SWIG_fail_ptr("Buffer_reserve",1,SWIGTYPE_p_ofBuffer); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (std::size_t)lua_tonumber(L, 2);
  (arg1)->reserve(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Buffer_clear(lua_State* L) { int SWIG_arg = 0; ofBuffer *arg1 = (ofBuffer *) 0 ;
  SWIG_check_num_args("ofBuffer::clear",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBuffer::clear",1,"ofBuffer *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBuffer,0))){
    SWIG_fail_ptr("Buffer_clear",1,SWIGTYPE_p_ofBuffer); }  (arg1)->clear(); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Buffer_allocate(lua_State* L) { int SWIG_arg = 0; ofBuffer *arg1 = (ofBuffer *) 0 ; std::size_t arg2 ;
  SWIG_check_num_args("ofBuffer::allocate",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBuffer::allocate",1,"ofBuffer *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofBuffer::allocate",2,"std::size_t");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBuffer,0))){
    SWIG_fail_ptr("Buffer_allocate",1,SWIGTYPE_p_ofBuffer); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (std::size_t)lua_tonumber(L, 2);
  (arg1)->allocate(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Buffer_resize(lua_State* L) { int SWIG_arg = 0; ofBuffer *arg1 = (ofBuffer *) 0 ; std::size_t arg2 ;
  SWIG_check_num_args("ofBuffer::resize",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBuffer::resize",1,"ofBuffer *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofBuffer::resize",2,"std::size_t");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBuffer,0))){
    SWIG_fail_ptr("Buffer_resize",1,SWIGTYPE_p_ofBuffer); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (std::size_t)lua_tonumber(L, 2);
  (arg1)->resize(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Buffer_getData(lua_State* L) { int SWIG_arg = 0; ofBuffer *arg1 = (ofBuffer *) 0 ; char *result = 0 ;
  SWIG_check_num_args("ofBuffer::getData",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBuffer::getData",1,"ofBuffer const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBuffer,0))){
    SWIG_fail_ptr("Buffer_getData",1,SWIGTYPE_p_ofBuffer); }  result = (char *)((ofBuffer const *)arg1)->getData();
  lua_pushstring(L,(const char *)result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Buffer_getText(lua_State* L) { int SWIG_arg = 0; ofBuffer *arg1 = (ofBuffer *) 0 ; std::string result;
  SWIG_check_num_args("ofBuffer::getText",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBuffer::getText",1,"ofBuffer const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBuffer,0))){
    SWIG_fail_ptr("Buffer_getText",1,SWIGTYPE_p_ofBuffer); }  result = ((ofBuffer const *)arg1)->getText();
  lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Buffer_size(lua_State* L) { int SWIG_arg = 0; ofBuffer *arg1 = (ofBuffer *) 0 ; std::size_t result;
  SWIG_check_num_args("ofBuffer::size",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofBuffer::size",1,"ofBuffer const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofBuffer,0))){
    SWIG_fail_ptr("Buffer_size",1,SWIGTYPE_p_ofBuffer); }  result = (std::size_t)((ofBuffer const *)arg1)->size();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static void swig_delete_Buffer(void *obj) {
ofBuffer *arg1 = (ofBuffer *) obj;
delete arg1;
}
static int _proxy__wrap_new_Buffer(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_Buffer);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_Buffer_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_Buffer_methods[]= {
    { "set", _wrap_Buffer_set},
    { "setall", _wrap_Buffer_setall},
    { "append", _wrap_Buffer_append},
    { "reserve", _wrap_Buffer_reserve},
    { "clear", _wrap_Buffer_clear},
    { "allocate", _wrap_Buffer_allocate},
    { "resize", _wrap_Buffer_resize},
    { "getData", _wrap_Buffer_getData},
    { "getText", _wrap_Buffer_getText},
    { "size", _wrap_Buffer_size},
    {0,0}
};
static swig_lua_method swig_Buffer_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_Buffer_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_Buffer_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_Buffer_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_Buffer_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_Buffer_Sf_SwigStatic = {
    "Buffer",
    swig_Buffer_Sf_SwigStatic_methods,
    swig_Buffer_Sf_SwigStatic_attributes,
    swig_Buffer_Sf_SwigStatic_constants,
    swig_Buffer_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_Buffer_bases[] = {0};
static const char *swig_Buffer_base_names[] = {0};
static swig_lua_class _wrap_class_Buffer = { "Buffer", "Buffer", &SWIGTYPE_p_ofBuffer,_proxy__wrap_new_Buffer, swig_delete_Buffer, swig_Buffer_methods, swig_Buffer_attributes, &swig_Buffer_Sf_SwigStatic, swig_Buffer_meta, swig_Buffer_bases, swig_Buffer_base_names };

static int _wrap_bufferFromFile__SWIG_0(lua_State* L) { int SWIG_arg = 0; std::filesystem::path *arg1 = 0 ; bool arg2 ;
  std::filesystem::path temp1 ; ofBuffer result; SWIG_check_num_args("ofBufferFromFile",2,2)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofBufferFromFile",1,"std::filesystem::path const &");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofBufferFromFile",2,"bool"); { size_t len = lua_rawlen(L, 1);
    temp1 = lua_tolstring(L, 1, &len); arg1 = &temp1; }  arg2 = (lua_toboolean(L, 2)!=0);
  result = ofBufferFromFile((boost::filesystem::path const &)*arg1,arg2); {
    ofBuffer * resultptr = new ofBuffer((const ofBuffer &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofBuffer,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_bufferFromFile__SWIG_1(lua_State* L) { int SWIG_arg = 0; std::filesystem::path *arg1 = 0 ;
  std::filesystem::path temp1 ; ofBuffer result; SWIG_check_num_args("ofBufferFromFile",1,1)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofBufferFromFile",1,"std::filesystem::path const &"); { size_t len = lua_rawlen(L, 1);
    temp1 = lua_tolstring(L, 1, &len); arg1 = &temp1; }  result = ofBufferFromFile((boost::filesystem::path const &)*arg1); {
    ofBuffer * resultptr = new ofBuffer((const ofBuffer &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofBuffer,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_bufferFromFile(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 1) { int _v;
    { _v = lua_isstring(L, argv[0]); }  if (_v) { return _wrap_bufferFromFile__SWIG_1(L);}  }  if (argc == 2) { int _v; {
      _v = lua_isstring(L, argv[0]); }  if (_v) { { _v = lua_isboolean(L,argv[1]); }  if (_v) {
        return _wrap_bufferFromFile__SWIG_0(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'bufferFromFile'\n" "  Possible C/C++ prototypes are:\n"
  "    ofBufferFromFile(std::filesystem::path const &,bool)\n" "    ofBufferFromFile(std::filesystem::path const &)\n");
  lua_error(L);return 0; }
static int _wrap_bufferToFile__SWIG_0(lua_State* L) { int SWIG_arg = 0; std::filesystem::path *arg1 = 0 ; ofBuffer *arg2 = 0 ;
  bool arg3 ; std::filesystem::path temp1 ; bool result; SWIG_check_num_args("ofBufferToFile",3,3)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofBufferToFile",1,"std::filesystem::path const &");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofBufferToFile",2,"ofBuffer const &");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("ofBufferToFile",3,"bool"); { size_t len = lua_rawlen(L, 1);
    temp1 = lua_tolstring(L, 1, &len); arg1 = &temp1; } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofBuffer,0))){
    SWIG_fail_ptr("bufferToFile",2,SWIGTYPE_p_ofBuffer); }  arg3 = (lua_toboolean(L, 3)!=0);
  result = (bool)ofBufferToFile((boost::filesystem::path const &)*arg1,(ofBuffer const &)*arg2,arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_bufferToFile__SWIG_1(lua_State* L) { int SWIG_arg = 0; std::filesystem::path *arg1 = 0 ; ofBuffer *arg2 = 0 ;
  std::filesystem::path temp1 ; bool result; SWIG_check_num_args("ofBufferToFile",2,2)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofBufferToFile",1,"std::filesystem::path const &");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofBufferToFile",2,"ofBuffer const &"); { size_t len = lua_rawlen(L, 1);
    temp1 = lua_tolstring(L, 1, &len); arg1 = &temp1; } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofBuffer,0))){
    SWIG_fail_ptr("bufferToFile",2,SWIGTYPE_p_ofBuffer); } 
  result = (bool)ofBufferToFile((boost::filesystem::path const &)*arg1,(ofBuffer const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_bufferToFile(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 2) { int _v;
    { _v = lua_isstring(L, argv[0]); }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofBuffer, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_bufferToFile__SWIG_1(L);}  }  }  if (argc == 3) { int _v; {
      _v = lua_isstring(L, argv[0]); }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofBuffer, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isboolean(L,argv[2]); }  if (_v) { return _wrap_bufferToFile__SWIG_0(L);}  }
       }  }  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'bufferToFile'\n"
  "  Possible C/C++ prototypes are:\n" "    ofBufferToFile(std::filesystem::path const &,ofBuffer const &,bool)\n"
  "    ofBufferToFile(std::filesystem::path const &,ofBuffer const &)\n"); lua_error(L);return 0; }
static int _wrap_FilePath_getFileExt(lua_State* L) { int SWIG_arg = 0; std::filesystem::path *arg1 = 0 ;
  std::filesystem::path temp1 ; std::string result; SWIG_check_num_args("ofFilePath::getFileExt",1,1)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofFilePath::getFileExt",1,"std::filesystem::path const &"); {
    size_t len = lua_rawlen(L, 1); temp1 = lua_tolstring(L, 1, &len); arg1 = &temp1; } 
  result = ofFilePath::getFileExt((boost::filesystem::path const &)*arg1);
  lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_FilePath_removeExt(lua_State* L) { int SWIG_arg = 0; std::filesystem::path *arg1 = 0 ;
  std::filesystem::path temp1 ; std::string result; SWIG_check_num_args("ofFilePath::removeExt",1,1)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofFilePath::removeExt",1,"std::filesystem::path const &"); {
    size_t len = lua_rawlen(L, 1); temp1 = lua_tolstring(L, 1, &len); arg1 = &temp1; } 
  result = ofFilePath::removeExt((boost::filesystem::path const &)*arg1);
  lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_FilePath_addLeadingSlash(lua_State* L) { int SWIG_arg = 0; std::filesystem::path *arg1 = 0 ;
  std::filesystem::path temp1 ; std::string result; SWIG_check_num_args("ofFilePath::addLeadingSlash",1,1)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofFilePath::addLeadingSlash",1,"std::filesystem::path const &"); {
    size_t len = lua_rawlen(L, 1); temp1 = lua_tolstring(L, 1, &len); arg1 = &temp1; } 
  result = ofFilePath::addLeadingSlash((boost::filesystem::path const &)*arg1);
  lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_FilePath_addTrailingSlash(lua_State* L) { int SWIG_arg = 0; std::filesystem::path *arg1 = 0 ;
  std::filesystem::path temp1 ; std::string result; SWIG_check_num_args("ofFilePath::addTrailingSlash",1,1)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofFilePath::addTrailingSlash",1,"std::filesystem::path const &"); {
    size_t len = lua_rawlen(L, 1); temp1 = lua_tolstring(L, 1, &len); arg1 = &temp1; } 
  result = ofFilePath::addTrailingSlash((boost::filesystem::path const &)*arg1);
  lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_FilePath_removeTrailingSlash(lua_State* L) { int SWIG_arg = 0; std::filesystem::path *arg1 = 0 ;
  std::filesystem::path temp1 ; std::string result; SWIG_check_num_args("ofFilePath::removeTrailingSlash",1,1)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofFilePath::removeTrailingSlash",1,"std::filesystem::path const &"); {
    size_t len = lua_rawlen(L, 1); temp1 = lua_tolstring(L, 1, &len); arg1 = &temp1; } 
  result = ofFilePath::removeTrailingSlash((boost::filesystem::path const &)*arg1);
  lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_FilePath_getPathForDirectory(lua_State* L) { int SWIG_arg = 0; std::filesystem::path *arg1 = 0 ;
  std::filesystem::path temp1 ; std::string result; SWIG_check_num_args("ofFilePath::getPathForDirectory",1,1)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofFilePath::getPathForDirectory",1,"std::filesystem::path const &"); {
    size_t len = lua_rawlen(L, 1); temp1 = lua_tolstring(L, 1, &len); arg1 = &temp1; } 
  result = ofFilePath::getPathForDirectory((boost::filesystem::path const &)*arg1);
  lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_FilePath_getAbsolutePath__SWIG_0(lua_State* L) { int SWIG_arg = 0; std::filesystem::path *arg1 = 0 ;
  bool arg2 ; std::filesystem::path temp1 ; std::string result; SWIG_check_num_args("ofFilePath::getAbsolutePath",2,2)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofFilePath::getAbsolutePath",1,"std::filesystem::path const &");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofFilePath::getAbsolutePath",2,"bool"); { size_t len = lua_rawlen(L, 1);
    temp1 = lua_tolstring(L, 1, &len); arg1 = &temp1; }  arg2 = (lua_toboolean(L, 2)!=0);
  result = ofFilePath::getAbsolutePath((boost::filesystem::path const &)*arg1,arg2);
  lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_FilePath_getAbsolutePath__SWIG_1(lua_State* L) { int SWIG_arg = 0; std::filesystem::path *arg1 = 0 ;
  std::filesystem::path temp1 ; std::string result; SWIG_check_num_args("ofFilePath::getAbsolutePath",1,1)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofFilePath::getAbsolutePath",1,"std::filesystem::path const &"); {
    size_t len = lua_rawlen(L, 1); temp1 = lua_tolstring(L, 1, &len); arg1 = &temp1; } 
  result = ofFilePath::getAbsolutePath((boost::filesystem::path const &)*arg1);
  lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_FilePath_getAbsolutePath(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L);
  if (argc == 1) { int _v; { _v = lua_isstring(L, argv[0]); }  if (_v) { return _wrap_FilePath_getAbsolutePath__SWIG_1(L);}  } 
  if (argc == 2) { int _v; { _v = lua_isstring(L, argv[0]); }  if (_v) { { _v = lua_isboolean(L,argv[1]); }  if (_v) {
        return _wrap_FilePath_getAbsolutePath__SWIG_0(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'FilePath_getAbsolutePath'\n"
  "  Possible C/C++ prototypes are:\n" "    ofFilePath::getAbsolutePath(std::filesystem::path const &,bool)\n"
  "    ofFilePath::getAbsolutePath(std::filesystem::path const &)\n"); lua_error(L);return 0; }
static int _wrap_FilePath_isAbsolute(lua_State* L) { int SWIG_arg = 0; std::filesystem::path *arg1 = 0 ;
  std::filesystem::path temp1 ; bool result; SWIG_check_num_args("ofFilePath::isAbsolute",1,1)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofFilePath::isAbsolute",1,"std::filesystem::path const &"); {
    size_t len = lua_rawlen(L, 1); temp1 = lua_tolstring(L, 1, &len); arg1 = &temp1; } 
  result = (bool)ofFilePath::isAbsolute((boost::filesystem::path const &)*arg1);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FilePath_getFileName__SWIG_0(lua_State* L) { int SWIG_arg = 0; std::filesystem::path *arg1 = 0 ; bool arg2 ;
  std::filesystem::path temp1 ; std::string result; SWIG_check_num_args("ofFilePath::getFileName",2,2)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofFilePath::getFileName",1,"std::filesystem::path const &");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofFilePath::getFileName",2,"bool"); { size_t len = lua_rawlen(L, 1);
    temp1 = lua_tolstring(L, 1, &len); arg1 = &temp1; }  arg2 = (lua_toboolean(L, 2)!=0);
  result = ofFilePath::getFileName((boost::filesystem::path const &)*arg1,arg2);
  lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_FilePath_getFileName__SWIG_1(lua_State* L) { int SWIG_arg = 0; std::filesystem::path *arg1 = 0 ;
  std::filesystem::path temp1 ; std::string result; SWIG_check_num_args("ofFilePath::getFileName",1,1)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofFilePath::getFileName",1,"std::filesystem::path const &"); {
    size_t len = lua_rawlen(L, 1); temp1 = lua_tolstring(L, 1, &len); arg1 = &temp1; } 
  result = ofFilePath::getFileName((boost::filesystem::path const &)*arg1);
  lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_FilePath_getFileName(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 1) {
    int _v; { _v = lua_isstring(L, argv[0]); }  if (_v) { return _wrap_FilePath_getFileName__SWIG_1(L);}  }  if (argc == 2) {
    int _v; { _v = lua_isstring(L, argv[0]); }  if (_v) { { _v = lua_isboolean(L,argv[1]); }  if (_v) {
        return _wrap_FilePath_getFileName__SWIG_0(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'FilePath_getFileName'\n"
  "  Possible C/C++ prototypes are:\n" "    ofFilePath::getFileName(std::filesystem::path const &,bool)\n"
  "    ofFilePath::getFileName(std::filesystem::path const &)\n"); lua_error(L);return 0; }
static int _wrap_FilePath_getBaseName(lua_State* L) { int SWIG_arg = 0; std::filesystem::path *arg1 = 0 ;
  std::filesystem::path temp1 ; std::string result; SWIG_check_num_args("ofFilePath::getBaseName",1,1)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofFilePath::getBaseName",1,"std::filesystem::path const &"); {
    size_t len = lua_rawlen(L, 1); temp1 = lua_tolstring(L, 1, &len); arg1 = &temp1; } 
  result = ofFilePath::getBaseName((boost::filesystem::path const &)*arg1);
  lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_FilePath_getEnclosingDirectory__SWIG_0(lua_State* L) { int SWIG_arg = 0; std::filesystem::path *arg1 = 0 ;
  bool arg2 ; std::filesystem::path temp1 ; std::string result; SWIG_check_num_args("ofFilePath::getEnclosingDirectory",2,2)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofFilePath::getEnclosingDirectory",1,"std::filesystem::path const &");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofFilePath::getEnclosingDirectory",2,"bool"); { size_t len = lua_rawlen(L, 1);
    temp1 = lua_tolstring(L, 1, &len); arg1 = &temp1; }  arg2 = (lua_toboolean(L, 2)!=0);
  result = ofFilePath::getEnclosingDirectory((boost::filesystem::path const &)*arg1,arg2);
  lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_FilePath_getEnclosingDirectory__SWIG_1(lua_State* L) { int SWIG_arg = 0; std::filesystem::path *arg1 = 0 ;
  std::filesystem::path temp1 ; std::string result; SWIG_check_num_args("ofFilePath::getEnclosingDirectory",1,1)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofFilePath::getEnclosingDirectory",1,"std::filesystem::path const &"); {
    size_t len = lua_rawlen(L, 1); temp1 = lua_tolstring(L, 1, &len); arg1 = &temp1; } 
  result = ofFilePath::getEnclosingDirectory((boost::filesystem::path const &)*arg1);
  lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_FilePath_getEnclosingDirectory(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L);
  if (argc == 1) { int _v; { _v = lua_isstring(L, argv[0]); }  if (_v) { return _wrap_FilePath_getEnclosingDirectory__SWIG_1(L);}
     }  if (argc == 2) { int _v; { _v = lua_isstring(L, argv[0]); }  if (_v) { { _v = lua_isboolean(L,argv[1]); }  if (_v) {
        return _wrap_FilePath_getEnclosingDirectory__SWIG_0(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'FilePath_getEnclosingDirectory'\n"
  "  Possible C/C++ prototypes are:\n" "    ofFilePath::getEnclosingDirectory(std::filesystem::path const &,bool)\n"
  "    ofFilePath::getEnclosingDirectory(std::filesystem::path const &)\n"); lua_error(L);return 0; }
static int _wrap_FilePath_createEnclosingDirectory__SWIG_0(lua_State* L) { int SWIG_arg = 0; std::filesystem::path *arg1 = 0 ;
  bool arg2 ; bool arg3 ; std::filesystem::path temp1 ; bool result;
  SWIG_check_num_args("ofFilePath::createEnclosingDirectory",3,3)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofFilePath::createEnclosingDirectory",1,"std::filesystem::path const &");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofFilePath::createEnclosingDirectory",2,"bool");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("ofFilePath::createEnclosingDirectory",3,"bool"); { size_t len = lua_rawlen(L, 1);
    temp1 = lua_tolstring(L, 1, &len); arg1 = &temp1; }  arg2 = (lua_toboolean(L, 2)!=0); arg3 = (lua_toboolean(L, 3)!=0);
  result = (bool)ofFilePath::createEnclosingDirectory((boost::filesystem::path const &)*arg1,arg2,arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FilePath_createEnclosingDirectory__SWIG_1(lua_State* L) { int SWIG_arg = 0; std::filesystem::path *arg1 = 0 ;
  bool arg2 ; std::filesystem::path temp1 ; bool result; SWIG_check_num_args("ofFilePath::createEnclosingDirectory",2,2)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofFilePath::createEnclosingDirectory",1,"std::filesystem::path const &");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofFilePath::createEnclosingDirectory",2,"bool"); { size_t len = lua_rawlen(L, 1);
    temp1 = lua_tolstring(L, 1, &len); arg1 = &temp1; }  arg2 = (lua_toboolean(L, 2)!=0);
  result = (bool)ofFilePath::createEnclosingDirectory((boost::filesystem::path const &)*arg1,arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FilePath_createEnclosingDirectory__SWIG_2(lua_State* L) { int SWIG_arg = 0; std::filesystem::path *arg1 = 0 ;
  std::filesystem::path temp1 ; bool result; SWIG_check_num_args("ofFilePath::createEnclosingDirectory",1,1)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofFilePath::createEnclosingDirectory",1,"std::filesystem::path const &"); {
    size_t len = lua_rawlen(L, 1); temp1 = lua_tolstring(L, 1, &len); arg1 = &temp1; } 
  result = (bool)ofFilePath::createEnclosingDirectory((boost::filesystem::path const &)*arg1);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FilePath_createEnclosingDirectory(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L);
  if (argc == 1) { int _v; { _v = lua_isstring(L, argv[0]); }  if (_v) {
      return _wrap_FilePath_createEnclosingDirectory__SWIG_2(L);}  }  if (argc == 2) { int _v; { _v = lua_isstring(L, argv[0]); }
     if (_v) { { _v = lua_isboolean(L,argv[1]); }  if (_v) { return _wrap_FilePath_createEnclosingDirectory__SWIG_1(L);}  }  } 
  if (argc == 3) { int _v; { _v = lua_isstring(L, argv[0]); }  if (_v) { { _v = lua_isboolean(L,argv[1]); }  if (_v) { {
          _v = lua_isboolean(L,argv[2]); }  if (_v) { return _wrap_FilePath_createEnclosingDirectory__SWIG_0(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'FilePath_createEnclosingDirectory'\n"
  "  Possible C/C++ prototypes are:\n" "    ofFilePath::createEnclosingDirectory(std::filesystem::path const &,bool,bool)\n"
  "    ofFilePath::createEnclosingDirectory(std::filesystem::path const &,bool)\n"
  "    ofFilePath::createEnclosingDirectory(std::filesystem::path const &)\n"); lua_error(L);return 0; }
static int _wrap_FilePath_getCurrentWorkingDirectory(lua_State* L) { int SWIG_arg = 0; std::string result;
  SWIG_check_num_args("ofFilePath::getCurrentWorkingDirectory",0,0) result = ofFilePath::getCurrentWorkingDirectory();
  lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_FilePath_join(lua_State* L) { int SWIG_arg = 0; std::filesystem::path *arg1 = 0 ;
  std::filesystem::path *arg2 = 0 ; std::filesystem::path temp1 ; std::filesystem::path temp2 ; std::string result;
  SWIG_check_num_args("ofFilePath::join",2,2)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofFilePath::join",1,"std::filesystem::path const &");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofFilePath::join",2,"std::filesystem::path const &"); { size_t len = lua_rawlen(L, 1);
    temp1 = lua_tolstring(L, 1, &len); arg1 = &temp1; }  { size_t len = lua_rawlen(L, 2); temp2 = lua_tolstring(L, 2, &len);
    arg2 = &temp2; }  result = ofFilePath::join((boost::filesystem::path const &)*arg1,(boost::filesystem::path const &)*arg2);
  lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_FilePath_getCurrentExePath(lua_State* L) { int SWIG_arg = 0; std::string result;
  SWIG_check_num_args("ofFilePath::getCurrentExePath",0,0) result = ofFilePath::getCurrentExePath();
  lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_FilePath_getCurrentExeDir(lua_State* L) { int SWIG_arg = 0; std::string result;
  SWIG_check_num_args("ofFilePath::getCurrentExeDir",0,0) result = ofFilePath::getCurrentExeDir();
  lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_FilePath_getUserHomeDir(lua_State* L) { int SWIG_arg = 0; std::string result;
  SWIG_check_num_args("ofFilePath::getUserHomeDir",0,0) result = ofFilePath::getUserHomeDir();
  lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_FilePath_makeRelative(lua_State* L) { int SWIG_arg = 0; std::filesystem::path *arg1 = 0 ;
  std::filesystem::path *arg2 = 0 ; std::filesystem::path temp1 ; std::filesystem::path temp2 ; std::string result;
  SWIG_check_num_args("ofFilePath::makeRelative",2,2)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofFilePath::makeRelative",1,"std::filesystem::path const &");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofFilePath::makeRelative",2,"std::filesystem::path const &"); {
    size_t len = lua_rawlen(L, 1); temp1 = lua_tolstring(L, 1, &len); arg1 = &temp1; }  { size_t len = lua_rawlen(L, 2);
    temp2 = lua_tolstring(L, 2, &len); arg2 = &temp2; } 
  result = ofFilePath::makeRelative((boost::filesystem::path const &)*arg1,(boost::filesystem::path const &)*arg2);
  lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_FilePath(lua_State* L) { int SWIG_arg = 0; ofFilePath *result = 0 ;
  SWIG_check_num_args("ofFilePath::ofFilePath",0,0) result = (ofFilePath *)new ofFilePath();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofFilePath,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static void swig_delete_FilePath(void *obj) {
ofFilePath *arg1 = (ofFilePath *) obj;
delete arg1;
}
static int _proxy__wrap_new_FilePath(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_FilePath);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_FilePath_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_FilePath_methods[]= {
    {0,0}
};
static swig_lua_method swig_FilePath_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_FilePath_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_FilePath_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_FilePath_Sf_SwigStatic_methods[]= {
    { "getFileExt", _wrap_FilePath_getFileExt},
    { "removeExt", _wrap_FilePath_removeExt},
    { "addLeadingSlash", _wrap_FilePath_addLeadingSlash},
    { "addTrailingSlash", _wrap_FilePath_addTrailingSlash},
    { "removeTrailingSlash", _wrap_FilePath_removeTrailingSlash},
    { "getPathForDirectory", _wrap_FilePath_getPathForDirectory},
    { "getAbsolutePath", _wrap_FilePath_getAbsolutePath},
    { "isAbsolute", _wrap_FilePath_isAbsolute},
    { "getFileName", _wrap_FilePath_getFileName},
    { "getBaseName", _wrap_FilePath_getBaseName},
    { "getEnclosingDirectory", _wrap_FilePath_getEnclosingDirectory},
    { "createEnclosingDirectory", _wrap_FilePath_createEnclosingDirectory},
    { "getCurrentWorkingDirectory", _wrap_FilePath_getCurrentWorkingDirectory},
    { "join", _wrap_FilePath_join},
    { "getCurrentExePath", _wrap_FilePath_getCurrentExePath},
    { "getCurrentExeDir", _wrap_FilePath_getCurrentExeDir},
    { "getUserHomeDir", _wrap_FilePath_getUserHomeDir},
    { "makeRelative", _wrap_FilePath_makeRelative},
    {0,0}
};
static swig_lua_class* swig_FilePath_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_FilePath_Sf_SwigStatic = {
    "FilePath",
    swig_FilePath_Sf_SwigStatic_methods,
    swig_FilePath_Sf_SwigStatic_attributes,
    swig_FilePath_Sf_SwigStatic_constants,
    swig_FilePath_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_FilePath_bases[] = {0};
static const char *swig_FilePath_base_names[] = {0};
static swig_lua_class _wrap_class_FilePath = { "FilePath", "FilePath", &SWIGTYPE_p_ofFilePath,_proxy__wrap_new_FilePath, swig_delete_FilePath, swig_FilePath_methods, swig_FilePath_attributes, &swig_FilePath_Sf_SwigStatic, swig_FilePath_meta, swig_FilePath_bases, swig_FilePath_base_names };

static int _wrap_new_File__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofFile *result = 0 ;
  SWIG_check_num_args("ofFile::ofFile",0,0) result = (ofFile *)new ofFile();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofFile,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_File__SWIG_1(lua_State* L) { int SWIG_arg = 0; std::filesystem::path *arg1 = 0 ; ofFile::Mode arg2 ;
  bool arg3 ; std::filesystem::path temp1 ; ofFile *result = 0 ; SWIG_check_num_args("ofFile::ofFile",3,3)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofFile::ofFile",1,"std::filesystem::path const &");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofFile::ofFile",2,"ofFile::Mode");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("ofFile::ofFile",3,"bool"); { size_t len = lua_rawlen(L, 1);
    temp1 = lua_tolstring(L, 1, &len); arg1 = &temp1; }  arg2 = (ofFile::Mode)(int)lua_tonumber(L, 2);
  arg3 = (lua_toboolean(L, 3)!=0); result = (ofFile *)new ofFile((std::filesystem::path const &)*arg1,arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofFile,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_File__SWIG_2(lua_State* L) { int SWIG_arg = 0; std::filesystem::path *arg1 = 0 ; ofFile::Mode arg2 ;
  std::filesystem::path temp1 ; ofFile *result = 0 ; SWIG_check_num_args("ofFile::ofFile",2,2)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofFile::ofFile",1,"std::filesystem::path const &");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofFile::ofFile",2,"ofFile::Mode"); { size_t len = lua_rawlen(L, 1);
    temp1 = lua_tolstring(L, 1, &len); arg1 = &temp1; }  arg2 = (ofFile::Mode)(int)lua_tonumber(L, 2);
  result = (ofFile *)new ofFile((std::filesystem::path const &)*arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofFile,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_File__SWIG_3(lua_State* L) { int SWIG_arg = 0; std::filesystem::path *arg1 = 0 ;
  std::filesystem::path temp1 ; ofFile *result = 0 ; SWIG_check_num_args("ofFile::ofFile",1,1)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofFile::ofFile",1,"std::filesystem::path const &"); { size_t len = lua_rawlen(L, 1);
    temp1 = lua_tolstring(L, 1, &len); arg1 = &temp1; }  result = (ofFile *)new ofFile((std::filesystem::path const &)*arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofFile,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_File__SWIG_4(lua_State* L) { int SWIG_arg = 0; ofFile *arg1 = 0 ; ofFile *result = 0 ;
  SWIG_check_num_args("ofFile::ofFile",1,1) if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofFile::ofFile",1,"ofFile const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFile,0))){ SWIG_fail_ptr("new_File",1,SWIGTYPE_p_ofFile); } 
  result = (ofFile *)new ofFile((ofFile const &)*arg1); SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofFile,1); SWIG_arg++; 
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_new_File(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 0) {
    return _wrap_new_File__SWIG_0(L);}  if (argc == 1) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofFile, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { return _wrap_new_File__SWIG_4(L);}  }  if (argc == 1) { int _v; {
      _v = lua_isstring(L, argv[0]); }  if (_v) { return _wrap_new_File__SWIG_3(L);}  }  if (argc == 2) { int _v; {
      _v = lua_isstring(L, argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { return _wrap_new_File__SWIG_2(L);}
       }  }  if (argc == 3) { int _v; { _v = lua_isstring(L, argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        { _v = lua_isboolean(L,argv[2]); }  if (_v) { return _wrap_new_File__SWIG_1(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_File'\n" "  Possible C/C++ prototypes are:\n"
  "    ofFile::ofFile()\n" "    ofFile::ofFile(std::filesystem::path const &,ofFile::Mode,bool)\n"
  "    ofFile::ofFile(std::filesystem::path const &,ofFile::Mode)\n" "    ofFile::ofFile(std::filesystem::path const &)\n"
  "    ofFile::ofFile(ofFile const &)\n"); lua_error(L);return 0; }
static int _wrap_File_open__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofFile *arg1 = (ofFile *) 0 ;
  std::filesystem::path *arg2 = 0 ; ofFile::Mode arg3 ; bool arg4 ; std::filesystem::path temp2 ; bool result;
  SWIG_check_num_args("ofFile::open",4,4) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFile::open",1,"ofFile *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofFile::open",2,"std::filesystem::path const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofFile::open",3,"ofFile::Mode");
  if(!lua_isboolean(L,4)) SWIG_fail_arg("ofFile::open",4,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFile,0))){ SWIG_fail_ptr("File_open",1,SWIGTYPE_p_ofFile); }  {
    size_t len = lua_rawlen(L, 2); temp2 = lua_tolstring(L, 2, &len); arg2 = &temp2; } 
  arg3 = (ofFile::Mode)(int)lua_tonumber(L, 3); arg4 = (lua_toboolean(L, 4)!=0);
  result = (bool)(arg1)->open((std::filesystem::path const &)*arg2,arg3,arg4); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_File_open__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofFile *arg1 = (ofFile *) 0 ;
  std::filesystem::path *arg2 = 0 ; ofFile::Mode arg3 ; std::filesystem::path temp2 ; bool result;
  SWIG_check_num_args("ofFile::open",3,3) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFile::open",1,"ofFile *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofFile::open",2,"std::filesystem::path const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofFile::open",3,"ofFile::Mode");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFile,0))){ SWIG_fail_ptr("File_open",1,SWIGTYPE_p_ofFile); }  {
    size_t len = lua_rawlen(L, 2); temp2 = lua_tolstring(L, 2, &len); arg2 = &temp2; } 
  arg3 = (ofFile::Mode)(int)lua_tonumber(L, 3); result = (bool)(arg1)->open((std::filesystem::path const &)*arg2,arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_File_open__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofFile *arg1 = (ofFile *) 0 ;
  std::filesystem::path *arg2 = 0 ; std::filesystem::path temp2 ; bool result; SWIG_check_num_args("ofFile::open",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFile::open",1,"ofFile *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofFile::open",2,"std::filesystem::path const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFile,0))){ SWIG_fail_ptr("File_open",1,SWIGTYPE_p_ofFile); }  {
    size_t len = lua_rawlen(L, 2); temp2 = lua_tolstring(L, 2, &len); arg2 = &temp2; } 
  result = (bool)(arg1)->open((std::filesystem::path const &)*arg2); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_File_open(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L); if (argc == 2) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofFile, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L, argv[1]); }  if (_v) {
        return _wrap_File_open__SWIG_2(L);}  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofFile, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { _v = lua_isstring(L, argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_File_open__SWIG_1(L);}  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofFile, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { _v = lua_isstring(L, argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { {
            _v = lua_isboolean(L,argv[3]); }  if (_v) { return _wrap_File_open__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'File_open'\n" "  Possible C/C++ prototypes are:\n"
  "    ofFile::open(std::filesystem::path const &,ofFile::Mode,bool)\n"
  "    ofFile::open(std::filesystem::path const &,ofFile::Mode)\n" "    ofFile::open(std::filesystem::path const &)\n");
  lua_error(L);return 0; }
static int _wrap_File_openFromCWD__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofFile *arg1 = (ofFile *) 0 ;
  std::filesystem::path *arg2 = 0 ; ofFile::Mode arg3 ; bool arg4 ; std::filesystem::path temp2 ; bool result;
  SWIG_check_num_args("ofFile::openFromCWD",4,4) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFile::openFromCWD",1,"ofFile *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofFile::openFromCWD",2,"std::filesystem::path const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofFile::openFromCWD",3,"ofFile::Mode");
  if(!lua_isboolean(L,4)) SWIG_fail_arg("ofFile::openFromCWD",4,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFile,0))){
    SWIG_fail_ptr("File_openFromCWD",1,SWIGTYPE_p_ofFile); }  { size_t len = lua_rawlen(L, 2);
    temp2 = lua_tolstring(L, 2, &len); arg2 = &temp2; }  arg3 = (ofFile::Mode)(int)lua_tonumber(L, 3);
  arg4 = (lua_toboolean(L, 4)!=0); result = (bool)(arg1)->openFromCWD((std::filesystem::path const &)*arg2,arg3,arg4);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_File_openFromCWD__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofFile *arg1 = (ofFile *) 0 ;
  std::filesystem::path *arg2 = 0 ; ofFile::Mode arg3 ; std::filesystem::path temp2 ; bool result;
  SWIG_check_num_args("ofFile::openFromCWD",3,3) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFile::openFromCWD",1,"ofFile *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofFile::openFromCWD",2,"std::filesystem::path const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofFile::openFromCWD",3,"ofFile::Mode");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFile,0))){
    SWIG_fail_ptr("File_openFromCWD",1,SWIGTYPE_p_ofFile); }  { size_t len = lua_rawlen(L, 2);
    temp2 = lua_tolstring(L, 2, &len); arg2 = &temp2; }  arg3 = (ofFile::Mode)(int)lua_tonumber(L, 3);
  result = (bool)(arg1)->openFromCWD((std::filesystem::path const &)*arg2,arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_File_openFromCWD__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofFile *arg1 = (ofFile *) 0 ;
  std::filesystem::path *arg2 = 0 ; std::filesystem::path temp2 ; bool result; SWIG_check_num_args("ofFile::openFromCWD",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFile::openFromCWD",1,"ofFile *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofFile::openFromCWD",2,"std::filesystem::path const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFile,0))){
    SWIG_fail_ptr("File_openFromCWD",1,SWIGTYPE_p_ofFile); }  { size_t len = lua_rawlen(L, 2);
    temp2 = lua_tolstring(L, 2, &len); arg2 = &temp2; } 
  result = (bool)(arg1)->openFromCWD((std::filesystem::path const &)*arg2); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_File_openFromCWD(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofFile, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L, argv[1]); }  if (_v) {
        return _wrap_File_openFromCWD__SWIG_2(L);}  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofFile, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { _v = lua_isstring(L, argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_File_openFromCWD__SWIG_1(L);}  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofFile, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { _v = lua_isstring(L, argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { {
            _v = lua_isboolean(L,argv[3]); }  if (_v) { return _wrap_File_openFromCWD__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'File_openFromCWD'\n" "  Possible C/C++ prototypes are:\n"
  "    ofFile::openFromCWD(std::filesystem::path const &,ofFile::Mode,bool)\n"
  "    ofFile::openFromCWD(std::filesystem::path const &,ofFile::Mode)\n"
  "    ofFile::openFromCWD(std::filesystem::path const &)\n"); lua_error(L);return 0; }
static int _wrap_File_changeMode__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofFile *arg1 = (ofFile *) 0 ; ofFile::Mode arg2 ;
  bool arg3 ; bool result; SWIG_check_num_args("ofFile::changeMode",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFile::changeMode",1,"ofFile *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofFile::changeMode",2,"ofFile::Mode");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("ofFile::changeMode",3,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFile,0))){
    SWIG_fail_ptr("File_changeMode",1,SWIGTYPE_p_ofFile); }  arg2 = (ofFile::Mode)(int)lua_tonumber(L, 2);
  arg3 = (lua_toboolean(L, 3)!=0); result = (bool)(arg1)->changeMode(arg2,arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_File_changeMode__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofFile *arg1 = (ofFile *) 0 ; ofFile::Mode arg2 ;
  bool result; SWIG_check_num_args("ofFile::changeMode",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFile::changeMode",1,"ofFile *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofFile::changeMode",2,"ofFile::Mode");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFile,0))){
    SWIG_fail_ptr("File_changeMode",1,SWIGTYPE_p_ofFile); }  arg2 = (ofFile::Mode)(int)lua_tonumber(L, 2);
  result = (bool)(arg1)->changeMode(arg2); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_File_changeMode(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofFile, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_File_changeMode__SWIG_1(L);}  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofFile, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isboolean(L,argv[2]); }  if (_v) {
          return _wrap_File_changeMode__SWIG_0(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'File_changeMode'\n" "  Possible C/C++ prototypes are:\n"
  "    ofFile::changeMode(ofFile::Mode,bool)\n" "    ofFile::changeMode(ofFile::Mode)\n"); lua_error(L);return 0; }
static int _wrap_File_close(lua_State* L) { int SWIG_arg = 0; ofFile *arg1 = (ofFile *) 0 ;
  SWIG_check_num_args("ofFile::close",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFile::close",1,"ofFile *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFile,0))){ SWIG_fail_ptr("File_close",1,SWIGTYPE_p_ofFile); } 
  (arg1)->close(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_File_create__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofFile *arg1 = (ofFile *) 0 ; bool result;
  SWIG_check_num_args("ofFile::create",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFile::create",1,"ofFile *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFile,0))){ SWIG_fail_ptr("File_create",1,SWIGTYPE_p_ofFile); } 
  result = (bool)(arg1)->create(); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_File_create__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofFile *arg1 = (ofFile *) 0 ;
  std::filesystem::path *arg2 = 0 ; std::filesystem::path temp2 ; bool result; SWIG_check_num_args("ofFile::create",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFile::create",1,"ofFile *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofFile::create",2,"std::filesystem::path const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFile,0))){ SWIG_fail_ptr("File_create",1,SWIGTYPE_p_ofFile); } 
  { size_t len = lua_rawlen(L, 2); temp2 = lua_tolstring(L, 2, &len); arg2 = &temp2; } 
  result = (bool)(arg1)->create((std::filesystem::path const &)*arg2); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_File_create(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 1) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofFile, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_File_create__SWIG_0(L);}  }  if (argc == 2) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofFile, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L, argv[1]); }  if (_v) {
        return _wrap_File_create__SWIG_1(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'File_create'\n" "  Possible C/C++ prototypes are:\n"
  "    ofFile::create()\n" "    ofFile::create(std::filesystem::path const &)\n"); lua_error(L);return 0; }
static int _wrap_File_exists(lua_State* L) { int SWIG_arg = 0; ofFile *arg1 = (ofFile *) 0 ; bool result;
  SWIG_check_num_args("ofFile::exists",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFile::exists",1,"ofFile const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFile,0))){ SWIG_fail_ptr("File_exists",1,SWIGTYPE_p_ofFile); } 
  result = (bool)((ofFile const *)arg1)->exists(); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_File_path(lua_State* L) { int SWIG_arg = 0; ofFile *arg1 = (ofFile *) 0 ; std::string result;
  SWIG_check_num_args("ofFile::path",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFile::path",1,"ofFile const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFile,0))){ SWIG_fail_ptr("File_path",1,SWIGTYPE_p_ofFile); } 
  result = ((ofFile const *)arg1)->path(); lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_File_getExtension(lua_State* L) { int SWIG_arg = 0; ofFile *arg1 = (ofFile *) 0 ; std::string result;
  SWIG_check_num_args("ofFile::getExtension",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFile::getExtension",1,"ofFile const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFile,0))){
    SWIG_fail_ptr("File_getExtension",1,SWIGTYPE_p_ofFile); }  result = ((ofFile const *)arg1)->getExtension();
  lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_File_getFileName(lua_State* L) { int SWIG_arg = 0; ofFile *arg1 = (ofFile *) 0 ; std::string result;
  SWIG_check_num_args("ofFile::getFileName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFile::getFileName",1,"ofFile const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFile,0))){
    SWIG_fail_ptr("File_getFileName",1,SWIGTYPE_p_ofFile); }  result = ((ofFile const *)arg1)->getFileName();
  lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_File_getBaseName(lua_State* L) { int SWIG_arg = 0; ofFile *arg1 = (ofFile *) 0 ; std::string result;
  SWIG_check_num_args("ofFile::getBaseName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFile::getBaseName",1,"ofFile const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFile,0))){
    SWIG_fail_ptr("File_getBaseName",1,SWIGTYPE_p_ofFile); }  result = ((ofFile const *)arg1)->getBaseName();
  lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_File_getEnclosingDirectory(lua_State* L) { int SWIG_arg = 0; ofFile *arg1 = (ofFile *) 0 ; std::string result;
  SWIG_check_num_args("ofFile::getEnclosingDirectory",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFile::getEnclosingDirectory",1,"ofFile const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFile,0))){
    SWIG_fail_ptr("File_getEnclosingDirectory",1,SWIGTYPE_p_ofFile); } 
  result = ((ofFile const *)arg1)->getEnclosingDirectory(); lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_File_getAbsolutePath(lua_State* L) { int SWIG_arg = 0; ofFile *arg1 = (ofFile *) 0 ; std::string result;
  SWIG_check_num_args("ofFile::getAbsolutePath",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFile::getAbsolutePath",1,"ofFile const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFile,0))){
    SWIG_fail_ptr("File_getAbsolutePath",1,SWIGTYPE_p_ofFile); }  result = ((ofFile const *)arg1)->getAbsolutePath();
  lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_File_canRead(lua_State* L) { int SWIG_arg = 0; ofFile *arg1 = (ofFile *) 0 ; bool result;
  SWIG_check_num_args("ofFile::canRead",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFile::canRead",1,"ofFile const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFile,0))){ SWIG_fail_ptr("File_canRead",1,SWIGTYPE_p_ofFile); } 
  result = (bool)((ofFile const *)arg1)->canRead(); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_File_canWrite(lua_State* L) { int SWIG_arg = 0; ofFile *arg1 = (ofFile *) 0 ; bool result;
  SWIG_check_num_args("ofFile::canWrite",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFile::canWrite",1,"ofFile const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFile,0))){ SWIG_fail_ptr("File_canWrite",1,SWIGTYPE_p_ofFile); }
   result = (bool)((ofFile const *)arg1)->canWrite(); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_File_canExecute(lua_State* L) { int SWIG_arg = 0; ofFile *arg1 = (ofFile *) 0 ; bool result;
  SWIG_check_num_args("ofFile::canExecute",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFile::canExecute",1,"ofFile const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFile,0))){
    SWIG_fail_ptr("File_canExecute",1,SWIGTYPE_p_ofFile); }  result = (bool)((ofFile const *)arg1)->canExecute();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_File_isFile(lua_State* L) { int SWIG_arg = 0; ofFile *arg1 = (ofFile *) 0 ; bool result;
  SWIG_check_num_args("ofFile::isFile",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFile::isFile",1,"ofFile const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFile,0))){ SWIG_fail_ptr("File_isFile",1,SWIGTYPE_p_ofFile); } 
  result = (bool)((ofFile const *)arg1)->isFile(); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_File_isLink(lua_State* L) { int SWIG_arg = 0; ofFile *arg1 = (ofFile *) 0 ; bool result;
  SWIG_check_num_args("ofFile::isLink",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFile::isLink",1,"ofFile const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFile,0))){ SWIG_fail_ptr("File_isLink",1,SWIGTYPE_p_ofFile); } 
  result = (bool)((ofFile const *)arg1)->isLink(); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_File_isDirectory(lua_State* L) { int SWIG_arg = 0; ofFile *arg1 = (ofFile *) 0 ; bool result;
  SWIG_check_num_args("ofFile::isDirectory",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFile::isDirectory",1,"ofFile const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFile,0))){
    SWIG_fail_ptr("File_isDirectory",1,SWIGTYPE_p_ofFile); }  result = (bool)((ofFile const *)arg1)->isDirectory();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_File_isDevice(lua_State* L) { int SWIG_arg = 0; ofFile *arg1 = (ofFile *) 0 ; bool result;
  SWIG_check_num_args("ofFile::isDevice",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFile::isDevice",1,"ofFile const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFile,0))){ SWIG_fail_ptr("File_isDevice",1,SWIGTYPE_p_ofFile); }
   result = (bool)((ofFile const *)arg1)->isDevice(); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_File_isHidden(lua_State* L) { int SWIG_arg = 0; ofFile *arg1 = (ofFile *) 0 ; bool result;
  SWIG_check_num_args("ofFile::isHidden",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFile::isHidden",1,"ofFile const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFile,0))){ SWIG_fail_ptr("File_isHidden",1,SWIGTYPE_p_ofFile); }
   result = (bool)((ofFile const *)arg1)->isHidden(); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_File_setWriteable__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofFile *arg1 = (ofFile *) 0 ; bool arg2 ;
  SWIG_check_num_args("ofFile::setWriteable",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFile::setWriteable",1,"ofFile *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofFile::setWriteable",2,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFile,0))){
    SWIG_fail_ptr("File_setWriteable",1,SWIGTYPE_p_ofFile); }  arg2 = (lua_toboolean(L, 2)!=0); (arg1)->setWriteable(arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_File_setWriteable__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofFile *arg1 = (ofFile *) 0 ;
  SWIG_check_num_args("ofFile::setWriteable",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFile::setWriteable",1,"ofFile *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFile,0))){
    SWIG_fail_ptr("File_setWriteable",1,SWIGTYPE_p_ofFile); }  (arg1)->setWriteable(); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_File_setWriteable(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 1) {
    int _v; { void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofFile, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_File_setWriteable__SWIG_1(L);}  }  if (argc == 2) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofFile, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isboolean(L,argv[1]); }  if (_v) {
        return _wrap_File_setWriteable__SWIG_0(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'File_setWriteable'\n" "  Possible C/C++ prototypes are:\n"
  "    ofFile::setWriteable(bool)\n" "    ofFile::setWriteable()\n"); lua_error(L);return 0; }
static int _wrap_File_setReadable__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofFile *arg1 = (ofFile *) 0 ; bool arg2 ;
  SWIG_check_num_args("ofFile::setReadable",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFile::setReadable",1,"ofFile *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofFile::setReadable",2,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFile,0))){
    SWIG_fail_ptr("File_setReadable",1,SWIGTYPE_p_ofFile); }  arg2 = (lua_toboolean(L, 2)!=0); (arg1)->setReadable(arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_File_setReadable__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofFile *arg1 = (ofFile *) 0 ;
  SWIG_check_num_args("ofFile::setReadable",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFile::setReadable",1,"ofFile *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFile,0))){
    SWIG_fail_ptr("File_setReadable",1,SWIGTYPE_p_ofFile); }  (arg1)->setReadable(); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_File_setReadable(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 1) {
    int _v; { void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofFile, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_File_setReadable__SWIG_1(L);}  }  if (argc == 2) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofFile, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isboolean(L,argv[1]); }  if (_v) {
        return _wrap_File_setReadable__SWIG_0(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'File_setReadable'\n" "  Possible C/C++ prototypes are:\n"
  "    ofFile::setReadable(bool)\n" "    ofFile::setReadable()\n"); lua_error(L);return 0; }
static int _wrap_File_setExecutable__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofFile *arg1 = (ofFile *) 0 ; bool arg2 ;
  SWIG_check_num_args("ofFile::setExecutable",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFile::setExecutable",1,"ofFile *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofFile::setExecutable",2,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFile,0))){
    SWIG_fail_ptr("File_setExecutable",1,SWIGTYPE_p_ofFile); }  arg2 = (lua_toboolean(L, 2)!=0); (arg1)->setExecutable(arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_File_setExecutable__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofFile *arg1 = (ofFile *) 0 ;
  SWIG_check_num_args("ofFile::setExecutable",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFile::setExecutable",1,"ofFile *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFile,0))){
    SWIG_fail_ptr("File_setExecutable",1,SWIGTYPE_p_ofFile); }  (arg1)->setExecutable(); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_File_setExecutable(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 1) {
    int _v; { void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofFile, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_File_setExecutable__SWIG_1(L);}  }  if (argc == 2) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofFile, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isboolean(L,argv[1]); }  if (_v) {
        return _wrap_File_setExecutable__SWIG_0(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'File_setExecutable'\n" "  Possible C/C++ prototypes are:\n"
  "    ofFile::setExecutable(bool)\n" "    ofFile::setExecutable()\n"); lua_error(L);return 0; }
static int _wrap_File_copyTo__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofFile *arg1 = (ofFile *) 0 ;
  std::filesystem::path *arg2 = 0 ; bool arg3 ; bool arg4 ; std::filesystem::path temp2 ; bool result;
  SWIG_check_num_args("ofFile::copyTo",4,4) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFile::copyTo",1,"ofFile const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofFile::copyTo",2,"std::filesystem::path const &");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("ofFile::copyTo",3,"bool");
  if(!lua_isboolean(L,4)) SWIG_fail_arg("ofFile::copyTo",4,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFile,0))){ SWIG_fail_ptr("File_copyTo",1,SWIGTYPE_p_ofFile); } 
  { size_t len = lua_rawlen(L, 2); temp2 = lua_tolstring(L, 2, &len); arg2 = &temp2; }  arg3 = (lua_toboolean(L, 3)!=0);
  arg4 = (lua_toboolean(L, 4)!=0);
  result = (bool)((ofFile const *)arg1)->copyTo((std::filesystem::path const &)*arg2,arg3,arg4);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_File_copyTo__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofFile *arg1 = (ofFile *) 0 ;
  std::filesystem::path *arg2 = 0 ; bool arg3 ; std::filesystem::path temp2 ; bool result;
  SWIG_check_num_args("ofFile::copyTo",3,3) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFile::copyTo",1,"ofFile const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofFile::copyTo",2,"std::filesystem::path const &");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("ofFile::copyTo",3,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFile,0))){ SWIG_fail_ptr("File_copyTo",1,SWIGTYPE_p_ofFile); } 
  { size_t len = lua_rawlen(L, 2); temp2 = lua_tolstring(L, 2, &len); arg2 = &temp2; }  arg3 = (lua_toboolean(L, 3)!=0);
  result = (bool)((ofFile const *)arg1)->copyTo((std::filesystem::path const &)*arg2,arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_File_copyTo__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofFile *arg1 = (ofFile *) 0 ;
  std::filesystem::path *arg2 = 0 ; std::filesystem::path temp2 ; bool result; SWIG_check_num_args("ofFile::copyTo",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFile::copyTo",1,"ofFile const *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofFile::copyTo",2,"std::filesystem::path const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFile,0))){ SWIG_fail_ptr("File_copyTo",1,SWIGTYPE_p_ofFile); } 
  { size_t len = lua_rawlen(L, 2); temp2 = lua_tolstring(L, 2, &len); arg2 = &temp2; } 
  result = (bool)((ofFile const *)arg1)->copyTo((std::filesystem::path const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_File_copyTo(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L); if (argc == 2) { int _v;
    { void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofFile, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L, argv[1]); }  if (_v) {
        return _wrap_File_copyTo__SWIG_2(L);}  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofFile, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { _v = lua_isstring(L, argv[1]); }  if (_v) { { _v = lua_isboolean(L,argv[2]); }  if (_v) {
          return _wrap_File_copyTo__SWIG_1(L);}  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofFile, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { _v = lua_isstring(L, argv[1]); }  if (_v) { { _v = lua_isboolean(L,argv[2]); }  if (_v) { {
            _v = lua_isboolean(L,argv[3]); }  if (_v) { return _wrap_File_copyTo__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'File_copyTo'\n" "  Possible C/C++ prototypes are:\n"
  "    ofFile::copyTo(std::filesystem::path const &,bool,bool) const\n"
  "    ofFile::copyTo(std::filesystem::path const &,bool) const\n" "    ofFile::copyTo(std::filesystem::path const &) const\n");
  lua_error(L);return 0; }
static int _wrap_File_moveTo__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofFile *arg1 = (ofFile *) 0 ;
  std::filesystem::path *arg2 = 0 ; bool arg3 ; bool arg4 ; std::filesystem::path temp2 ; bool result;
  SWIG_check_num_args("ofFile::moveTo",4,4) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFile::moveTo",1,"ofFile *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofFile::moveTo",2,"std::filesystem::path const &");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("ofFile::moveTo",3,"bool");
  if(!lua_isboolean(L,4)) SWIG_fail_arg("ofFile::moveTo",4,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFile,0))){ SWIG_fail_ptr("File_moveTo",1,SWIGTYPE_p_ofFile); } 
  { size_t len = lua_rawlen(L, 2); temp2 = lua_tolstring(L, 2, &len); arg2 = &temp2; }  arg3 = (lua_toboolean(L, 3)!=0);
  arg4 = (lua_toboolean(L, 4)!=0); result = (bool)(arg1)->moveTo((std::filesystem::path const &)*arg2,arg3,arg4);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_File_moveTo__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofFile *arg1 = (ofFile *) 0 ;
  std::filesystem::path *arg2 = 0 ; bool arg3 ; std::filesystem::path temp2 ; bool result;
  SWIG_check_num_args("ofFile::moveTo",3,3) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFile::moveTo",1,"ofFile *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofFile::moveTo",2,"std::filesystem::path const &");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("ofFile::moveTo",3,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFile,0))){ SWIG_fail_ptr("File_moveTo",1,SWIGTYPE_p_ofFile); } 
  { size_t len = lua_rawlen(L, 2); temp2 = lua_tolstring(L, 2, &len); arg2 = &temp2; }  arg3 = (lua_toboolean(L, 3)!=0);
  result = (bool)(arg1)->moveTo((std::filesystem::path const &)*arg2,arg3); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_File_moveTo__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofFile *arg1 = (ofFile *) 0 ;
  std::filesystem::path *arg2 = 0 ; std::filesystem::path temp2 ; bool result; SWIG_check_num_args("ofFile::moveTo",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFile::moveTo",1,"ofFile *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofFile::moveTo",2,"std::filesystem::path const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFile,0))){ SWIG_fail_ptr("File_moveTo",1,SWIGTYPE_p_ofFile); } 
  { size_t len = lua_rawlen(L, 2); temp2 = lua_tolstring(L, 2, &len); arg2 = &temp2; } 
  result = (bool)(arg1)->moveTo((std::filesystem::path const &)*arg2); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_File_moveTo(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L); if (argc == 2) { int _v;
    { void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofFile, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L, argv[1]); }  if (_v) {
        return _wrap_File_moveTo__SWIG_2(L);}  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofFile, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { _v = lua_isstring(L, argv[1]); }  if (_v) { { _v = lua_isboolean(L,argv[2]); }  if (_v) {
          return _wrap_File_moveTo__SWIG_1(L);}  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofFile, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { _v = lua_isstring(L, argv[1]); }  if (_v) { { _v = lua_isboolean(L,argv[2]); }  if (_v) { {
            _v = lua_isboolean(L,argv[3]); }  if (_v) { return _wrap_File_moveTo__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'File_moveTo'\n" "  Possible C/C++ prototypes are:\n"
  "    ofFile::moveTo(std::filesystem::path const &,bool,bool)\n" "    ofFile::moveTo(std::filesystem::path const &,bool)\n"
  "    ofFile::moveTo(std::filesystem::path const &)\n"); lua_error(L);return 0; }
static int _wrap_File_renameTo__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofFile *arg1 = (ofFile *) 0 ;
  std::filesystem::path *arg2 = 0 ; bool arg3 ; bool arg4 ; std::filesystem::path temp2 ; bool result;
  SWIG_check_num_args("ofFile::renameTo",4,4) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFile::renameTo",1,"ofFile *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofFile::renameTo",2,"std::filesystem::path const &");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("ofFile::renameTo",3,"bool");
  if(!lua_isboolean(L,4)) SWIG_fail_arg("ofFile::renameTo",4,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFile,0))){ SWIG_fail_ptr("File_renameTo",1,SWIGTYPE_p_ofFile); }
   { size_t len = lua_rawlen(L, 2); temp2 = lua_tolstring(L, 2, &len); arg2 = &temp2; }  arg3 = (lua_toboolean(L, 3)!=0);
  arg4 = (lua_toboolean(L, 4)!=0); result = (bool)(arg1)->renameTo((std::filesystem::path const &)*arg2,arg3,arg4);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_File_renameTo__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofFile *arg1 = (ofFile *) 0 ;
  std::filesystem::path *arg2 = 0 ; bool arg3 ; std::filesystem::path temp2 ; bool result;
  SWIG_check_num_args("ofFile::renameTo",3,3) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFile::renameTo",1,"ofFile *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofFile::renameTo",2,"std::filesystem::path const &");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("ofFile::renameTo",3,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFile,0))){ SWIG_fail_ptr("File_renameTo",1,SWIGTYPE_p_ofFile); }
   { size_t len = lua_rawlen(L, 2); temp2 = lua_tolstring(L, 2, &len); arg2 = &temp2; }  arg3 = (lua_toboolean(L, 3)!=0);
  result = (bool)(arg1)->renameTo((std::filesystem::path const &)*arg2,arg3); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_File_renameTo__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofFile *arg1 = (ofFile *) 0 ;
  std::filesystem::path *arg2 = 0 ; std::filesystem::path temp2 ; bool result; SWIG_check_num_args("ofFile::renameTo",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFile::renameTo",1,"ofFile *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofFile::renameTo",2,"std::filesystem::path const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFile,0))){ SWIG_fail_ptr("File_renameTo",1,SWIGTYPE_p_ofFile); }
   { size_t len = lua_rawlen(L, 2); temp2 = lua_tolstring(L, 2, &len); arg2 = &temp2; } 
  result = (bool)(arg1)->renameTo((std::filesystem::path const &)*arg2); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_File_renameTo(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofFile, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L, argv[1]); }  if (_v) {
        return _wrap_File_renameTo__SWIG_2(L);}  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofFile, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { _v = lua_isstring(L, argv[1]); }  if (_v) { { _v = lua_isboolean(L,argv[2]); }  if (_v) {
          return _wrap_File_renameTo__SWIG_1(L);}  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofFile, 0)) { _v = 0; }  else {
        _v = 1; }  }  if (_v) { { _v = lua_isstring(L, argv[1]); }  if (_v) { { _v = lua_isboolean(L,argv[2]); }  if (_v) { {
            _v = lua_isboolean(L,argv[3]); }  if (_v) { return _wrap_File_renameTo__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'File_renameTo'\n" "  Possible C/C++ prototypes are:\n"
  "    ofFile::renameTo(std::filesystem::path const &,bool,bool)\n" "    ofFile::renameTo(std::filesystem::path const &,bool)\n"
  "    ofFile::renameTo(std::filesystem::path const &)\n"); lua_error(L);return 0; }
static int _wrap_File_remove__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofFile *arg1 = (ofFile *) 0 ; bool arg2 ; bool result;
  SWIG_check_num_args("ofFile::remove",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFile::remove",1,"ofFile *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofFile::remove",2,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFile,0))){ SWIG_fail_ptr("File_remove",1,SWIGTYPE_p_ofFile); } 
  arg2 = (lua_toboolean(L, 2)!=0); result = (bool)(arg1)->remove(arg2); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_File_remove__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofFile *arg1 = (ofFile *) 0 ; bool result;
  SWIG_check_num_args("ofFile::remove",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFile::remove",1,"ofFile *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFile,0))){ SWIG_fail_ptr("File_remove",1,SWIGTYPE_p_ofFile); } 
  result = (bool)(arg1)->remove(); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_File_remove(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 1) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofFile, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_File_remove__SWIG_1(L);}  }  if (argc == 2) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofFile, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isboolean(L,argv[1]); }  if (_v) {
        return _wrap_File_remove__SWIG_0(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'File_remove'\n" "  Possible C/C++ prototypes are:\n"
  "    ofFile::remove(bool)\n" "    ofFile::remove()\n"); lua_error(L);return 0; }
static int _wrap_File_getSize(lua_State* L) { int SWIG_arg = 0; ofFile *arg1 = (ofFile *) 0 ; uint64_t result;
  SWIG_check_num_args("ofFile::getSize",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFile::getSize",1,"ofFile const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFile,0))){ SWIG_fail_ptr("File_getSize",1,SWIGTYPE_p_ofFile); } 
  result = (uint64_t)((ofFile const *)arg1)->getSize(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_File___eq(lua_State* L) { int SWIG_arg = 0; ofFile *arg1 = (ofFile *) 0 ; ofFile *arg2 = 0 ; bool result;
  SWIG_check_num_args("ofFile::operator ==",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFile::operator ==",1,"ofFile const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofFile::operator ==",2,"ofFile const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFile,0))){ SWIG_fail_ptr("File___eq",1,SWIGTYPE_p_ofFile); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofFile,0))){ SWIG_fail_ptr("File___eq",2,SWIGTYPE_p_ofFile); } 
  result = (bool)((ofFile const *)arg1)->operator ==((ofFile const &)*arg2); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_File___lt(lua_State* L) { int SWIG_arg = 0; ofFile *arg1 = (ofFile *) 0 ; ofFile *arg2 = 0 ; bool result;
  SWIG_check_num_args("ofFile::operator <",2,2) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFile::operator <",1,"ofFile const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofFile::operator <",2,"ofFile const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFile,0))){ SWIG_fail_ptr("File___lt",1,SWIGTYPE_p_ofFile); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofFile,0))){ SWIG_fail_ptr("File___lt",2,SWIGTYPE_p_ofFile); } 
  result = (bool)((ofFile const *)arg1)->operator <((ofFile const &)*arg2); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_File___le(lua_State* L) { int SWIG_arg = 0; ofFile *arg1 = (ofFile *) 0 ; ofFile *arg2 = 0 ; bool result;
  SWIG_check_num_args("ofFile::operator <=",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFile::operator <=",1,"ofFile const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofFile::operator <=",2,"ofFile const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFile,0))){ SWIG_fail_ptr("File___le",1,SWIGTYPE_p_ofFile); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofFile,0))){ SWIG_fail_ptr("File___le",2,SWIGTYPE_p_ofFile); } 
  result = (bool)((ofFile const *)arg1)->operator <=((ofFile const &)*arg2); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_File_readToBuffer(lua_State* L) { int SWIG_arg = 0; ofFile *arg1 = (ofFile *) 0 ; ofBuffer result;
  SWIG_check_num_args("ofFile::readToBuffer",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFile::readToBuffer",1,"ofFile *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFile,0))){
    SWIG_fail_ptr("File_readToBuffer",1,SWIGTYPE_p_ofFile); }  result = (arg1)->readToBuffer(); {
    ofBuffer * resultptr = new ofBuffer((const ofBuffer &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofBuffer,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_File_writeFromBuffer(lua_State* L) { int SWIG_arg = 0; ofFile *arg1 = (ofFile *) 0 ; ofBuffer *arg2 = 0 ;
  bool result; SWIG_check_num_args("ofFile::writeFromBuffer",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFile::writeFromBuffer",1,"ofFile *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofFile::writeFromBuffer",2,"ofBuffer const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFile,0))){
    SWIG_fail_ptr("File_writeFromBuffer",1,SWIGTYPE_p_ofFile); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofBuffer,0))){
    SWIG_fail_ptr("File_writeFromBuffer",2,SWIGTYPE_p_ofBuffer); } 
  result = (bool)(arg1)->writeFromBuffer((ofBuffer const &)*arg2); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_File_copyFromTo__SWIG_0(lua_State* L) { int SWIG_arg = 0; std::filesystem::path *arg1 = 0 ;
  std::filesystem::path *arg2 = 0 ; bool arg3 ; bool arg4 ; std::filesystem::path temp1 ; std::filesystem::path temp2 ;
  bool result; SWIG_check_num_args("ofFile::copyFromTo",4,4)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofFile::copyFromTo",1,"std::filesystem::path const &");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofFile::copyFromTo",2,"std::filesystem::path const &");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("ofFile::copyFromTo",3,"bool");
  if(!lua_isboolean(L,4)) SWIG_fail_arg("ofFile::copyFromTo",4,"bool"); { size_t len = lua_rawlen(L, 1);
    temp1 = lua_tolstring(L, 1, &len); arg1 = &temp1; }  { size_t len = lua_rawlen(L, 2); temp2 = lua_tolstring(L, 2, &len);
    arg2 = &temp2; }  arg3 = (lua_toboolean(L, 3)!=0); arg4 = (lua_toboolean(L, 4)!=0);
  result = (bool)ofFile::copyFromTo((boost::filesystem::path const &)*arg1,(boost::filesystem::path const &)*arg2,arg3,arg4);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_File_copyFromTo__SWIG_1(lua_State* L) { int SWIG_arg = 0; std::filesystem::path *arg1 = 0 ;
  std::filesystem::path *arg2 = 0 ; bool arg3 ; std::filesystem::path temp1 ; std::filesystem::path temp2 ; bool result;
  SWIG_check_num_args("ofFile::copyFromTo",3,3)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofFile::copyFromTo",1,"std::filesystem::path const &");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofFile::copyFromTo",2,"std::filesystem::path const &");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("ofFile::copyFromTo",3,"bool"); { size_t len = lua_rawlen(L, 1);
    temp1 = lua_tolstring(L, 1, &len); arg1 = &temp1; }  { size_t len = lua_rawlen(L, 2); temp2 = lua_tolstring(L, 2, &len);
    arg2 = &temp2; }  arg3 = (lua_toboolean(L, 3)!=0);
  result = (bool)ofFile::copyFromTo((boost::filesystem::path const &)*arg1,(boost::filesystem::path const &)*arg2,arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_File_copyFromTo__SWIG_2(lua_State* L) { int SWIG_arg = 0; std::filesystem::path *arg1 = 0 ;
  std::filesystem::path *arg2 = 0 ; std::filesystem::path temp1 ; std::filesystem::path temp2 ; bool result;
  SWIG_check_num_args("ofFile::copyFromTo",2,2)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofFile::copyFromTo",1,"std::filesystem::path const &");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofFile::copyFromTo",2,"std::filesystem::path const &"); { size_t len = lua_rawlen(L, 1);
    temp1 = lua_tolstring(L, 1, &len); arg1 = &temp1; }  { size_t len = lua_rawlen(L, 2); temp2 = lua_tolstring(L, 2, &len);
    arg2 = &temp2; } 
  result = (bool)ofFile::copyFromTo((boost::filesystem::path const &)*arg1,(boost::filesystem::path const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_File_copyFromTo(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { _v = lua_isstring(L, argv[0]); }  if (_v) { { _v = lua_isstring(L, argv[1]); }  if (_v) {
        return _wrap_File_copyFromTo__SWIG_2(L);}  }  }  if (argc == 3) { int _v; { _v = lua_isstring(L, argv[0]); }  if (_v) {
      { _v = lua_isstring(L, argv[1]); }  if (_v) { { _v = lua_isboolean(L,argv[2]); }  if (_v) {
          return _wrap_File_copyFromTo__SWIG_1(L);}  }  }  }  if (argc == 4) { int _v; { _v = lua_isstring(L, argv[0]); } 
    if (_v) { { _v = lua_isstring(L, argv[1]); }  if (_v) { { _v = lua_isboolean(L,argv[2]); }  if (_v) { {
            _v = lua_isboolean(L,argv[3]); }  if (_v) { return _wrap_File_copyFromTo__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'File_copyFromTo'\n" "  Possible C/C++ prototypes are:\n"
  "    ofFile::copyFromTo(std::filesystem::path const &,std::filesystem::path const &,bool,bool)\n"
  "    ofFile::copyFromTo(std::filesystem::path const &,std::filesystem::path const &,bool)\n"
  "    ofFile::copyFromTo(std::filesystem::path const &,std::filesystem::path const &)\n"); lua_error(L);return 0; }
static int _wrap_File_moveFromTo__SWIG_0(lua_State* L) { int SWIG_arg = 0; std::filesystem::path *arg1 = 0 ;
  std::filesystem::path *arg2 = 0 ; bool arg3 ; bool arg4 ; std::filesystem::path temp1 ; std::filesystem::path temp2 ;
  bool result; SWIG_check_num_args("ofFile::moveFromTo",4,4)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofFile::moveFromTo",1,"std::filesystem::path const &");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofFile::moveFromTo",2,"std::filesystem::path const &");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("ofFile::moveFromTo",3,"bool");
  if(!lua_isboolean(L,4)) SWIG_fail_arg("ofFile::moveFromTo",4,"bool"); { size_t len = lua_rawlen(L, 1);
    temp1 = lua_tolstring(L, 1, &len); arg1 = &temp1; }  { size_t len = lua_rawlen(L, 2); temp2 = lua_tolstring(L, 2, &len);
    arg2 = &temp2; }  arg3 = (lua_toboolean(L, 3)!=0); arg4 = (lua_toboolean(L, 4)!=0);
  result = (bool)ofFile::moveFromTo((boost::filesystem::path const &)*arg1,(boost::filesystem::path const &)*arg2,arg3,arg4);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_File_moveFromTo__SWIG_1(lua_State* L) { int SWIG_arg = 0; std::filesystem::path *arg1 = 0 ;
  std::filesystem::path *arg2 = 0 ; bool arg3 ; std::filesystem::path temp1 ; std::filesystem::path temp2 ; bool result;
  SWIG_check_num_args("ofFile::moveFromTo",3,3)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofFile::moveFromTo",1,"std::filesystem::path const &");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofFile::moveFromTo",2,"std::filesystem::path const &");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("ofFile::moveFromTo",3,"bool"); { size_t len = lua_rawlen(L, 1);
    temp1 = lua_tolstring(L, 1, &len); arg1 = &temp1; }  { size_t len = lua_rawlen(L, 2); temp2 = lua_tolstring(L, 2, &len);
    arg2 = &temp2; }  arg3 = (lua_toboolean(L, 3)!=0);
  result = (bool)ofFile::moveFromTo((boost::filesystem::path const &)*arg1,(boost::filesystem::path const &)*arg2,arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_File_moveFromTo__SWIG_2(lua_State* L) { int SWIG_arg = 0; std::filesystem::path *arg1 = 0 ;
  std::filesystem::path *arg2 = 0 ; std::filesystem::path temp1 ; std::filesystem::path temp2 ; bool result;
  SWIG_check_num_args("ofFile::moveFromTo",2,2)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofFile::moveFromTo",1,"std::filesystem::path const &");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofFile::moveFromTo",2,"std::filesystem::path const &"); { size_t len = lua_rawlen(L, 1);
    temp1 = lua_tolstring(L, 1, &len); arg1 = &temp1; }  { size_t len = lua_rawlen(L, 2); temp2 = lua_tolstring(L, 2, &len);
    arg2 = &temp2; } 
  result = (bool)ofFile::moveFromTo((boost::filesystem::path const &)*arg1,(boost::filesystem::path const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_File_moveFromTo(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { _v = lua_isstring(L, argv[0]); }  if (_v) { { _v = lua_isstring(L, argv[1]); }  if (_v) {
        return _wrap_File_moveFromTo__SWIG_2(L);}  }  }  if (argc == 3) { int _v; { _v = lua_isstring(L, argv[0]); }  if (_v) {
      { _v = lua_isstring(L, argv[1]); }  if (_v) { { _v = lua_isboolean(L,argv[2]); }  if (_v) {
          return _wrap_File_moveFromTo__SWIG_1(L);}  }  }  }  if (argc == 4) { int _v; { _v = lua_isstring(L, argv[0]); } 
    if (_v) { { _v = lua_isstring(L, argv[1]); }  if (_v) { { _v = lua_isboolean(L,argv[2]); }  if (_v) { {
            _v = lua_isboolean(L,argv[3]); }  if (_v) { return _wrap_File_moveFromTo__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'File_moveFromTo'\n" "  Possible C/C++ prototypes are:\n"
  "    ofFile::moveFromTo(std::filesystem::path const &,std::filesystem::path const &,bool,bool)\n"
  "    ofFile::moveFromTo(std::filesystem::path const &,std::filesystem::path const &,bool)\n"
  "    ofFile::moveFromTo(std::filesystem::path const &,std::filesystem::path const &)\n"); lua_error(L);return 0; }
static int _wrap_File_doesFileExist__SWIG_0(lua_State* L) { int SWIG_arg = 0; std::filesystem::path *arg1 = 0 ; bool arg2 ;
  std::filesystem::path temp1 ; bool result; SWIG_check_num_args("ofFile::doesFileExist",2,2)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofFile::doesFileExist",1,"std::filesystem::path const &");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofFile::doesFileExist",2,"bool"); { size_t len = lua_rawlen(L, 1);
    temp1 = lua_tolstring(L, 1, &len); arg1 = &temp1; }  arg2 = (lua_toboolean(L, 2)!=0);
  result = (bool)ofFile::doesFileExist((boost::filesystem::path const &)*arg1,arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_File_doesFileExist__SWIG_1(lua_State* L) { int SWIG_arg = 0; std::filesystem::path *arg1 = 0 ;
  std::filesystem::path temp1 ; bool result; SWIG_check_num_args("ofFile::doesFileExist",1,1)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofFile::doesFileExist",1,"std::filesystem::path const &"); {
    size_t len = lua_rawlen(L, 1); temp1 = lua_tolstring(L, 1, &len); arg1 = &temp1; } 
  result = (bool)ofFile::doesFileExist((boost::filesystem::path const &)*arg1); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_File_doesFileExist(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 1) {
    int _v; { _v = lua_isstring(L, argv[0]); }  if (_v) { return _wrap_File_doesFileExist__SWIG_1(L);}  }  if (argc == 2) {
    int _v; { _v = lua_isstring(L, argv[0]); }  if (_v) { { _v = lua_isboolean(L,argv[1]); }  if (_v) {
        return _wrap_File_doesFileExist__SWIG_0(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'File_doesFileExist'\n" "  Possible C/C++ prototypes are:\n"
  "    ofFile::doesFileExist(std::filesystem::path const &,bool)\n"
  "    ofFile::doesFileExist(std::filesystem::path const &)\n"); lua_error(L);return 0; }
static int _wrap_File_removeFile__SWIG_0(lua_State* L) { int SWIG_arg = 0; std::filesystem::path *arg1 = 0 ; bool arg2 ;
  std::filesystem::path temp1 ; bool result; SWIG_check_num_args("ofFile::removeFile",2,2)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofFile::removeFile",1,"std::filesystem::path const &");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofFile::removeFile",2,"bool"); { size_t len = lua_rawlen(L, 1);
    temp1 = lua_tolstring(L, 1, &len); arg1 = &temp1; }  arg2 = (lua_toboolean(L, 2)!=0);
  result = (bool)ofFile::removeFile((boost::filesystem::path const &)*arg1,arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_File_removeFile__SWIG_1(lua_State* L) { int SWIG_arg = 0; std::filesystem::path *arg1 = 0 ;
  std::filesystem::path temp1 ; bool result; SWIG_check_num_args("ofFile::removeFile",1,1)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofFile::removeFile",1,"std::filesystem::path const &"); { size_t len = lua_rawlen(L, 1);
    temp1 = lua_tolstring(L, 1, &len); arg1 = &temp1; } 
  result = (bool)ofFile::removeFile((boost::filesystem::path const &)*arg1); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_File_removeFile(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 1) { int _v;
    { _v = lua_isstring(L, argv[0]); }  if (_v) { return _wrap_File_removeFile__SWIG_1(L);}  }  if (argc == 2) { int _v; {
      _v = lua_isstring(L, argv[0]); }  if (_v) { { _v = lua_isboolean(L,argv[1]); }  if (_v) {
        return _wrap_File_removeFile__SWIG_0(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'File_removeFile'\n" "  Possible C/C++ prototypes are:\n"
  "    ofFile::removeFile(std::filesystem::path const &,bool)\n" "    ofFile::removeFile(std::filesystem::path const &)\n");
  lua_error(L);return 0; }
static void swig_delete_File(void *obj) {
ofFile *arg1 = (ofFile *) obj;
delete arg1;
}
static int _proxy__wrap_new_File(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_File);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_File_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_File_methods[]= {
    { "open", _wrap_File_open},
    { "openFromCWD", _wrap_File_openFromCWD},
    { "changeMode", _wrap_File_changeMode},
    { "close", _wrap_File_close},
    { "create", _wrap_File_create},
    { "exists", _wrap_File_exists},
    { "path", _wrap_File_path},
    { "getExtension", _wrap_File_getExtension},
    { "getFileName", _wrap_File_getFileName},
    { "getBaseName", _wrap_File_getBaseName},
    { "getEnclosingDirectory", _wrap_File_getEnclosingDirectory},
    { "getAbsolutePath", _wrap_File_getAbsolutePath},
    { "canRead", _wrap_File_canRead},
    { "canWrite", _wrap_File_canWrite},
    { "canExecute", _wrap_File_canExecute},
    { "isFile", _wrap_File_isFile},
    { "isLink", _wrap_File_isLink},
    { "isDirectory", _wrap_File_isDirectory},
    { "isDevice", _wrap_File_isDevice},
    { "isHidden", _wrap_File_isHidden},
    { "setWriteable", _wrap_File_setWriteable},
    { "setReadable", _wrap_File_setReadable},
    { "setExecutable", _wrap_File_setExecutable},
    { "copyTo", _wrap_File_copyTo},
    { "moveTo", _wrap_File_moveTo},
    { "renameTo", _wrap_File_renameTo},
    { "remove", _wrap_File_remove},
    { "getSize", _wrap_File_getSize},
    { "__eq", _wrap_File___eq},
    { "__lt", _wrap_File___lt},
    { "__le", _wrap_File___le},
    { "readToBuffer", _wrap_File_readToBuffer},
    { "writeFromBuffer", _wrap_File_writeFromBuffer},
    {0,0}
};
static swig_lua_method swig_File_meta[] = {
    { "__eq", _wrap_File___eq},
    { "__lt", _wrap_File___lt},
    { "__le", _wrap_File___le},
    {0,0}
};

static swig_lua_attribute swig_File_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_File_Sf_SwigStatic_constants[]= {
    {SWIG_LUA_CONSTTAB_INT("Reference", ofFile::Reference)},
    {SWIG_LUA_CONSTTAB_INT("ReadOnly", ofFile::ReadOnly)},
    {SWIG_LUA_CONSTTAB_INT("WriteOnly", ofFile::WriteOnly)},
    {SWIG_LUA_CONSTTAB_INT("ReadWrite", ofFile::ReadWrite)},
    {SWIG_LUA_CONSTTAB_INT("Append", ofFile::Append)},
    {0,0,0,0,0,0}
};
static swig_lua_method swig_File_Sf_SwigStatic_methods[]= {
    { "copyFromTo", _wrap_File_copyFromTo},
    { "moveFromTo", _wrap_File_moveFromTo},
    { "doesFileExist", _wrap_File_doesFileExist},
    { "removeFile", _wrap_File_removeFile},
    {0,0}
};
static swig_lua_class* swig_File_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_File_Sf_SwigStatic = {
    "File",
    swig_File_Sf_SwigStatic_methods,
    swig_File_Sf_SwigStatic_attributes,
    swig_File_Sf_SwigStatic_constants,
    swig_File_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_File_bases[] = {0};
static const char *swig_File_base_names[] = {0};
static swig_lua_class _wrap_class_File = { "File", "File", &SWIGTYPE_p_ofFile,_proxy__wrap_new_File, swig_delete_File, swig_File_methods, swig_File_attributes, &swig_File_Sf_SwigStatic, swig_File_meta, swig_File_bases, swig_File_base_names };

static int _wrap_new_Directory__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofDirectory *result = 0 ;
  SWIG_check_num_args("ofDirectory::ofDirectory",0,0) result = (ofDirectory *)new ofDirectory();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofDirectory,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_Directory__SWIG_1(lua_State* L) { int SWIG_arg = 0; std::filesystem::path *arg1 = 0 ;
  std::filesystem::path temp1 ; ofDirectory *result = 0 ; SWIG_check_num_args("ofDirectory::ofDirectory",1,1)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofDirectory::ofDirectory",1,"std::filesystem::path const &"); {
    size_t len = lua_rawlen(L, 1); temp1 = lua_tolstring(L, 1, &len); arg1 = &temp1; } 
  result = (ofDirectory *)new ofDirectory((std::filesystem::path const &)*arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofDirectory,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_Directory(lua_State* L) { int argc; int argv[2]={ 1,2} ; argc = lua_gettop(L); if (argc == 0) {
    return _wrap_new_Directory__SWIG_0(L);}  if (argc == 1) { int _v; { _v = lua_isstring(L, argv[0]); }  if (_v) {
      return _wrap_new_Directory__SWIG_1(L);}  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_Directory'\n" "  Possible C/C++ prototypes are:\n"
  "    ofDirectory::ofDirectory()\n" "    ofDirectory::ofDirectory(std::filesystem::path const &)\n"); lua_error(L);return 0; }
static int _wrap_Directory_open(lua_State* L) { int SWIG_arg = 0; ofDirectory *arg1 = (ofDirectory *) 0 ;
  std::filesystem::path *arg2 = 0 ; std::filesystem::path temp2 ; SWIG_check_num_args("ofDirectory::open",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofDirectory::open",1,"ofDirectory *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofDirectory::open",2,"std::filesystem::path const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofDirectory,0))){
    SWIG_fail_ptr("Directory_open",1,SWIGTYPE_p_ofDirectory); }  { size_t len = lua_rawlen(L, 2);
    temp2 = lua_tolstring(L, 2, &len); arg2 = &temp2; }  (arg1)->open((std::filesystem::path const &)*arg2); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Directory_openFromCWD(lua_State* L) { int SWIG_arg = 0; ofDirectory *arg1 = (ofDirectory *) 0 ;
  std::filesystem::path *arg2 = 0 ; std::filesystem::path temp2 ; SWIG_check_num_args("ofDirectory::openFromCWD",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofDirectory::openFromCWD",1,"ofDirectory *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofDirectory::openFromCWD",2,"std::filesystem::path const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofDirectory,0))){
    SWIG_fail_ptr("Directory_openFromCWD",1,SWIGTYPE_p_ofDirectory); }  { size_t len = lua_rawlen(L, 2);
    temp2 = lua_tolstring(L, 2, &len); arg2 = &temp2; }  (arg1)->openFromCWD((std::filesystem::path const &)*arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Directory_close(lua_State* L) { int SWIG_arg = 0; ofDirectory *arg1 = (ofDirectory *) 0 ;
  SWIG_check_num_args("ofDirectory::close",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofDirectory::close",1,"ofDirectory *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofDirectory,0))){
    SWIG_fail_ptr("Directory_close",1,SWIGTYPE_p_ofDirectory); }  (arg1)->close(); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Directory_create__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofDirectory *arg1 = (ofDirectory *) 0 ; bool arg2 ;
  bool result; SWIG_check_num_args("ofDirectory::create",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofDirectory::create",1,"ofDirectory *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofDirectory::create",2,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofDirectory,0))){
    SWIG_fail_ptr("Directory_create",1,SWIGTYPE_p_ofDirectory); }  arg2 = (lua_toboolean(L, 2)!=0);
  result = (bool)(arg1)->create(arg2); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Directory_create__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofDirectory *arg1 = (ofDirectory *) 0 ; bool result;
  SWIG_check_num_args("ofDirectory::create",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofDirectory::create",1,"ofDirectory *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofDirectory,0))){
    SWIG_fail_ptr("Directory_create",1,SWIGTYPE_p_ofDirectory); }  result = (bool)(arg1)->create();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Directory_create(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 1) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofDirectory, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { return _wrap_Directory_create__SWIG_1(L);}  }  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofDirectory, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isboolean(L,argv[1]); }  if (_v) { return _wrap_Directory_create__SWIG_0(L);}  }
     }  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Directory_create'\n"
  "  Possible C/C++ prototypes are:\n" "    ofDirectory::create(bool)\n" "    ofDirectory::create()\n"); lua_error(L);return 0; }
static int _wrap_Directory_exists(lua_State* L) { int SWIG_arg = 0; ofDirectory *arg1 = (ofDirectory *) 0 ; bool result;
  SWIG_check_num_args("ofDirectory::exists",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofDirectory::exists",1,"ofDirectory const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofDirectory,0))){
    SWIG_fail_ptr("Directory_exists",1,SWIGTYPE_p_ofDirectory); }  result = (bool)((ofDirectory const *)arg1)->exists();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Directory_path(lua_State* L) { int SWIG_arg = 0; ofDirectory *arg1 = (ofDirectory *) 0 ; std::string result;
  SWIG_check_num_args("ofDirectory::path",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofDirectory::path",1,"ofDirectory const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofDirectory,0))){
    SWIG_fail_ptr("Directory_path",1,SWIGTYPE_p_ofDirectory); }  result = ((ofDirectory const *)arg1)->path();
  lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Directory_getAbsolutePath(lua_State* L) { int SWIG_arg = 0; ofDirectory *arg1 = (ofDirectory *) 0 ;
  std::string result; SWIG_check_num_args("ofDirectory::getAbsolutePath",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofDirectory::getAbsolutePath",1,"ofDirectory const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofDirectory,0))){
    SWIG_fail_ptr("Directory_getAbsolutePath",1,SWIGTYPE_p_ofDirectory); } 
  result = ((ofDirectory const *)arg1)->getAbsolutePath(); lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Directory_canRead(lua_State* L) { int SWIG_arg = 0; ofDirectory *arg1 = (ofDirectory *) 0 ; bool result;
  SWIG_check_num_args("ofDirectory::canRead",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofDirectory::canRead",1,"ofDirectory const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofDirectory,0))){
    SWIG_fail_ptr("Directory_canRead",1,SWIGTYPE_p_ofDirectory); }  result = (bool)((ofDirectory const *)arg1)->canRead();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Directory_canWrite(lua_State* L) { int SWIG_arg = 0; ofDirectory *arg1 = (ofDirectory *) 0 ; bool result;
  SWIG_check_num_args("ofDirectory::canWrite",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofDirectory::canWrite",1,"ofDirectory const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofDirectory,0))){
    SWIG_fail_ptr("Directory_canWrite",1,SWIGTYPE_p_ofDirectory); }  result = (bool)((ofDirectory const *)arg1)->canWrite();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Directory_canExecute(lua_State* L) { int SWIG_arg = 0; ofDirectory *arg1 = (ofDirectory *) 0 ; bool result;
  SWIG_check_num_args("ofDirectory::canExecute",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofDirectory::canExecute",1,"ofDirectory const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofDirectory,0))){
    SWIG_fail_ptr("Directory_canExecute",1,SWIGTYPE_p_ofDirectory); }  result = (bool)((ofDirectory const *)arg1)->canExecute();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Directory_isDirectory(lua_State* L) { int SWIG_arg = 0; ofDirectory *arg1 = (ofDirectory *) 0 ; bool result;
  SWIG_check_num_args("ofDirectory::isDirectory",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofDirectory::isDirectory",1,"ofDirectory const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofDirectory,0))){
    SWIG_fail_ptr("Directory_isDirectory",1,SWIGTYPE_p_ofDirectory); } 
  result = (bool)((ofDirectory const *)arg1)->isDirectory(); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Directory_isHidden(lua_State* L) { int SWIG_arg = 0; ofDirectory *arg1 = (ofDirectory *) 0 ; bool result;
  SWIG_check_num_args("ofDirectory::isHidden",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofDirectory::isHidden",1,"ofDirectory const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofDirectory,0))){
    SWIG_fail_ptr("Directory_isHidden",1,SWIGTYPE_p_ofDirectory); }  result = (bool)((ofDirectory const *)arg1)->isHidden();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Directory_setWriteable__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofDirectory *arg1 = (ofDirectory *) 0 ;
  bool arg2 ; SWIG_check_num_args("ofDirectory::setWriteable",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofDirectory::setWriteable",1,"ofDirectory *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofDirectory::setWriteable",2,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofDirectory,0))){
    SWIG_fail_ptr("Directory_setWriteable",1,SWIGTYPE_p_ofDirectory); }  arg2 = (lua_toboolean(L, 2)!=0);
  (arg1)->setWriteable(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Directory_setWriteable__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofDirectory *arg1 = (ofDirectory *) 0 ;
  SWIG_check_num_args("ofDirectory::setWriteable",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofDirectory::setWriteable",1,"ofDirectory *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofDirectory,0))){
    SWIG_fail_ptr("Directory_setWriteable",1,SWIGTYPE_p_ofDirectory); }  (arg1)->setWriteable(); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Directory_setWriteable(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 1) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofDirectory, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { return _wrap_Directory_setWriteable__SWIG_1(L);}  }  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofDirectory, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isboolean(L,argv[1]); }  if (_v) {
        return _wrap_Directory_setWriteable__SWIG_0(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Directory_setWriteable'\n"
  "  Possible C/C++ prototypes are:\n" "    ofDirectory::setWriteable(bool)\n" "    ofDirectory::setWriteable()\n");
  lua_error(L);return 0; }
static int _wrap_Directory_setReadable__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofDirectory *arg1 = (ofDirectory *) 0 ;
  bool arg2 ; SWIG_check_num_args("ofDirectory::setReadable",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofDirectory::setReadable",1,"ofDirectory *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofDirectory::setReadable",2,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofDirectory,0))){
    SWIG_fail_ptr("Directory_setReadable",1,SWIGTYPE_p_ofDirectory); }  arg2 = (lua_toboolean(L, 2)!=0);
  (arg1)->setReadable(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Directory_setReadable__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofDirectory *arg1 = (ofDirectory *) 0 ;
  SWIG_check_num_args("ofDirectory::setReadable",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofDirectory::setReadable",1,"ofDirectory *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofDirectory,0))){
    SWIG_fail_ptr("Directory_setReadable",1,SWIGTYPE_p_ofDirectory); }  (arg1)->setReadable(); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Directory_setReadable(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 1) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofDirectory, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { return _wrap_Directory_setReadable__SWIG_1(L);}  }  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofDirectory, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isboolean(L,argv[1]); }  if (_v) {
        return _wrap_Directory_setReadable__SWIG_0(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Directory_setReadable'\n"
  "  Possible C/C++ prototypes are:\n" "    ofDirectory::setReadable(bool)\n" "    ofDirectory::setReadable()\n");
  lua_error(L);return 0; }
static int _wrap_Directory_setExecutable__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofDirectory *arg1 = (ofDirectory *) 0 ;
  bool arg2 ; SWIG_check_num_args("ofDirectory::setExecutable",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofDirectory::setExecutable",1,"ofDirectory *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofDirectory::setExecutable",2,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofDirectory,0))){
    SWIG_fail_ptr("Directory_setExecutable",1,SWIGTYPE_p_ofDirectory); }  arg2 = (lua_toboolean(L, 2)!=0);
  (arg1)->setExecutable(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Directory_setExecutable__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofDirectory *arg1 = (ofDirectory *) 0 ;
  SWIG_check_num_args("ofDirectory::setExecutable",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofDirectory::setExecutable",1,"ofDirectory *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofDirectory,0))){
    SWIG_fail_ptr("Directory_setExecutable",1,SWIGTYPE_p_ofDirectory); }  (arg1)->setExecutable(); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Directory_setExecutable(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 1) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofDirectory, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { return _wrap_Directory_setExecutable__SWIG_1(L);}  }  if (argc == 2) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofDirectory, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isboolean(L,argv[1]); }  if (_v) {
        return _wrap_Directory_setExecutable__SWIG_0(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Directory_setExecutable'\n"
  "  Possible C/C++ prototypes are:\n" "    ofDirectory::setExecutable(bool)\n" "    ofDirectory::setExecutable()\n");
  lua_error(L);return 0; }
static int _wrap_Directory_setShowHidden(lua_State* L) { int SWIG_arg = 0; ofDirectory *arg1 = (ofDirectory *) 0 ; bool arg2 ;
  SWIG_check_num_args("ofDirectory::setShowHidden",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofDirectory::setShowHidden",1,"ofDirectory *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofDirectory::setShowHidden",2,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofDirectory,0))){
    SWIG_fail_ptr("Directory_setShowHidden",1,SWIGTYPE_p_ofDirectory); }  arg2 = (lua_toboolean(L, 2)!=0);
  (arg1)->setShowHidden(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Directory_copyTo__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofDirectory *arg1 = (ofDirectory *) 0 ;
  std::filesystem::path *arg2 = 0 ; bool arg3 ; bool arg4 ; std::filesystem::path temp2 ; bool result;
  SWIG_check_num_args("ofDirectory::copyTo",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofDirectory::copyTo",1,"ofDirectory *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofDirectory::copyTo",2,"std::filesystem::path const &");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("ofDirectory::copyTo",3,"bool");
  if(!lua_isboolean(L,4)) SWIG_fail_arg("ofDirectory::copyTo",4,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofDirectory,0))){
    SWIG_fail_ptr("Directory_copyTo",1,SWIGTYPE_p_ofDirectory); }  { size_t len = lua_rawlen(L, 2);
    temp2 = lua_tolstring(L, 2, &len); arg2 = &temp2; }  arg3 = (lua_toboolean(L, 3)!=0); arg4 = (lua_toboolean(L, 4)!=0);
  result = (bool)(arg1)->copyTo((std::filesystem::path const &)*arg2,arg3,arg4);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Directory_copyTo__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofDirectory *arg1 = (ofDirectory *) 0 ;
  std::filesystem::path *arg2 = 0 ; bool arg3 ; std::filesystem::path temp2 ; bool result;
  SWIG_check_num_args("ofDirectory::copyTo",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofDirectory::copyTo",1,"ofDirectory *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofDirectory::copyTo",2,"std::filesystem::path const &");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("ofDirectory::copyTo",3,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofDirectory,0))){
    SWIG_fail_ptr("Directory_copyTo",1,SWIGTYPE_p_ofDirectory); }  { size_t len = lua_rawlen(L, 2);
    temp2 = lua_tolstring(L, 2, &len); arg2 = &temp2; }  arg3 = (lua_toboolean(L, 3)!=0);
  result = (bool)(arg1)->copyTo((std::filesystem::path const &)*arg2,arg3); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Directory_copyTo__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofDirectory *arg1 = (ofDirectory *) 0 ;
  std::filesystem::path *arg2 = 0 ; std::filesystem::path temp2 ; bool result; SWIG_check_num_args("ofDirectory::copyTo",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofDirectory::copyTo",1,"ofDirectory *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofDirectory::copyTo",2,"std::filesystem::path const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofDirectory,0))){
    SWIG_fail_ptr("Directory_copyTo",1,SWIGTYPE_p_ofDirectory); }  { size_t len = lua_rawlen(L, 2);
    temp2 = lua_tolstring(L, 2, &len); arg2 = &temp2; }  result = (bool)(arg1)->copyTo((std::filesystem::path const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Directory_copyTo(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofDirectory, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L, argv[1]); }  if (_v) { return _wrap_Directory_copyTo__SWIG_2(L);}  }
     }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofDirectory, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L, argv[1]); }  if (_v) { { _v = lua_isboolean(L,argv[2]); } 
        if (_v) { return _wrap_Directory_copyTo__SWIG_1(L);}  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofDirectory, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L, argv[1]); }  if (_v) { { _v = lua_isboolean(L,argv[2]); } 
        if (_v) { { _v = lua_isboolean(L,argv[3]); }  if (_v) { return _wrap_Directory_copyTo__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Directory_copyTo'\n" "  Possible C/C++ prototypes are:\n"
  "    ofDirectory::copyTo(std::filesystem::path const &,bool,bool)\n"
  "    ofDirectory::copyTo(std::filesystem::path const &,bool)\n" "    ofDirectory::copyTo(std::filesystem::path const &)\n");
  lua_error(L);return 0; }
static int _wrap_Directory_moveTo__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofDirectory *arg1 = (ofDirectory *) 0 ;
  std::filesystem::path *arg2 = 0 ; bool arg3 ; bool arg4 ; std::filesystem::path temp2 ; bool result;
  SWIG_check_num_args("ofDirectory::moveTo",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofDirectory::moveTo",1,"ofDirectory *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofDirectory::moveTo",2,"std::filesystem::path const &");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("ofDirectory::moveTo",3,"bool");
  if(!lua_isboolean(L,4)) SWIG_fail_arg("ofDirectory::moveTo",4,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofDirectory,0))){
    SWIG_fail_ptr("Directory_moveTo",1,SWIGTYPE_p_ofDirectory); }  { size_t len = lua_rawlen(L, 2);
    temp2 = lua_tolstring(L, 2, &len); arg2 = &temp2; }  arg3 = (lua_toboolean(L, 3)!=0); arg4 = (lua_toboolean(L, 4)!=0);
  result = (bool)(arg1)->moveTo((std::filesystem::path const &)*arg2,arg3,arg4);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Directory_moveTo__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofDirectory *arg1 = (ofDirectory *) 0 ;
  std::filesystem::path *arg2 = 0 ; bool arg3 ; std::filesystem::path temp2 ; bool result;
  SWIG_check_num_args("ofDirectory::moveTo",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofDirectory::moveTo",1,"ofDirectory *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofDirectory::moveTo",2,"std::filesystem::path const &");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("ofDirectory::moveTo",3,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofDirectory,0))){
    SWIG_fail_ptr("Directory_moveTo",1,SWIGTYPE_p_ofDirectory); }  { size_t len = lua_rawlen(L, 2);
    temp2 = lua_tolstring(L, 2, &len); arg2 = &temp2; }  arg3 = (lua_toboolean(L, 3)!=0);
  result = (bool)(arg1)->moveTo((std::filesystem::path const &)*arg2,arg3); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Directory_moveTo__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofDirectory *arg1 = (ofDirectory *) 0 ;
  std::filesystem::path *arg2 = 0 ; std::filesystem::path temp2 ; bool result; SWIG_check_num_args("ofDirectory::moveTo",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofDirectory::moveTo",1,"ofDirectory *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofDirectory::moveTo",2,"std::filesystem::path const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofDirectory,0))){
    SWIG_fail_ptr("Directory_moveTo",1,SWIGTYPE_p_ofDirectory); }  { size_t len = lua_rawlen(L, 2);
    temp2 = lua_tolstring(L, 2, &len); arg2 = &temp2; }  result = (bool)(arg1)->moveTo((std::filesystem::path const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Directory_moveTo(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofDirectory, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L, argv[1]); }  if (_v) { return _wrap_Directory_moveTo__SWIG_2(L);}  }
     }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofDirectory, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L, argv[1]); }  if (_v) { { _v = lua_isboolean(L,argv[2]); } 
        if (_v) { return _wrap_Directory_moveTo__SWIG_1(L);}  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofDirectory, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L, argv[1]); }  if (_v) { { _v = lua_isboolean(L,argv[2]); } 
        if (_v) { { _v = lua_isboolean(L,argv[3]); }  if (_v) { return _wrap_Directory_moveTo__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Directory_moveTo'\n" "  Possible C/C++ prototypes are:\n"
  "    ofDirectory::moveTo(std::filesystem::path const &,bool,bool)\n"
  "    ofDirectory::moveTo(std::filesystem::path const &,bool)\n" "    ofDirectory::moveTo(std::filesystem::path const &)\n");
  lua_error(L);return 0; }
static int _wrap_Directory_renameTo__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofDirectory *arg1 = (ofDirectory *) 0 ;
  std::filesystem::path *arg2 = 0 ; bool arg3 ; bool arg4 ; std::filesystem::path temp2 ; bool result;
  SWIG_check_num_args("ofDirectory::renameTo",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofDirectory::renameTo",1,"ofDirectory *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofDirectory::renameTo",2,"std::filesystem::path const &");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("ofDirectory::renameTo",3,"bool");
  if(!lua_isboolean(L,4)) SWIG_fail_arg("ofDirectory::renameTo",4,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofDirectory,0))){
    SWIG_fail_ptr("Directory_renameTo",1,SWIGTYPE_p_ofDirectory); }  { size_t len = lua_rawlen(L, 2);
    temp2 = lua_tolstring(L, 2, &len); arg2 = &temp2; }  arg3 = (lua_toboolean(L, 3)!=0); arg4 = (lua_toboolean(L, 4)!=0);
  result = (bool)(arg1)->renameTo((std::filesystem::path const &)*arg2,arg3,arg4);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Directory_renameTo__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofDirectory *arg1 = (ofDirectory *) 0 ;
  std::filesystem::path *arg2 = 0 ; bool arg3 ; std::filesystem::path temp2 ; bool result;
  SWIG_check_num_args("ofDirectory::renameTo",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofDirectory::renameTo",1,"ofDirectory *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofDirectory::renameTo",2,"std::filesystem::path const &");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("ofDirectory::renameTo",3,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofDirectory,0))){
    SWIG_fail_ptr("Directory_renameTo",1,SWIGTYPE_p_ofDirectory); }  { size_t len = lua_rawlen(L, 2);
    temp2 = lua_tolstring(L, 2, &len); arg2 = &temp2; }  arg3 = (lua_toboolean(L, 3)!=0);
  result = (bool)(arg1)->renameTo((std::filesystem::path const &)*arg2,arg3); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Directory_renameTo__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofDirectory *arg1 = (ofDirectory *) 0 ;
  std::filesystem::path *arg2 = 0 ; std::filesystem::path temp2 ; bool result; SWIG_check_num_args("ofDirectory::renameTo",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofDirectory::renameTo",1,"ofDirectory *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofDirectory::renameTo",2,"std::filesystem::path const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofDirectory,0))){
    SWIG_fail_ptr("Directory_renameTo",1,SWIGTYPE_p_ofDirectory); }  { size_t len = lua_rawlen(L, 2);
    temp2 = lua_tolstring(L, 2, &len); arg2 = &temp2; }  result = (bool)(arg1)->renameTo((std::filesystem::path const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Directory_renameTo(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofDirectory, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L, argv[1]); }  if (_v) { return _wrap_Directory_renameTo__SWIG_2(L);}
       }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofDirectory, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L, argv[1]); }  if (_v) { { _v = lua_isboolean(L,argv[2]); } 
        if (_v) { return _wrap_Directory_renameTo__SWIG_1(L);}  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofDirectory, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L, argv[1]); }  if (_v) { { _v = lua_isboolean(L,argv[2]); } 
        if (_v) { { _v = lua_isboolean(L,argv[3]); }  if (_v) { return _wrap_Directory_renameTo__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Directory_renameTo'\n" "  Possible C/C++ prototypes are:\n"
  "    ofDirectory::renameTo(std::filesystem::path const &,bool,bool)\n"
  "    ofDirectory::renameTo(std::filesystem::path const &,bool)\n"
  "    ofDirectory::renameTo(std::filesystem::path const &)\n"); lua_error(L);return 0; }
static int _wrap_Directory_remove(lua_State* L) { int SWIG_arg = 0; ofDirectory *arg1 = (ofDirectory *) 0 ; bool arg2 ;
  bool result; SWIG_check_num_args("ofDirectory::remove",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofDirectory::remove",1,"ofDirectory *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofDirectory::remove",2,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofDirectory,0))){
    SWIG_fail_ptr("Directory_remove",1,SWIGTYPE_p_ofDirectory); }  arg2 = (lua_toboolean(L, 2)!=0);
  result = (bool)(arg1)->remove(arg2); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Directory_allowExt(lua_State* L) { int SWIG_arg = 0; ofDirectory *arg1 = (ofDirectory *) 0 ;
  std::string *arg2 = 0 ; std::string temp2 ; SWIG_check_num_args("ofDirectory::allowExt",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofDirectory::allowExt",1,"ofDirectory *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofDirectory::allowExt",2,"std::string const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofDirectory,0))){
    SWIG_fail_ptr("Directory_allowExt",1,SWIGTYPE_p_ofDirectory); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2; (arg1)->allowExt((std::string const &)*arg2); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Directory_listDir__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofDirectory *arg1 = (ofDirectory *) 0 ;
  std::string *arg2 = 0 ; std::string temp2 ; std::size_t result; SWIG_check_num_args("ofDirectory::listDir",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofDirectory::listDir",1,"ofDirectory *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofDirectory::listDir",2,"std::string const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofDirectory,0))){
    SWIG_fail_ptr("Directory_listDir",1,SWIGTYPE_p_ofDirectory); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  result = (std::size_t)(arg1)->listDir((std::string const &)*arg2); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Directory_listDir__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofDirectory *arg1 = (ofDirectory *) 0 ;
  std::size_t result; SWIG_check_num_args("ofDirectory::listDir",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofDirectory::listDir",1,"ofDirectory *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofDirectory,0))){
    SWIG_fail_ptr("Directory_listDir",1,SWIGTYPE_p_ofDirectory); }  result = (std::size_t)(arg1)->listDir();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Directory_listDir(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 1) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofDirectory, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { return _wrap_Directory_listDir__SWIG_1(L);}  }  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofDirectory, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L,argv[1]); }  if (_v) { return _wrap_Directory_listDir__SWIG_0(L);}  }
     }  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Directory_listDir'\n"
  "  Possible C/C++ prototypes are:\n" "    ofDirectory::listDir(std::string const &)\n" "    ofDirectory::listDir()\n");
  lua_error(L);return 0; }
static int _wrap_Directory_getOriginalDirectory(lua_State* L) { int SWIG_arg = 0; ofDirectory *arg1 = (ofDirectory *) 0 ;
  std::string result; SWIG_check_num_args("ofDirectory::getOriginalDirectory",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofDirectory::getOriginalDirectory",1,"ofDirectory const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofDirectory,0))){
    SWIG_fail_ptr("Directory_getOriginalDirectory",1,SWIGTYPE_p_ofDirectory); } 
  result = ((ofDirectory const *)arg1)->getOriginalDirectory();
  lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_Directory_getName(lua_State* L) { int SWIG_arg = 0; ofDirectory *arg1 = (ofDirectory *) 0 ; std::size_t arg2 ;
  std::string result; SWIG_check_num_args("ofDirectory::getName",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofDirectory::getName",1,"ofDirectory const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofDirectory::getName",2,"std::size_t");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofDirectory,0))){
    SWIG_fail_ptr("Directory_getName",1,SWIGTYPE_p_ofDirectory); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (std::size_t)lua_tonumber(L, 2);
  result = ((ofDirectory const *)arg1)->getName(arg2); lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Directory_getPath(lua_State* L) { int SWIG_arg = 0; ofDirectory *arg1 = (ofDirectory *) 0 ; std::size_t arg2 ;
  std::string result; SWIG_check_num_args("ofDirectory::getPath",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofDirectory::getPath",1,"ofDirectory const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofDirectory::getPath",2,"std::size_t");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofDirectory,0))){
    SWIG_fail_ptr("Directory_getPath",1,SWIGTYPE_p_ofDirectory); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (std::size_t)lua_tonumber(L, 2);
  result = ((ofDirectory const *)arg1)->getPath(arg2); lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Directory_getFile__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofDirectory *arg1 = (ofDirectory *) 0 ;
  std::size_t arg2 ; ofFile::Mode arg3 ; bool arg4 ; ofFile result; SWIG_check_num_args("ofDirectory::getFile",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofDirectory::getFile",1,"ofDirectory const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofDirectory::getFile",2,"std::size_t");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofDirectory::getFile",3,"ofFile::Mode");
  if(!lua_isboolean(L,4)) SWIG_fail_arg("ofDirectory::getFile",4,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofDirectory,0))){
    SWIG_fail_ptr("Directory_getFile",1,SWIGTYPE_p_ofDirectory); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (std::size_t)lua_tonumber(L, 2);
  arg3 = (ofFile::Mode)(int)lua_tonumber(L, 3); arg4 = (lua_toboolean(L, 4)!=0);
  result = ((ofDirectory const *)arg1)->getFile(arg2,arg3,arg4); { ofFile * resultptr = new ofFile((const ofFile &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofFile,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Directory_getFile__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofDirectory *arg1 = (ofDirectory *) 0 ;
  std::size_t arg2 ; ofFile::Mode arg3 ; ofFile result; SWIG_check_num_args("ofDirectory::getFile",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofDirectory::getFile",1,"ofDirectory const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofDirectory::getFile",2,"std::size_t");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofDirectory::getFile",3,"ofFile::Mode");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofDirectory,0))){
    SWIG_fail_ptr("Directory_getFile",1,SWIGTYPE_p_ofDirectory); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (std::size_t)lua_tonumber(L, 2);
  arg3 = (ofFile::Mode)(int)lua_tonumber(L, 3); result = ((ofDirectory const *)arg1)->getFile(arg2,arg3); {
    ofFile * resultptr = new ofFile((const ofFile &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofFile,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Directory_getFile__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofDirectory *arg1 = (ofDirectory *) 0 ;
  std::size_t arg2 ; ofFile result; SWIG_check_num_args("ofDirectory::getFile",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofDirectory::getFile",1,"ofDirectory const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofDirectory::getFile",2,"std::size_t");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofDirectory,0))){
    SWIG_fail_ptr("Directory_getFile",1,SWIGTYPE_p_ofDirectory); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (std::size_t)lua_tonumber(L, 2);
  result = ((ofDirectory const *)arg1)->getFile(arg2); { ofFile * resultptr = new ofFile((const ofFile &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofFile,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Directory_getFile(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofDirectory, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { return _wrap_Directory_getFile__SWIG_2(L);}  }
     }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofDirectory, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_Directory_getFile__SWIG_1(L);}  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofDirectory, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          { _v = lua_isboolean(L,argv[3]); }  if (_v) { return _wrap_Directory_getFile__SWIG_0(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Directory_getFile'\n" "  Possible C/C++ prototypes are:\n"
  "    ofDirectory::getFile(std::size_t,ofFile::Mode,bool) const\n" "    ofDirectory::getFile(std::size_t,ofFile::Mode) const\n"
  "    ofDirectory::getFile(std::size_t) const\n"); lua_error(L);return 0; }
static int _wrap_Directory_getFiles(lua_State* L) { int SWIG_arg = 0; ofDirectory *arg1 = (ofDirectory *) 0 ;
  std::vector< ofFile > *result = 0 ; SWIG_check_num_args("ofDirectory::getFiles",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofDirectory::getFiles",1,"ofDirectory const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofDirectory,0))){
    SWIG_fail_ptr("Directory_getFiles",1,SWIGTYPE_p_ofDirectory); } 
  result = (std::vector< ofFile > *) &((ofDirectory const *)arg1)->getFiles();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorT_ofFile_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Directory_getShowHidden(lua_State* L) { int SWIG_arg = 0; ofDirectory *arg1 = (ofDirectory *) 0 ; bool result;
  SWIG_check_num_args("ofDirectory::getShowHidden",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofDirectory::getShowHidden",1,"ofDirectory const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofDirectory,0))){
    SWIG_fail_ptr("Directory_getShowHidden",1,SWIGTYPE_p_ofDirectory); } 
  result = (bool)((ofDirectory const *)arg1)->getShowHidden(); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Directory_reset(lua_State* L) { int SWIG_arg = 0; ofDirectory *arg1 = (ofDirectory *) 0 ;
  SWIG_check_num_args("ofDirectory::reset",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofDirectory::reset",1,"ofDirectory *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofDirectory,0))){
    SWIG_fail_ptr("Directory_reset",1,SWIGTYPE_p_ofDirectory); }  (arg1)->reset(); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Directory_sort(lua_State* L) { int SWIG_arg = 0; ofDirectory *arg1 = (ofDirectory *) 0 ;
  SWIG_check_num_args("ofDirectory::sort",1,1) if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofDirectory::sort",1,"ofDirectory *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofDirectory,0))){
    SWIG_fail_ptr("Directory_sort",1,SWIGTYPE_p_ofDirectory); }  (arg1)->sort(); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Directory_sortByDate(lua_State* L) { int SWIG_arg = 0; ofDirectory *arg1 = (ofDirectory *) 0 ;
  SWIG_check_num_args("ofDirectory::sortByDate",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofDirectory::sortByDate",1,"ofDirectory *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofDirectory,0))){
    SWIG_fail_ptr("Directory_sortByDate",1,SWIGTYPE_p_ofDirectory); }  (arg1)->sortByDate(); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_Directory_getSorted(lua_State* L) { int SWIG_arg = 0; ofDirectory *arg1 = (ofDirectory *) 0 ;
  ofDirectory result; SWIG_check_num_args("ofDirectory::getSorted",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofDirectory::getSorted",1,"ofDirectory *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofDirectory,0))){
    SWIG_fail_ptr("Directory_getSorted",1,SWIGTYPE_p_ofDirectory); }  result = (arg1)->getSorted(); {
    ofDirectory * resultptr = new ofDirectory((const ofDirectory &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofDirectory,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_Directory_size(lua_State* L) { int SWIG_arg = 0; ofDirectory *arg1 = (ofDirectory *) 0 ; std::size_t result;
  SWIG_check_num_args("ofDirectory::size",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofDirectory::size",1,"ofDirectory const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofDirectory,0))){
    SWIG_fail_ptr("Directory_size",1,SWIGTYPE_p_ofDirectory); }  result = (std::size_t)((ofDirectory const *)arg1)->size();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Directory___eq(lua_State* L) { int SWIG_arg = 0; ofDirectory *arg1 = (ofDirectory *) 0 ;
  ofDirectory *arg2 = 0 ; bool result; SWIG_check_num_args("ofDirectory::operator ==",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofDirectory::operator ==",1,"ofDirectory const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofDirectory::operator ==",2,"ofDirectory const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofDirectory,0))){
    SWIG_fail_ptr("Directory___eq",1,SWIGTYPE_p_ofDirectory); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofDirectory,0))){
    SWIG_fail_ptr("Directory___eq",2,SWIGTYPE_p_ofDirectory); } 
  result = (bool)((ofDirectory const *)arg1)->operator ==((ofDirectory const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Directory___lt(lua_State* L) { int SWIG_arg = 0; ofDirectory *arg1 = (ofDirectory *) 0 ;
  ofDirectory *arg2 = 0 ; bool result; SWIG_check_num_args("ofDirectory::operator <",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofDirectory::operator <",1,"ofDirectory const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofDirectory::operator <",2,"ofDirectory const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofDirectory,0))){
    SWIG_fail_ptr("Directory___lt",1,SWIGTYPE_p_ofDirectory); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofDirectory,0))){
    SWIG_fail_ptr("Directory___lt",2,SWIGTYPE_p_ofDirectory); } 
  result = (bool)((ofDirectory const *)arg1)->operator <((ofDirectory const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Directory___le(lua_State* L) { int SWIG_arg = 0; ofDirectory *arg1 = (ofDirectory *) 0 ;
  ofDirectory *arg2 = 0 ; bool result; SWIG_check_num_args("ofDirectory::operator <=",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofDirectory::operator <=",1,"ofDirectory const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofDirectory::operator <=",2,"ofDirectory const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofDirectory,0))){
    SWIG_fail_ptr("Directory___le",1,SWIGTYPE_p_ofDirectory); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofDirectory,0))){
    SWIG_fail_ptr("Directory___le",2,SWIGTYPE_p_ofDirectory); } 
  result = (bool)((ofDirectory const *)arg1)->operator <=((ofDirectory const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Directory_createDirectory__SWIG_0(lua_State* L) { int SWIG_arg = 0; std::filesystem::path *arg1 = 0 ;
  bool arg2 ; bool arg3 ; std::filesystem::path temp1 ; bool result; SWIG_check_num_args("ofDirectory::createDirectory",3,3)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofDirectory::createDirectory",1,"std::filesystem::path const &");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofDirectory::createDirectory",2,"bool");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("ofDirectory::createDirectory",3,"bool"); { size_t len = lua_rawlen(L, 1);
    temp1 = lua_tolstring(L, 1, &len); arg1 = &temp1; }  arg2 = (lua_toboolean(L, 2)!=0); arg3 = (lua_toboolean(L, 3)!=0);
  result = (bool)ofDirectory::createDirectory((boost::filesystem::path const &)*arg1,arg2,arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Directory_createDirectory__SWIG_1(lua_State* L) { int SWIG_arg = 0; std::filesystem::path *arg1 = 0 ;
  bool arg2 ; std::filesystem::path temp1 ; bool result; SWIG_check_num_args("ofDirectory::createDirectory",2,2)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofDirectory::createDirectory",1,"std::filesystem::path const &");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofDirectory::createDirectory",2,"bool"); { size_t len = lua_rawlen(L, 1);
    temp1 = lua_tolstring(L, 1, &len); arg1 = &temp1; }  arg2 = (lua_toboolean(L, 2)!=0);
  result = (bool)ofDirectory::createDirectory((boost::filesystem::path const &)*arg1,arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Directory_createDirectory__SWIG_2(lua_State* L) { int SWIG_arg = 0; std::filesystem::path *arg1 = 0 ;
  std::filesystem::path temp1 ; bool result; SWIG_check_num_args("ofDirectory::createDirectory",1,1)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofDirectory::createDirectory",1,"std::filesystem::path const &"); {
    size_t len = lua_rawlen(L, 1); temp1 = lua_tolstring(L, 1, &len); arg1 = &temp1; } 
  result = (bool)ofDirectory::createDirectory((boost::filesystem::path const &)*arg1);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Directory_createDirectory(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L);
  if (argc == 1) { int _v; { _v = lua_isstring(L, argv[0]); }  if (_v) { return _wrap_Directory_createDirectory__SWIG_2(L);}  } 
  if (argc == 2) { int _v; { _v = lua_isstring(L, argv[0]); }  if (_v) { { _v = lua_isboolean(L,argv[1]); }  if (_v) {
        return _wrap_Directory_createDirectory__SWIG_1(L);}  }  }  if (argc == 3) { int _v; { _v = lua_isstring(L, argv[0]); } 
    if (_v) { { _v = lua_isboolean(L,argv[1]); }  if (_v) { { _v = lua_isboolean(L,argv[2]); }  if (_v) {
          return _wrap_Directory_createDirectory__SWIG_0(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Directory_createDirectory'\n"
  "  Possible C/C++ prototypes are:\n" "    ofDirectory::createDirectory(std::filesystem::path const &,bool,bool)\n"
  "    ofDirectory::createDirectory(std::filesystem::path const &,bool)\n"
  "    ofDirectory::createDirectory(std::filesystem::path const &)\n"); lua_error(L);return 0; }
static int _wrap_Directory_isDirectoryEmpty__SWIG_0(lua_State* L) { int SWIG_arg = 0; std::filesystem::path *arg1 = 0 ;
  bool arg2 ; std::filesystem::path temp1 ; bool result; SWIG_check_num_args("ofDirectory::isDirectoryEmpty",2,2)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofDirectory::isDirectoryEmpty",1,"std::filesystem::path const &");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofDirectory::isDirectoryEmpty",2,"bool"); { size_t len = lua_rawlen(L, 1);
    temp1 = lua_tolstring(L, 1, &len); arg1 = &temp1; }  arg2 = (lua_toboolean(L, 2)!=0);
  result = (bool)ofDirectory::isDirectoryEmpty((boost::filesystem::path const &)*arg1,arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Directory_isDirectoryEmpty__SWIG_1(lua_State* L) { int SWIG_arg = 0; std::filesystem::path *arg1 = 0 ;
  std::filesystem::path temp1 ; bool result; SWIG_check_num_args("ofDirectory::isDirectoryEmpty",1,1)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofDirectory::isDirectoryEmpty",1,"std::filesystem::path const &"); {
    size_t len = lua_rawlen(L, 1); temp1 = lua_tolstring(L, 1, &len); arg1 = &temp1; } 
  result = (bool)ofDirectory::isDirectoryEmpty((boost::filesystem::path const &)*arg1);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Directory_isDirectoryEmpty(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L);
  if (argc == 1) { int _v; { _v = lua_isstring(L, argv[0]); }  if (_v) { return _wrap_Directory_isDirectoryEmpty__SWIG_1(L);}  }
   if (argc == 2) { int _v; { _v = lua_isstring(L, argv[0]); }  if (_v) { { _v = lua_isboolean(L,argv[1]); }  if (_v) {
        return _wrap_Directory_isDirectoryEmpty__SWIG_0(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Directory_isDirectoryEmpty'\n"
  "  Possible C/C++ prototypes are:\n" "    ofDirectory::isDirectoryEmpty(std::filesystem::path const &,bool)\n"
  "    ofDirectory::isDirectoryEmpty(std::filesystem::path const &)\n"); lua_error(L);return 0; }
static int _wrap_Directory_doesDirectoryExist__SWIG_0(lua_State* L) { int SWIG_arg = 0; std::filesystem::path *arg1 = 0 ;
  bool arg2 ; std::filesystem::path temp1 ; bool result; SWIG_check_num_args("ofDirectory::doesDirectoryExist",2,2)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofDirectory::doesDirectoryExist",1,"std::filesystem::path const &");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofDirectory::doesDirectoryExist",2,"bool"); { size_t len = lua_rawlen(L, 1);
    temp1 = lua_tolstring(L, 1, &len); arg1 = &temp1; }  arg2 = (lua_toboolean(L, 2)!=0);
  result = (bool)ofDirectory::doesDirectoryExist((boost::filesystem::path const &)*arg1,arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Directory_doesDirectoryExist__SWIG_1(lua_State* L) { int SWIG_arg = 0; std::filesystem::path *arg1 = 0 ;
  std::filesystem::path temp1 ; bool result; SWIG_check_num_args("ofDirectory::doesDirectoryExist",1,1)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofDirectory::doesDirectoryExist",1,"std::filesystem::path const &"); {
    size_t len = lua_rawlen(L, 1); temp1 = lua_tolstring(L, 1, &len); arg1 = &temp1; } 
  result = (bool)ofDirectory::doesDirectoryExist((boost::filesystem::path const &)*arg1);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Directory_doesDirectoryExist(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L);
  if (argc == 1) { int _v; { _v = lua_isstring(L, argv[0]); }  if (_v) { return _wrap_Directory_doesDirectoryExist__SWIG_1(L);}
     }  if (argc == 2) { int _v; { _v = lua_isstring(L, argv[0]); }  if (_v) { { _v = lua_isboolean(L,argv[1]); }  if (_v) {
        return _wrap_Directory_doesDirectoryExist__SWIG_0(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Directory_doesDirectoryExist'\n"
  "  Possible C/C++ prototypes are:\n" "    ofDirectory::doesDirectoryExist(std::filesystem::path const &,bool)\n"
  "    ofDirectory::doesDirectoryExist(std::filesystem::path const &)\n"); lua_error(L);return 0; }
static int _wrap_Directory_removeDirectory__SWIG_0(lua_State* L) { int SWIG_arg = 0; std::filesystem::path *arg1 = 0 ;
  bool arg2 ; bool arg3 ; std::filesystem::path temp1 ; bool result; SWIG_check_num_args("ofDirectory::removeDirectory",3,3)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofDirectory::removeDirectory",1,"std::filesystem::path const &");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofDirectory::removeDirectory",2,"bool");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("ofDirectory::removeDirectory",3,"bool"); { size_t len = lua_rawlen(L, 1);
    temp1 = lua_tolstring(L, 1, &len); arg1 = &temp1; }  arg2 = (lua_toboolean(L, 2)!=0); arg3 = (lua_toboolean(L, 3)!=0);
  result = (bool)ofDirectory::removeDirectory((boost::filesystem::path const &)*arg1,arg2,arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Directory_removeDirectory__SWIG_1(lua_State* L) { int SWIG_arg = 0; std::filesystem::path *arg1 = 0 ;
  bool arg2 ; std::filesystem::path temp1 ; bool result; SWIG_check_num_args("ofDirectory::removeDirectory",2,2)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofDirectory::removeDirectory",1,"std::filesystem::path const &");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofDirectory::removeDirectory",2,"bool"); { size_t len = lua_rawlen(L, 1);
    temp1 = lua_tolstring(L, 1, &len); arg1 = &temp1; }  arg2 = (lua_toboolean(L, 2)!=0);
  result = (bool)ofDirectory::removeDirectory((boost::filesystem::path const &)*arg1,arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_Directory_removeDirectory(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L);
  if (argc == 2) { int _v; { _v = lua_isstring(L, argv[0]); }  if (_v) { { _v = lua_isboolean(L,argv[1]); }  if (_v) {
        return _wrap_Directory_removeDirectory__SWIG_1(L);}  }  }  if (argc == 3) { int _v; { _v = lua_isstring(L, argv[0]); } 
    if (_v) { { _v = lua_isboolean(L,argv[1]); }  if (_v) { { _v = lua_isboolean(L,argv[2]); }  if (_v) {
          return _wrap_Directory_removeDirectory__SWIG_0(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'Directory_removeDirectory'\n"
  "  Possible C/C++ prototypes are:\n" "    ofDirectory::removeDirectory(std::filesystem::path const &,bool,bool)\n"
  "    ofDirectory::removeDirectory(std::filesystem::path const &,bool)\n"); lua_error(L);return 0; }
static void swig_delete_Directory(void *obj) {
ofDirectory *arg1 = (ofDirectory *) obj;
delete arg1;
}
static int _proxy__wrap_new_Directory(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_Directory);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_Directory_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_Directory_methods[]= {
    { "open", _wrap_Directory_open},
    { "openFromCWD", _wrap_Directory_openFromCWD},
    { "close", _wrap_Directory_close},
    { "create", _wrap_Directory_create},
    { "exists", _wrap_Directory_exists},
    { "path", _wrap_Directory_path},
    { "getAbsolutePath", _wrap_Directory_getAbsolutePath},
    { "canRead", _wrap_Directory_canRead},
    { "canWrite", _wrap_Directory_canWrite},
    { "canExecute", _wrap_Directory_canExecute},
    { "isDirectory", _wrap_Directory_isDirectory},
    { "isHidden", _wrap_Directory_isHidden},
    { "setWriteable", _wrap_Directory_setWriteable},
    { "setReadable", _wrap_Directory_setReadable},
    { "setExecutable", _wrap_Directory_setExecutable},
    { "setShowHidden", _wrap_Directory_setShowHidden},
    { "copyTo", _wrap_Directory_copyTo},
    { "moveTo", _wrap_Directory_moveTo},
    { "renameTo", _wrap_Directory_renameTo},
    { "remove", _wrap_Directory_remove},
    { "allowExt", _wrap_Directory_allowExt},
    { "listDir", _wrap_Directory_listDir},
    { "getOriginalDirectory", _wrap_Directory_getOriginalDirectory},
    { "getName", _wrap_Directory_getName},
    { "getPath", _wrap_Directory_getPath},
    { "getFile", _wrap_Directory_getFile},
    { "getFiles", _wrap_Directory_getFiles},
    { "getShowHidden", _wrap_Directory_getShowHidden},
    { "reset", _wrap_Directory_reset},
    { "sort", _wrap_Directory_sort},
    { "sortByDate", _wrap_Directory_sortByDate},
    { "getSorted", _wrap_Directory_getSorted},
    { "size", _wrap_Directory_size},
    { "__eq", _wrap_Directory___eq},
    { "__lt", _wrap_Directory___lt},
    { "__le", _wrap_Directory___le},
    {0,0}
};
static swig_lua_method swig_Directory_meta[] = {
    { "__eq", _wrap_Directory___eq},
    { "__lt", _wrap_Directory___lt},
    { "__le", _wrap_Directory___le},
    {0,0}
};

static swig_lua_attribute swig_Directory_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_Directory_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_Directory_Sf_SwigStatic_methods[]= {
    { "createDirectory", _wrap_Directory_createDirectory},
    { "isDirectoryEmpty", _wrap_Directory_isDirectoryEmpty},
    { "doesDirectoryExist", _wrap_Directory_doesDirectoryExist},
    { "removeDirectory", _wrap_Directory_removeDirectory},
    {0,0}
};
static swig_lua_class* swig_Directory_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_Directory_Sf_SwigStatic = {
    "Directory",
    swig_Directory_Sf_SwigStatic_methods,
    swig_Directory_Sf_SwigStatic_attributes,
    swig_Directory_Sf_SwigStatic_constants,
    swig_Directory_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_Directory_bases[] = {0};
static const char *swig_Directory_base_names[] = {0};
static swig_lua_class _wrap_class_Directory = { "Directory", "Directory", &SWIGTYPE_p_ofDirectory,_proxy__wrap_new_Directory, swig_delete_Directory, swig_Directory_methods, swig_Directory_attributes, &swig_Directory_Sf_SwigStatic, swig_Directory_meta, swig_Directory_bases, swig_Directory_base_names };

static int _wrap_log(lua_State* L) { int SWIG_arg = 0; ofLogLevel arg1 ; std::string *arg2 = 0 ; std::string temp2 ;
  SWIG_check_num_args("log",2,2) if(!lua_isnumber(L,1)) SWIG_fail_arg("log",1,"ofLogLevel");
  if(!lua_isstring(L,2)) SWIG_fail_arg("log",2,"std::string const &"); arg1 = (ofLogLevel)(int)lua_tonumber(L, 1);
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2; log(arg1,(std::string const &)*arg2); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_setLogLevel__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofLogLevel arg1 ;
  SWIG_check_num_args("ofSetLogLevel",1,1) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofSetLogLevel",1,"ofLogLevel");
  arg1 = (ofLogLevel)(int)lua_tonumber(L, 1); ofSetLogLevel(arg1); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_setLogLevel__SWIG_1(lua_State* L) { int SWIG_arg = 0; std::string arg1 ; ofLogLevel arg2 ;
  SWIG_check_num_args("ofSetLogLevel",2,2) if(!lua_isstring(L,1)) SWIG_fail_arg("ofSetLogLevel",1,"std::string");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofSetLogLevel",2,"ofLogLevel"); (&arg1)->assign(lua_tostring(L,1),lua_rawlen(L,1));
  arg2 = (ofLogLevel)(int)lua_tonumber(L, 2); ofSetLogLevel(arg1,arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_setLogLevel(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 1) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { return _wrap_setLogLevel__SWIG_0(L);}  }  if (argc == 2) { int _v; {
      _v = lua_isstring(L,argv[0]); }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) {
        return _wrap_setLogLevel__SWIG_1(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'setLogLevel'\n" "  Possible C/C++ prototypes are:\n"
  "    ofSetLogLevel(ofLogLevel)\n" "    ofSetLogLevel(std::string,ofLogLevel)\n"); lua_error(L);return 0; }
static int _wrap_getLogLevel__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofLogLevel result;
  SWIG_check_num_args("ofGetLogLevel",0,0) result = (ofLogLevel)ofGetLogLevel();
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_getLogLevel__SWIG_1(lua_State* L) { int SWIG_arg = 0; std::string arg1 ; ofLogLevel result;
  SWIG_check_num_args("ofGetLogLevel",1,1) if(!lua_isstring(L,1)) SWIG_fail_arg("ofGetLogLevel",1,"std::string");
  (&arg1)->assign(lua_tostring(L,1),lua_rawlen(L,1)); result = (ofLogLevel)ofGetLogLevel(arg1);
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_getLogLevel(lua_State* L) { int argc; int argv[2]={ 1,2} ; argc = lua_gettop(L); if (argc == 0) {
    return _wrap_getLogLevel__SWIG_0(L);}  if (argc == 1) { int _v; { _v = lua_isstring(L,argv[0]); }  if (_v) {
      return _wrap_getLogLevel__SWIG_1(L);}  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'getLogLevel'\n" "  Possible C/C++ prototypes are:\n"
  "    ofGetLogLevel()\n" "    ofGetLogLevel(std::string)\n"); lua_error(L);return 0; }
static int _wrap_getLogLevelName__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofLogLevel arg1 ; bool arg2 ; std::string result;
  SWIG_check_num_args("ofGetLogLevelName",2,2) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofGetLogLevelName",1,"ofLogLevel");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofGetLogLevelName",2,"bool"); arg1 = (ofLogLevel)(int)lua_tonumber(L, 1);
  arg2 = (lua_toboolean(L, 2)!=0); result = ofGetLogLevelName(arg1,arg2);
  lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_getLogLevelName__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofLogLevel arg1 ; std::string result;
  SWIG_check_num_args("ofGetLogLevelName",1,1) if(!lua_isnumber(L,1)) SWIG_fail_arg("ofGetLogLevelName",1,"ofLogLevel");
  arg1 = (ofLogLevel)(int)lua_tonumber(L, 1); result = ofGetLogLevelName(arg1);
  lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_getLogLevelName(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 1) { int _v;
    { _v = lua_isnumber(L,argv[0]); }  if (_v) { return _wrap_getLogLevelName__SWIG_1(L);}  }  if (argc == 2) { int _v; {
      _v = lua_isnumber(L,argv[0]); }  if (_v) { { _v = lua_isboolean(L,argv[1]); }  if (_v) {
        return _wrap_getLogLevelName__SWIG_0(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'getLogLevelName'\n" "  Possible C/C++ prototypes are:\n"
  "    ofGetLogLevelName(ofLogLevel,bool)\n" "    ofGetLogLevelName(ofLogLevel)\n"); lua_error(L);return 0; }
static int _wrap_logToFile__SWIG_0(lua_State* L) { int SWIG_arg = 0; std::filesystem::path *arg1 = 0 ; bool arg2 ;
  std::filesystem::path temp1 ; SWIG_check_num_args("ofLogToFile",2,2)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofLogToFile",1,"std::filesystem::path const &");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofLogToFile",2,"bool"); { size_t len = lua_rawlen(L, 1);
    temp1 = lua_tolstring(L, 1, &len); arg1 = &temp1; }  arg2 = (lua_toboolean(L, 2)!=0);
  ofLogToFile((boost::filesystem::path const &)*arg1,arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_logToFile__SWIG_1(lua_State* L) { int SWIG_arg = 0; std::filesystem::path *arg1 = 0 ;
  std::filesystem::path temp1 ; SWIG_check_num_args("ofLogToFile",1,1)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofLogToFile",1,"std::filesystem::path const &"); { size_t len = lua_rawlen(L, 1);
    temp1 = lua_tolstring(L, 1, &len); arg1 = &temp1; }  ofLogToFile((boost::filesystem::path const &)*arg1); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_logToFile(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 1) { int _v; {
      _v = lua_isstring(L, argv[0]); }  if (_v) { return _wrap_logToFile__SWIG_1(L);}  }  if (argc == 2) { int _v; {
      _v = lua_isstring(L, argv[0]); }  if (_v) { { _v = lua_isboolean(L,argv[1]); }  if (_v) {
        return _wrap_logToFile__SWIG_0(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'logToFile'\n" "  Possible C/C++ prototypes are:\n"
  "    ofLogToFile(std::filesystem::path const &,bool)\n" "    ofLogToFile(std::filesystem::path const &)\n");
  lua_error(L);return 0; }
static int _wrap_logToConsole(lua_State* L) { int SWIG_arg = 0; SWIG_check_num_args("ofLogToConsole",0,0) ofLogToConsole();
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_getLoggerChannel(lua_State* L) { int SWIG_arg = 0;
  SwigValueWrapper< std::shared_ptr< ofBaseLoggerChannel > > result; SWIG_check_num_args("ofGetLoggerChannel",0,0)
  result = ofGetLoggerChannel(); {
    std::shared_ptr< ofBaseLoggerChannel > * resultptr = new std::shared_ptr< ofBaseLoggerChannel >((const std::shared_ptr< ofBaseLoggerChannel > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_std__shared_ptrT_ofBaseLoggerChannel_t,1); SWIG_arg++; } 
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_new_FileDialogResult(lua_State* L) { int SWIG_arg = 0; ofFileDialogResult *result = 0 ;
  SWIG_check_num_args("ofFileDialogResult::ofFileDialogResult",0,0) result = (ofFileDialogResult *)new ofFileDialogResult();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofFileDialogResult,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_FileDialogResult_getName(lua_State* L) { int SWIG_arg = 0;
  ofFileDialogResult *arg1 = (ofFileDialogResult *) 0 ; std::string result;
  SWIG_check_num_args("ofFileDialogResult::getName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFileDialogResult::getName",1,"ofFileDialogResult *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFileDialogResult,0))){
    SWIG_fail_ptr("FileDialogResult_getName",1,SWIGTYPE_p_ofFileDialogResult); }  result = (arg1)->getName();
  lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_FileDialogResult_getPath(lua_State* L) { int SWIG_arg = 0;
  ofFileDialogResult *arg1 = (ofFileDialogResult *) 0 ; std::string result;
  SWIG_check_num_args("ofFileDialogResult::getPath",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFileDialogResult::getPath",1,"ofFileDialogResult *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFileDialogResult,0))){
    SWIG_fail_ptr("FileDialogResult_getPath",1,SWIGTYPE_p_ofFileDialogResult); }  result = (arg1)->getPath();
  lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_FileDialogResult_filePath_set(lua_State* L) { int SWIG_arg = 0;
  ofFileDialogResult *arg1 = (ofFileDialogResult *) 0 ; std::string *arg2 = 0 ; std::string temp2 ;
  SWIG_check_num_args("ofFileDialogResult::filePath",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFileDialogResult::filePath",1,"ofFileDialogResult *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofFileDialogResult::filePath",2,"std::string const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFileDialogResult,0))){
    SWIG_fail_ptr("FileDialogResult_filePath_set",1,SWIGTYPE_p_ofFileDialogResult); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2; if (arg1) (arg1)->filePath = *arg2; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FileDialogResult_filePath_get(lua_State* L) { int SWIG_arg = 0;
  ofFileDialogResult *arg1 = (ofFileDialogResult *) 0 ; std::string *result = 0 ;
  SWIG_check_num_args("ofFileDialogResult::filePath",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFileDialogResult::filePath",1,"ofFileDialogResult *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFileDialogResult,0))){
    SWIG_fail_ptr("FileDialogResult_filePath_get",1,SWIGTYPE_p_ofFileDialogResult); } 
  result = (std::string *) & ((arg1)->filePath); lua_pushlstring(L,result->data(),result->size()); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FileDialogResult_fileName_set(lua_State* L) { int SWIG_arg = 0;
  ofFileDialogResult *arg1 = (ofFileDialogResult *) 0 ; std::string *arg2 = 0 ; std::string temp2 ;
  SWIG_check_num_args("ofFileDialogResult::fileName",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFileDialogResult::fileName",1,"ofFileDialogResult *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofFileDialogResult::fileName",2,"std::string const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFileDialogResult,0))){
    SWIG_fail_ptr("FileDialogResult_fileName_set",1,SWIGTYPE_p_ofFileDialogResult); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2; if (arg1) (arg1)->fileName = *arg2; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FileDialogResult_fileName_get(lua_State* L) { int SWIG_arg = 0;
  ofFileDialogResult *arg1 = (ofFileDialogResult *) 0 ; std::string *result = 0 ;
  SWIG_check_num_args("ofFileDialogResult::fileName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFileDialogResult::fileName",1,"ofFileDialogResult *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFileDialogResult,0))){
    SWIG_fail_ptr("FileDialogResult_fileName_get",1,SWIGTYPE_p_ofFileDialogResult); } 
  result = (std::string *) & ((arg1)->fileName); lua_pushlstring(L,result->data(),result->size()); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FileDialogResult_bSuccess_set(lua_State* L) { int SWIG_arg = 0;
  ofFileDialogResult *arg1 = (ofFileDialogResult *) 0 ; bool arg2 ; SWIG_check_num_args("ofFileDialogResult::bSuccess",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFileDialogResult::bSuccess",1,"ofFileDialogResult *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofFileDialogResult::bSuccess",2,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFileDialogResult,0))){
    SWIG_fail_ptr("FileDialogResult_bSuccess_set",1,SWIGTYPE_p_ofFileDialogResult); }  arg2 = (lua_toboolean(L, 2)!=0);
  if (arg1) (arg1)->bSuccess = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_FileDialogResult_bSuccess_get(lua_State* L) { int SWIG_arg = 0;
  ofFileDialogResult *arg1 = (ofFileDialogResult *) 0 ; bool result; SWIG_check_num_args("ofFileDialogResult::bSuccess",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofFileDialogResult::bSuccess",1,"ofFileDialogResult *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofFileDialogResult,0))){
    SWIG_fail_ptr("FileDialogResult_bSuccess_get",1,SWIGTYPE_p_ofFileDialogResult); }  result = (bool) ((arg1)->bSuccess);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static void swig_delete_FileDialogResult(void *obj) {
ofFileDialogResult *arg1 = (ofFileDialogResult *) obj;
delete arg1;
}
static int _proxy__wrap_new_FileDialogResult(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_FileDialogResult);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_FileDialogResult_attributes[] = {
    { "filePath", _wrap_FileDialogResult_filePath_get, _wrap_FileDialogResult_filePath_set },
    { "fileName", _wrap_FileDialogResult_fileName_get, _wrap_FileDialogResult_fileName_set },
    { "bSuccess", _wrap_FileDialogResult_bSuccess_get, _wrap_FileDialogResult_bSuccess_set },
    {0,0,0}
};
static swig_lua_method swig_FileDialogResult_methods[]= {
    { "getName", _wrap_FileDialogResult_getName},
    { "getPath", _wrap_FileDialogResult_getPath},
    {0,0}
};
static swig_lua_method swig_FileDialogResult_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_FileDialogResult_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_FileDialogResult_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_FileDialogResult_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_FileDialogResult_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_FileDialogResult_Sf_SwigStatic = {
    "FileDialogResult",
    swig_FileDialogResult_Sf_SwigStatic_methods,
    swig_FileDialogResult_Sf_SwigStatic_attributes,
    swig_FileDialogResult_Sf_SwigStatic_constants,
    swig_FileDialogResult_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_FileDialogResult_bases[] = {0};
static const char *swig_FileDialogResult_base_names[] = {0};
static swig_lua_class _wrap_class_FileDialogResult = { "FileDialogResult", "FileDialogResult", &SWIGTYPE_p_ofFileDialogResult,_proxy__wrap_new_FileDialogResult, swig_delete_FileDialogResult, swig_FileDialogResult_methods, swig_FileDialogResult_attributes, &swig_FileDialogResult_Sf_SwigStatic, swig_FileDialogResult_meta, swig_FileDialogResult_bases, swig_FileDialogResult_base_names };

static int _wrap_systemAlertDialog(lua_State* L) { int SWIG_arg = 0; std::string arg1 ;
  SWIG_check_num_args("ofSystemAlertDialog",1,1) if(!lua_isstring(L,1)) SWIG_fail_arg("ofSystemAlertDialog",1,"std::string");
  (&arg1)->assign(lua_tostring(L,1),lua_rawlen(L,1)); ofSystemAlertDialog(arg1); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_systemLoadDialog__SWIG_0(lua_State* L) { int SWIG_arg = 0; std::string arg1 ; bool arg2 ; std::string arg3 ;
  ofFileDialogResult result; SWIG_check_num_args("ofSystemLoadDialog",3,3)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofSystemLoadDialog",1,"std::string");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofSystemLoadDialog",2,"bool");
  if(!lua_isstring(L,3)) SWIG_fail_arg("ofSystemLoadDialog",3,"std::string");
  (&arg1)->assign(lua_tostring(L,1),lua_rawlen(L,1)); arg2 = (lua_toboolean(L, 2)!=0);
  (&arg3)->assign(lua_tostring(L,3),lua_rawlen(L,3)); result = ofSystemLoadDialog(arg1,arg2,arg3); {
    ofFileDialogResult * resultptr = new ofFileDialogResult((const ofFileDialogResult &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofFileDialogResult,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_systemLoadDialog__SWIG_1(lua_State* L) { int SWIG_arg = 0; std::string arg1 ; bool arg2 ;
  ofFileDialogResult result; SWIG_check_num_args("ofSystemLoadDialog",2,2)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofSystemLoadDialog",1,"std::string");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofSystemLoadDialog",2,"bool"); (&arg1)->assign(lua_tostring(L,1),lua_rawlen(L,1));
  arg2 = (lua_toboolean(L, 2)!=0); result = ofSystemLoadDialog(arg1,arg2); {
    ofFileDialogResult * resultptr = new ofFileDialogResult((const ofFileDialogResult &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofFileDialogResult,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_systemLoadDialog__SWIG_2(lua_State* L) { int SWIG_arg = 0; std::string arg1 ; ofFileDialogResult result;
  SWIG_check_num_args("ofSystemLoadDialog",1,1) if(!lua_isstring(L,1)) SWIG_fail_arg("ofSystemLoadDialog",1,"std::string");
  (&arg1)->assign(lua_tostring(L,1),lua_rawlen(L,1)); result = ofSystemLoadDialog(arg1); {
    ofFileDialogResult * resultptr = new ofFileDialogResult((const ofFileDialogResult &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofFileDialogResult,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_systemLoadDialog__SWIG_3(lua_State* L) { int SWIG_arg = 0; ofFileDialogResult result;
  SWIG_check_num_args("ofSystemLoadDialog",0,0) result = ofSystemLoadDialog(); {
    ofFileDialogResult * resultptr = new ofFileDialogResult((const ofFileDialogResult &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofFileDialogResult,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_systemLoadDialog(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 0) {
    return _wrap_systemLoadDialog__SWIG_3(L);}  if (argc == 1) { int _v; { _v = lua_isstring(L,argv[0]); }  if (_v) {
      return _wrap_systemLoadDialog__SWIG_2(L);}  }  if (argc == 2) { int _v; { _v = lua_isstring(L,argv[0]); }  if (_v) { {
        _v = lua_isboolean(L,argv[1]); }  if (_v) { return _wrap_systemLoadDialog__SWIG_1(L);}  }  }  if (argc == 3) { int _v; {
      _v = lua_isstring(L,argv[0]); }  if (_v) { { _v = lua_isboolean(L,argv[1]); }  if (_v) { { _v = lua_isstring(L,argv[2]); }
         if (_v) { return _wrap_systemLoadDialog__SWIG_0(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'systemLoadDialog'\n" "  Possible C/C++ prototypes are:\n"
  "    ofSystemLoadDialog(std::string,bool,std::string)\n" "    ofSystemLoadDialog(std::string,bool)\n"
  "    ofSystemLoadDialog(std::string)\n" "    ofSystemLoadDialog()\n"); lua_error(L);return 0; }
static int _wrap_systemSaveDialog(lua_State* L) { int SWIG_arg = 0; std::string arg1 ; std::string arg2 ;
  ofFileDialogResult result; SWIG_check_num_args("ofSystemSaveDialog",2,2)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofSystemSaveDialog",1,"std::string");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofSystemSaveDialog",2,"std::string");
  (&arg1)->assign(lua_tostring(L,1),lua_rawlen(L,1)); (&arg2)->assign(lua_tostring(L,2),lua_rawlen(L,2));
  result = ofSystemSaveDialog(arg1,arg2); {
    ofFileDialogResult * resultptr = new ofFileDialogResult((const ofFileDialogResult &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofFileDialogResult,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_systemTextBoxDialog__SWIG_0(lua_State* L) { int SWIG_arg = 0; std::string arg1 ; std::string arg2 ;
  std::string result; SWIG_check_num_args("ofSystemTextBoxDialog",2,2)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofSystemTextBoxDialog",1,"std::string");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofSystemTextBoxDialog",2,"std::string");
  (&arg1)->assign(lua_tostring(L,1),lua_rawlen(L,1)); (&arg2)->assign(lua_tostring(L,2),lua_rawlen(L,2));
  result = ofSystemTextBoxDialog(arg1,arg2); lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_systemTextBoxDialog__SWIG_1(lua_State* L) { int SWIG_arg = 0; std::string arg1 ; std::string result;
  SWIG_check_num_args("ofSystemTextBoxDialog",1,1)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofSystemTextBoxDialog",1,"std::string");
  (&arg1)->assign(lua_tostring(L,1),lua_rawlen(L,1)); result = ofSystemTextBoxDialog(arg1);
  lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_systemTextBoxDialog(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 1) {
    int _v; { _v = lua_isstring(L,argv[0]); }  if (_v) { return _wrap_systemTextBoxDialog__SWIG_1(L);}  }  if (argc == 2) {
    int _v; { _v = lua_isstring(L,argv[0]); }  if (_v) { { _v = lua_isstring(L,argv[1]); }  if (_v) {
        return _wrap_systemTextBoxDialog__SWIG_0(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'systemTextBoxDialog'\n"
  "  Possible C/C++ prototypes are:\n" "    ofSystemTextBoxDialog(std::string,std::string)\n"
  "    ofSystemTextBoxDialog(std::string)\n"); lua_error(L);return 0; }
static int _wrap_new_HttpRequest__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofHttpRequest *result = 0 ;
  SWIG_check_num_args("ofHttpRequest::ofHttpRequest",0,0) result = (ofHttpRequest *)new ofHttpRequest();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofHttpRequest,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_HttpRequest__SWIG_1(lua_State* L) { int SWIG_arg = 0; std::string *arg1 = 0 ; std::string *arg2 = 0 ;
  bool arg3 ; std::string temp1 ; std::string temp2 ; ofHttpRequest *result = 0 ;
  SWIG_check_num_args("ofHttpRequest::ofHttpRequest",3,3)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofHttpRequest::ofHttpRequest",1,"std::string const &");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofHttpRequest::ofHttpRequest",2,"std::string const &");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("ofHttpRequest::ofHttpRequest",3,"bool");
  temp1.assign(lua_tostring(L,1),lua_rawlen(L,1)); arg1=&temp1; temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  arg3 = (lua_toboolean(L, 3)!=0);
  result = (ofHttpRequest *)new ofHttpRequest((std::string const &)*arg1,(std::string const &)*arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofHttpRequest,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_HttpRequest__SWIG_2(lua_State* L) { int SWIG_arg = 0; std::string *arg1 = 0 ; std::string *arg2 = 0 ;
  std::string temp1 ; std::string temp2 ; ofHttpRequest *result = 0 ; SWIG_check_num_args("ofHttpRequest::ofHttpRequest",2,2)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofHttpRequest::ofHttpRequest",1,"std::string const &");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofHttpRequest::ofHttpRequest",2,"std::string const &");
  temp1.assign(lua_tostring(L,1),lua_rawlen(L,1)); arg1=&temp1; temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  result = (ofHttpRequest *)new ofHttpRequest((std::string const &)*arg1,(std::string const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofHttpRequest,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_HttpRequest(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L); if (argc == 0) {
    return _wrap_new_HttpRequest__SWIG_0(L);}  if (argc == 2) { int _v; { _v = lua_isstring(L,argv[0]); }  if (_v) { {
        _v = lua_isstring(L,argv[1]); }  if (_v) { return _wrap_new_HttpRequest__SWIG_2(L);}  }  }  if (argc == 3) { int _v; {
      _v = lua_isstring(L,argv[0]); }  if (_v) { { _v = lua_isstring(L,argv[1]); }  if (_v) { { _v = lua_isboolean(L,argv[2]); }
         if (_v) { return _wrap_new_HttpRequest__SWIG_1(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_HttpRequest'\n" "  Possible C/C++ prototypes are:\n"
  "    ofHttpRequest::ofHttpRequest()\n" "    ofHttpRequest::ofHttpRequest(std::string const &,std::string const &,bool)\n"
  "    ofHttpRequest::ofHttpRequest(std::string const &,std::string const &)\n"); lua_error(L);return 0; }
static int _wrap_HttpRequest_url_set(lua_State* L) { int SWIG_arg = 0; ofHttpRequest *arg1 = (ofHttpRequest *) 0 ;
  std::string *arg2 = 0 ; std::string temp2 ; SWIG_check_num_args("ofHttpRequest::url",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofHttpRequest::url",1,"ofHttpRequest *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofHttpRequest::url",2,"std::string const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofHttpRequest,0))){
    SWIG_fail_ptr("HttpRequest_url_set",1,SWIGTYPE_p_ofHttpRequest); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2; if (arg1) (arg1)->url = *arg2; return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_HttpRequest_url_get(lua_State* L) { int SWIG_arg = 0; ofHttpRequest *arg1 = (ofHttpRequest *) 0 ;
  std::string *result = 0 ; SWIG_check_num_args("ofHttpRequest::url",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofHttpRequest::url",1,"ofHttpRequest *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofHttpRequest,0))){
    SWIG_fail_ptr("HttpRequest_url_get",1,SWIGTYPE_p_ofHttpRequest); }  result = (std::string *) & ((arg1)->url);
  lua_pushlstring(L,result->data(),result->size()); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_HttpRequest_name_set(lua_State* L) { int SWIG_arg = 0; ofHttpRequest *arg1 = (ofHttpRequest *) 0 ;
  std::string *arg2 = 0 ; std::string temp2 ; SWIG_check_num_args("ofHttpRequest::name",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofHttpRequest::name",1,"ofHttpRequest *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofHttpRequest::name",2,"std::string const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofHttpRequest,0))){
    SWIG_fail_ptr("HttpRequest_name_set",1,SWIGTYPE_p_ofHttpRequest); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2; if (arg1) (arg1)->name = *arg2; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_HttpRequest_name_get(lua_State* L) { int SWIG_arg = 0; ofHttpRequest *arg1 = (ofHttpRequest *) 0 ;
  std::string *result = 0 ; SWIG_check_num_args("ofHttpRequest::name",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofHttpRequest::name",1,"ofHttpRequest *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofHttpRequest,0))){
    SWIG_fail_ptr("HttpRequest_name_get",1,SWIGTYPE_p_ofHttpRequest); }  result = (std::string *) & ((arg1)->name);
  lua_pushlstring(L,result->data(),result->size()); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_HttpRequest_saveTo_set(lua_State* L) { int SWIG_arg = 0; ofHttpRequest *arg1 = (ofHttpRequest *) 0 ;
  bool arg2 ; SWIG_check_num_args("ofHttpRequest::saveTo",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofHttpRequest::saveTo",1,"ofHttpRequest *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofHttpRequest::saveTo",2,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofHttpRequest,0))){
    SWIG_fail_ptr("HttpRequest_saveTo_set",1,SWIGTYPE_p_ofHttpRequest); }  arg2 = (lua_toboolean(L, 2)!=0);
  if (arg1) (arg1)->saveTo = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_HttpRequest_saveTo_get(lua_State* L) { int SWIG_arg = 0; ofHttpRequest *arg1 = (ofHttpRequest *) 0 ;
  bool result; SWIG_check_num_args("ofHttpRequest::saveTo",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofHttpRequest::saveTo",1,"ofHttpRequest *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofHttpRequest,0))){
    SWIG_fail_ptr("HttpRequest_saveTo_get",1,SWIGTYPE_p_ofHttpRequest); }  result = (bool) ((arg1)->saveTo);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_HttpRequest_headers_set(lua_State* L) { int SWIG_arg = 0; ofHttpRequest *arg1 = (ofHttpRequest *) 0 ;
  std::map< std::string,std::string > *arg2 = (std::map< std::string,std::string > *) 0 ;
  SWIG_check_num_args("ofHttpRequest::headers",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofHttpRequest::headers",1,"ofHttpRequest *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofHttpRequest::headers",2,"std::map< std::string,std::string > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofHttpRequest,0))){
    SWIG_fail_ptr("HttpRequest_headers_set",1,SWIGTYPE_p_ofHttpRequest); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_std__mapT_std__string_std__string_t,0))){
    SWIG_fail_ptr("HttpRequest_headers_set",2,SWIGTYPE_p_std__mapT_std__string_std__string_t); } 
  if (arg1) (arg1)->headers = *arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_HttpRequest_headers_get(lua_State* L) { int SWIG_arg = 0; ofHttpRequest *arg1 = (ofHttpRequest *) 0 ;
  std::map< std::string,std::string > *result = 0 ; SWIG_check_num_args("ofHttpRequest::headers",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofHttpRequest::headers",1,"ofHttpRequest *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofHttpRequest,0))){
    SWIG_fail_ptr("HttpRequest_headers_get",1,SWIGTYPE_p_ofHttpRequest); } 
  result = (std::map< std::string,std::string > *)& ((arg1)->headers);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__mapT_std__string_std__string_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_HttpRequest_body_set(lua_State* L) { int SWIG_arg = 0; ofHttpRequest *arg1 = (ofHttpRequest *) 0 ;
  std::string *arg2 = 0 ; std::string temp2 ; SWIG_check_num_args("ofHttpRequest::body",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofHttpRequest::body",1,"ofHttpRequest *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofHttpRequest::body",2,"std::string const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofHttpRequest,0))){
    SWIG_fail_ptr("HttpRequest_body_set",1,SWIGTYPE_p_ofHttpRequest); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2; if (arg1) (arg1)->body = *arg2; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_HttpRequest_body_get(lua_State* L) { int SWIG_arg = 0; ofHttpRequest *arg1 = (ofHttpRequest *) 0 ;
  std::string *result = 0 ; SWIG_check_num_args("ofHttpRequest::body",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofHttpRequest::body",1,"ofHttpRequest *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofHttpRequest,0))){
    SWIG_fail_ptr("HttpRequest_body_get",1,SWIGTYPE_p_ofHttpRequest); }  result = (std::string *) & ((arg1)->body);
  lua_pushlstring(L,result->data(),result->size()); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_HttpRequest_contentType_set(lua_State* L) { int SWIG_arg = 0; ofHttpRequest *arg1 = (ofHttpRequest *) 0 ;
  std::string *arg2 = 0 ; std::string temp2 ; SWIG_check_num_args("ofHttpRequest::contentType",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofHttpRequest::contentType",1,"ofHttpRequest *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofHttpRequest::contentType",2,"std::string const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofHttpRequest,0))){
    SWIG_fail_ptr("HttpRequest_contentType_set",1,SWIGTYPE_p_ofHttpRequest); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2; if (arg1) (arg1)->contentType = *arg2; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_HttpRequest_contentType_get(lua_State* L) { int SWIG_arg = 0; ofHttpRequest *arg1 = (ofHttpRequest *) 0 ;
  std::string *result = 0 ; SWIG_check_num_args("ofHttpRequest::contentType",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofHttpRequest::contentType",1,"ofHttpRequest *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofHttpRequest,0))){
    SWIG_fail_ptr("HttpRequest_contentType_get",1,SWIGTYPE_p_ofHttpRequest); } 
  result = (std::string *) & ((arg1)->contentType); lua_pushlstring(L,result->data(),result->size()); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_HttpRequest_done_set(lua_State* L) { int SWIG_arg = 0; ofHttpRequest *arg1 = (ofHttpRequest *) 0 ;
  std::function< void (ofHttpResponse const &) > *arg2 = (std::function< void (ofHttpResponse const &) > *) 0 ;
  SWIG_check_num_args("ofHttpRequest::done",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofHttpRequest::done",1,"ofHttpRequest *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofHttpRequest::done",2,"std::function< void (ofHttpResponse const &) > *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofHttpRequest,0))){
    SWIG_fail_ptr("HttpRequest_done_set",1,SWIGTYPE_p_ofHttpRequest); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_std__functionT_void_fofHttpResponse_const_RF_t,0))){
    SWIG_fail_ptr("HttpRequest_done_set",2,SWIGTYPE_p_std__functionT_void_fofHttpResponse_const_RF_t); } 
  if (arg1) (arg1)->done = *arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_HttpRequest_done_get(lua_State* L) { int SWIG_arg = 0; ofHttpRequest *arg1 = (ofHttpRequest *) 0 ;
  std::function< void (ofHttpResponse const &) > *result = 0 ; SWIG_check_num_args("ofHttpRequest::done",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofHttpRequest::done",1,"ofHttpRequest *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofHttpRequest,0))){
    SWIG_fail_ptr("HttpRequest_done_get",1,SWIGTYPE_p_ofHttpRequest); } 
  result = (std::function< void (ofHttpResponse const &) > *)& ((arg1)->done);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__functionT_void_fofHttpResponse_const_RF_t,0); SWIG_arg++;  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_HttpRequest_timeoutSeconds_set(lua_State* L) { int SWIG_arg = 0; ofHttpRequest *arg1 = (ofHttpRequest *) 0 ;
  size_t arg2 ; SWIG_check_num_args("ofHttpRequest::timeoutSeconds",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofHttpRequest::timeoutSeconds",1,"ofHttpRequest *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofHttpRequest::timeoutSeconds",2,"size_t");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofHttpRequest,0))){
    SWIG_fail_ptr("HttpRequest_timeoutSeconds_set",1,SWIGTYPE_p_ofHttpRequest); } 
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative") arg2 = (size_t)lua_tonumber(L, 2);
  if (arg1) (arg1)->timeoutSeconds = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_HttpRequest_timeoutSeconds_get(lua_State* L) { int SWIG_arg = 0; ofHttpRequest *arg1 = (ofHttpRequest *) 0 ;
  size_t result; SWIG_check_num_args("ofHttpRequest::timeoutSeconds",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofHttpRequest::timeoutSeconds",1,"ofHttpRequest *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofHttpRequest,0))){
    SWIG_fail_ptr("HttpRequest_timeoutSeconds_get",1,SWIGTYPE_p_ofHttpRequest); }  result = (size_t) ((arg1)->timeoutSeconds);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_HttpRequest_getId(lua_State* L) { int SWIG_arg = 0; ofHttpRequest *arg1 = (ofHttpRequest *) 0 ; int result;
  SWIG_check_num_args("ofHttpRequest::getId",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofHttpRequest::getId",1,"ofHttpRequest const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofHttpRequest,0))){
    SWIG_fail_ptr("HttpRequest_getId",1,SWIGTYPE_p_ofHttpRequest); }  result = (int)((ofHttpRequest const *)arg1)->getId();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_HttpRequest_method_set(lua_State* L) { int SWIG_arg = 0; ofHttpRequest *arg1 = (ofHttpRequest *) 0 ;
  enum ofHttpRequest::Method arg2 ; SWIG_check_num_args("ofHttpRequest::method",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofHttpRequest::method",1,"ofHttpRequest *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofHttpRequest::method",2,"enum ofHttpRequest::Method");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofHttpRequest,0))){
    SWIG_fail_ptr("HttpRequest_method_set",1,SWIGTYPE_p_ofHttpRequest); } 
  arg2 = (enum ofHttpRequest::Method)(int)lua_tonumber(L, 2); if (arg1) (arg1)->method = arg2; return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_HttpRequest_method_get(lua_State* L) { int SWIG_arg = 0; ofHttpRequest *arg1 = (ofHttpRequest *) 0 ;
  enum ofHttpRequest::Method result; SWIG_check_num_args("ofHttpRequest::method",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofHttpRequest::method",1,"ofHttpRequest *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofHttpRequest,0))){
    SWIG_fail_ptr("HttpRequest_method_get",1,SWIGTYPE_p_ofHttpRequest); } 
  result = (enum ofHttpRequest::Method) ((arg1)->method); lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static void swig_delete_HttpRequest(void *obj) {
ofHttpRequest *arg1 = (ofHttpRequest *) obj;
delete arg1;
}
static int _proxy__wrap_new_HttpRequest(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_HttpRequest);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_HttpRequest_attributes[] = {
    { "url", _wrap_HttpRequest_url_get, _wrap_HttpRequest_url_set },
    { "name", _wrap_HttpRequest_name_get, _wrap_HttpRequest_name_set },
    { "saveTo", _wrap_HttpRequest_saveTo_get, _wrap_HttpRequest_saveTo_set },
    { "headers", _wrap_HttpRequest_headers_get, _wrap_HttpRequest_headers_set },
    { "body", _wrap_HttpRequest_body_get, _wrap_HttpRequest_body_set },
    { "contentType", _wrap_HttpRequest_contentType_get, _wrap_HttpRequest_contentType_set },
    { "done", _wrap_HttpRequest_done_get, _wrap_HttpRequest_done_set },
    { "timeoutSeconds", _wrap_HttpRequest_timeoutSeconds_get, _wrap_HttpRequest_timeoutSeconds_set },
    { "method", _wrap_HttpRequest_method_get, _wrap_HttpRequest_method_set },
    {0,0,0}
};
static swig_lua_method swig_HttpRequest_methods[]= {
    { "getId", _wrap_HttpRequest_getId},
    {0,0}
};
static swig_lua_method swig_HttpRequest_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_HttpRequest_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_HttpRequest_Sf_SwigStatic_constants[]= {
    {SWIG_LUA_CONSTTAB_INT("GET", ofHttpRequest::GET)},
    {SWIG_LUA_CONSTTAB_INT("POST", ofHttpRequest::POST)},
    {0,0,0,0,0,0}
};
static swig_lua_method swig_HttpRequest_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_HttpRequest_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_HttpRequest_Sf_SwigStatic = {
    "HttpRequest",
    swig_HttpRequest_Sf_SwigStatic_methods,
    swig_HttpRequest_Sf_SwigStatic_attributes,
    swig_HttpRequest_Sf_SwigStatic_constants,
    swig_HttpRequest_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_HttpRequest_bases[] = {0};
static const char *swig_HttpRequest_base_names[] = {0};
static swig_lua_class _wrap_class_HttpRequest = { "HttpRequest", "HttpRequest", &SWIGTYPE_p_ofHttpRequest,_proxy__wrap_new_HttpRequest, swig_delete_HttpRequest, swig_HttpRequest_methods, swig_HttpRequest_attributes, &swig_HttpRequest_Sf_SwigStatic, swig_HttpRequest_meta, swig_HttpRequest_bases, swig_HttpRequest_base_names };

static int _wrap_new_HttpResponse__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofHttpResponse *result = 0 ;
  SWIG_check_num_args("ofHttpResponse::ofHttpResponse",0,0) result = (ofHttpResponse *)new ofHttpResponse();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofHttpResponse,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_HttpResponse__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofHttpRequest *arg1 = 0 ; ofBuffer *arg2 = 0 ;
  int arg3 ; std::string *arg4 = 0 ; std::string temp4 ; ofHttpResponse *result = 0 ;
  SWIG_check_num_args("ofHttpResponse::ofHttpResponse",4,4)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofHttpResponse::ofHttpResponse",1,"ofHttpRequest const &");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofHttpResponse::ofHttpResponse",2,"ofBuffer const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofHttpResponse::ofHttpResponse",3,"int");
  if(!lua_isstring(L,4)) SWIG_fail_arg("ofHttpResponse::ofHttpResponse",4,"std::string const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofHttpRequest,0))){
    SWIG_fail_ptr("new_HttpResponse",1,SWIGTYPE_p_ofHttpRequest); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofBuffer,0))){
    SWIG_fail_ptr("new_HttpResponse",2,SWIGTYPE_p_ofBuffer); }  arg3 = (int)lua_tonumber(L, 3);
  temp4.assign(lua_tostring(L,4),lua_rawlen(L,4)); arg4=&temp4;
  result = (ofHttpResponse *)new ofHttpResponse((ofHttpRequest const &)*arg1,(ofBuffer const &)*arg2,arg3,(std::string const &)*arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofHttpResponse,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_HttpResponse__SWIG_2(lua_State* L) { int SWIG_arg = 0; ofHttpRequest *arg1 = 0 ; int arg2 ;
  std::string *arg3 = 0 ; std::string temp3 ; ofHttpResponse *result = 0 ;
  SWIG_check_num_args("ofHttpResponse::ofHttpResponse",3,3)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("ofHttpResponse::ofHttpResponse",1,"ofHttpRequest const &");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofHttpResponse::ofHttpResponse",2,"int");
  if(!lua_isstring(L,3)) SWIG_fail_arg("ofHttpResponse::ofHttpResponse",3,"std::string const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofHttpRequest,0))){
    SWIG_fail_ptr("new_HttpResponse",1,SWIGTYPE_p_ofHttpRequest); }  arg2 = (int)lua_tonumber(L, 2);
  temp3.assign(lua_tostring(L,3),lua_rawlen(L,3)); arg3=&temp3;
  result = (ofHttpResponse *)new ofHttpResponse((ofHttpRequest const &)*arg1,arg2,(std::string const &)*arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofHttpResponse,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_new_HttpResponse(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L); if (argc == 0) {
    return _wrap_new_HttpResponse__SWIG_0(L);}  if (argc == 3) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofHttpRequest, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isstring(L,argv[2]); }  if (_v) {
          return _wrap_new_HttpResponse__SWIG_2(L);}  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofHttpRequest, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofBuffer, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isstring(L,argv[3]); } 
          if (_v) { return _wrap_new_HttpResponse__SWIG_1(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'new_HttpResponse'\n" "  Possible C/C++ prototypes are:\n"
  "    ofHttpResponse::ofHttpResponse()\n"
  "    ofHttpResponse::ofHttpResponse(ofHttpRequest const &,ofBuffer const &,int,std::string const &)\n"
  "    ofHttpResponse::ofHttpResponse(ofHttpRequest const &,int,std::string const &)\n"); lua_error(L);return 0; }
static int _wrap_HttpResponse_request_set(lua_State* L) { int SWIG_arg = 0; ofHttpResponse *arg1 = (ofHttpResponse *) 0 ;
  ofHttpRequest *arg2 = (ofHttpRequest *) 0 ; SWIG_check_num_args("ofHttpResponse::request",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofHttpResponse::request",1,"ofHttpResponse *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofHttpResponse::request",2,"ofHttpRequest *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofHttpResponse,0))){
    SWIG_fail_ptr("HttpResponse_request_set",1,SWIGTYPE_p_ofHttpResponse); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofHttpRequest,0))){
    SWIG_fail_ptr("HttpResponse_request_set",2,SWIGTYPE_p_ofHttpRequest); }  if (arg1) (arg1)->request = *arg2; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_HttpResponse_request_get(lua_State* L) { int SWIG_arg = 0; ofHttpResponse *arg1 = (ofHttpResponse *) 0 ;
  ofHttpRequest *result = 0 ; SWIG_check_num_args("ofHttpResponse::request",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofHttpResponse::request",1,"ofHttpResponse *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofHttpResponse,0))){
    SWIG_fail_ptr("HttpResponse_request_get",1,SWIGTYPE_p_ofHttpResponse); }  result = (ofHttpRequest *)& ((arg1)->request);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofHttpRequest,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_HttpResponse_data_set(lua_State* L) { int SWIG_arg = 0; ofHttpResponse *arg1 = (ofHttpResponse *) 0 ;
  ofBuffer *arg2 = (ofBuffer *) 0 ; SWIG_check_num_args("ofHttpResponse::data",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofHttpResponse::data",1,"ofHttpResponse *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ofHttpResponse::data",2,"ofBuffer *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofHttpResponse,0))){
    SWIG_fail_ptr("HttpResponse_data_set",1,SWIGTYPE_p_ofHttpResponse); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofBuffer,0))){
    SWIG_fail_ptr("HttpResponse_data_set",2,SWIGTYPE_p_ofBuffer); }  if (arg1) (arg1)->data = *arg2; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_HttpResponse_data_get(lua_State* L) { int SWIG_arg = 0; ofHttpResponse *arg1 = (ofHttpResponse *) 0 ;
  ofBuffer *result = 0 ; SWIG_check_num_args("ofHttpResponse::data",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofHttpResponse::data",1,"ofHttpResponse *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofHttpResponse,0))){
    SWIG_fail_ptr("HttpResponse_data_get",1,SWIGTYPE_p_ofHttpResponse); }  result = (ofBuffer *)& ((arg1)->data);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofBuffer,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_HttpResponse_status_set(lua_State* L) { int SWIG_arg = 0; ofHttpResponse *arg1 = (ofHttpResponse *) 0 ;
  int arg2 ; SWIG_check_num_args("ofHttpResponse::status",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofHttpResponse::status",1,"ofHttpResponse *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofHttpResponse::status",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofHttpResponse,0))){
    SWIG_fail_ptr("HttpResponse_status_set",1,SWIGTYPE_p_ofHttpResponse); }  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->status = arg2; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_HttpResponse_status_get(lua_State* L) { int SWIG_arg = 0; ofHttpResponse *arg1 = (ofHttpResponse *) 0 ;
  int result; SWIG_check_num_args("ofHttpResponse::status",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofHttpResponse::status",1,"ofHttpResponse *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofHttpResponse,0))){
    SWIG_fail_ptr("HttpResponse_status_get",1,SWIGTYPE_p_ofHttpResponse); }  result = (int) ((arg1)->status);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_HttpResponse_error_set(lua_State* L) { int SWIG_arg = 0; ofHttpResponse *arg1 = (ofHttpResponse *) 0 ;
  std::string *arg2 = 0 ; std::string temp2 ; SWIG_check_num_args("ofHttpResponse::error",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofHttpResponse::error",1,"ofHttpResponse *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofHttpResponse::error",2,"std::string const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofHttpResponse,0))){
    SWIG_fail_ptr("HttpResponse_error_set",1,SWIGTYPE_p_ofHttpResponse); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2; if (arg1) (arg1)->error = *arg2; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_HttpResponse_error_get(lua_State* L) { int SWIG_arg = 0; ofHttpResponse *arg1 = (ofHttpResponse *) 0 ;
  std::string *result = 0 ; SWIG_check_num_args("ofHttpResponse::error",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofHttpResponse::error",1,"ofHttpResponse *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofHttpResponse,0))){
    SWIG_fail_ptr("HttpResponse_error_get",1,SWIGTYPE_p_ofHttpResponse); }  result = (std::string *) & ((arg1)->error);
  lua_pushlstring(L,result->data(),result->size()); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static void swig_delete_HttpResponse(void *obj) {
ofHttpResponse *arg1 = (ofHttpResponse *) obj;
delete arg1;
}
static int _proxy__wrap_new_HttpResponse(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_HttpResponse);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_HttpResponse_attributes[] = {
    { "request", _wrap_HttpResponse_request_get, _wrap_HttpResponse_request_set },
    { "data", _wrap_HttpResponse_data_get, _wrap_HttpResponse_data_set },
    { "status", _wrap_HttpResponse_status_get, _wrap_HttpResponse_status_set },
    { "error", _wrap_HttpResponse_error_get, _wrap_HttpResponse_error_set },
    {0,0,0}
};
static swig_lua_method swig_HttpResponse_methods[]= {
    {0,0}
};
static swig_lua_method swig_HttpResponse_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_HttpResponse_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_HttpResponse_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_HttpResponse_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_HttpResponse_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_HttpResponse_Sf_SwigStatic = {
    "HttpResponse",
    swig_HttpResponse_Sf_SwigStatic_methods,
    swig_HttpResponse_Sf_SwigStatic_attributes,
    swig_HttpResponse_Sf_SwigStatic_constants,
    swig_HttpResponse_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_HttpResponse_bases[] = {0};
static const char *swig_HttpResponse_base_names[] = {0};
static swig_lua_class _wrap_class_HttpResponse = { "HttpResponse", "HttpResponse", &SWIGTYPE_p_ofHttpResponse,_proxy__wrap_new_HttpResponse, swig_delete_HttpResponse, swig_HttpResponse_methods, swig_HttpResponse_attributes, &swig_HttpResponse_Sf_SwigStatic, swig_HttpResponse_meta, swig_HttpResponse_bases, swig_HttpResponse_base_names };

static int _wrap_loadURL(lua_State* L) { int SWIG_arg = 0; std::string *arg1 = 0 ; std::string temp1 ; ofHttpResponse result;
  SWIG_check_num_args("ofLoadURL",1,1) if(!lua_isstring(L,1)) SWIG_fail_arg("ofLoadURL",1,"std::string const &");
  temp1.assign(lua_tostring(L,1),lua_rawlen(L,1)); arg1=&temp1; result = ofLoadURL((std::string const &)*arg1); {
    ofHttpResponse * resultptr = new ofHttpResponse((const ofHttpResponse &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofHttpResponse,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_loadURLAsync__SWIG_0(lua_State* L) { int SWIG_arg = 0; std::string *arg1 = 0 ; std::string *arg2 = 0 ;
  std::string temp1 ; std::string temp2 ; int result; SWIG_check_num_args("ofLoadURLAsync",2,2)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofLoadURLAsync",1,"std::string const &");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofLoadURLAsync",2,"std::string const &");
  temp1.assign(lua_tostring(L,1),lua_rawlen(L,1)); arg1=&temp1; temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2;
  result = (int)ofLoadURLAsync((std::string const &)*arg1,(std::string const &)*arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_loadURLAsync__SWIG_1(lua_State* L) { int SWIG_arg = 0; std::string *arg1 = 0 ; std::string temp1 ; int result;
  SWIG_check_num_args("ofLoadURLAsync",1,1) if(!lua_isstring(L,1)) SWIG_fail_arg("ofLoadURLAsync",1,"std::string const &");
  temp1.assign(lua_tostring(L,1),lua_rawlen(L,1)); arg1=&temp1; result = (int)ofLoadURLAsync((std::string const &)*arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_loadURLAsync(lua_State* L) { int argc; int argv[3]={ 1,2,3} ; argc = lua_gettop(L); if (argc == 1) { int _v; {
      _v = lua_isstring(L,argv[0]); }  if (_v) { return _wrap_loadURLAsync__SWIG_1(L);}  }  if (argc == 2) { int _v; {
      _v = lua_isstring(L,argv[0]); }  if (_v) { { _v = lua_isstring(L,argv[1]); }  if (_v) {
        return _wrap_loadURLAsync__SWIG_0(L);}  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'loadURLAsync'\n" "  Possible C/C++ prototypes are:\n"
  "    ofLoadURLAsync(std::string const &,std::string const &)\n" "    ofLoadURLAsync(std::string const &)\n");
  lua_error(L);return 0; }
static int _wrap_saveURLTo(lua_State* L) { int SWIG_arg = 0; std::string *arg1 = 0 ; std::filesystem::path *arg2 = 0 ;
  std::string temp1 ; std::filesystem::path temp2 ; ofHttpResponse result; SWIG_check_num_args("ofSaveURLTo",2,2)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofSaveURLTo",1,"std::string const &");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofSaveURLTo",2,"std::filesystem::path const &");
  temp1.assign(lua_tostring(L,1),lua_rawlen(L,1)); arg1=&temp1; { size_t len = lua_rawlen(L, 2);
    temp2 = lua_tolstring(L, 2, &len); arg2 = &temp2; } 
  result = ofSaveURLTo((std::string const &)*arg1,(boost::filesystem::path const &)*arg2); {
    ofHttpResponse * resultptr = new ofHttpResponse((const ofHttpResponse &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofHttpResponse,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_saveURLAsync(lua_State* L) { int SWIG_arg = 0; std::string *arg1 = 0 ; std::filesystem::path *arg2 = 0 ;
  std::string temp1 ; std::filesystem::path temp2 ; int result; SWIG_check_num_args("ofSaveURLAsync",2,2)
  if(!lua_isstring(L,1)) SWIG_fail_arg("ofSaveURLAsync",1,"std::string const &");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofSaveURLAsync",2,"std::filesystem::path const &");
  temp1.assign(lua_tostring(L,1),lua_rawlen(L,1)); arg1=&temp1; { size_t len = lua_rawlen(L, 2);
    temp2 = lua_tolstring(L, 2, &len); arg2 = &temp2; } 
  result = (int)ofSaveURLAsync((std::string const &)*arg1,(boost::filesystem::path const &)*arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_removeURLRequest(lua_State* L) { int SWIG_arg = 0; int arg1 ; SWIG_check_num_args("ofRemoveURLRequest",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ofRemoveURLRequest",1,"int"); arg1 = (int)lua_tonumber(L, 1); ofRemoveURLRequest(arg1);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_removeAllURLRequests(lua_State* L) { int SWIG_arg = 0; SWIG_check_num_args("ofRemoveAllURLRequests",0,0)
  ofRemoveAllURLRequests(); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_stopURLLoader(lua_State* L) { int SWIG_arg = 0; SWIG_check_num_args("ofStopURLLoader",0,0) ofStopURLLoader();
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_new_URLFileLoader(lua_State* L) { int SWIG_arg = 0; ofURLFileLoader *result = 0 ;
  SWIG_check_num_args("ofURLFileLoader::ofURLFileLoader",0,0) result = (ofURLFileLoader *)new ofURLFileLoader();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofURLFileLoader,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_URLFileLoader_get(lua_State* L) { int SWIG_arg = 0; ofURLFileLoader *arg1 = (ofURLFileLoader *) 0 ;
  std::string *arg2 = 0 ; std::string temp2 ; ofHttpResponse result; SWIG_check_num_args("ofURLFileLoader::get",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofURLFileLoader::get",1,"ofURLFileLoader *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofURLFileLoader::get",2,"std::string const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofURLFileLoader,0))){
    SWIG_fail_ptr("URLFileLoader_get",1,SWIGTYPE_p_ofURLFileLoader); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2; result = (arg1)->get((std::string const &)*arg2); {
    ofHttpResponse * resultptr = new ofHttpResponse((const ofHttpResponse &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofHttpResponse,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_URLFileLoader_getAsync__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofURLFileLoader *arg1 = (ofURLFileLoader *) 0 ; std::string *arg2 = 0 ; std::string *arg3 = 0 ; std::string temp2 ;
  std::string temp3 ; int result; SWIG_check_num_args("ofURLFileLoader::getAsync",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofURLFileLoader::getAsync",1,"ofURLFileLoader *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofURLFileLoader::getAsync",2,"std::string const &");
  if(!lua_isstring(L,3)) SWIG_fail_arg("ofURLFileLoader::getAsync",3,"std::string const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofURLFileLoader,0))){
    SWIG_fail_ptr("URLFileLoader_getAsync",1,SWIGTYPE_p_ofURLFileLoader); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2; temp3.assign(lua_tostring(L,3),lua_rawlen(L,3)); arg3=&temp3;
  result = (int)(arg1)->getAsync((std::string const &)*arg2,(std::string const &)*arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_URLFileLoader_getAsync__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofURLFileLoader *arg1 = (ofURLFileLoader *) 0 ; std::string *arg2 = 0 ; std::string temp2 ; int result;
  SWIG_check_num_args("ofURLFileLoader::getAsync",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofURLFileLoader::getAsync",1,"ofURLFileLoader *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofURLFileLoader::getAsync",2,"std::string const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofURLFileLoader,0))){
    SWIG_fail_ptr("URLFileLoader_getAsync",1,SWIGTYPE_p_ofURLFileLoader); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2; result = (int)(arg1)->getAsync((std::string const &)*arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_URLFileLoader_getAsync(lua_State* L) { int argc; int argv[4]={ 1,2,3,4} ; argc = lua_gettop(L);
  if (argc == 2) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofURLFileLoader, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L,argv[1]); }  if (_v) {
        return _wrap_URLFileLoader_getAsync__SWIG_1(L);}  }  }  if (argc == 3) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofURLFileLoader, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isstring(L,argv[1]); }  if (_v) { { _v = lua_isstring(L,argv[2]); }  if (_v) {
          return _wrap_URLFileLoader_getAsync__SWIG_0(L);}  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'URLFileLoader_getAsync'\n"
  "  Possible C/C++ prototypes are:\n" "    ofURLFileLoader::getAsync(std::string const &,std::string const &)\n"
  "    ofURLFileLoader::getAsync(std::string const &)\n"); lua_error(L);return 0; }
static int _wrap_URLFileLoader_saveTo(lua_State* L) { int SWIG_arg = 0; ofURLFileLoader *arg1 = (ofURLFileLoader *) 0 ;
  std::string *arg2 = 0 ; std::filesystem::path *arg3 = 0 ; std::string temp2 ; std::filesystem::path temp3 ;
  ofHttpResponse result; SWIG_check_num_args("ofURLFileLoader::saveTo",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofURLFileLoader::saveTo",1,"ofURLFileLoader *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofURLFileLoader::saveTo",2,"std::string const &");
  if(!lua_isstring(L,3)) SWIG_fail_arg("ofURLFileLoader::saveTo",3,"std::filesystem::path const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofURLFileLoader,0))){
    SWIG_fail_ptr("URLFileLoader_saveTo",1,SWIGTYPE_p_ofURLFileLoader); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2; { size_t len = lua_rawlen(L, 3);
    temp3 = lua_tolstring(L, 3, &len); arg3 = &temp3; } 
  result = (arg1)->saveTo((std::string const &)*arg2,(std::filesystem::path const &)*arg3); {
    ofHttpResponse * resultptr = new ofHttpResponse((const ofHttpResponse &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofHttpResponse,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_URLFileLoader_saveAsync(lua_State* L) { int SWIG_arg = 0; ofURLFileLoader *arg1 = (ofURLFileLoader *) 0 ;
  std::string *arg2 = 0 ; std::filesystem::path *arg3 = 0 ; std::string temp2 ; std::filesystem::path temp3 ; int result;
  SWIG_check_num_args("ofURLFileLoader::saveAsync",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofURLFileLoader::saveAsync",1,"ofURLFileLoader *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofURLFileLoader::saveAsync",2,"std::string const &");
  if(!lua_isstring(L,3)) SWIG_fail_arg("ofURLFileLoader::saveAsync",3,"std::filesystem::path const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofURLFileLoader,0))){
    SWIG_fail_ptr("URLFileLoader_saveAsync",1,SWIGTYPE_p_ofURLFileLoader); } 
  temp2.assign(lua_tostring(L,2),lua_rawlen(L,2)); arg2=&temp2; { size_t len = lua_rawlen(L, 3);
    temp3 = lua_tolstring(L, 3, &len); arg3 = &temp3; } 
  result = (int)(arg1)->saveAsync((std::string const &)*arg2,(std::filesystem::path const &)*arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_URLFileLoader_remove(lua_State* L) { int SWIG_arg = 0; ofURLFileLoader *arg1 = (ofURLFileLoader *) 0 ;
  int arg2 ; SWIG_check_num_args("ofURLFileLoader::remove",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofURLFileLoader::remove",1,"ofURLFileLoader *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofURLFileLoader::remove",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofURLFileLoader,0))){
    SWIG_fail_ptr("URLFileLoader_remove",1,SWIGTYPE_p_ofURLFileLoader); }  arg2 = (int)lua_tonumber(L, 2); (arg1)->remove(arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_URLFileLoader_clear(lua_State* L) { int SWIG_arg = 0; ofURLFileLoader *arg1 = (ofURLFileLoader *) 0 ;
  SWIG_check_num_args("ofURLFileLoader::clear",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofURLFileLoader::clear",1,"ofURLFileLoader *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofURLFileLoader,0))){
    SWIG_fail_ptr("URLFileLoader_clear",1,SWIGTYPE_p_ofURLFileLoader); }  (arg1)->clear(); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_URLFileLoader_stop(lua_State* L) { int SWIG_arg = 0; ofURLFileLoader *arg1 = (ofURLFileLoader *) 0 ;
  SWIG_check_num_args("ofURLFileLoader::stop",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofURLFileLoader::stop",1,"ofURLFileLoader *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofURLFileLoader,0))){
    SWIG_fail_ptr("URLFileLoader_stop",1,SWIGTYPE_p_ofURLFileLoader); }  (arg1)->stop(); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_URLFileLoader_handleRequest(lua_State* L) { int SWIG_arg = 0; ofURLFileLoader *arg1 = (ofURLFileLoader *) 0 ;
  ofHttpRequest *arg2 = 0 ; ofHttpResponse result; SWIG_check_num_args("ofURLFileLoader::handleRequest",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofURLFileLoader::handleRequest",1,"ofURLFileLoader *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofURLFileLoader::handleRequest",2,"ofHttpRequest const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofURLFileLoader,0))){
    SWIG_fail_ptr("URLFileLoader_handleRequest",1,SWIGTYPE_p_ofURLFileLoader); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofHttpRequest,0))){
    SWIG_fail_ptr("URLFileLoader_handleRequest",2,SWIGTYPE_p_ofHttpRequest); } 
  result = (arg1)->handleRequest((ofHttpRequest const &)*arg2); {
    ofHttpResponse * resultptr = new ofHttpResponse((const ofHttpResponse &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ofHttpResponse,1); SWIG_arg++; }  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_URLFileLoader_handleRequestAsync(lua_State* L) { int SWIG_arg = 0;
  ofURLFileLoader *arg1 = (ofURLFileLoader *) 0 ; ofHttpRequest *arg2 = 0 ; int result;
  SWIG_check_num_args("ofURLFileLoader::handleRequestAsync",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofURLFileLoader::handleRequestAsync",1,"ofURLFileLoader *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofURLFileLoader::handleRequestAsync",2,"ofHttpRequest const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofURLFileLoader,0))){
    SWIG_fail_ptr("URLFileLoader_handleRequestAsync",1,SWIGTYPE_p_ofURLFileLoader); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofHttpRequest,0))){
    SWIG_fail_ptr("URLFileLoader_handleRequestAsync",2,SWIGTYPE_p_ofHttpRequest); } 
  result = (int)(arg1)->handleRequestAsync((ofHttpRequest const &)*arg2); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static void swig_delete_URLFileLoader(void *obj) {
ofURLFileLoader *arg1 = (ofURLFileLoader *) obj;
delete arg1;
}
static int _proxy__wrap_new_URLFileLoader(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_URLFileLoader);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_URLFileLoader_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_URLFileLoader_methods[]= {
    { "get", _wrap_URLFileLoader_get},
    { "getAsync", _wrap_URLFileLoader_getAsync},
    { "saveTo", _wrap_URLFileLoader_saveTo},
    { "saveAsync", _wrap_URLFileLoader_saveAsync},
    { "remove", _wrap_URLFileLoader_remove},
    { "clear", _wrap_URLFileLoader_clear},
    { "stop", _wrap_URLFileLoader_stop},
    { "handleRequest", _wrap_URLFileLoader_handleRequest},
    { "handleRequestAsync", _wrap_URLFileLoader_handleRequestAsync},
    {0,0}
};
static swig_lua_method swig_URLFileLoader_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_URLFileLoader_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_URLFileLoader_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_URLFileLoader_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_URLFileLoader_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_URLFileLoader_Sf_SwigStatic = {
    "URLFileLoader",
    swig_URLFileLoader_Sf_SwigStatic_methods,
    swig_URLFileLoader_Sf_SwigStatic_attributes,
    swig_URLFileLoader_Sf_SwigStatic_constants,
    swig_URLFileLoader_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_URLFileLoader_bases[] = {0};
static const char *swig_URLFileLoader_base_names[] = {0};
static swig_lua_class _wrap_class_URLFileLoader = { "URLFileLoader", "URLFileLoader", &SWIGTYPE_p_ofURLFileLoader,_proxy__wrap_new_URLFileLoader, swig_delete_URLFileLoader, swig_URLFileLoader_methods, swig_URLFileLoader_attributes, &swig_URLFileLoader_Sf_SwigStatic, swig_URLFileLoader_meta, swig_URLFileLoader_bases, swig_URLFileLoader_base_names };

static int _wrap_new_VideoGrabber(lua_State* L) { int SWIG_arg = 0; ofVideoGrabber *result = 0 ;
  SWIG_check_num_args("ofVideoGrabber::ofVideoGrabber",0,0) result = (ofVideoGrabber *)new ofVideoGrabber();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofVideoGrabber,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_VideoGrabber_listDevices(lua_State* L) { int SWIG_arg = 0; ofVideoGrabber *arg1 = (ofVideoGrabber *) 0 ;
  std::vector< ofVideoDevice > result; SWIG_check_num_args("ofVideoGrabber::listDevices",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoGrabber::listDevices",1,"ofVideoGrabber const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoGrabber,0))){
    SWIG_fail_ptr("VideoGrabber_listDevices",1,SWIGTYPE_p_ofVideoGrabber); } 
  result = ((ofVideoGrabber const *)arg1)->listDevices(); {
    std::vector< ofVideoDevice > * resultptr = new std::vector< ofVideoDevice >((const std::vector< ofVideoDevice > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_std__vectorT_ofVideoDevice_t,1); SWIG_arg++; }  return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_VideoGrabber_isFrameNew(lua_State* L) { int SWIG_arg = 0; ofVideoGrabber *arg1 = (ofVideoGrabber *) 0 ;
  bool result; SWIG_check_num_args("ofVideoGrabber::isFrameNew",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoGrabber::isFrameNew",1,"ofVideoGrabber const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoGrabber,0))){
    SWIG_fail_ptr("VideoGrabber_isFrameNew",1,SWIGTYPE_p_ofVideoGrabber); } 
  result = (bool)((ofVideoGrabber const *)arg1)->isFrameNew(); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_VideoGrabber_update(lua_State* L) { int SWIG_arg = 0; ofVideoGrabber *arg1 = (ofVideoGrabber *) 0 ;
  SWIG_check_num_args("ofVideoGrabber::update",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoGrabber::update",1,"ofVideoGrabber *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoGrabber,0))){
    SWIG_fail_ptr("VideoGrabber_update",1,SWIGTYPE_p_ofVideoGrabber); }  (arg1)->update(); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_VideoGrabber_close(lua_State* L) { int SWIG_arg = 0; ofVideoGrabber *arg1 = (ofVideoGrabber *) 0 ;
  SWIG_check_num_args("ofVideoGrabber::close",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoGrabber::close",1,"ofVideoGrabber *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoGrabber,0))){
    SWIG_fail_ptr("VideoGrabber_close",1,SWIGTYPE_p_ofVideoGrabber); }  (arg1)->close(); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_VideoGrabber_setup__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofVideoGrabber *arg1 = (ofVideoGrabber *) 0 ;
  int arg2 ; int arg3 ; bool result; SWIG_check_num_args("ofVideoGrabber::setup",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoGrabber::setup",1,"ofVideoGrabber *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVideoGrabber::setup",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVideoGrabber::setup",3,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoGrabber,0))){
    SWIG_fail_ptr("VideoGrabber_setup",1,SWIGTYPE_p_ofVideoGrabber); }  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3); result = (bool)(arg1)->setup(arg2,arg3); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_VideoGrabber_setup__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofVideoGrabber *arg1 = (ofVideoGrabber *) 0 ;
  int arg2 ; int arg3 ; bool arg4 ; bool result; SWIG_check_num_args("ofVideoGrabber::setup",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoGrabber::setup",1,"ofVideoGrabber *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVideoGrabber::setup",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVideoGrabber::setup",3,"int");
  if(!lua_isboolean(L,4)) SWIG_fail_arg("ofVideoGrabber::setup",4,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoGrabber,0))){
    SWIG_fail_ptr("VideoGrabber_setup",1,SWIGTYPE_p_ofVideoGrabber); }  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3); arg4 = (lua_toboolean(L, 4)!=0); result = (bool)(arg1)->setup(arg2,arg3,arg4);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_VideoGrabber_setup(lua_State* L) { int argc; int argv[5]={ 1,2,3,4,5} ; argc = lua_gettop(L); if (argc == 3) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVideoGrabber, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          return _wrap_VideoGrabber_setup__SWIG_0(L);}  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVideoGrabber, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          { _v = lua_isboolean(L,argv[3]); }  if (_v) { return _wrap_VideoGrabber_setup__SWIG_1(L);}  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'VideoGrabber_setup'\n" "  Possible C/C++ prototypes are:\n"
  "    ofVideoGrabber::setup(int,int)\n" "    ofVideoGrabber::setup(int,int,bool)\n"); lua_error(L);return 0; }
static int _wrap_VideoGrabber_setPixelFormat(lua_State* L) { int SWIG_arg = 0; ofVideoGrabber *arg1 = (ofVideoGrabber *) 0 ;
  ofPixelFormat arg2 ; bool result; SWIG_check_num_args("ofVideoGrabber::setPixelFormat",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoGrabber::setPixelFormat",1,"ofVideoGrabber *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVideoGrabber::setPixelFormat",2,"ofPixelFormat");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoGrabber,0))){
    SWIG_fail_ptr("VideoGrabber_setPixelFormat",1,SWIGTYPE_p_ofVideoGrabber); }  arg2 = (ofPixelFormat)(int)lua_tonumber(L, 2);
  result = (bool)(arg1)->setPixelFormat(arg2); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_VideoGrabber_getPixelFormat(lua_State* L) { int SWIG_arg = 0; ofVideoGrabber *arg1 = (ofVideoGrabber *) 0 ;
  ofPixelFormat result; SWIG_check_num_args("ofVideoGrabber::getPixelFormat",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoGrabber::getPixelFormat",1,"ofVideoGrabber const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoGrabber,0))){
    SWIG_fail_ptr("VideoGrabber_getPixelFormat",1,SWIGTYPE_p_ofVideoGrabber); } 
  result = (ofPixelFormat)((ofVideoGrabber const *)arg1)->getPixelFormat();
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_VideoGrabber_videoSettings(lua_State* L) { int SWIG_arg = 0; ofVideoGrabber *arg1 = (ofVideoGrabber *) 0 ;
  SWIG_check_num_args("ofVideoGrabber::videoSettings",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoGrabber::videoSettings",1,"ofVideoGrabber *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoGrabber,0))){
    SWIG_fail_ptr("VideoGrabber_videoSettings",1,SWIGTYPE_p_ofVideoGrabber); }  (arg1)->videoSettings(); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_VideoGrabber_getPixels__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofVideoGrabber *arg1 = (ofVideoGrabber *) 0 ;
  ofPixels *result = 0 ; SWIG_check_num_args("ofVideoGrabber::getPixels",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoGrabber::getPixels",1,"ofVideoGrabber *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoGrabber,0))){
    SWIG_fail_ptr("VideoGrabber_getPixels",1,SWIGTYPE_p_ofVideoGrabber); }  result = (ofPixels *) &(arg1)->getPixels();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_VideoGrabber_getPixels__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofVideoGrabber *arg1 = (ofVideoGrabber *) 0 ;
  ofPixels *result = 0 ; SWIG_check_num_args("ofVideoGrabber::getPixels",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoGrabber::getPixels",1,"ofVideoGrabber const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoGrabber,0))){
    SWIG_fail_ptr("VideoGrabber_getPixels",1,SWIGTYPE_p_ofVideoGrabber); } 
  result = (ofPixels *) &((ofVideoGrabber const *)arg1)->getPixels();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_VideoGrabber_getPixels(lua_State* L) { int argc; int argv[2]={ 1,2} ; argc = lua_gettop(L); if (argc == 1) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVideoGrabber, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { return _wrap_VideoGrabber_getPixels__SWIG_0(L);}  }  if (argc == 1) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVideoGrabber, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { return _wrap_VideoGrabber_getPixels__SWIG_1(L);}  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'VideoGrabber_getPixels'\n"
  "  Possible C/C++ prototypes are:\n" "    ofVideoGrabber::getPixels()\n" "    ofVideoGrabber::getPixels() const\n");
  lua_error(L);return 0; }
static int _wrap_VideoGrabber_getTexture__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofVideoGrabber *arg1 = (ofVideoGrabber *) 0 ;
  ofTexture *result = 0 ; SWIG_check_num_args("ofVideoGrabber::getTexture",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoGrabber::getTexture",1,"ofVideoGrabber *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoGrabber,0))){
    SWIG_fail_ptr("VideoGrabber_getTexture",1,SWIGTYPE_p_ofVideoGrabber); }  result = (ofTexture *) &(arg1)->getTexture();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofTexture,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_VideoGrabber_getTexture__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofVideoGrabber *arg1 = (ofVideoGrabber *) 0 ;
  ofTexture *result = 0 ; SWIG_check_num_args("ofVideoGrabber::getTexture",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoGrabber::getTexture",1,"ofVideoGrabber const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoGrabber,0))){
    SWIG_fail_ptr("VideoGrabber_getTexture",1,SWIGTYPE_p_ofVideoGrabber); } 
  result = (ofTexture *) &((ofVideoGrabber const *)arg1)->getTexture();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofTexture,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_VideoGrabber_getTexture(lua_State* L) { int argc; int argv[2]={ 1,2} ; argc = lua_gettop(L); if (argc == 1) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVideoGrabber, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { return _wrap_VideoGrabber_getTexture__SWIG_0(L);}  }  if (argc == 1) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVideoGrabber, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_VideoGrabber_getTexture__SWIG_1(L);}  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'VideoGrabber_getTexture'\n"
  "  Possible C/C++ prototypes are:\n" "    ofVideoGrabber::getTexture()\n" "    ofVideoGrabber::getTexture() const\n");
  lua_error(L);return 0; }
static int _wrap_VideoGrabber_getTexturePlanes__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofVideoGrabber *arg1 = (ofVideoGrabber *) 0 ; std::vector< ofTexture > *result = 0 ;
  SWIG_check_num_args("ofVideoGrabber::getTexturePlanes",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoGrabber::getTexturePlanes",1,"ofVideoGrabber *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoGrabber,0))){
    SWIG_fail_ptr("VideoGrabber_getTexturePlanes",1,SWIGTYPE_p_ofVideoGrabber); } 
  result = (std::vector< ofTexture > *) &(arg1)->getTexturePlanes();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorT_ofTexture_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_VideoGrabber_getTexturePlanes__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofVideoGrabber *arg1 = (ofVideoGrabber *) 0 ; std::vector< ofTexture > *result = 0 ;
  SWIG_check_num_args("ofVideoGrabber::getTexturePlanes",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoGrabber::getTexturePlanes",1,"ofVideoGrabber const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoGrabber,0))){
    SWIG_fail_ptr("VideoGrabber_getTexturePlanes",1,SWIGTYPE_p_ofVideoGrabber); } 
  result = (std::vector< ofTexture > *) &((ofVideoGrabber const *)arg1)->getTexturePlanes();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorT_ofTexture_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_VideoGrabber_getTexturePlanes(lua_State* L) { int argc; int argv[2]={ 1,2} ; argc = lua_gettop(L);
  if (argc == 1) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVideoGrabber, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { return _wrap_VideoGrabber_getTexturePlanes__SWIG_0(L);}  }  if (argc == 1) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVideoGrabber, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_VideoGrabber_getTexturePlanes__SWIG_1(L);}  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'VideoGrabber_getTexturePlanes'\n"
  "  Possible C/C++ prototypes are:\n" "    ofVideoGrabber::getTexturePlanes()\n"
  "    ofVideoGrabber::getTexturePlanes() const\n"); lua_error(L);return 0; }
static int _wrap_VideoGrabber_setVerbose(lua_State* L) { int SWIG_arg = 0; ofVideoGrabber *arg1 = (ofVideoGrabber *) 0 ;
  bool arg2 ; SWIG_check_num_args("ofVideoGrabber::setVerbose",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoGrabber::setVerbose",1,"ofVideoGrabber *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofVideoGrabber::setVerbose",2,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoGrabber,0))){
    SWIG_fail_ptr("VideoGrabber_setVerbose",1,SWIGTYPE_p_ofVideoGrabber); }  arg2 = (lua_toboolean(L, 2)!=0);
  (arg1)->setVerbose(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_VideoGrabber_setDeviceID(lua_State* L) { int SWIG_arg = 0; ofVideoGrabber *arg1 = (ofVideoGrabber *) 0 ;
  int arg2 ; SWIG_check_num_args("ofVideoGrabber::setDeviceID",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoGrabber::setDeviceID",1,"ofVideoGrabber *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVideoGrabber::setDeviceID",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoGrabber,0))){
    SWIG_fail_ptr("VideoGrabber_setDeviceID",1,SWIGTYPE_p_ofVideoGrabber); }  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setDeviceID(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_VideoGrabber_setDesiredFrameRate(lua_State* L) { int SWIG_arg = 0;
  ofVideoGrabber *arg1 = (ofVideoGrabber *) 0 ; int arg2 ; SWIG_check_num_args("ofVideoGrabber::setDesiredFrameRate",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoGrabber::setDesiredFrameRate",1,"ofVideoGrabber *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVideoGrabber::setDesiredFrameRate",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoGrabber,0))){
    SWIG_fail_ptr("VideoGrabber_setDesiredFrameRate",1,SWIGTYPE_p_ofVideoGrabber); }  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->setDesiredFrameRate(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_VideoGrabber_setUseTexture(lua_State* L) { int SWIG_arg = 0; ofVideoGrabber *arg1 = (ofVideoGrabber *) 0 ;
  bool arg2 ; SWIG_check_num_args("ofVideoGrabber::setUseTexture",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoGrabber::setUseTexture",1,"ofVideoGrabber *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofVideoGrabber::setUseTexture",2,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoGrabber,0))){
    SWIG_fail_ptr("VideoGrabber_setUseTexture",1,SWIGTYPE_p_ofVideoGrabber); }  arg2 = (lua_toboolean(L, 2)!=0);
  (arg1)->setUseTexture(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_VideoGrabber_isUsingTexture(lua_State* L) { int SWIG_arg = 0; ofVideoGrabber *arg1 = (ofVideoGrabber *) 0 ;
  bool result; SWIG_check_num_args("ofVideoGrabber::isUsingTexture",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoGrabber::isUsingTexture",1,"ofVideoGrabber const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoGrabber,0))){
    SWIG_fail_ptr("VideoGrabber_isUsingTexture",1,SWIGTYPE_p_ofVideoGrabber); } 
  result = (bool)((ofVideoGrabber const *)arg1)->isUsingTexture(); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_VideoGrabber_draw__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofVideoGrabber *arg1 = (ofVideoGrabber *) 0 ;
  float arg2 ; float arg3 ; float arg4 ; float arg5 ; SWIG_check_num_args("ofVideoGrabber::draw",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoGrabber::draw",1,"ofVideoGrabber const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVideoGrabber::draw",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVideoGrabber::draw",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofVideoGrabber::draw",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofVideoGrabber::draw",5,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoGrabber,0))){
    SWIG_fail_ptr("VideoGrabber_draw",1,SWIGTYPE_p_ofVideoGrabber); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); arg5 = (float)lua_tonumber(L, 5);
  ((ofVideoGrabber const *)arg1)->draw(arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_VideoGrabber_draw__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofVideoGrabber *arg1 = (ofVideoGrabber *) 0 ;
  float arg2 ; float arg3 ; SWIG_check_num_args("ofVideoGrabber::draw",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoGrabber::draw",1,"ofVideoGrabber const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVideoGrabber::draw",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVideoGrabber::draw",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoGrabber,0))){
    SWIG_fail_ptr("VideoGrabber_draw",1,SWIGTYPE_p_ofVideoGrabber); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); ((ofVideoGrabber const *)arg1)->draw(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_VideoGrabber_draw__SWIG_2_0(lua_State* L) { int SWIG_arg = 0; ofVideoGrabber *arg1 = (ofVideoGrabber *) 0 ;
  glm::vec2 *arg2 = 0 ; SWIG_check_num_args("draw",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("draw",1,"ofVideoGrabber const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("draw",2,"glm::vec2 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoGrabber,0))){
    SWIG_fail_ptr("VideoGrabber_draw",1,SWIGTYPE_p_ofVideoGrabber); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec2,0))){
    SWIG_fail_ptr("VideoGrabber_draw",2,SWIGTYPE_p_glm__vec2); } 
  ((ofVideoGrabber const *)arg1)->draw((glm::vec2 const &)*arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_VideoGrabber_draw__SWIG_2_1(lua_State* L) { int SWIG_arg = 0; ofVideoGrabber *arg1 = (ofVideoGrabber *) 0 ;
  ofRectangle *arg2 = 0 ; SWIG_check_num_args("draw",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("draw",1,"ofVideoGrabber const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("draw",2,"ofRectangle const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoGrabber,0))){
    SWIG_fail_ptr("VideoGrabber_draw",1,SWIGTYPE_p_ofVideoGrabber); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("VideoGrabber_draw",2,SWIGTYPE_p_ofRectangle); } 
  ((ofVideoGrabber const *)arg1)->draw((ofRectangle const &)*arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_VideoGrabber_draw__SWIG_2_2(lua_State* L) { int SWIG_arg = 0; ofVideoGrabber *arg1 = (ofVideoGrabber *) 0 ;
  glm::vec2 *arg2 = 0 ; float arg3 ; float arg4 ; SWIG_check_num_args("draw",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("draw",1,"ofVideoGrabber const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("draw",2,"glm::vec2 const &"); if(!lua_isnumber(L,3)) SWIG_fail_arg("draw",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("draw",4,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoGrabber,0))){
    SWIG_fail_ptr("VideoGrabber_draw",1,SWIGTYPE_p_ofVideoGrabber); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec2,0))){
    SWIG_fail_ptr("VideoGrabber_draw",2,SWIGTYPE_p_glm__vec2); }  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4); ((ofVideoGrabber const *)arg1)->draw((glm::vec2 const &)*arg2,arg3,arg4); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_VideoGrabber_draw(lua_State* L) { int argc; int argv[6]={ 1,2,3,4,5,6} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVideoGrabber, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec2, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_VideoGrabber_draw__SWIG_2_0(L);}  }  }  if (argc == 2) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVideoGrabber, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_VideoGrabber_draw__SWIG_2_1(L);}  }  }  if (argc == 3) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVideoGrabber, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { return _wrap_VideoGrabber_draw__SWIG_1(L);}  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVideoGrabber, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec2, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); } 
          if (_v) { return _wrap_VideoGrabber_draw__SWIG_2_2(L);}  }  }  }  }  if (argc == 5) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVideoGrabber, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) {
              return _wrap_VideoGrabber_draw__SWIG_0(L);}  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'VideoGrabber_draw'\n" "  Possible C/C++ prototypes are:\n"
  "    ofVideoGrabber::draw(float,float,float,float) const\n" "    ofVideoGrabber::draw(float,float) const\n"
  "    draw(glm::vec2 const &) const\n" "    draw(ofRectangle const &) const\n"
  "    draw(glm::vec2 const &,float,float) const\n"); lua_error(L);return 0; }
static int _wrap_VideoGrabber_bind(lua_State* L) { int SWIG_arg = 0; ofVideoGrabber *arg1 = (ofVideoGrabber *) 0 ;
  SWIG_check_num_args("ofVideoGrabber::bind",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoGrabber::bind",1,"ofVideoGrabber const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoGrabber,0))){
    SWIG_fail_ptr("VideoGrabber_bind",1,SWIGTYPE_p_ofVideoGrabber); }  ((ofVideoGrabber const *)arg1)->bind(); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_VideoGrabber_unbind(lua_State* L) { int SWIG_arg = 0; ofVideoGrabber *arg1 = (ofVideoGrabber *) 0 ;
  SWIG_check_num_args("ofVideoGrabber::unbind",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoGrabber::unbind",1,"ofVideoGrabber const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoGrabber,0))){
    SWIG_fail_ptr("VideoGrabber_unbind",1,SWIGTYPE_p_ofVideoGrabber); }  ((ofVideoGrabber const *)arg1)->unbind();
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_VideoGrabber_setAnchorPercent(lua_State* L) { int SWIG_arg = 0; ofVideoGrabber *arg1 = (ofVideoGrabber *) 0 ;
  float arg2 ; float arg3 ; SWIG_check_num_args("ofVideoGrabber::setAnchorPercent",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoGrabber::setAnchorPercent",1,"ofVideoGrabber *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVideoGrabber::setAnchorPercent",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVideoGrabber::setAnchorPercent",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoGrabber,0))){
    SWIG_fail_ptr("VideoGrabber_setAnchorPercent",1,SWIGTYPE_p_ofVideoGrabber); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); (arg1)->setAnchorPercent(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_VideoGrabber_setAnchorPoint(lua_State* L) { int SWIG_arg = 0; ofVideoGrabber *arg1 = (ofVideoGrabber *) 0 ;
  float arg2 ; float arg3 ; SWIG_check_num_args("ofVideoGrabber::setAnchorPoint",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoGrabber::setAnchorPoint",1,"ofVideoGrabber *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVideoGrabber::setAnchorPoint",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVideoGrabber::setAnchorPoint",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoGrabber,0))){
    SWIG_fail_ptr("VideoGrabber_setAnchorPoint",1,SWIGTYPE_p_ofVideoGrabber); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); (arg1)->setAnchorPoint(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_VideoGrabber_resetAnchor(lua_State* L) { int SWIG_arg = 0; ofVideoGrabber *arg1 = (ofVideoGrabber *) 0 ;
  SWIG_check_num_args("ofVideoGrabber::resetAnchor",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoGrabber::resetAnchor",1,"ofVideoGrabber *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoGrabber,0))){
    SWIG_fail_ptr("VideoGrabber_resetAnchor",1,SWIGTYPE_p_ofVideoGrabber); }  (arg1)->resetAnchor(); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_VideoGrabber_getHeight(lua_State* L) { int SWIG_arg = 0; ofVideoGrabber *arg1 = (ofVideoGrabber *) 0 ;
  float result; SWIG_check_num_args("ofVideoGrabber::getHeight",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoGrabber::getHeight",1,"ofVideoGrabber const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoGrabber,0))){
    SWIG_fail_ptr("VideoGrabber_getHeight",1,SWIGTYPE_p_ofVideoGrabber); } 
  result = (float)((ofVideoGrabber const *)arg1)->getHeight(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_VideoGrabber_getWidth(lua_State* L) { int SWIG_arg = 0; ofVideoGrabber *arg1 = (ofVideoGrabber *) 0 ;
  float result; SWIG_check_num_args("ofVideoGrabber::getWidth",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoGrabber::getWidth",1,"ofVideoGrabber const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoGrabber,0))){
    SWIG_fail_ptr("VideoGrabber_getWidth",1,SWIGTYPE_p_ofVideoGrabber); } 
  result = (float)((ofVideoGrabber const *)arg1)->getWidth(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_VideoGrabber_isInitialized(lua_State* L) { int SWIG_arg = 0; ofVideoGrabber *arg1 = (ofVideoGrabber *) 0 ;
  bool result; SWIG_check_num_args("ofVideoGrabber::isInitialized",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoGrabber::isInitialized",1,"ofVideoGrabber const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoGrabber,0))){
    SWIG_fail_ptr("VideoGrabber_isInitialized",1,SWIGTYPE_p_ofVideoGrabber); } 
  result = (bool)((ofVideoGrabber const *)arg1)->isInitialized(); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_VideoGrabber_setGrabber(lua_State* L) { int SWIG_arg = 0; ofVideoGrabber *arg1 = (ofVideoGrabber *) 0 ;
  SwigValueWrapper< std::shared_ptr< ofBaseVideoGrabber > > arg2 ; std::shared_ptr< ofBaseVideoGrabber > *argp2 ;
  SWIG_check_num_args("ofVideoGrabber::setGrabber",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoGrabber::setGrabber",1,"ofVideoGrabber *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVideoGrabber::setGrabber",2,"std::shared_ptr< ofBaseVideoGrabber >");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoGrabber,0))){
    SWIG_fail_ptr("VideoGrabber_setGrabber",1,SWIGTYPE_p_ofVideoGrabber); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_std__shared_ptrT_ofBaseVideoGrabber_t,0))){
    SWIG_fail_ptr("VideoGrabber_setGrabber",2,SWIGTYPE_p_std__shared_ptrT_ofBaseVideoGrabber_t); }  arg2 = *argp2;
  (arg1)->setGrabber(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static void swig_delete_VideoGrabber(void *obj) {
ofVideoGrabber *arg1 = (ofVideoGrabber *) obj;
delete arg1;
}
static int _proxy__wrap_new_VideoGrabber(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_VideoGrabber);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_VideoGrabber_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_VideoGrabber_methods[]= {
    { "listDevices", _wrap_VideoGrabber_listDevices},
    { "isFrameNew", _wrap_VideoGrabber_isFrameNew},
    { "update", _wrap_VideoGrabber_update},
    { "close", _wrap_VideoGrabber_close},
    { "setup", _wrap_VideoGrabber_setup},
    { "setPixelFormat", _wrap_VideoGrabber_setPixelFormat},
    { "getPixelFormat", _wrap_VideoGrabber_getPixelFormat},
    { "videoSettings", _wrap_VideoGrabber_videoSettings},
    { "getPixels", _wrap_VideoGrabber_getPixels},
    { "getTexture", _wrap_VideoGrabber_getTexture},
    { "getTexturePlanes", _wrap_VideoGrabber_getTexturePlanes},
    { "setVerbose", _wrap_VideoGrabber_setVerbose},
    { "setDeviceID", _wrap_VideoGrabber_setDeviceID},
    { "setDesiredFrameRate", _wrap_VideoGrabber_setDesiredFrameRate},
    { "setUseTexture", _wrap_VideoGrabber_setUseTexture},
    { "isUsingTexture", _wrap_VideoGrabber_isUsingTexture},
    { "draw", _wrap_VideoGrabber_draw},
    { "bind", _wrap_VideoGrabber_bind},
    { "unbind", _wrap_VideoGrabber_unbind},
    { "setAnchorPercent", _wrap_VideoGrabber_setAnchorPercent},
    { "setAnchorPoint", _wrap_VideoGrabber_setAnchorPoint},
    { "resetAnchor", _wrap_VideoGrabber_resetAnchor},
    { "getHeight", _wrap_VideoGrabber_getHeight},
    { "getWidth", _wrap_VideoGrabber_getWidth},
    { "isInitialized", _wrap_VideoGrabber_isInitialized},
    { "setGrabber", _wrap_VideoGrabber_setGrabber},
    {0,0}
};
static swig_lua_method swig_VideoGrabber_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_VideoGrabber_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_VideoGrabber_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_VideoGrabber_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_VideoGrabber_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_VideoGrabber_Sf_SwigStatic = {
    "VideoGrabber",
    swig_VideoGrabber_Sf_SwigStatic_methods,
    swig_VideoGrabber_Sf_SwigStatic_attributes,
    swig_VideoGrabber_Sf_SwigStatic_constants,
    swig_VideoGrabber_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_VideoGrabber_bases[] = {0};
static const char *swig_VideoGrabber_base_names[] = {0};
static swig_lua_class _wrap_class_VideoGrabber = { "VideoGrabber", "VideoGrabber", &SWIGTYPE_p_ofVideoGrabber,_proxy__wrap_new_VideoGrabber, swig_delete_VideoGrabber, swig_VideoGrabber_methods, swig_VideoGrabber_attributes, &swig_VideoGrabber_Sf_SwigStatic, swig_VideoGrabber_meta, swig_VideoGrabber_bases, swig_VideoGrabber_base_names };

static int _wrap_new_VideoPlayer(lua_State* L) { int SWIG_arg = 0; ofVideoPlayer *result = 0 ;
  SWIG_check_num_args("ofVideoPlayer::ofVideoPlayer",0,0) result = (ofVideoPlayer *)new ofVideoPlayer();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofVideoPlayer,1); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_VideoPlayer_load(lua_State* L) { int SWIG_arg = 0; ofVideoPlayer *arg1 = (ofVideoPlayer *) 0 ;
  std::string arg2 ; bool result; SWIG_check_num_args("ofVideoPlayer::load",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoPlayer::load",1,"ofVideoPlayer *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofVideoPlayer::load",2,"std::string");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoPlayer,0))){
    SWIG_fail_ptr("VideoPlayer_load",1,SWIGTYPE_p_ofVideoPlayer); }  (&arg2)->assign(lua_tostring(L,2),lua_rawlen(L,2));
  result = (bool)(arg1)->load(arg2); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_VideoPlayer_loadAsync(lua_State* L) { int SWIG_arg = 0; ofVideoPlayer *arg1 = (ofVideoPlayer *) 0 ;
  std::string arg2 ; SWIG_check_num_args("ofVideoPlayer::loadAsync",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoPlayer::loadAsync",1,"ofVideoPlayer *");
  if(!lua_isstring(L,2)) SWIG_fail_arg("ofVideoPlayer::loadAsync",2,"std::string");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoPlayer,0))){
    SWIG_fail_ptr("VideoPlayer_loadAsync",1,SWIGTYPE_p_ofVideoPlayer); }  (&arg2)->assign(lua_tostring(L,2),lua_rawlen(L,2));
  (arg1)->loadAsync(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_VideoPlayer_getMoviePath(lua_State* L) { int SWIG_arg = 0; ofVideoPlayer *arg1 = (ofVideoPlayer *) 0 ;
  std::string result; SWIG_check_num_args("ofVideoPlayer::getMoviePath",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoPlayer::getMoviePath",1,"ofVideoPlayer const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoPlayer,0))){
    SWIG_fail_ptr("VideoPlayer_getMoviePath",1,SWIGTYPE_p_ofVideoPlayer); } 
  result = ((ofVideoPlayer const *)arg1)->getMoviePath(); lua_pushlstring(L,(&result)->data(),(&result)->size()); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_VideoPlayer_setPixelFormat(lua_State* L) { int SWIG_arg = 0; ofVideoPlayer *arg1 = (ofVideoPlayer *) 0 ;
  ofPixelFormat arg2 ; bool result; SWIG_check_num_args("ofVideoPlayer::setPixelFormat",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoPlayer::setPixelFormat",1,"ofVideoPlayer *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVideoPlayer::setPixelFormat",2,"ofPixelFormat");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoPlayer,0))){
    SWIG_fail_ptr("VideoPlayer_setPixelFormat",1,SWIGTYPE_p_ofVideoPlayer); }  arg2 = (ofPixelFormat)(int)lua_tonumber(L, 2);
  result = (bool)(arg1)->setPixelFormat(arg2); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_VideoPlayer_getPixelFormat(lua_State* L) { int SWIG_arg = 0; ofVideoPlayer *arg1 = (ofVideoPlayer *) 0 ;
  ofPixelFormat result; SWIG_check_num_args("ofVideoPlayer::getPixelFormat",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoPlayer::getPixelFormat",1,"ofVideoPlayer const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoPlayer,0))){
    SWIG_fail_ptr("VideoPlayer_getPixelFormat",1,SWIGTYPE_p_ofVideoPlayer); } 
  result = (ofPixelFormat)((ofVideoPlayer const *)arg1)->getPixelFormat();
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++; return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_VideoPlayer_closeMovie(lua_State* L) { int SWIG_arg = 0; ofVideoPlayer *arg1 = (ofVideoPlayer *) 0 ;
  SWIG_check_num_args("ofVideoPlayer::closeMovie",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoPlayer::closeMovie",1,"ofVideoPlayer *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoPlayer,0))){
    SWIG_fail_ptr("VideoPlayer_closeMovie",1,SWIGTYPE_p_ofVideoPlayer); }  (arg1)->closeMovie(); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_VideoPlayer_close(lua_State* L) { int SWIG_arg = 0; ofVideoPlayer *arg1 = (ofVideoPlayer *) 0 ;
  SWIG_check_num_args("ofVideoPlayer::close",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoPlayer::close",1,"ofVideoPlayer *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoPlayer,0))){
    SWIG_fail_ptr("VideoPlayer_close",1,SWIGTYPE_p_ofVideoPlayer); }  (arg1)->close(); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_VideoPlayer_update(lua_State* L) { int SWIG_arg = 0; ofVideoPlayer *arg1 = (ofVideoPlayer *) 0 ;
  SWIG_check_num_args("ofVideoPlayer::update",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoPlayer::update",1,"ofVideoPlayer *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoPlayer,0))){
    SWIG_fail_ptr("VideoPlayer_update",1,SWIGTYPE_p_ofVideoPlayer); }  (arg1)->update(); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_VideoPlayer_play(lua_State* L) { int SWIG_arg = 0; ofVideoPlayer *arg1 = (ofVideoPlayer *) 0 ;
  SWIG_check_num_args("ofVideoPlayer::play",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoPlayer::play",1,"ofVideoPlayer *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoPlayer,0))){
    SWIG_fail_ptr("VideoPlayer_play",1,SWIGTYPE_p_ofVideoPlayer); }  (arg1)->play(); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_VideoPlayer_stop(lua_State* L) { int SWIG_arg = 0; ofVideoPlayer *arg1 = (ofVideoPlayer *) 0 ;
  SWIG_check_num_args("ofVideoPlayer::stop",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoPlayer::stop",1,"ofVideoPlayer *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoPlayer,0))){
    SWIG_fail_ptr("VideoPlayer_stop",1,SWIGTYPE_p_ofVideoPlayer); }  (arg1)->stop(); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_VideoPlayer_isFrameNew(lua_State* L) { int SWIG_arg = 0; ofVideoPlayer *arg1 = (ofVideoPlayer *) 0 ;
  bool result; SWIG_check_num_args("ofVideoPlayer::isFrameNew",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoPlayer::isFrameNew",1,"ofVideoPlayer const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoPlayer,0))){
    SWIG_fail_ptr("VideoPlayer_isFrameNew",1,SWIGTYPE_p_ofVideoPlayer); } 
  result = (bool)((ofVideoPlayer const *)arg1)->isFrameNew(); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_VideoPlayer_getPixels__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofVideoPlayer *arg1 = (ofVideoPlayer *) 0 ;
  ofPixels *result = 0 ; SWIG_check_num_args("ofVideoPlayer::getPixels",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoPlayer::getPixels",1,"ofVideoPlayer *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoPlayer,0))){
    SWIG_fail_ptr("VideoPlayer_getPixels",1,SWIGTYPE_p_ofVideoPlayer); }  result = (ofPixels *) &(arg1)->getPixels();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_VideoPlayer_getPixels__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofVideoPlayer *arg1 = (ofVideoPlayer *) 0 ;
  ofPixels *result = 0 ; SWIG_check_num_args("ofVideoPlayer::getPixels",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoPlayer::getPixels",1,"ofVideoPlayer const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoPlayer,0))){
    SWIG_fail_ptr("VideoPlayer_getPixels",1,SWIGTYPE_p_ofVideoPlayer); } 
  result = (ofPixels *) &((ofVideoPlayer const *)arg1)->getPixels();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofPixels_T_unsigned_char_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_VideoPlayer_getPixels(lua_State* L) { int argc; int argv[2]={ 1,2} ; argc = lua_gettop(L); if (argc == 1) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVideoPlayer, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { return _wrap_VideoPlayer_getPixels__SWIG_0(L);}  }  if (argc == 1) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVideoPlayer, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { return _wrap_VideoPlayer_getPixels__SWIG_1(L);}  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'VideoPlayer_getPixels'\n"
  "  Possible C/C++ prototypes are:\n" "    ofVideoPlayer::getPixels()\n" "    ofVideoPlayer::getPixels() const\n");
  lua_error(L);return 0; }
static int _wrap_VideoPlayer_getPosition(lua_State* L) { int SWIG_arg = 0; ofVideoPlayer *arg1 = (ofVideoPlayer *) 0 ;
  float result; SWIG_check_num_args("ofVideoPlayer::getPosition",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoPlayer::getPosition",1,"ofVideoPlayer const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoPlayer,0))){
    SWIG_fail_ptr("VideoPlayer_getPosition",1,SWIGTYPE_p_ofVideoPlayer); } 
  result = (float)((ofVideoPlayer const *)arg1)->getPosition(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_VideoPlayer_getSpeed(lua_State* L) { int SWIG_arg = 0; ofVideoPlayer *arg1 = (ofVideoPlayer *) 0 ;
  float result; SWIG_check_num_args("ofVideoPlayer::getSpeed",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoPlayer::getSpeed",1,"ofVideoPlayer const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoPlayer,0))){
    SWIG_fail_ptr("VideoPlayer_getSpeed",1,SWIGTYPE_p_ofVideoPlayer); } 
  result = (float)((ofVideoPlayer const *)arg1)->getSpeed(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_VideoPlayer_getDuration(lua_State* L) { int SWIG_arg = 0; ofVideoPlayer *arg1 = (ofVideoPlayer *) 0 ;
  float result; SWIG_check_num_args("ofVideoPlayer::getDuration",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoPlayer::getDuration",1,"ofVideoPlayer const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoPlayer,0))){
    SWIG_fail_ptr("VideoPlayer_getDuration",1,SWIGTYPE_p_ofVideoPlayer); } 
  result = (float)((ofVideoPlayer const *)arg1)->getDuration(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_VideoPlayer_getIsMovieDone(lua_State* L) { int SWIG_arg = 0; ofVideoPlayer *arg1 = (ofVideoPlayer *) 0 ;
  bool result; SWIG_check_num_args("ofVideoPlayer::getIsMovieDone",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoPlayer::getIsMovieDone",1,"ofVideoPlayer const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoPlayer,0))){
    SWIG_fail_ptr("VideoPlayer_getIsMovieDone",1,SWIGTYPE_p_ofVideoPlayer); } 
  result = (bool)((ofVideoPlayer const *)arg1)->getIsMovieDone(); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_VideoPlayer_setPosition(lua_State* L) { int SWIG_arg = 0; ofVideoPlayer *arg1 = (ofVideoPlayer *) 0 ;
  float arg2 ; SWIG_check_num_args("ofVideoPlayer::setPosition",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoPlayer::setPosition",1,"ofVideoPlayer *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVideoPlayer::setPosition",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoPlayer,0))){
    SWIG_fail_ptr("VideoPlayer_setPosition",1,SWIGTYPE_p_ofVideoPlayer); }  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setPosition(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_VideoPlayer_setVolume(lua_State* L) { int SWIG_arg = 0; ofVideoPlayer *arg1 = (ofVideoPlayer *) 0 ;
  float arg2 ; SWIG_check_num_args("ofVideoPlayer::setVolume",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoPlayer::setVolume",1,"ofVideoPlayer *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVideoPlayer::setVolume",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoPlayer,0))){
    SWIG_fail_ptr("VideoPlayer_setVolume",1,SWIGTYPE_p_ofVideoPlayer); }  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setVolume(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_VideoPlayer_setLoopState(lua_State* L) { int SWIG_arg = 0; ofVideoPlayer *arg1 = (ofVideoPlayer *) 0 ;
  ofLoopType arg2 ; SWIG_check_num_args("ofVideoPlayer::setLoopState",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoPlayer::setLoopState",1,"ofVideoPlayer *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVideoPlayer::setLoopState",2,"ofLoopType");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoPlayer,0))){
    SWIG_fail_ptr("VideoPlayer_setLoopState",1,SWIGTYPE_p_ofVideoPlayer); }  arg2 = (ofLoopType)(int)lua_tonumber(L, 2);
  (arg1)->setLoopState(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_VideoPlayer_getLoopState(lua_State* L) { int SWIG_arg = 0; ofVideoPlayer *arg1 = (ofVideoPlayer *) 0 ;
  ofLoopType result; SWIG_check_num_args("ofVideoPlayer::getLoopState",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoPlayer::getLoopState",1,"ofVideoPlayer const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoPlayer,0))){
    SWIG_fail_ptr("VideoPlayer_getLoopState",1,SWIGTYPE_p_ofVideoPlayer); } 
  result = (ofLoopType)((ofVideoPlayer const *)arg1)->getLoopState(); lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_VideoPlayer_setSpeed(lua_State* L) { int SWIG_arg = 0; ofVideoPlayer *arg1 = (ofVideoPlayer *) 0 ; float arg2 ;
  SWIG_check_num_args("ofVideoPlayer::setSpeed",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoPlayer::setSpeed",1,"ofVideoPlayer *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVideoPlayer::setSpeed",2,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoPlayer,0))){
    SWIG_fail_ptr("VideoPlayer_setSpeed",1,SWIGTYPE_p_ofVideoPlayer); }  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setSpeed(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_VideoPlayer_setFrame(lua_State* L) { int SWIG_arg = 0; ofVideoPlayer *arg1 = (ofVideoPlayer *) 0 ; int arg2 ;
  SWIG_check_num_args("ofVideoPlayer::setFrame",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoPlayer::setFrame",1,"ofVideoPlayer *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVideoPlayer::setFrame",2,"int");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoPlayer,0))){
    SWIG_fail_ptr("VideoPlayer_setFrame",1,SWIGTYPE_p_ofVideoPlayer); }  arg2 = (int)lua_tonumber(L, 2); (arg1)->setFrame(arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_VideoPlayer_setUseTexture(lua_State* L) { int SWIG_arg = 0; ofVideoPlayer *arg1 = (ofVideoPlayer *) 0 ;
  bool arg2 ; SWIG_check_num_args("ofVideoPlayer::setUseTexture",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoPlayer::setUseTexture",1,"ofVideoPlayer *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofVideoPlayer::setUseTexture",2,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoPlayer,0))){
    SWIG_fail_ptr("VideoPlayer_setUseTexture",1,SWIGTYPE_p_ofVideoPlayer); }  arg2 = (lua_toboolean(L, 2)!=0);
  (arg1)->setUseTexture(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_VideoPlayer_isUsingTexture(lua_State* L) { int SWIG_arg = 0; ofVideoPlayer *arg1 = (ofVideoPlayer *) 0 ;
  bool result; SWIG_check_num_args("ofVideoPlayer::isUsingTexture",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoPlayer::isUsingTexture",1,"ofVideoPlayer const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoPlayer,0))){
    SWIG_fail_ptr("VideoPlayer_isUsingTexture",1,SWIGTYPE_p_ofVideoPlayer); } 
  result = (bool)((ofVideoPlayer const *)arg1)->isUsingTexture(); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_VideoPlayer_getTexture__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofVideoPlayer *arg1 = (ofVideoPlayer *) 0 ;
  ofTexture *result = 0 ; SWIG_check_num_args("ofVideoPlayer::getTexture",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoPlayer::getTexture",1,"ofVideoPlayer *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoPlayer,0))){
    SWIG_fail_ptr("VideoPlayer_getTexture",1,SWIGTYPE_p_ofVideoPlayer); }  result = (ofTexture *) &(arg1)->getTexture();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofTexture,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_VideoPlayer_getTexture__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofVideoPlayer *arg1 = (ofVideoPlayer *) 0 ;
  ofTexture *result = 0 ; SWIG_check_num_args("ofVideoPlayer::getTexture",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoPlayer::getTexture",1,"ofVideoPlayer const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoPlayer,0))){
    SWIG_fail_ptr("VideoPlayer_getTexture",1,SWIGTYPE_p_ofVideoPlayer); } 
  result = (ofTexture *) &((ofVideoPlayer const *)arg1)->getTexture();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ofTexture,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_VideoPlayer_getTexture(lua_State* L) { int argc; int argv[2]={ 1,2} ; argc = lua_gettop(L); if (argc == 1) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVideoPlayer, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { return _wrap_VideoPlayer_getTexture__SWIG_0(L);}  }  if (argc == 1) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVideoPlayer, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { return _wrap_VideoPlayer_getTexture__SWIG_1(L);}  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'VideoPlayer_getTexture'\n"
  "  Possible C/C++ prototypes are:\n" "    ofVideoPlayer::getTexture()\n" "    ofVideoPlayer::getTexture() const\n");
  lua_error(L);return 0; }
static int _wrap_VideoPlayer_getTexturePlanes__SWIG_0(lua_State* L) { int SWIG_arg = 0;
  ofVideoPlayer *arg1 = (ofVideoPlayer *) 0 ; std::vector< ofTexture > *result = 0 ;
  SWIG_check_num_args("ofVideoPlayer::getTexturePlanes",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoPlayer::getTexturePlanes",1,"ofVideoPlayer *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoPlayer,0))){
    SWIG_fail_ptr("VideoPlayer_getTexturePlanes",1,SWIGTYPE_p_ofVideoPlayer); } 
  result = (std::vector< ofTexture > *) &(arg1)->getTexturePlanes();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorT_ofTexture_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_VideoPlayer_getTexturePlanes__SWIG_1(lua_State* L) { int SWIG_arg = 0;
  ofVideoPlayer *arg1 = (ofVideoPlayer *) 0 ; std::vector< ofTexture > *result = 0 ;
  SWIG_check_num_args("ofVideoPlayer::getTexturePlanes",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoPlayer::getTexturePlanes",1,"ofVideoPlayer const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoPlayer,0))){
    SWIG_fail_ptr("VideoPlayer_getTexturePlanes",1,SWIGTYPE_p_ofVideoPlayer); } 
  result = (std::vector< ofTexture > *) &((ofVideoPlayer const *)arg1)->getTexturePlanes();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorT_ofTexture_t,0); SWIG_arg++;  return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_VideoPlayer_getTexturePlanes(lua_State* L) { int argc; int argv[2]={ 1,2} ; argc = lua_gettop(L);
  if (argc == 1) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVideoPlayer, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { return _wrap_VideoPlayer_getTexturePlanes__SWIG_0(L);}  }  if (argc == 1) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVideoPlayer, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { return _wrap_VideoPlayer_getTexturePlanes__SWIG_1(L);}  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'VideoPlayer_getTexturePlanes'\n"
  "  Possible C/C++ prototypes are:\n" "    ofVideoPlayer::getTexturePlanes()\n"
  "    ofVideoPlayer::getTexturePlanes() const\n"); lua_error(L);return 0; }
static int _wrap_VideoPlayer_draw__SWIG_0(lua_State* L) { int SWIG_arg = 0; ofVideoPlayer *arg1 = (ofVideoPlayer *) 0 ;
  float arg2 ; float arg3 ; float arg4 ; float arg5 ; SWIG_check_num_args("ofVideoPlayer::draw",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoPlayer::draw",1,"ofVideoPlayer const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVideoPlayer::draw",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVideoPlayer::draw",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ofVideoPlayer::draw",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ofVideoPlayer::draw",5,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoPlayer,0))){
    SWIG_fail_ptr("VideoPlayer_draw",1,SWIGTYPE_p_ofVideoPlayer); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); arg4 = (float)lua_tonumber(L, 4); arg5 = (float)lua_tonumber(L, 5);
  ((ofVideoPlayer const *)arg1)->draw(arg2,arg3,arg4,arg5); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_VideoPlayer_draw__SWIG_1(lua_State* L) { int SWIG_arg = 0; ofVideoPlayer *arg1 = (ofVideoPlayer *) 0 ;
  float arg2 ; float arg3 ; SWIG_check_num_args("ofVideoPlayer::draw",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoPlayer::draw",1,"ofVideoPlayer const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVideoPlayer::draw",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVideoPlayer::draw",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoPlayer,0))){
    SWIG_fail_ptr("VideoPlayer_draw",1,SWIGTYPE_p_ofVideoPlayer); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); ((ofVideoPlayer const *)arg1)->draw(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail:
  lua_error(L); return SWIG_arg; }
static int _wrap_VideoPlayer_draw__SWIG_2_0(lua_State* L) { int SWIG_arg = 0; ofVideoPlayer *arg1 = (ofVideoPlayer *) 0 ;
  glm::vec2 *arg2 = 0 ; SWIG_check_num_args("draw",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("draw",1,"ofVideoPlayer const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("draw",2,"glm::vec2 const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoPlayer,0))){
    SWIG_fail_ptr("VideoPlayer_draw",1,SWIGTYPE_p_ofVideoPlayer); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec2,0))){
    SWIG_fail_ptr("VideoPlayer_draw",2,SWIGTYPE_p_glm__vec2); }  ((ofVideoPlayer const *)arg1)->draw((glm::vec2 const &)*arg2);
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_VideoPlayer_draw__SWIG_2_1(lua_State* L) { int SWIG_arg = 0; ofVideoPlayer *arg1 = (ofVideoPlayer *) 0 ;
  ofRectangle *arg2 = 0 ; SWIG_check_num_args("draw",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("draw",1,"ofVideoPlayer const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("draw",2,"ofRectangle const &");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoPlayer,0))){
    SWIG_fail_ptr("VideoPlayer_draw",1,SWIGTYPE_p_ofVideoPlayer); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ofRectangle,0))){
    SWIG_fail_ptr("VideoPlayer_draw",2,SWIGTYPE_p_ofRectangle); } 
  ((ofVideoPlayer const *)arg1)->draw((ofRectangle const &)*arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_VideoPlayer_draw__SWIG_2_2(lua_State* L) { int SWIG_arg = 0; ofVideoPlayer *arg1 = (ofVideoPlayer *) 0 ;
  glm::vec2 *arg2 = 0 ; float arg3 ; float arg4 ; SWIG_check_num_args("draw",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("draw",1,"ofVideoPlayer const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("draw",2,"glm::vec2 const &"); if(!lua_isnumber(L,3)) SWIG_fail_arg("draw",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("draw",4,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoPlayer,0))){
    SWIG_fail_ptr("VideoPlayer_draw",1,SWIGTYPE_p_ofVideoPlayer); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glm__vec2,0))){
    SWIG_fail_ptr("VideoPlayer_draw",2,SWIGTYPE_p_glm__vec2); }  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4); ((ofVideoPlayer const *)arg1)->draw((glm::vec2 const &)*arg2,arg3,arg4); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_VideoPlayer_draw(lua_State* L) { int argc; int argv[6]={ 1,2,3,4,5,6} ; argc = lua_gettop(L); if (argc == 2) {
    int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVideoPlayer, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec2, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_VideoPlayer_draw__SWIG_2_0(L);}  }  }  if (argc == 2) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVideoPlayer, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_ofRectangle, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { return _wrap_VideoPlayer_draw__SWIG_2_1(L);}  }  }  if (argc == 3) { int _v; {
      void *ptr; if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVideoPlayer, 0)) {
        _v = 0; }  else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }
         if (_v) { return _wrap_VideoPlayer_draw__SWIG_1(L);}  }  }  }  if (argc == 4) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVideoPlayer, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_glm__vec2, 0)) { _v = 0; }
         else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) { { _v = lua_isnumber(L,argv[3]); } 
          if (_v) { return _wrap_VideoPlayer_draw__SWIG_2_2(L);}  }  }  }  }  if (argc == 5) { int _v; { void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_ofVideoPlayer, 0)) { _v = 0; }
       else { _v = 1; }  }  if (_v) { { _v = lua_isnumber(L,argv[1]); }  if (_v) { { _v = lua_isnumber(L,argv[2]); }  if (_v) {
          { _v = lua_isnumber(L,argv[3]); }  if (_v) { { _v = lua_isnumber(L,argv[4]); }  if (_v) {
              return _wrap_VideoPlayer_draw__SWIG_0(L);}  }  }  }  }  } 
  SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function 'VideoPlayer_draw'\n" "  Possible C/C++ prototypes are:\n"
  "    ofVideoPlayer::draw(float,float,float,float) const\n" "    ofVideoPlayer::draw(float,float) const\n"
  "    draw(glm::vec2 const &) const\n" "    draw(ofRectangle const &) const\n"
  "    draw(glm::vec2 const &,float,float) const\n"); lua_error(L);return 0; }
static int _wrap_VideoPlayer_bind(lua_State* L) { int SWIG_arg = 0; ofVideoPlayer *arg1 = (ofVideoPlayer *) 0 ;
  SWIG_check_num_args("ofVideoPlayer::bind",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoPlayer::bind",1,"ofVideoPlayer const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoPlayer,0))){
    SWIG_fail_ptr("VideoPlayer_bind",1,SWIGTYPE_p_ofVideoPlayer); }  ((ofVideoPlayer const *)arg1)->bind(); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_VideoPlayer_unbind(lua_State* L) { int SWIG_arg = 0; ofVideoPlayer *arg1 = (ofVideoPlayer *) 0 ;
  SWIG_check_num_args("ofVideoPlayer::unbind",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoPlayer::unbind",1,"ofVideoPlayer const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoPlayer,0))){
    SWIG_fail_ptr("VideoPlayer_unbind",1,SWIGTYPE_p_ofVideoPlayer); }  ((ofVideoPlayer const *)arg1)->unbind(); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_VideoPlayer_setAnchorPercent(lua_State* L) { int SWIG_arg = 0; ofVideoPlayer *arg1 = (ofVideoPlayer *) 0 ;
  float arg2 ; float arg3 ; SWIG_check_num_args("ofVideoPlayer::setAnchorPercent",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoPlayer::setAnchorPercent",1,"ofVideoPlayer *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVideoPlayer::setAnchorPercent",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVideoPlayer::setAnchorPercent",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoPlayer,0))){
    SWIG_fail_ptr("VideoPlayer_setAnchorPercent",1,SWIGTYPE_p_ofVideoPlayer); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); (arg1)->setAnchorPercent(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_VideoPlayer_setAnchorPoint(lua_State* L) { int SWIG_arg = 0; ofVideoPlayer *arg1 = (ofVideoPlayer *) 0 ;
  float arg2 ; float arg3 ; SWIG_check_num_args("ofVideoPlayer::setAnchorPoint",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoPlayer::setAnchorPoint",1,"ofVideoPlayer *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ofVideoPlayer::setAnchorPoint",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ofVideoPlayer::setAnchorPoint",3,"float");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoPlayer,0))){
    SWIG_fail_ptr("VideoPlayer_setAnchorPoint",1,SWIGTYPE_p_ofVideoPlayer); }  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3); (arg1)->setAnchorPoint(arg2,arg3); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L);
  return SWIG_arg; }
static int _wrap_VideoPlayer_resetAnchor(lua_State* L) { int SWIG_arg = 0; ofVideoPlayer *arg1 = (ofVideoPlayer *) 0 ;
  SWIG_check_num_args("ofVideoPlayer::resetAnchor",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoPlayer::resetAnchor",1,"ofVideoPlayer *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoPlayer,0))){
    SWIG_fail_ptr("VideoPlayer_resetAnchor",1,SWIGTYPE_p_ofVideoPlayer); }  (arg1)->resetAnchor(); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_VideoPlayer_setPaused(lua_State* L) { int SWIG_arg = 0; ofVideoPlayer *arg1 = (ofVideoPlayer *) 0 ; bool arg2 ;
  SWIG_check_num_args("ofVideoPlayer::setPaused",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoPlayer::setPaused",1,"ofVideoPlayer *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ofVideoPlayer::setPaused",2,"bool");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoPlayer,0))){
    SWIG_fail_ptr("VideoPlayer_setPaused",1,SWIGTYPE_p_ofVideoPlayer); }  arg2 = (lua_toboolean(L, 2)!=0);
  (arg1)->setPaused(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_VideoPlayer_getCurrentFrame(lua_State* L) { int SWIG_arg = 0; ofVideoPlayer *arg1 = (ofVideoPlayer *) 0 ;
  int result; SWIG_check_num_args("ofVideoPlayer::getCurrentFrame",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoPlayer::getCurrentFrame",1,"ofVideoPlayer const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoPlayer,0))){
    SWIG_fail_ptr("VideoPlayer_getCurrentFrame",1,SWIGTYPE_p_ofVideoPlayer); } 
  result = (int)((ofVideoPlayer const *)arg1)->getCurrentFrame(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_VideoPlayer_getTotalNumFrames(lua_State* L) { int SWIG_arg = 0; ofVideoPlayer *arg1 = (ofVideoPlayer *) 0 ;
  int result; SWIG_check_num_args("ofVideoPlayer::getTotalNumFrames",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoPlayer::getTotalNumFrames",1,"ofVideoPlayer const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoPlayer,0))){
    SWIG_fail_ptr("VideoPlayer_getTotalNumFrames",1,SWIGTYPE_p_ofVideoPlayer); } 
  result = (int)((ofVideoPlayer const *)arg1)->getTotalNumFrames(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_VideoPlayer_firstFrame(lua_State* L) { int SWIG_arg = 0; ofVideoPlayer *arg1 = (ofVideoPlayer *) 0 ;
  SWIG_check_num_args("ofVideoPlayer::firstFrame",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoPlayer::firstFrame",1,"ofVideoPlayer *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoPlayer,0))){
    SWIG_fail_ptr("VideoPlayer_firstFrame",1,SWIGTYPE_p_ofVideoPlayer); }  (arg1)->firstFrame(); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_VideoPlayer_nextFrame(lua_State* L) { int SWIG_arg = 0; ofVideoPlayer *arg1 = (ofVideoPlayer *) 0 ;
  SWIG_check_num_args("ofVideoPlayer::nextFrame",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoPlayer::nextFrame",1,"ofVideoPlayer *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoPlayer,0))){
    SWIG_fail_ptr("VideoPlayer_nextFrame",1,SWIGTYPE_p_ofVideoPlayer); }  (arg1)->nextFrame(); return SWIG_arg; if(0) SWIG_fail;
  fail: lua_error(L); return SWIG_arg; }
static int _wrap_VideoPlayer_previousFrame(lua_State* L) { int SWIG_arg = 0; ofVideoPlayer *arg1 = (ofVideoPlayer *) 0 ;
  SWIG_check_num_args("ofVideoPlayer::previousFrame",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoPlayer::previousFrame",1,"ofVideoPlayer *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoPlayer,0))){
    SWIG_fail_ptr("VideoPlayer_previousFrame",1,SWIGTYPE_p_ofVideoPlayer); }  (arg1)->previousFrame(); return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_VideoPlayer_getHeight(lua_State* L) { int SWIG_arg = 0; ofVideoPlayer *arg1 = (ofVideoPlayer *) 0 ;
  float result; SWIG_check_num_args("ofVideoPlayer::getHeight",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoPlayer::getHeight",1,"ofVideoPlayer const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoPlayer,0))){
    SWIG_fail_ptr("VideoPlayer_getHeight",1,SWIGTYPE_p_ofVideoPlayer); } 
  result = (float)((ofVideoPlayer const *)arg1)->getHeight(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_VideoPlayer_getWidth(lua_State* L) { int SWIG_arg = 0; ofVideoPlayer *arg1 = (ofVideoPlayer *) 0 ;
  float result; SWIG_check_num_args("ofVideoPlayer::getWidth",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoPlayer::getWidth",1,"ofVideoPlayer const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoPlayer,0))){
    SWIG_fail_ptr("VideoPlayer_getWidth",1,SWIGTYPE_p_ofVideoPlayer); } 
  result = (float)((ofVideoPlayer const *)arg1)->getWidth(); lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_VideoPlayer_isPaused(lua_State* L) { int SWIG_arg = 0; ofVideoPlayer *arg1 = (ofVideoPlayer *) 0 ; bool result;
  SWIG_check_num_args("ofVideoPlayer::isPaused",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoPlayer::isPaused",1,"ofVideoPlayer const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoPlayer,0))){
    SWIG_fail_ptr("VideoPlayer_isPaused",1,SWIGTYPE_p_ofVideoPlayer); } 
  result = (bool)((ofVideoPlayer const *)arg1)->isPaused(); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_VideoPlayer_isLoaded(lua_State* L) { int SWIG_arg = 0; ofVideoPlayer *arg1 = (ofVideoPlayer *) 0 ; bool result;
  SWIG_check_num_args("ofVideoPlayer::isLoaded",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoPlayer::isLoaded",1,"ofVideoPlayer const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoPlayer,0))){
    SWIG_fail_ptr("VideoPlayer_isLoaded",1,SWIGTYPE_p_ofVideoPlayer); } 
  result = (bool)((ofVideoPlayer const *)arg1)->isLoaded(); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_VideoPlayer_isPlaying(lua_State* L) { int SWIG_arg = 0; ofVideoPlayer *arg1 = (ofVideoPlayer *) 0 ;
  bool result; SWIG_check_num_args("ofVideoPlayer::isPlaying",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoPlayer::isPlaying",1,"ofVideoPlayer const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoPlayer,0))){
    SWIG_fail_ptr("VideoPlayer_isPlaying",1,SWIGTYPE_p_ofVideoPlayer); } 
  result = (bool)((ofVideoPlayer const *)arg1)->isPlaying(); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++; return SWIG_arg;
  if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_VideoPlayer_isInitialized(lua_State* L) { int SWIG_arg = 0; ofVideoPlayer *arg1 = (ofVideoPlayer *) 0 ;
  bool result; SWIG_check_num_args("ofVideoPlayer::isInitialized",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoPlayer::isInitialized",1,"ofVideoPlayer const *");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoPlayer,0))){
    SWIG_fail_ptr("VideoPlayer_isInitialized",1,SWIGTYPE_p_ofVideoPlayer); } 
  result = (bool)((ofVideoPlayer const *)arg1)->isInitialized(); lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static int _wrap_VideoPlayer_setPlayer(lua_State* L) { int SWIG_arg = 0; ofVideoPlayer *arg1 = (ofVideoPlayer *) 0 ;
  SwigValueWrapper< std::shared_ptr< ofBaseVideoPlayer > > arg2 ; std::shared_ptr< ofBaseVideoPlayer > *argp2 ;
  SWIG_check_num_args("ofVideoPlayer::setPlayer",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ofVideoPlayer::setPlayer",1,"ofVideoPlayer *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("ofVideoPlayer::setPlayer",2,"std::shared_ptr< ofBaseVideoPlayer >");
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ofVideoPlayer,0))){
    SWIG_fail_ptr("VideoPlayer_setPlayer",1,SWIGTYPE_p_ofVideoPlayer); } 
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_std__shared_ptrT_ofBaseVideoPlayer_t,0))){
    SWIG_fail_ptr("VideoPlayer_setPlayer",2,SWIGTYPE_p_std__shared_ptrT_ofBaseVideoPlayer_t); }  arg2 = *argp2;
  (arg1)->setPlayer(arg2); return SWIG_arg; if(0) SWIG_fail; fail: lua_error(L); return SWIG_arg; }
static void swig_delete_VideoPlayer(void *obj) {
ofVideoPlayer *arg1 = (ofVideoPlayer *) obj;
delete arg1;
}
static int _proxy__wrap_new_VideoPlayer(lua_State *L) {
    assert(lua_istable(L,1));
    lua_pushcfunction(L,_wrap_new_VideoPlayer);
    assert(!lua_isnil(L,-1));
    lua_replace(L,1); /* replace our table with real constructor */
    lua_call(L,lua_gettop(L)-1,1);
    return 1;
}
static swig_lua_attribute swig_VideoPlayer_attributes[] = {
    {0,0,0}
};
static swig_lua_method swig_VideoPlayer_methods[]= {
    { "load", _wrap_VideoPlayer_load},
    { "loadAsync", _wrap_VideoPlayer_loadAsync},
    { "getMoviePath", _wrap_VideoPlayer_getMoviePath},
    { "setPixelFormat", _wrap_VideoPlayer_setPixelFormat},
    { "getPixelFormat", _wrap_VideoPlayer_getPixelFormat},
    { "closeMovie", _wrap_VideoPlayer_closeMovie},
    { "close", _wrap_VideoPlayer_close},
    { "update", _wrap_VideoPlayer_update},
    { "play", _wrap_VideoPlayer_play},
    { "stop", _wrap_VideoPlayer_stop},
    { "isFrameNew", _wrap_VideoPlayer_isFrameNew},
    { "getPixels", _wrap_VideoPlayer_getPixels},
    { "getPosition", _wrap_VideoPlayer_getPosition},
    { "getSpeed", _wrap_VideoPlayer_getSpeed},
    { "getDuration", _wrap_VideoPlayer_getDuration},
    { "getIsMovieDone", _wrap_VideoPlayer_getIsMovieDone},
    { "setPosition", _wrap_VideoPlayer_setPosition},
    { "setVolume", _wrap_VideoPlayer_setVolume},
    { "setLoopState", _wrap_VideoPlayer_setLoopState},
    { "getLoopState", _wrap_VideoPlayer_getLoopState},
    { "setSpeed", _wrap_VideoPlayer_setSpeed},
    { "setFrame", _wrap_VideoPlayer_setFrame},
    { "setUseTexture", _wrap_VideoPlayer_setUseTexture},
    { "isUsingTexture", _wrap_VideoPlayer_isUsingTexture},
    { "getTexture", _wrap_VideoPlayer_getTexture},
    { "getTexturePlanes", _wrap_VideoPlayer_getTexturePlanes},
    { "draw", _wrap_VideoPlayer_draw},
    { "bind", _wrap_VideoPlayer_bind},
    { "unbind", _wrap_VideoPlayer_unbind},
    { "setAnchorPercent", _wrap_VideoPlayer_setAnchorPercent},
    { "setAnchorPoint", _wrap_VideoPlayer_setAnchorPoint},
    { "resetAnchor", _wrap_VideoPlayer_resetAnchor},
    { "setPaused", _wrap_VideoPlayer_setPaused},
    { "getCurrentFrame", _wrap_VideoPlayer_getCurrentFrame},
    { "getTotalNumFrames", _wrap_VideoPlayer_getTotalNumFrames},
    { "firstFrame", _wrap_VideoPlayer_firstFrame},
    { "nextFrame", _wrap_VideoPlayer_nextFrame},
    { "previousFrame", _wrap_VideoPlayer_previousFrame},
    { "getHeight", _wrap_VideoPlayer_getHeight},
    { "getWidth", _wrap_VideoPlayer_getWidth},
    { "isPaused", _wrap_VideoPlayer_isPaused},
    { "isLoaded", _wrap_VideoPlayer_isLoaded},
    { "isPlaying", _wrap_VideoPlayer_isPlaying},
    { "isInitialized", _wrap_VideoPlayer_isInitialized},
    { "setPlayer", _wrap_VideoPlayer_setPlayer},
    {0,0}
};
static swig_lua_method swig_VideoPlayer_meta[] = {
    {0,0}
};

static swig_lua_attribute swig_VideoPlayer_Sf_SwigStatic_attributes[] = {
    {0,0,0}
};
static swig_lua_const_info swig_VideoPlayer_Sf_SwigStatic_constants[]= {
    {0,0,0,0,0,0}
};
static swig_lua_method swig_VideoPlayer_Sf_SwigStatic_methods[]= {
    {0,0}
};
static swig_lua_class* swig_VideoPlayer_Sf_SwigStatic_classes[]= {
    0
};

static swig_lua_namespace swig_VideoPlayer_Sf_SwigStatic = {
    "VideoPlayer",
    swig_VideoPlayer_Sf_SwigStatic_methods,
    swig_VideoPlayer_Sf_SwigStatic_attributes,
    swig_VideoPlayer_Sf_SwigStatic_constants,
    swig_VideoPlayer_Sf_SwigStatic_classes,
    0
};
static swig_lua_class *swig_VideoPlayer_bases[] = {0};
static const char *swig_VideoPlayer_base_names[] = {0};
static swig_lua_class _wrap_class_VideoPlayer = { "VideoPlayer", "VideoPlayer", &SWIGTYPE_p_ofVideoPlayer,_proxy__wrap_new_VideoPlayer, swig_delete_VideoPlayer, swig_VideoPlayer_methods, swig_VideoPlayer_attributes, &swig_VideoPlayer_Sf_SwigStatic, swig_VideoPlayer_meta, swig_VideoPlayer_bases, swig_VideoPlayer_base_names };

static swig_lua_attribute swig_SwigModule_attributes[] = {
    { "TTF_SANS", _wrap_TTF_SANS_get, SWIG_Lua_set_immutable },
    { "TTF_SERIF", _wrap_TTF_SERIF_get, SWIG_Lua_set_immutable },
    { "TTF_MONO", _wrap_TTF_MONO_get, SWIG_Lua_set_immutable },
    { "Color_white", _wrap_Color_white_get, SWIG_Lua_set_immutable },
    { "Color_gray", _wrap_Color_gray_get, SWIG_Lua_set_immutable },
    { "Color_black", _wrap_Color_black_get, SWIG_Lua_set_immutable },
    { "Color_red", _wrap_Color_red_get, SWIG_Lua_set_immutable },
    { "Color_green", _wrap_Color_green_get, SWIG_Lua_set_immutable },
    { "Color_blue", _wrap_Color_blue_get, SWIG_Lua_set_immutable },
    { "Color_cyan", _wrap_Color_cyan_get, SWIG_Lua_set_immutable },
    { "Color_magenta", _wrap_Color_magenta_get, SWIG_Lua_set_immutable },
    { "Color_yellow", _wrap_Color_yellow_get, SWIG_Lua_set_immutable },
    { "Color_aliceBlue", _wrap_Color_aliceBlue_get, SWIG_Lua_set_immutable },
    { "Color_antiqueWhite", _wrap_Color_antiqueWhite_get, SWIG_Lua_set_immutable },
    { "Color_aqua", _wrap_Color_aqua_get, SWIG_Lua_set_immutable },
    { "Color_aquamarine", _wrap_Color_aquamarine_get, SWIG_Lua_set_immutable },
    { "Color_azure", _wrap_Color_azure_get, SWIG_Lua_set_immutable },
    { "Color_beige", _wrap_Color_beige_get, SWIG_Lua_set_immutable },
    { "Color_bisque", _wrap_Color_bisque_get, SWIG_Lua_set_immutable },
    { "Color_blanchedAlmond", _wrap_Color_blanchedAlmond_get, SWIG_Lua_set_immutable },
    { "Color_blueViolet", _wrap_Color_blueViolet_get, SWIG_Lua_set_immutable },
    { "Color_brown", _wrap_Color_brown_get, SWIG_Lua_set_immutable },
    { "Color_burlyWood", _wrap_Color_burlyWood_get, SWIG_Lua_set_immutable },
    { "Color_cadetBlue", _wrap_Color_cadetBlue_get, SWIG_Lua_set_immutable },
    { "Color_chartreuse", _wrap_Color_chartreuse_get, SWIG_Lua_set_immutable },
    { "Color_chocolate", _wrap_Color_chocolate_get, SWIG_Lua_set_immutable },
    { "Color_coral", _wrap_Color_coral_get, SWIG_Lua_set_immutable },
    { "Color_cornflowerBlue", _wrap_Color_cornflowerBlue_get, SWIG_Lua_set_immutable },
    { "Color_cornsilk", _wrap_Color_cornsilk_get, SWIG_Lua_set_immutable },
    { "Color_crimson", _wrap_Color_crimson_get, SWIG_Lua_set_immutable },
    { "Color_darkBlue", _wrap_Color_darkBlue_get, SWIG_Lua_set_immutable },
    { "Color_darkCyan", _wrap_Color_darkCyan_get, SWIG_Lua_set_immutable },
    { "Color_darkGoldenRod", _wrap_Color_darkGoldenRod_get, SWIG_Lua_set_immutable },
    { "Color_darkGray", _wrap_Color_darkGray_get, SWIG_Lua_set_immutable },
    { "Color_darkGrey", _wrap_Color_darkGrey_get, SWIG_Lua_set_immutable },
    { "Color_darkGreen", _wrap_Color_darkGreen_get, SWIG_Lua_set_immutable },
    { "Color_darkKhaki", _wrap_Color_darkKhaki_get, SWIG_Lua_set_immutable },
    { "Color_darkMagenta", _wrap_Color_darkMagenta_get, SWIG_Lua_set_immutable },
    { "Color_darkOliveGreen", _wrap_Color_darkOliveGreen_get, SWIG_Lua_set_immutable },
    { "Color_darkorange", _wrap_Color_darkorange_get, SWIG_Lua_set_immutable },
    { "Color_darkOrchid", _wrap_Color_darkOrchid_get, SWIG_Lua_set_immutable },
    { "Color_darkRed", _wrap_Color_darkRed_get, SWIG_Lua_set_immutable },
    { "Color_darkSalmon", _wrap_Color_darkSalmon_get, SWIG_Lua_set_immutable },
    { "Color_darkSeaGreen", _wrap_Color_darkSeaGreen_get, SWIG_Lua_set_immutable },
    { "Color_darkSlateBlue", _wrap_Color_darkSlateBlue_get, SWIG_Lua_set_immutable },
    { "Color_darkSlateGray", _wrap_Color_darkSlateGray_get, SWIG_Lua_set_immutable },
    { "Color_darkSlateGrey", _wrap_Color_darkSlateGrey_get, SWIG_Lua_set_immutable },
    { "Color_darkTurquoise", _wrap_Color_darkTurquoise_get, SWIG_Lua_set_immutable },
    { "Color_darkViolet", _wrap_Color_darkViolet_get, SWIG_Lua_set_immutable },
    { "Color_deepPink", _wrap_Color_deepPink_get, SWIG_Lua_set_immutable },
    { "Color_deepSkyBlue", _wrap_Color_deepSkyBlue_get, SWIG_Lua_set_immutable },
    { "Color_dimGray", _wrap_Color_dimGray_get, SWIG_Lua_set_immutable },
    { "Color_dimGrey", _wrap_Color_dimGrey_get, SWIG_Lua_set_immutable },
    { "Color_dodgerBlue", _wrap_Color_dodgerBlue_get, SWIG_Lua_set_immutable },
    { "Color_fireBrick", _wrap_Color_fireBrick_get, SWIG_Lua_set_immutable },
    { "Color_floralWhite", _wrap_Color_floralWhite_get, SWIG_Lua_set_immutable },
    { "Color_forestGreen", _wrap_Color_forestGreen_get, SWIG_Lua_set_immutable },
    { "Color_fuchsia", _wrap_Color_fuchsia_get, SWIG_Lua_set_immutable },
    { "Color_gainsboro", _wrap_Color_gainsboro_get, SWIG_Lua_set_immutable },
    { "Color_ghostWhite", _wrap_Color_ghostWhite_get, SWIG_Lua_set_immutable },
    { "Color_gold", _wrap_Color_gold_get, SWIG_Lua_set_immutable },
    { "Color_goldenRod", _wrap_Color_goldenRod_get, SWIG_Lua_set_immutable },
    { "Color_grey", _wrap_Color_grey_get, SWIG_Lua_set_immutable },
    { "Color_greenYellow", _wrap_Color_greenYellow_get, SWIG_Lua_set_immutable },
    { "Color_honeyDew", _wrap_Color_honeyDew_get, SWIG_Lua_set_immutable },
    { "Color_hotPink", _wrap_Color_hotPink_get, SWIG_Lua_set_immutable },
    { "Color_indianRed", _wrap_Color_indianRed_get, SWIG_Lua_set_immutable },
    { "Color_indigo", _wrap_Color_indigo_get, SWIG_Lua_set_immutable },
    { "Color_ivory", _wrap_Color_ivory_get, SWIG_Lua_set_immutable },
    { "Color_khaki", _wrap_Color_khaki_get, SWIG_Lua_set_immutable },
    { "Color_lavender", _wrap_Color_lavender_get, SWIG_Lua_set_immutable },
    { "Color_lavenderBlush", _wrap_Color_lavenderBlush_get, SWIG_Lua_set_immutable },
    { "Color_lawnGreen", _wrap_Color_lawnGreen_get, SWIG_Lua_set_immutable },
    { "Color_lemonChiffon", _wrap_Color_lemonChiffon_get, SWIG_Lua_set_immutable },
    { "Color_lightBlue", _wrap_Color_lightBlue_get, SWIG_Lua_set_immutable },
    { "Color_lightCoral", _wrap_Color_lightCoral_get, SWIG_Lua_set_immutable },
    { "Color_lightCyan", _wrap_Color_lightCyan_get, SWIG_Lua_set_immutable },
    { "Color_lightGoldenRodYellow", _wrap_Color_lightGoldenRodYellow_get, SWIG_Lua_set_immutable },
    { "Color_lightGray", _wrap_Color_lightGray_get, SWIG_Lua_set_immutable },
    { "Color_lightGrey", _wrap_Color_lightGrey_get, SWIG_Lua_set_immutable },
    { "Color_lightGreen", _wrap_Color_lightGreen_get, SWIG_Lua_set_immutable },
    { "Color_lightPink", _wrap_Color_lightPink_get, SWIG_Lua_set_immutable },
    { "Color_lightSalmon", _wrap_Color_lightSalmon_get, SWIG_Lua_set_immutable },
    { "Color_lightSeaGreen", _wrap_Color_lightSeaGreen_get, SWIG_Lua_set_immutable },
    { "Color_lightSkyBlue", _wrap_Color_lightSkyBlue_get, SWIG_Lua_set_immutable },
    { "Color_lightSlateGray", _wrap_Color_lightSlateGray_get, SWIG_Lua_set_immutable },
    { "Color_lightSlateGrey", _wrap_Color_lightSlateGrey_get, SWIG_Lua_set_immutable },
    { "Color_lightSteelBlue", _wrap_Color_lightSteelBlue_get, SWIG_Lua_set_immutable },
    { "Color_lightYellow", _wrap_Color_lightYellow_get, SWIG_Lua_set_immutable },
    { "Color_lime", _wrap_Color_lime_get, SWIG_Lua_set_immutable },
    { "Color_limeGreen", _wrap_Color_limeGreen_get, SWIG_Lua_set_immutable },
    { "Color_linen", _wrap_Color_linen_get, SWIG_Lua_set_immutable },
    { "Color_maroon", _wrap_Color_maroon_get, SWIG_Lua_set_immutable },
    { "Color_mediumAquaMarine", _wrap_Color_mediumAquaMarine_get, SWIG_Lua_set_immutable },
    { "Color_mediumBlue", _wrap_Color_mediumBlue_get, SWIG_Lua_set_immutable },
    { "Color_mediumOrchid", _wrap_Color_mediumOrchid_get, SWIG_Lua_set_immutable },
    { "Color_mediumPurple", _wrap_Color_mediumPurple_get, SWIG_Lua_set_immutable },
    { "Color_mediumSeaGreen", _wrap_Color_mediumSeaGreen_get, SWIG_Lua_set_immutable },
    { "Color_mediumSlateBlue", _wrap_Color_mediumSlateBlue_get, SWIG_Lua_set_immutable },
    { "Color_mediumSpringGreen", _wrap_Color_mediumSpringGreen_get, SWIG_Lua_set_immutable },
    { "Color_mediumTurquoise", _wrap_Color_mediumTurquoise_get, SWIG_Lua_set_immutable },
    { "Color_mediumVioletRed", _wrap_Color_mediumVioletRed_get, SWIG_Lua_set_immutable },
    { "Color_midnightBlue", _wrap_Color_midnightBlue_get, SWIG_Lua_set_immutable },
    { "Color_mintCream", _wrap_Color_mintCream_get, SWIG_Lua_set_immutable },
    { "Color_mistyRose", _wrap_Color_mistyRose_get, SWIG_Lua_set_immutable },
    { "Color_moccasin", _wrap_Color_moccasin_get, SWIG_Lua_set_immutable },
    { "Color_navajoWhite", _wrap_Color_navajoWhite_get, SWIG_Lua_set_immutable },
    { "Color_navy", _wrap_Color_navy_get, SWIG_Lua_set_immutable },
    { "Color_oldLace", _wrap_Color_oldLace_get, SWIG_Lua_set_immutable },
    { "Color_olive", _wrap_Color_olive_get, SWIG_Lua_set_immutable },
    { "Color_oliveDrab", _wrap_Color_oliveDrab_get, SWIG_Lua_set_immutable },
    { "Color_orange", _wrap_Color_orange_get, SWIG_Lua_set_immutable },
    { "Color_orangeRed", _wrap_Color_orangeRed_get, SWIG_Lua_set_immutable },
    { "Color_orchid", _wrap_Color_orchid_get, SWIG_Lua_set_immutable },
    { "Color_paleGoldenRod", _wrap_Color_paleGoldenRod_get, SWIG_Lua_set_immutable },
    { "Color_paleGreen", _wrap_Color_paleGreen_get, SWIG_Lua_set_immutable },
    { "Color_paleTurquoise", _wrap_Color_paleTurquoise_get, SWIG_Lua_set_immutable },
    { "Color_paleVioletRed", _wrap_Color_paleVioletRed_get, SWIG_Lua_set_immutable },
    { "Color_papayaWhip", _wrap_Color_papayaWhip_get, SWIG_Lua_set_immutable },
    { "Color_peachPuff", _wrap_Color_peachPuff_get, SWIG_Lua_set_immutable },
    { "Color_peru", _wrap_Color_peru_get, SWIG_Lua_set_immutable },
    { "Color_pink", _wrap_Color_pink_get, SWIG_Lua_set_immutable },
    { "Color_plum", _wrap_Color_plum_get, SWIG_Lua_set_immutable },
    { "Color_powderBlue", _wrap_Color_powderBlue_get, SWIG_Lua_set_immutable },
    { "Color_purple", _wrap_Color_purple_get, SWIG_Lua_set_immutable },
    { "Color_rosyBrown", _wrap_Color_rosyBrown_get, SWIG_Lua_set_immutable },
    { "Color_royalBlue", _wrap_Color_royalBlue_get, SWIG_Lua_set_immutable },
    { "Color_saddleBrown", _wrap_Color_saddleBrown_get, SWIG_Lua_set_immutable },
    { "Color_salmon", _wrap_Color_salmon_get, SWIG_Lua_set_immutable },
    { "Color_sandyBrown", _wrap_Color_sandyBrown_get, SWIG_Lua_set_immutable },
    { "Color_seaGreen", _wrap_Color_seaGreen_get, SWIG_Lua_set_immutable },
    { "Color_seaShell", _wrap_Color_seaShell_get, SWIG_Lua_set_immutable },
    { "Color_sienna", _wrap_Color_sienna_get, SWIG_Lua_set_immutable },
    { "Color_silver", _wrap_Color_silver_get, SWIG_Lua_set_immutable },
    { "Color_skyBlue", _wrap_Color_skyBlue_get, SWIG_Lua_set_immutable },
    { "Color_slateBlue", _wrap_Color_slateBlue_get, SWIG_Lua_set_immutable },
    { "Color_slateGray", _wrap_Color_slateGray_get, SWIG_Lua_set_immutable },
    { "Color_slateGrey", _wrap_Color_slateGrey_get, SWIG_Lua_set_immutable },
    { "Color_snow", _wrap_Color_snow_get, SWIG_Lua_set_immutable },
    { "Color_springGreen", _wrap_Color_springGreen_get, SWIG_Lua_set_immutable },
    { "Color_steelBlue", _wrap_Color_steelBlue_get, SWIG_Lua_set_immutable },
    { "Color_blueSteel", _wrap_Color_blueSteel_get, SWIG_Lua_set_immutable },
    { "Color_tan", _wrap_Color_tan_get, SWIG_Lua_set_immutable },
    { "Color_teal", _wrap_Color_teal_get, SWIG_Lua_set_immutable },
    { "Color_thistle", _wrap_Color_thistle_get, SWIG_Lua_set_immutable },
    { "Color_tomato", _wrap_Color_tomato_get, SWIG_Lua_set_immutable },
    { "Color_turquoise", _wrap_Color_turquoise_get, SWIG_Lua_set_immutable },
    { "Color_violet", _wrap_Color_violet_get, SWIG_Lua_set_immutable },
    { "Color_wheat", _wrap_Color_wheat_get, SWIG_Lua_set_immutable },
    { "Color_whiteSmoke", _wrap_Color_whiteSmoke_get, SWIG_Lua_set_immutable },
    { "Color_yellowGreen", _wrap_Color_yellowGreen_get, SWIG_Lua_set_immutable },
    { "FloatColor_white", _wrap_FloatColor_white_get, SWIG_Lua_set_immutable },
    { "FloatColor_gray", _wrap_FloatColor_gray_get, SWIG_Lua_set_immutable },
    { "FloatColor_black", _wrap_FloatColor_black_get, SWIG_Lua_set_immutable },
    { "FloatColor_red", _wrap_FloatColor_red_get, SWIG_Lua_set_immutable },
    { "FloatColor_green", _wrap_FloatColor_green_get, SWIG_Lua_set_immutable },
    { "FloatColor_blue", _wrap_FloatColor_blue_get, SWIG_Lua_set_immutable },
    { "FloatColor_cyan", _wrap_FloatColor_cyan_get, SWIG_Lua_set_immutable },
    { "FloatColor_magenta", _wrap_FloatColor_magenta_get, SWIG_Lua_set_immutable },
    { "FloatColor_yellow", _wrap_FloatColor_yellow_get, SWIG_Lua_set_immutable },
    { "FloatColor_aliceBlue", _wrap_FloatColor_aliceBlue_get, SWIG_Lua_set_immutable },
    { "FloatColor_antiqueWhite", _wrap_FloatColor_antiqueWhite_get, SWIG_Lua_set_immutable },
    { "FloatColor_aqua", _wrap_FloatColor_aqua_get, SWIG_Lua_set_immutable },
    { "FloatColor_aquamarine", _wrap_FloatColor_aquamarine_get, SWIG_Lua_set_immutable },
    { "FloatColor_azure", _wrap_FloatColor_azure_get, SWIG_Lua_set_immutable },
    { "FloatColor_beige", _wrap_FloatColor_beige_get, SWIG_Lua_set_immutable },
    { "FloatColor_bisque", _wrap_FloatColor_bisque_get, SWIG_Lua_set_immutable },
    { "FloatColor_blanchedAlmond", _wrap_FloatColor_blanchedAlmond_get, SWIG_Lua_set_immutable },
    { "FloatColor_blueViolet", _wrap_FloatColor_blueViolet_get, SWIG_Lua_set_immutable },
    { "FloatColor_brown", _wrap_FloatColor_brown_get, SWIG_Lua_set_immutable },
    { "FloatColor_burlyWood", _wrap_FloatColor_burlyWood_get, SWIG_Lua_set_immutable },
    { "FloatColor_cadetBlue", _wrap_FloatColor_cadetBlue_get, SWIG_Lua_set_immutable },
    { "FloatColor_chartreuse", _wrap_FloatColor_chartreuse_get, SWIG_Lua_set_immutable },
    { "FloatColor_chocolate", _wrap_FloatColor_chocolate_get, SWIG_Lua_set_immutable },
    { "FloatColor_coral", _wrap_FloatColor_coral_get, SWIG_Lua_set_immutable },
    { "FloatColor_cornflowerBlue", _wrap_FloatColor_cornflowerBlue_get, SWIG_Lua_set_immutable },
    { "FloatColor_cornsilk", _wrap_FloatColor_cornsilk_get, SWIG_Lua_set_immutable },
    { "FloatColor_crimson", _wrap_FloatColor_crimson_get, SWIG_Lua_set_immutable },
    { "FloatColor_darkBlue", _wrap_FloatColor_darkBlue_get, SWIG_Lua_set_immutable },
    { "FloatColor_darkCyan", _wrap_FloatColor_darkCyan_get, SWIG_Lua_set_immutable },
    { "FloatColor_darkGoldenRod", _wrap_FloatColor_darkGoldenRod_get, SWIG_Lua_set_immutable },
    { "FloatColor_darkGray", _wrap_FloatColor_darkGray_get, SWIG_Lua_set_immutable },
    { "FloatColor_darkGrey", _wrap_FloatColor_darkGrey_get, SWIG_Lua_set_immutable },
    { "FloatColor_darkGreen", _wrap_FloatColor_darkGreen_get, SWIG_Lua_set_immutable },
    { "FloatColor_darkKhaki", _wrap_FloatColor_darkKhaki_get, SWIG_Lua_set_immutable },
    { "FloatColor_darkMagenta", _wrap_FloatColor_darkMagenta_get, SWIG_Lua_set_immutable },
    { "FloatColor_darkOliveGreen", _wrap_FloatColor_darkOliveGreen_get, SWIG_Lua_set_immutable },
    { "FloatColor_darkorange", _wrap_FloatColor_darkorange_get, SWIG_Lua_set_immutable },
    { "FloatColor_darkOrchid", _wrap_FloatColor_darkOrchid_get, SWIG_Lua_set_immutable },
    { "FloatColor_darkRed", _wrap_FloatColor_darkRed_get, SWIG_Lua_set_immutable },
    { "FloatColor_darkSalmon", _wrap_FloatColor_darkSalmon_get, SWIG_Lua_set_immutable },
    { "FloatColor_darkSeaGreen", _wrap_FloatColor_darkSeaGreen_get, SWIG_Lua_set_immutable },
    { "FloatColor_darkSlateBlue", _wrap_FloatColor_darkSlateBlue_get, SWIG_Lua_set_immutable },
    { "FloatColor_darkSlateGray", _wrap_FloatColor_darkSlateGray_get, SWIG_Lua_set_immutable },
    { "FloatColor_darkSlateGrey", _wrap_FloatColor_darkSlateGrey_get, SWIG_Lua_set_immutable },
    { "FloatColor_darkTurquoise", _wrap_FloatColor_darkTurquoise_get, SWIG_Lua_set_immutable },
    { "FloatColor_darkViolet", _wrap_FloatColor_darkViolet_get, SWIG_Lua_set_immutable },
    { "FloatColor_deepPink", _wrap_FloatColor_deepPink_get, SWIG_Lua_set_immutable },
    { "FloatColor_deepSkyBlue", _wrap_FloatColor_deepSkyBlue_get, SWIG_Lua_set_immutable },
    { "FloatColor_dimGray", _wrap_FloatColor_dimGray_get, SWIG_Lua_set_immutable },
    { "FloatColor_dimGrey", _wrap_FloatColor_dimGrey_get, SWIG_Lua_set_immutable },
    { "FloatColor_dodgerBlue", _wrap_FloatColor_dodgerBlue_get, SWIG_Lua_set_immutable },
    { "FloatColor_fireBrick", _wrap_FloatColor_fireBrick_get, SWIG_Lua_set_immutable },
    { "FloatColor_floralWhite", _wrap_FloatColor_floralWhite_get, SWIG_Lua_set_immutable },
    { "FloatColor_forestGreen", _wrap_FloatColor_forestGreen_get, SWIG_Lua_set_immutable },
    { "FloatColor_fuchsia", _wrap_FloatColor_fuchsia_get, SWIG_Lua_set_immutable },
    { "FloatColor_gainsboro", _wrap_FloatColor_gainsboro_get, SWIG_Lua_set_immutable },
    { "FloatColor_ghostWhite", _wrap_FloatColor_ghostWhite_get, SWIG_Lua_set_immutable },
    { "FloatColor_gold", _wrap_FloatColor_gold_get, SWIG_Lua_set_immutable },
    { "FloatColor_goldenRod", _wrap_FloatColor_goldenRod_get, SWIG_Lua_set_immutable },
    { "FloatColor_grey", _wrap_FloatColor_grey_get, SWIG_Lua_set_immutable },
    { "FloatColor_greenYellow", _wrap_FloatColor_greenYellow_get, SWIG_Lua_set_immutable },
    { "FloatColor_honeyDew", _wrap_FloatColor_honeyDew_get, SWIG_Lua_set_immutable },
    { "FloatColor_hotPink", _wrap_FloatColor_hotPink_get, SWIG_Lua_set_immutable },
    { "FloatColor_indianRed", _wrap_FloatColor_indianRed_get, SWIG_Lua_set_immutable },
    { "FloatColor_indigo", _wrap_FloatColor_indigo_get, SWIG_Lua_set_immutable },
    { "FloatColor_ivory", _wrap_FloatColor_ivory_get, SWIG_Lua_set_immutable },
    { "FloatColor_khaki", _wrap_FloatColor_khaki_get, SWIG_Lua_set_immutable },
    { "FloatColor_lavender", _wrap_FloatColor_lavender_get, SWIG_Lua_set_immutable },
    { "FloatColor_lavenderBlush", _wrap_FloatColor_lavenderBlush_get, SWIG_Lua_set_immutable },
    { "FloatColor_lawnGreen", _wrap_FloatColor_lawnGreen_get, SWIG_Lua_set_immutable },
    { "FloatColor_lemonChiffon", _wrap_FloatColor_lemonChiffon_get, SWIG_Lua_set_immutable },
    { "FloatColor_lightBlue", _wrap_FloatColor_lightBlue_get, SWIG_Lua_set_immutable },
    { "FloatColor_lightCoral", _wrap_FloatColor_lightCoral_get, SWIG_Lua_set_immutable },
    { "FloatColor_lightCyan", _wrap_FloatColor_lightCyan_get, SWIG_Lua_set_immutable },
    { "FloatColor_lightGoldenRodYellow", _wrap_FloatColor_lightGoldenRodYellow_get, SWIG_Lua_set_immutable },
    { "FloatColor_lightGray", _wrap_FloatColor_lightGray_get, SWIG_Lua_set_immutable },
    { "FloatColor_lightGrey", _wrap_FloatColor_lightGrey_get, SWIG_Lua_set_immutable },
    { "FloatColor_lightGreen", _wrap_FloatColor_lightGreen_get, SWIG_Lua_set_immutable },
    { "FloatColor_lightPink", _wrap_FloatColor_lightPink_get, SWIG_Lua_set_immutable },
    { "FloatColor_lightSalmon", _wrap_FloatColor_lightSalmon_get, SWIG_Lua_set_immutable },
    { "FloatColor_lightSeaGreen", _wrap_FloatColor_lightSeaGreen_get, SWIG_Lua_set_immutable },
    { "FloatColor_lightSkyBlue", _wrap_FloatColor_lightSkyBlue_get, SWIG_Lua_set_immutable },
    { "FloatColor_lightSlateGray", _wrap_FloatColor_lightSlateGray_get, SWIG_Lua_set_immutable },
    { "FloatColor_lightSlateGrey", _wrap_FloatColor_lightSlateGrey_get, SWIG_Lua_set_immutable },
    { "FloatColor_lightSteelBlue", _wrap_FloatColor_lightSteelBlue_get, SWIG_Lua_set_immutable },
    { "FloatColor_lightYellow", _wrap_FloatColor_lightYellow_get, SWIG_Lua_set_immutable },
    { "FloatColor_lime", _wrap_FloatColor_lime_get, SWIG_Lua_set_immutable },
    { "FloatColor_limeGreen", _wrap_FloatColor_limeGreen_get, SWIG_Lua_set_immutable },
    { "FloatColor_linen", _wrap_FloatColor_linen_get, SWIG_Lua_set_immutable },
    { "FloatColor_maroon", _wrap_FloatColor_maroon_get, SWIG_Lua_set_immutable },
    { "FloatColor_mediumAquaMarine", _wrap_FloatColor_mediumAquaMarine_get, SWIG_Lua_set_immutable },
    { "FloatColor_mediumBlue", _wrap_FloatColor_mediumBlue_get, SWIG_Lua_set_immutable },
    { "FloatColor_mediumOrchid", _wrap_FloatColor_mediumOrchid_get, SWIG_Lua_set_immutable },
    { "FloatColor_mediumPurple", _wrap_FloatColor_mediumPurple_get, SWIG_Lua_set_immutable },
    { "FloatColor_mediumSeaGreen", _wrap_FloatColor_mediumSeaGreen_get, SWIG_Lua_set_immutable },
    { "FloatColor_mediumSlateBlue", _wrap_FloatColor_mediumSlateBlue_get, SWIG_Lua_set_immutable },
    { "FloatColor_mediumSpringGreen", _wrap_FloatColor_mediumSpringGreen_get, SWIG_Lua_set_immutable },
    { "FloatColor_mediumTurquoise", _wrap_FloatColor_mediumTurquoise_get, SWIG_Lua_set_immutable },
    { "FloatColor_mediumVioletRed", _wrap_FloatColor_mediumVioletRed_get, SWIG_Lua_set_immutable },
    { "FloatColor_midnightBlue", _wrap_FloatColor_midnightBlue_get, SWIG_Lua_set_immutable },
    { "FloatColor_mintCream", _wrap_FloatColor_mintCream_get, SWIG_Lua_set_immutable },
    { "FloatColor_mistyRose", _wrap_FloatColor_mistyRose_get, SWIG_Lua_set_immutable },
    { "FloatColor_moccasin", _wrap_FloatColor_moccasin_get, SWIG_Lua_set_immutable },
    { "FloatColor_navajoWhite", _wrap_FloatColor_navajoWhite_get, SWIG_Lua_set_immutable },
    { "FloatColor_navy", _wrap_FloatColor_navy_get, SWIG_Lua_set_immutable },
    { "FloatColor_oldLace", _wrap_FloatColor_oldLace_get, SWIG_Lua_set_immutable },
    { "FloatColor_olive", _wrap_FloatColor_olive_get, SWIG_Lua_set_immutable },
    { "FloatColor_oliveDrab", _wrap_FloatColor_oliveDrab_get, SWIG_Lua_set_immutable },
    { "FloatColor_orange", _wrap_FloatColor_orange_get, SWIG_Lua_set_immutable },
    { "FloatColor_orangeRed", _wrap_FloatColor_orangeRed_get, SWIG_Lua_set_immutable },
    { "FloatColor_orchid", _wrap_FloatColor_orchid_get, SWIG_Lua_set_immutable },
    { "FloatColor_paleGoldenRod", _wrap_FloatColor_paleGoldenRod_get, SWIG_Lua_set_immutable },
    { "FloatColor_paleGreen", _wrap_FloatColor_paleGreen_get, SWIG_Lua_set_immutable },
    { "FloatColor_paleTurquoise", _wrap_FloatColor_paleTurquoise_get, SWIG_Lua_set_immutable },
    { "FloatColor_paleVioletRed", _wrap_FloatColor_paleVioletRed_get, SWIG_Lua_set_immutable },
    { "FloatColor_papayaWhip", _wrap_FloatColor_papayaWhip_get, SWIG_Lua_set_immutable },
    { "FloatColor_peachPuff", _wrap_FloatColor_peachPuff_get, SWIG_Lua_set_immutable },
    { "FloatColor_peru", _wrap_FloatColor_peru_get, SWIG_Lua_set_immutable },
    { "FloatColor_pink", _wrap_FloatColor_pink_get, SWIG_Lua_set_immutable },
    { "FloatColor_plum", _wrap_FloatColor_plum_get, SWIG_Lua_set_immutable },
    { "FloatColor_powderBlue", _wrap_FloatColor_powderBlue_get, SWIG_Lua_set_immutable },
    { "FloatColor_purple", _wrap_FloatColor_purple_get, SWIG_Lua_set_immutable },
    { "FloatColor_rosyBrown", _wrap_FloatColor_rosyBrown_get, SWIG_Lua_set_immutable },
    { "FloatColor_royalBlue", _wrap_FloatColor_royalBlue_get, SWIG_Lua_set_immutable },
    { "FloatColor_saddleBrown", _wrap_FloatColor_saddleBrown_get, SWIG_Lua_set_immutable },
    { "FloatColor_salmon", _wrap_FloatColor_salmon_get, SWIG_Lua_set_immutable },
    { "FloatColor_sandyBrown", _wrap_FloatColor_sandyBrown_get, SWIG_Lua_set_immutable },
    { "FloatColor_seaGreen", _wrap_FloatColor_seaGreen_get, SWIG_Lua_set_immutable },
    { "FloatColor_seaShell", _wrap_FloatColor_seaShell_get, SWIG_Lua_set_immutable },
    { "FloatColor_sienna", _wrap_FloatColor_sienna_get, SWIG_Lua_set_immutable },
    { "FloatColor_silver", _wrap_FloatColor_silver_get, SWIG_Lua_set_immutable },
    { "FloatColor_skyBlue", _wrap_FloatColor_skyBlue_get, SWIG_Lua_set_immutable },
    { "FloatColor_slateBlue", _wrap_FloatColor_slateBlue_get, SWIG_Lua_set_immutable },
    { "FloatColor_slateGray", _wrap_FloatColor_slateGray_get, SWIG_Lua_set_immutable },
    { "FloatColor_slateGrey", _wrap_FloatColor_slateGrey_get, SWIG_Lua_set_immutable },
    { "FloatColor_snow", _wrap_FloatColor_snow_get, SWIG_Lua_set_immutable },
    { "FloatColor_springGreen", _wrap_FloatColor_springGreen_get, SWIG_Lua_set_immutable },
    { "FloatColor_steelBlue", _wrap_FloatColor_steelBlue_get, SWIG_Lua_set_immutable },
    { "FloatColor_blueSteel", _wrap_FloatColor_blueSteel_get, SWIG_Lua_set_immutable },
    { "FloatColor_tan", _wrap_FloatColor_tan_get, SWIG_Lua_set_immutable },
    { "FloatColor_teal", _wrap_FloatColor_teal_get, SWIG_Lua_set_immutable },
    { "FloatColor_thistle", _wrap_FloatColor_thistle_get, SWIG_Lua_set_immutable },
    { "FloatColor_tomato", _wrap_FloatColor_tomato_get, SWIG_Lua_set_immutable },
    { "FloatColor_turquoise", _wrap_FloatColor_turquoise_get, SWIG_Lua_set_immutable },
    { "FloatColor_violet", _wrap_FloatColor_violet_get, SWIG_Lua_set_immutable },
    { "FloatColor_wheat", _wrap_FloatColor_wheat_get, SWIG_Lua_set_immutable },
    { "FloatColor_whiteSmoke", _wrap_FloatColor_whiteSmoke_get, SWIG_Lua_set_immutable },
    { "FloatColor_yellowGreen", _wrap_FloatColor_yellowGreen_get, SWIG_Lua_set_immutable },
    { "ShortColor_white", _wrap_ShortColor_white_get, SWIG_Lua_set_immutable },
    { "ShortColor_gray", _wrap_ShortColor_gray_get, SWIG_Lua_set_immutable },
    { "ShortColor_black", _wrap_ShortColor_black_get, SWIG_Lua_set_immutable },
    { "ShortColor_red", _wrap_ShortColor_red_get, SWIG_Lua_set_immutable },
    { "ShortColor_green", _wrap_ShortColor_green_get, SWIG_Lua_set_immutable },
    { "ShortColor_blue", _wrap_ShortColor_blue_get, SWIG_Lua_set_immutable },
    { "ShortColor_cyan", _wrap_ShortColor_cyan_get, SWIG_Lua_set_immutable },
    { "ShortColor_magenta", _wrap_ShortColor_magenta_get, SWIG_Lua_set_immutable },
    { "ShortColor_yellow", _wrap_ShortColor_yellow_get, SWIG_Lua_set_immutable },
    { "ShortColor_aliceBlue", _wrap_ShortColor_aliceBlue_get, SWIG_Lua_set_immutable },
    { "ShortColor_antiqueWhite", _wrap_ShortColor_antiqueWhite_get, SWIG_Lua_set_immutable },
    { "ShortColor_aqua", _wrap_ShortColor_aqua_get, SWIG_Lua_set_immutable },
    { "ShortColor_aquamarine", _wrap_ShortColor_aquamarine_get, SWIG_Lua_set_immutable },
    { "ShortColor_azure", _wrap_ShortColor_azure_get, SWIG_Lua_set_immutable },
    { "ShortColor_beige", _wrap_ShortColor_beige_get, SWIG_Lua_set_immutable },
    { "ShortColor_bisque", _wrap_ShortColor_bisque_get, SWIG_Lua_set_immutable },
    { "ShortColor_blanchedAlmond", _wrap_ShortColor_blanchedAlmond_get, SWIG_Lua_set_immutable },
    { "ShortColor_blueViolet", _wrap_ShortColor_blueViolet_get, SWIG_Lua_set_immutable },
    { "ShortColor_brown", _wrap_ShortColor_brown_get, SWIG_Lua_set_immutable },
    { "ShortColor_burlyWood", _wrap_ShortColor_burlyWood_get, SWIG_Lua_set_immutable },
    { "ShortColor_cadetBlue", _wrap_ShortColor_cadetBlue_get, SWIG_Lua_set_immutable },
    { "ShortColor_chartreuse", _wrap_ShortColor_chartreuse_get, SWIG_Lua_set_immutable },
    { "ShortColor_chocolate", _wrap_ShortColor_chocolate_get, SWIG_Lua_set_immutable },
    { "ShortColor_coral", _wrap_ShortColor_coral_get, SWIG_Lua_set_immutable },
    { "ShortColor_cornflowerBlue", _wrap_ShortColor_cornflowerBlue_get, SWIG_Lua_set_immutable },
    { "ShortColor_cornsilk", _wrap_ShortColor_cornsilk_get, SWIG_Lua_set_immutable },
    { "ShortColor_crimson", _wrap_ShortColor_crimson_get, SWIG_Lua_set_immutable },
    { "ShortColor_darkBlue", _wrap_ShortColor_darkBlue_get, SWIG_Lua_set_immutable },
    { "ShortColor_darkCyan", _wrap_ShortColor_darkCyan_get, SWIG_Lua_set_immutable },
    { "ShortColor_darkGoldenRod", _wrap_ShortColor_darkGoldenRod_get, SWIG_Lua_set_immutable },
    { "ShortColor_darkGray", _wrap_ShortColor_darkGray_get, SWIG_Lua_set_immutable },
    { "ShortColor_darkGrey", _wrap_ShortColor_darkGrey_get, SWIG_Lua_set_immutable },
    { "ShortColor_darkGreen", _wrap_ShortColor_darkGreen_get, SWIG_Lua_set_immutable },
    { "ShortColor_darkKhaki", _wrap_ShortColor_darkKhaki_get, SWIG_Lua_set_immutable },
    { "ShortColor_darkMagenta", _wrap_ShortColor_darkMagenta_get, SWIG_Lua_set_immutable },
    { "ShortColor_darkOliveGreen", _wrap_ShortColor_darkOliveGreen_get, SWIG_Lua_set_immutable },
    { "ShortColor_darkorange", _wrap_ShortColor_darkorange_get, SWIG_Lua_set_immutable },
    { "ShortColor_darkOrchid", _wrap_ShortColor_darkOrchid_get, SWIG_Lua_set_immutable },
    { "ShortColor_darkRed", _wrap_ShortColor_darkRed_get, SWIG_Lua_set_immutable },
    { "ShortColor_darkSalmon", _wrap_ShortColor_darkSalmon_get, SWIG_Lua_set_immutable },
    { "ShortColor_darkSeaGreen", _wrap_ShortColor_darkSeaGreen_get, SWIG_Lua_set_immutable },
    { "ShortColor_darkSlateBlue", _wrap_ShortColor_darkSlateBlue_get, SWIG_Lua_set_immutable },
    { "ShortColor_darkSlateGray", _wrap_ShortColor_darkSlateGray_get, SWIG_Lua_set_immutable },
    { "ShortColor_darkSlateGrey", _wrap_ShortColor_darkSlateGrey_get, SWIG_Lua_set_immutable },
    { "ShortColor_darkTurquoise", _wrap_ShortColor_darkTurquoise_get, SWIG_Lua_set_immutable },
    { "ShortColor_darkViolet", _wrap_ShortColor_darkViolet_get, SWIG_Lua_set_immutable },
    { "ShortColor_deepPink", _wrap_ShortColor_deepPink_get, SWIG_Lua_set_immutable },
    { "ShortColor_deepSkyBlue", _wrap_ShortColor_deepSkyBlue_get, SWIG_Lua_set_immutable },
    { "ShortColor_dimGray", _wrap_ShortColor_dimGray_get, SWIG_Lua_set_immutable },
    { "ShortColor_dimGrey", _wrap_ShortColor_dimGrey_get, SWIG_Lua_set_immutable },
    { "ShortColor_dodgerBlue", _wrap_ShortColor_dodgerBlue_get, SWIG_Lua_set_immutable },
    { "ShortColor_fireBrick", _wrap_ShortColor_fireBrick_get, SWIG_Lua_set_immutable },
    { "ShortColor_floralWhite", _wrap_ShortColor_floralWhite_get, SWIG_Lua_set_immutable },
    { "ShortColor_forestGreen", _wrap_ShortColor_forestGreen_get, SWIG_Lua_set_immutable },
    { "ShortColor_fuchsia", _wrap_ShortColor_fuchsia_get, SWIG_Lua_set_immutable },
    { "ShortColor_gainsboro", _wrap_ShortColor_gainsboro_get, SWIG_Lua_set_immutable },
    { "ShortColor_ghostWhite", _wrap_ShortColor_ghostWhite_get, SWIG_Lua_set_immutable },
    { "ShortColor_gold", _wrap_ShortColor_gold_get, SWIG_Lua_set_immutable },
    { "ShortColor_goldenRod", _wrap_ShortColor_goldenRod_get, SWIG_Lua_set_immutable },
    { "ShortColor_grey", _wrap_ShortColor_grey_get, SWIG_Lua_set_immutable },
    { "ShortColor_greenYellow", _wrap_ShortColor_greenYellow_get, SWIG_Lua_set_immutable },
    { "ShortColor_honeyDew", _wrap_ShortColor_honeyDew_get, SWIG_Lua_set_immutable },
    { "ShortColor_hotPink", _wrap_ShortColor_hotPink_get, SWIG_Lua_set_immutable },
    { "ShortColor_indianRed", _wrap_ShortColor_indianRed_get, SWIG_Lua_set_immutable },
    { "ShortColor_indigo", _wrap_ShortColor_indigo_get, SWIG_Lua_set_immutable },
    { "ShortColor_ivory", _wrap_ShortColor_ivory_get, SWIG_Lua_set_immutable },
    { "ShortColor_khaki", _wrap_ShortColor_khaki_get, SWIG_Lua_set_immutable },
    { "ShortColor_lavender", _wrap_ShortColor_lavender_get, SWIG_Lua_set_immutable },
    { "ShortColor_lavenderBlush", _wrap_ShortColor_lavenderBlush_get, SWIG_Lua_set_immutable },
    { "ShortColor_lawnGreen", _wrap_ShortColor_lawnGreen_get, SWIG_Lua_set_immutable },
    { "ShortColor_lemonChiffon", _wrap_ShortColor_lemonChiffon_get, SWIG_Lua_set_immutable },
    { "ShortColor_lightBlue", _wrap_ShortColor_lightBlue_get, SWIG_Lua_set_immutable },
    { "ShortColor_lightCoral", _wrap_ShortColor_lightCoral_get, SWIG_Lua_set_immutable },
    { "ShortColor_lightCyan", _wrap_ShortColor_lightCyan_get, SWIG_Lua_set_immutable },
    { "ShortColor_lightGoldenRodYellow", _wrap_ShortColor_lightGoldenRodYellow_get, SWIG_Lua_set_immutable },
    { "ShortColor_lightGray", _wrap_ShortColor_lightGray_get, SWIG_Lua_set_immutable },
    { "ShortColor_lightGrey", _wrap_ShortColor_lightGrey_get, SWIG_Lua_set_immutable },
    { "ShortColor_lightGreen", _wrap_ShortColor_lightGreen_get, SWIG_Lua_set_immutable },
    { "ShortColor_lightPink", _wrap_ShortColor_lightPink_get, SWIG_Lua_set_immutable },
    { "ShortColor_lightSalmon", _wrap_ShortColor_lightSalmon_get, SWIG_Lua_set_immutable },
    { "ShortColor_lightSeaGreen", _wrap_ShortColor_lightSeaGreen_get, SWIG_Lua_set_immutable },
    { "ShortColor_lightSkyBlue", _wrap_ShortColor_lightSkyBlue_get, SWIG_Lua_set_immutable },
    { "ShortColor_lightSlateGray", _wrap_ShortColor_lightSlateGray_get, SWIG_Lua_set_immutable },
    { "ShortColor_lightSlateGrey", _wrap_ShortColor_lightSlateGrey_get, SWIG_Lua_set_immutable },
    { "ShortColor_lightSteelBlue", _wrap_ShortColor_lightSteelBlue_get, SWIG_Lua_set_immutable },
    { "ShortColor_lightYellow", _wrap_ShortColor_lightYellow_get, SWIG_Lua_set_immutable },
    { "ShortColor_lime", _wrap_ShortColor_lime_get, SWIG_Lua_set_immutable },
    { "ShortColor_limeGreen", _wrap_ShortColor_limeGreen_get, SWIG_Lua_set_immutable },
    { "ShortColor_linen", _wrap_ShortColor_linen_get, SWIG_Lua_set_immutable },
    { "ShortColor_maroon", _wrap_ShortColor_maroon_get, SWIG_Lua_set_immutable },
    { "ShortColor_mediumAquaMarine", _wrap_ShortColor_mediumAquaMarine_get, SWIG_Lua_set_immutable },
    { "ShortColor_mediumBlue", _wrap_ShortColor_mediumBlue_get, SWIG_Lua_set_immutable },
    { "ShortColor_mediumOrchid", _wrap_ShortColor_mediumOrchid_get, SWIG_Lua_set_immutable },
    { "ShortColor_mediumPurple", _wrap_ShortColor_mediumPurple_get, SWIG_Lua_set_immutable },
    { "ShortColor_mediumSeaGreen", _wrap_ShortColor_mediumSeaGreen_get, SWIG_Lua_set_immutable },
    { "ShortColor_mediumSlateBlue", _wrap_ShortColor_mediumSlateBlue_get, SWIG_Lua_set_immutable },
    { "ShortColor_mediumSpringGreen", _wrap_ShortColor_mediumSpringGreen_get, SWIG_Lua_set_immutable },
    { "ShortColor_mediumTurquoise", _wrap_ShortColor_mediumTurquoise_get, SWIG_Lua_set_immutable },
    { "ShortColor_mediumVioletRed", _wrap_ShortColor_mediumVioletRed_get, SWIG_Lua_set_immutable },
    { "ShortColor_midnightBlue", _wrap_ShortColor_midnightBlue_get, SWIG_Lua_set_immutable },
    { "ShortColor_mintCream", _wrap_ShortColor_mintCream_get, SWIG_Lua_set_immutable },
    { "ShortColor_mistyRose", _wrap_ShortColor_mistyRose_get, SWIG_Lua_set_immutable },
    { "ShortColor_moccasin", _wrap_ShortColor_moccasin_get, SWIG_Lua_set_immutable },
    { "ShortColor_navajoWhite", _wrap_ShortColor_navajoWhite_get, SWIG_Lua_set_immutable },
    { "ShortColor_navy", _wrap_ShortColor_navy_get, SWIG_Lua_set_immutable },
    { "ShortColor_oldLace", _wrap_ShortColor_oldLace_get, SWIG_Lua_set_immutable },
    { "ShortColor_olive", _wrap_ShortColor_olive_get, SWIG_Lua_set_immutable },
    { "ShortColor_oliveDrab", _wrap_ShortColor_oliveDrab_get, SWIG_Lua_set_immutable },
    { "ShortColor_orange", _wrap_ShortColor_orange_get, SWIG_Lua_set_immutable },
    { "ShortColor_orangeRed", _wrap_ShortColor_orangeRed_get, SWIG_Lua_set_immutable },
    { "ShortColor_orchid", _wrap_ShortColor_orchid_get, SWIG_Lua_set_immutable },
    { "ShortColor_paleGoldenRod", _wrap_ShortColor_paleGoldenRod_get, SWIG_Lua_set_immutable },
    { "ShortColor_paleGreen", _wrap_ShortColor_paleGreen_get, SWIG_Lua_set_immutable },
    { "ShortColor_paleTurquoise", _wrap_ShortColor_paleTurquoise_get, SWIG_Lua_set_immutable },
    { "ShortColor_paleVioletRed", _wrap_ShortColor_paleVioletRed_get, SWIG_Lua_set_immutable },
    { "ShortColor_papayaWhip", _wrap_ShortColor_papayaWhip_get, SWIG_Lua_set_immutable },
    { "ShortColor_peachPuff", _wrap_ShortColor_peachPuff_get, SWIG_Lua_set_immutable },
    { "ShortColor_peru", _wrap_ShortColor_peru_get, SWIG_Lua_set_immutable },
    { "ShortColor_pink", _wrap_ShortColor_pink_get, SWIG_Lua_set_immutable },
    { "ShortColor_plum", _wrap_ShortColor_plum_get, SWIG_Lua_set_immutable },
    { "ShortColor_powderBlue", _wrap_ShortColor_powderBlue_get, SWIG_Lua_set_immutable },
    { "ShortColor_purple", _wrap_ShortColor_purple_get, SWIG_Lua_set_immutable },
    { "ShortColor_rosyBrown", _wrap_ShortColor_rosyBrown_get, SWIG_Lua_set_immutable },
    { "ShortColor_royalBlue", _wrap_ShortColor_royalBlue_get, SWIG_Lua_set_immutable },
    { "ShortColor_saddleBrown", _wrap_ShortColor_saddleBrown_get, SWIG_Lua_set_immutable },
    { "ShortColor_salmon", _wrap_ShortColor_salmon_get, SWIG_Lua_set_immutable },
    { "ShortColor_sandyBrown", _wrap_ShortColor_sandyBrown_get, SWIG_Lua_set_immutable },
    { "ShortColor_seaGreen", _wrap_ShortColor_seaGreen_get, SWIG_Lua_set_immutable },
    { "ShortColor_seaShell", _wrap_ShortColor_seaShell_get, SWIG_Lua_set_immutable },
    { "ShortColor_sienna", _wrap_ShortColor_sienna_get, SWIG_Lua_set_immutable },
    { "ShortColor_silver", _wrap_ShortColor_silver_get, SWIG_Lua_set_immutable },
    { "ShortColor_skyBlue", _wrap_ShortColor_skyBlue_get, SWIG_Lua_set_immutable },
    { "ShortColor_slateBlue", _wrap_ShortColor_slateBlue_get, SWIG_Lua_set_immutable },
    { "ShortColor_slateGray", _wrap_ShortColor_slateGray_get, SWIG_Lua_set_immutable },
    { "ShortColor_slateGrey", _wrap_ShortColor_slateGrey_get, SWIG_Lua_set_immutable },
    { "ShortColor_snow", _wrap_ShortColor_snow_get, SWIG_Lua_set_immutable },
    { "ShortColor_springGreen", _wrap_ShortColor_springGreen_get, SWIG_Lua_set_immutable },
    { "ShortColor_steelBlue", _wrap_ShortColor_steelBlue_get, SWIG_Lua_set_immutable },
    { "ShortColor_blueSteel", _wrap_ShortColor_blueSteel_get, SWIG_Lua_set_immutable },
    { "ShortColor_tan", _wrap_ShortColor_tan_get, SWIG_Lua_set_immutable },
    { "ShortColor_teal", _wrap_ShortColor_teal_get, SWIG_Lua_set_immutable },
    { "ShortColor_thistle", _wrap_ShortColor_thistle_get, SWIG_Lua_set_immutable },
    { "ShortColor_tomato", _wrap_ShortColor_tomato_get, SWIG_Lua_set_immutable },
    { "ShortColor_turquoise", _wrap_ShortColor_turquoise_get, SWIG_Lua_set_immutable },
    { "ShortColor_violet", _wrap_ShortColor_violet_get, SWIG_Lua_set_immutable },
    { "ShortColor_wheat", _wrap_ShortColor_wheat_get, SWIG_Lua_set_immutable },
    { "ShortColor_whiteSmoke", _wrap_ShortColor_whiteSmoke_get, SWIG_Lua_set_immutable },
    { "ShortColor_yellowGreen", _wrap_ShortColor_yellowGreen_get, SWIG_Lua_set_immutable },
    {0,0,0}
};
static swig_lua_const_info swig_SwigModule_constants[]= {
    {SWIG_LUA_CONSTTAB_INT("VERSION_MAJOR", 0)},
    {SWIG_LUA_CONSTTAB_INT("VERSION_MINOR", 10)},
    {SWIG_LUA_CONSTTAB_INT("VERSION_PATCH", 0)},
    {SWIG_LUA_CONSTTAB_STRING("VERSION_PRE_RELEASE", "stable")},
    {SWIG_LUA_CONSTTAB_INT("USE_LEGACY_VECTOR_MATH", 0)},
    {SWIG_LUA_CONSTTAB_INT("USING_STD_FS", 0)},
    {SWIG_LUA_CONSTTAB_INT("TARGET_OSX", OF_TARGET_OSX)},
    {SWIG_LUA_CONSTTAB_INT("TARGET_MINGW", OF_TARGET_MINGW)},
    {SWIG_LUA_CONSTTAB_INT("TARGET_WINVS", OF_TARGET_WINVS)},
    {SWIG_LUA_CONSTTAB_INT("TARGET_IOS", OF_TARGET_IOS)},
    {SWIG_LUA_CONSTTAB_INT("TARGET_ANDROID", OF_TARGET_ANDROID)},
    {SWIG_LUA_CONSTTAB_INT("TARGET_LINUX", OF_TARGET_LINUX)},
    {SWIG_LUA_CONSTTAB_INT("TARGET_LINUX64", OF_TARGET_LINUX64)},
    {SWIG_LUA_CONSTTAB_INT("TARGET_LINUXARMV6L", OF_TARGET_LINUXARMV6L)},
    {SWIG_LUA_CONSTTAB_INT("TARGET_LINUXARMV7L", OF_TARGET_LINUXARMV7L)},
    {SWIG_LUA_CONSTTAB_INT("TARGET_EMSCRIPTEN", OF_TARGET_EMSCRIPTEN)},
    {SWIG_LUA_CONSTTAB_INT("B14400", 14400)},
    {SWIG_LUA_CONSTTAB_INT("B28800", 28800)},
    {SWIG_LUA_CONSTTAB_INT("HAS_TLS", 1)},
    {SWIG_LUA_CONSTTAB_FLOAT("PI", 3.14159265358979323846)},
    {SWIG_LUA_CONSTTAB_FLOAT("TWO_PI", 6.28318530717958647693)},
    {SWIG_LUA_CONSTTAB_FLOAT("M_TWO_PI", 6.28318530717958647693)},
    {SWIG_LUA_CONSTTAB_FLOAT("FOUR_PI", 12.56637061435917295385)},
    {SWIG_LUA_CONSTTAB_FLOAT("HALF_PI", 1.57079632679489661923)},
    {SWIG_LUA_CONSTTAB_FLOAT("DEG_TO_RAD", (3.14159265358979323846/180.0))},
    {SWIG_LUA_CONSTTAB_FLOAT("RAD_TO_DEG", (180.0/3.14159265358979323846))},
    {SWIG_LUA_CONSTTAB_INT("FBOMODE_NODEFAULTS", OF_FBOMODE_NODEFAULTS)},
    {SWIG_LUA_CONSTTAB_INT("FBOMODE_PERSPECTIVE", OF_FBOMODE_PERSPECTIVE)},
    {SWIG_LUA_CONSTTAB_INT("FBOMODE_MATRIXFLIP", OF_FBOMODE_MATRIXFLIP)},
    {SWIG_LUA_CONSTTAB_INT("COMPRESS_NONE", OF_COMPRESS_NONE)},
    {SWIG_LUA_CONSTTAB_INT("COMPRESS_SRGB", OF_COMPRESS_SRGB)},
    {SWIG_LUA_CONSTTAB_INT("COMPRESS_ARB", OF_COMPRESS_ARB)},
    {SWIG_LUA_CONSTTAB_INT("IMAGE_QUALITY_BEST", OF_IMAGE_QUALITY_BEST)},
    {SWIG_LUA_CONSTTAB_INT("IMAGE_QUALITY_HIGH", OF_IMAGE_QUALITY_HIGH)},
    {SWIG_LUA_CONSTTAB_INT("IMAGE_QUALITY_MEDIUM", OF_IMAGE_QUALITY_MEDIUM)},
    {SWIG_LUA_CONSTTAB_INT("IMAGE_QUALITY_LOW", OF_IMAGE_QUALITY_LOW)},
    {SWIG_LUA_CONSTTAB_INT("IMAGE_QUALITY_WORST", OF_IMAGE_QUALITY_WORST)},
    {SWIG_LUA_CONSTTAB_INT("IMAGE_FORMAT_BMP", OF_IMAGE_FORMAT_BMP)},
    {SWIG_LUA_CONSTTAB_INT("IMAGE_FORMAT_ICO", OF_IMAGE_FORMAT_ICO)},
    {SWIG_LUA_CONSTTAB_INT("IMAGE_FORMAT_JPEG", OF_IMAGE_FORMAT_JPEG)},
    {SWIG_LUA_CONSTTAB_INT("IMAGE_FORMAT_JNG", OF_IMAGE_FORMAT_JNG)},
    {SWIG_LUA_CONSTTAB_INT("IMAGE_FORMAT_KOALA", OF_IMAGE_FORMAT_KOALA)},
    {SWIG_LUA_CONSTTAB_INT("IMAGE_FORMAT_LBM", OF_IMAGE_FORMAT_LBM)},
    {SWIG_LUA_CONSTTAB_INT("IMAGE_FORMAT_IFF", OF_IMAGE_FORMAT_IFF)},
    {SWIG_LUA_CONSTTAB_INT("IMAGE_FORMAT_MNG", OF_IMAGE_FORMAT_MNG)},
    {SWIG_LUA_CONSTTAB_INT("IMAGE_FORMAT_PBM", OF_IMAGE_FORMAT_PBM)},
    {SWIG_LUA_CONSTTAB_INT("IMAGE_FORMAT_PBMRAW", OF_IMAGE_FORMAT_PBMRAW)},
    {SWIG_LUA_CONSTTAB_INT("IMAGE_FORMAT_PCD", OF_IMAGE_FORMAT_PCD)},
    {SWIG_LUA_CONSTTAB_INT("IMAGE_FORMAT_PCX", OF_IMAGE_FORMAT_PCX)},
    {SWIG_LUA_CONSTTAB_INT("IMAGE_FORMAT_PGM", OF_IMAGE_FORMAT_PGM)},
    {SWIG_LUA_CONSTTAB_INT("IMAGE_FORMAT_PGMRAW", OF_IMAGE_FORMAT_PGMRAW)},
    {SWIG_LUA_CONSTTAB_INT("IMAGE_FORMAT_PNG", OF_IMAGE_FORMAT_PNG)},
    {SWIG_LUA_CONSTTAB_INT("IMAGE_FORMAT_PPM", OF_IMAGE_FORMAT_PPM)},
    {SWIG_LUA_CONSTTAB_INT("IMAGE_FORMAT_PPMRAW", OF_IMAGE_FORMAT_PPMRAW)},
    {SWIG_LUA_CONSTTAB_INT("IMAGE_FORMAT_RAS", OF_IMAGE_FORMAT_RAS)},
    {SWIG_LUA_CONSTTAB_INT("IMAGE_FORMAT_TARGA", OF_IMAGE_FORMAT_TARGA)},
    {SWIG_LUA_CONSTTAB_INT("IMAGE_FORMAT_TIFF", OF_IMAGE_FORMAT_TIFF)},
    {SWIG_LUA_CONSTTAB_INT("IMAGE_FORMAT_WBMP", OF_IMAGE_FORMAT_WBMP)},
    {SWIG_LUA_CONSTTAB_INT("IMAGE_FORMAT_PSD", OF_IMAGE_FORMAT_PSD)},
    {SWIG_LUA_CONSTTAB_INT("IMAGE_FORMAT_CUT", OF_IMAGE_FORMAT_CUT)},
    {SWIG_LUA_CONSTTAB_INT("IMAGE_FORMAT_XBM", OF_IMAGE_FORMAT_XBM)},
    {SWIG_LUA_CONSTTAB_INT("IMAGE_FORMAT_XPM", OF_IMAGE_FORMAT_XPM)},
    {SWIG_LUA_CONSTTAB_INT("IMAGE_FORMAT_DDS", OF_IMAGE_FORMAT_DDS)},
    {SWIG_LUA_CONSTTAB_INT("IMAGE_FORMAT_GIF", OF_IMAGE_FORMAT_GIF)},
    {SWIG_LUA_CONSTTAB_INT("IMAGE_FORMAT_HDR", OF_IMAGE_FORMAT_HDR)},
    {SWIG_LUA_CONSTTAB_INT("IMAGE_FORMAT_FAXG3", OF_IMAGE_FORMAT_FAXG3)},
    {SWIG_LUA_CONSTTAB_INT("IMAGE_FORMAT_SGI", OF_IMAGE_FORMAT_SGI)},
    {SWIG_LUA_CONSTTAB_INT("IMAGE_FORMAT_EXR", OF_IMAGE_FORMAT_EXR)},
    {SWIG_LUA_CONSTTAB_INT("IMAGE_FORMAT_J2K", OF_IMAGE_FORMAT_J2K)},
    {SWIG_LUA_CONSTTAB_INT("IMAGE_FORMAT_JP2", OF_IMAGE_FORMAT_JP2)},
    {SWIG_LUA_CONSTTAB_INT("IMAGE_FORMAT_PFM", OF_IMAGE_FORMAT_PFM)},
    {SWIG_LUA_CONSTTAB_INT("IMAGE_FORMAT_PICT", OF_IMAGE_FORMAT_PICT)},
    {SWIG_LUA_CONSTTAB_INT("IMAGE_FORMAT_RAW", OF_IMAGE_FORMAT_RAW)},
    {SWIG_LUA_CONSTTAB_INT("SoundDevice_UNSPECIFIED", ofSoundDevice::UNSPECIFIED)},
    {SWIG_LUA_CONSTTAB_INT("SoundDevice_DEFAULT", ofSoundDevice::DEFAULT)},
    {SWIG_LUA_CONSTTAB_INT("SoundDevice_ALSA", ofSoundDevice::ALSA)},
    {SWIG_LUA_CONSTTAB_INT("SoundDevice_PULSE", ofSoundDevice::PULSE)},
    {SWIG_LUA_CONSTTAB_INT("SoundDevice_OSS", ofSoundDevice::OSS)},
    {SWIG_LUA_CONSTTAB_INT("SoundDevice_JACK", ofSoundDevice::JACK)},
    {SWIG_LUA_CONSTTAB_INT("SoundDevice_OSX_CORE", ofSoundDevice::OSX_CORE)},
    {SWIG_LUA_CONSTTAB_INT("SoundDevice_MS_WASAPI", ofSoundDevice::MS_WASAPI)},
    {SWIG_LUA_CONSTTAB_INT("SoundDevice_MS_ASIO", ofSoundDevice::MS_ASIO)},
    {SWIG_LUA_CONSTTAB_INT("SoundDevice_MS_DS", ofSoundDevice::MS_DS)},
    {SWIG_LUA_CONSTTAB_INT("SoundDevice_NUM_APIS", ofSoundDevice::NUM_APIS)},
    {SWIG_LUA_CONSTTAB_INT("LOOP_NONE", OF_LOOP_NONE)},
    {SWIG_LUA_CONSTTAB_INT("LOOP_PALINDROME", OF_LOOP_PALINDROME)},
    {SWIG_LUA_CONSTTAB_INT("LOOP_NORMAL", OF_LOOP_NORMAL)},
    {SWIG_LUA_CONSTTAB_INT("EasyCam_TRANSFORM_NONE", ofEasyCam::TRANSFORM_NONE)},
    {SWIG_LUA_CONSTTAB_INT("EasyCam_TRANSFORM_ROTATE", ofEasyCam::TRANSFORM_ROTATE)},
    {SWIG_LUA_CONSTTAB_INT("EasyCam_TRANSFORM_TRANSLATE_XY", ofEasyCam::TRANSFORM_TRANSLATE_XY)},
    {SWIG_LUA_CONSTTAB_INT("EasyCam_TRANSFORM_TRANSLATE_Z", ofEasyCam::TRANSFORM_TRANSLATE_Z)},
    {SWIG_LUA_CONSTTAB_INT("EasyCam_TRANSFORM_SCALE", ofEasyCam::TRANSFORM_SCALE)},
    {SWIG_LUA_CONSTTAB_INT("BoxPrimitive_SIDE_FRONT", ofBoxPrimitive::SIDE_FRONT)},
    {SWIG_LUA_CONSTTAB_INT("BoxPrimitive_SIDE_RIGHT", ofBoxPrimitive::SIDE_RIGHT)},
    {SWIG_LUA_CONSTTAB_INT("BoxPrimitive_SIDE_LEFT", ofBoxPrimitive::SIDE_LEFT)},
    {SWIG_LUA_CONSTTAB_INT("BoxPrimitive_SIDE_BACK", ofBoxPrimitive::SIDE_BACK)},
    {SWIG_LUA_CONSTTAB_INT("BoxPrimitive_SIDE_TOP", ofBoxPrimitive::SIDE_TOP)},
    {SWIG_LUA_CONSTTAB_INT("BoxPrimitive_SIDE_BOTTOM", ofBoxPrimitive::SIDE_BOTTOM)},
    {SWIG_LUA_CONSTTAB_INT("BoxPrimitive_SIDES_TOTAL", ofBoxPrimitive::SIDES_TOTAL)},
    {SWIG_LUA_CONSTTAB_INT("FIRMATA_MAJOR_VERSION", 2)},
    {SWIG_LUA_CONSTTAB_INT("FIRMATA_MINOR_VERSION", 5)},
    {SWIG_LUA_CONSTTAB_INT("FIRMATA_BUGFIX_VERSION", 0)},
    {SWIG_LUA_CONSTTAB_INT("FIRMATA_MAX_DATA_BYTES", 64)},
    {SWIG_LUA_CONSTTAB_INT("DIGITAL_MESSAGE", 0x90)},
    {SWIG_LUA_CONSTTAB_INT("ANALOG_MESSAGE", 0xE0)},
    {SWIG_LUA_CONSTTAB_INT("REPORT_ANALOG", 0xC0)},
    {SWIG_LUA_CONSTTAB_INT("REPORT_DIGITAL", 0xD0)},
    {SWIG_LUA_CONSTTAB_INT("SET_PIN_MODE", 0xF4)},
    {SWIG_LUA_CONSTTAB_INT("SET_DIGITAL_PIN_VALUE", 0xF5)},
    {SWIG_LUA_CONSTTAB_INT("REPORT_VERSION", 0xF9)},
    {SWIG_LUA_CONSTTAB_INT("SYSTEM_RESET", 0xFF)},
    {SWIG_LUA_CONSTTAB_INT("START_SYSEX", 0xF0)},
    {SWIG_LUA_CONSTTAB_INT("END_SYSEX", 0xF7)},
    {SWIG_LUA_CONSTTAB_INT("SERIAL_MESSAGE", 0x60)},
    {SWIG_LUA_CONSTTAB_INT("ENCODER_DATA", 0x61)},
    {SWIG_LUA_CONSTTAB_INT("SERVO_CONFIG", 0x70)},
    {SWIG_LUA_CONSTTAB_INT("STRING_DATA", 0x71)},
    {SWIG_LUA_CONSTTAB_INT("STEPPER_DATA", 0x72)},
    {SWIG_LUA_CONSTTAB_INT("ONEWIRE_DATA", 0x73)},
    {SWIG_LUA_CONSTTAB_INT("SHIFT_DATA", 0x75)},
    {SWIG_LUA_CONSTTAB_INT("I2C_REQUEST", 0x76)},
    {SWIG_LUA_CONSTTAB_INT("I2C_REPLY", 0x77)},
    {SWIG_LUA_CONSTTAB_INT("I2C_CONFIG", 0x78)},
    {SWIG_LUA_CONSTTAB_INT("EXTENDED_ANALOG", 0x6F)},
    {SWIG_LUA_CONSTTAB_INT("PIN_STATE_QUERY", 0x6D)},
    {SWIG_LUA_CONSTTAB_INT("PIN_STATE_RESPONSE", 0x6E)},
    {SWIG_LUA_CONSTTAB_INT("CAPABILITY_QUERY", 0x6B)},
    {SWIG_LUA_CONSTTAB_INT("CAPABILITY_RESPONSE", 0x6C)},
    {SWIG_LUA_CONSTTAB_INT("ANALOG_MAPPING_QUERY", 0x69)},
    {SWIG_LUA_CONSTTAB_INT("ANALOG_MAPPING_RESPONSE", 0x6A)},
    {SWIG_LUA_CONSTTAB_INT("REPORT_FIRMWARE", 0x79)},
    {SWIG_LUA_CONSTTAB_INT("SAMPLING_INTERVAL", 0x7A)},
    {SWIG_LUA_CONSTTAB_INT("SCHEDULER_DATA", 0x7B)},
    {SWIG_LUA_CONSTTAB_INT("SYSEX_NON_REALTIME", 0x7E)},
    {SWIG_LUA_CONSTTAB_INT("SYSEX_REALTIME", 0x7F)},
    {SWIG_LUA_CONSTTAB_INT("ARD_INPUT", 0x00)},
    {SWIG_LUA_CONSTTAB_INT("ARD_OUTPUT", 0x01)},
    {SWIG_LUA_CONSTTAB_INT("ARD_ANALOG", 0x02)},
    {SWIG_LUA_CONSTTAB_INT("ARD_PWM", 0x03)},
    {SWIG_LUA_CONSTTAB_INT("ARD_SERVO", 0x04)},
    {SWIG_LUA_CONSTTAB_INT("ARD_SHIFT", 0x05)},
    {SWIG_LUA_CONSTTAB_INT("ARD_I2C", 0x06)},
    {SWIG_LUA_CONSTTAB_INT("ARD_ONEWIRE", 0x07)},
    {SWIG_LUA_CONSTTAB_INT("ARD_STEPPER", 0x08)},
    {SWIG_LUA_CONSTTAB_INT("ARD_ENCODER", 0x09)},
    {SWIG_LUA_CONSTTAB_INT("ARD_SERIAL", 0x0A)},
    {SWIG_LUA_CONSTTAB_INT("ARD_INPUT_PULLUP", 0x0B)},
    {SWIG_LUA_CONSTTAB_INT("ARD_IGNORE", 0x7F)},
    {SWIG_LUA_CONSTTAB_INT("TOTAL_PIN_MODES", 13)},
    {SWIG_LUA_CONSTTAB_INT("MAX_STEPPERS", 6)},
    {SWIG_LUA_CONSTTAB_INT("STEPPER_CONFIG", 0)},
    {SWIG_LUA_CONSTTAB_INT("STEPPER_STEP", 1)},
    {SWIG_LUA_CONSTTAB_INT("ONEWIRE_SEARCH_REQUEST", 0x40)},
    {SWIG_LUA_CONSTTAB_INT("ONEWIRE_CONFIG_REQUEST", 0x41)},
    {SWIG_LUA_CONSTTAB_INT("ONEWIRE_SEARCH_REPLY", 0x42)},
    {SWIG_LUA_CONSTTAB_INT("ONEWIRE_READ_REPLY", 0x43)},
    {SWIG_LUA_CONSTTAB_INT("ONEWIRE_SEARCH_ALARMS_REQUEST", 0x44)},
    {SWIG_LUA_CONSTTAB_INT("ONEWIRE_SEARCH_ALARMS_REPLY", 0x45)},
    {SWIG_LUA_CONSTTAB_INT("ONEWIRE_RESET_REQUEST_BIT", 0x01)},
    {SWIG_LUA_CONSTTAB_INT("ONEWIRE_SKIP_REQUEST_BIT", 0x02)},
    {SWIG_LUA_CONSTTAB_INT("ONEWIRE_SELECT_REQUEST_BIT", 0x04)},
    {SWIG_LUA_CONSTTAB_INT("ONEWIRE_READ_REQUEST_BIT", 0x08)},
    {SWIG_LUA_CONSTTAB_INT("ONEWIRE_DELAY_REQUEST_BIT", 0x10)},
    {SWIG_LUA_CONSTTAB_INT("ONEWIRE_WRITE_REQUEST_BIT", 0x20)},
    {SWIG_LUA_CONSTTAB_INT("ONEWIRE_WITHDATA_REQUEST_BITS", 0x3C)},
    {SWIG_LUA_CONSTTAB_INT("ONEWIRE_POWER", 1)},
    {SWIG_LUA_CONSTTAB_INT("I2C_STOP_TX", 1)},
    {SWIG_LUA_CONSTTAB_INT("I2C_RESTART_TX", 0)},
    {SWIG_LUA_CONSTTAB_INT("I2C_MAX_QUERIES", 8)},
    {SWIG_LUA_CONSTTAB_INT("I2C_REGISTER_NOT_SPECIFIED", -1)},
    {SWIG_LUA_CONSTTAB_INT("MAX_ENCODERS", 5)},
    {SWIG_LUA_CONSTTAB_INT("ENCODER_ATTACH", 0x00)},
    {SWIG_LUA_CONSTTAB_INT("ENCODER_REPORT_POSITION", 0x01)},
    {SWIG_LUA_CONSTTAB_INT("ENCODER_REPORT_POSITIONS", 0x02)},
    {SWIG_LUA_CONSTTAB_INT("ENCODER_RESET_POSITION", 0x03)},
    {SWIG_LUA_CONSTTAB_INT("ENCODER_REPORT_AUTO", 0x04)},
    {SWIG_LUA_CONSTTAB_INT("ENCODER_DETACH", 0x05)},
    {SWIG_LUA_CONSTTAB_INT("ENCODER_DIRECTION_MASK", 0x40)},
    {SWIG_LUA_CONSTTAB_INT("ENCODER_CHANNEL_MASK", 0x3F)},
    {SWIG_LUA_CONSTTAB_INT("SERIAL_CONFIG", 0x10)},
    {SWIG_LUA_CONSTTAB_INT("SERIAL_WRITE", 0x20)},
    {SWIG_LUA_CONSTTAB_INT("SERIAL_READ", 0x30)},
    {SWIG_LUA_CONSTTAB_INT("SERIAL_REPLY", 0x40)},
    {SWIG_LUA_CONSTTAB_INT("SERIAL_CLOSE", 0x50)},
    {SWIG_LUA_CONSTTAB_INT("SERIAL_FLUSH", 0x60)},
    {SWIG_LUA_CONSTTAB_INT("SERIAL_LISTEN", 0x70)},
    {SWIG_LUA_CONSTTAB_INT("ARD_TOTAL_PORTS", 15)},
    {SWIG_LUA_CONSTTAB_INT("ARD_HIGH", 1)},
    {SWIG_LUA_CONSTTAB_INT("ARD_LOW", 0)},
    {SWIG_LUA_CONSTTAB_INT("ARD_ON", 1)},
    {SWIG_LUA_CONSTTAB_INT("ARD_OFF", 0)},
    {SWIG_LUA_CONSTTAB_FLOAT("ARDUINO_DELAY_LENGTH", 4.0)},
    {SWIG_LUA_CONSTTAB_INT("MODE_INPUT", MODE_INPUT)},
    {SWIG_LUA_CONSTTAB_INT("MODE_OUTPUT", MODE_OUTPUT)},
    {SWIG_LUA_CONSTTAB_INT("MODE_INPUT_PULLUP", MODE_INPUT_PULLUP)},
    {SWIG_LUA_CONSTTAB_INT("MODE_ANALOG", MODE_ANALOG)},
    {SWIG_LUA_CONSTTAB_INT("MODE_PWM", MODE_PWM)},
    {SWIG_LUA_CONSTTAB_INT("MODE_SERVO", MODE_SERVO)},
    {SWIG_LUA_CONSTTAB_INT("MODE_I2C", MODE_I2C)},
    {SWIG_LUA_CONSTTAB_INT("MODE_SERIAL", MODE_SERIAL)},
    {SWIG_LUA_CONSTTAB_INT("MODE_ONEWIRE", MODE_ONEWIRE)},
    {SWIG_LUA_CONSTTAB_INT("MODE_STEPPER", MODE_STEPPER)},
    {SWIG_LUA_CONSTTAB_INT("MODE_ENCODER", MODE_ENCODER)},
    {SWIG_LUA_CONSTTAB_INT("FIRMATA_STEPPER_DRIVER", FIRMATA_STEPPER_DRIVER)},
    {SWIG_LUA_CONSTTAB_INT("FIRMATA_STEPPER_TWO_WIRE", FIRMATA_STEPPER_TWO_WIRE)},
    {SWIG_LUA_CONSTTAB_INT("FIRMATA_STEPPER_FOUR_WIRE", FIRMATA_STEPPER_FOUR_WIRE)},
    {SWIG_LUA_CONSTTAB_INT("FIRMATA_STEPPER_CCW", FIRMATA_STEPPER_CCW)},
    {SWIG_LUA_CONSTTAB_INT("FIRMATA_STEPPER_CW", FIRMATA_STEPPER_CW)},
    {SWIG_LUA_CONSTTAB_INT("FIRMATA_I2C_WRITE", FIRMATA_I2C_WRITE)},
    {SWIG_LUA_CONSTTAB_INT("FIRMATA_I2C_READ", FIRMATA_I2C_READ)},
    {SWIG_LUA_CONSTTAB_INT("FIRMATA_I2C_CONTINUOUS_READ", FIRMATA_I2C_CONTINUOUS_READ)},
    {SWIG_LUA_CONSTTAB_INT("FIRMATA_I2C_STOP_READING", FIRMATA_I2C_STOP_READING)},
    {SWIG_LUA_CONSTTAB_INT("FIRMATA_SERIAL_READ_CONTINUOUS", FIRMATA_SERIAL_READ_CONTINUOUS)},
    {SWIG_LUA_CONSTTAB_INT("FIRMATA_SERIAL_STOP_READING", FIRMATA_SERIAL_STOP_READING)},
    {SWIG_LUA_CONSTTAB_INT("HW_SERIAL0", HW_SERIAL0)},
    {SWIG_LUA_CONSTTAB_INT("HW_SERIAL1", HW_SERIAL1)},
    {SWIG_LUA_CONSTTAB_INT("HW_SERIAL2", HW_SERIAL2)},
    {SWIG_LUA_CONSTTAB_INT("HW_SERIAL3", HW_SERIAL3)},
    {SWIG_LUA_CONSTTAB_INT("SW_SERIAL0", SW_SERIAL0)},
    {SWIG_LUA_CONSTTAB_INT("SW_SERIAL1", SW_SERIAL1)},
    {SWIG_LUA_CONSTTAB_INT("SW_SERIAL2", SW_SERIAL2)},
    {SWIG_LUA_CONSTTAB_INT("SW_SERIAL3", SW_SERIAL3)},
    {SWIG_LUA_CONSTTAB_INT("SERIAL_NO_DATA", -2)},
    {SWIG_LUA_CONSTTAB_INT("SERIAL_ERROR", -1)},
    {SWIG_LUA_CONSTTAB_INT("Vec2f_DIM", ofVec2f::DIM)},
    {SWIG_LUA_CONSTTAB_INT("Vec3f_DIM", ofVec3f::DIM)},
    {SWIG_LUA_CONSTTAB_INT("Vec4f_DIM", ofVec4f::DIM)},
    {SWIG_LUA_CONSTTAB_INT("KEY_RETURN", OF_KEY_RETURN)},
    {SWIG_LUA_CONSTTAB_INT("KEY_ESC", OF_KEY_ESC)},
    {SWIG_LUA_CONSTTAB_INT("KEY_TAB", OF_KEY_TAB)},
    {SWIG_LUA_CONSTTAB_INT("KEY_BACKSPACE", OF_KEY_BACKSPACE)},
    {SWIG_LUA_CONSTTAB_INT("KEY_DEL", OF_KEY_DEL)},
    {SWIG_LUA_CONSTTAB_INT("KEY_SHIFT", OF_KEY_SHIFT)},
    {SWIG_LUA_CONSTTAB_INT("KEY_CONTROL", OF_KEY_CONTROL)},
    {SWIG_LUA_CONSTTAB_INT("KEY_ALT", OF_KEY_ALT)},
    {SWIG_LUA_CONSTTAB_INT("KEY_SUPER", OF_KEY_SUPER)},
    {SWIG_LUA_CONSTTAB_INT("KEY_COMMAND", OF_KEY_COMMAND)},
    {SWIG_LUA_CONSTTAB_INT("KEY_LEFT_SHIFT", OF_KEY_LEFT_SHIFT)},
    {SWIG_LUA_CONSTTAB_INT("KEY_RIGHT_SHIFT", OF_KEY_RIGHT_SHIFT)},
    {SWIG_LUA_CONSTTAB_INT("KEY_LEFT_CONTROL", OF_KEY_LEFT_CONTROL)},
    {SWIG_LUA_CONSTTAB_INT("KEY_RIGHT_CONTROL", OF_KEY_RIGHT_CONTROL)},
    {SWIG_LUA_CONSTTAB_INT("KEY_LEFT_ALT", OF_KEY_LEFT_ALT)},
    {SWIG_LUA_CONSTTAB_INT("KEY_RIGHT_ALT", OF_KEY_RIGHT_ALT)},
    {SWIG_LUA_CONSTTAB_INT("KEY_LEFT_SUPER", OF_KEY_LEFT_SUPER)},
    {SWIG_LUA_CONSTTAB_INT("KEY_RIGHT_SUPER", OF_KEY_RIGHT_SUPER)},
    {SWIG_LUA_CONSTTAB_INT("KEY_LEFT_COMMAND", OF_KEY_LEFT_COMMAND)},
    {SWIG_LUA_CONSTTAB_INT("KEY_RIGHT_COMMAND", OF_KEY_RIGHT_COMMAND)},
    {SWIG_LUA_CONSTTAB_INT("KEY_F1", OF_KEY_F1)},
    {SWIG_LUA_CONSTTAB_INT("KEY_F2", OF_KEY_F2)},
    {SWIG_LUA_CONSTTAB_INT("KEY_F3", OF_KEY_F3)},
    {SWIG_LUA_CONSTTAB_INT("KEY_F4", OF_KEY_F4)},
    {SWIG_LUA_CONSTTAB_INT("KEY_F5", OF_KEY_F5)},
    {SWIG_LUA_CONSTTAB_INT("KEY_F6", OF_KEY_F6)},
    {SWIG_LUA_CONSTTAB_INT("KEY_F7", OF_KEY_F7)},
    {SWIG_LUA_CONSTTAB_INT("KEY_F8", OF_KEY_F8)},
    {SWIG_LUA_CONSTTAB_INT("KEY_F9", OF_KEY_F9)},
    {SWIG_LUA_CONSTTAB_INT("KEY_F10", OF_KEY_F10)},
    {SWIG_LUA_CONSTTAB_INT("KEY_F11", OF_KEY_F11)},
    {SWIG_LUA_CONSTTAB_INT("KEY_F12", OF_KEY_F12)},
    {SWIG_LUA_CONSTTAB_INT("KEY_LEFT", OF_KEY_LEFT)},
    {SWIG_LUA_CONSTTAB_INT("KEY_UP", OF_KEY_UP)},
    {SWIG_LUA_CONSTTAB_INT("KEY_RIGHT", OF_KEY_RIGHT)},
    {SWIG_LUA_CONSTTAB_INT("KEY_DOWN", OF_KEY_DOWN)},
    {SWIG_LUA_CONSTTAB_INT("KEY_PAGE_UP", OF_KEY_PAGE_UP)},
    {SWIG_LUA_CONSTTAB_INT("KEY_PAGE_DOWN", OF_KEY_PAGE_DOWN)},
    {SWIG_LUA_CONSTTAB_INT("KEY_HOME", OF_KEY_HOME)},
    {SWIG_LUA_CONSTTAB_INT("KEY_END", OF_KEY_END)},
    {SWIG_LUA_CONSTTAB_INT("KEY_INSERT", OF_KEY_INSERT)},
    {SWIG_LUA_CONSTTAB_INT("MOUSE_BUTTON_1", OF_MOUSE_BUTTON_1)},
    {SWIG_LUA_CONSTTAB_INT("MOUSE_BUTTON_2", OF_MOUSE_BUTTON_2)},
    {SWIG_LUA_CONSTTAB_INT("MOUSE_BUTTON_3", OF_MOUSE_BUTTON_3)},
    {SWIG_LUA_CONSTTAB_INT("MOUSE_BUTTON_4", OF_MOUSE_BUTTON_4)},
    {SWIG_LUA_CONSTTAB_INT("MOUSE_BUTTON_5", OF_MOUSE_BUTTON_5)},
    {SWIG_LUA_CONSTTAB_INT("MOUSE_BUTTON_6", OF_MOUSE_BUTTON_6)},
    {SWIG_LUA_CONSTTAB_INT("MOUSE_BUTTON_7", OF_MOUSE_BUTTON_7)},
    {SWIG_LUA_CONSTTAB_INT("MOUSE_BUTTON_8", OF_MOUSE_BUTTON_8)},
    {SWIG_LUA_CONSTTAB_INT("MOUSE_BUTTON_LAST", OF_MOUSE_BUTTON_LAST)},
    {SWIG_LUA_CONSTTAB_INT("MOUSE_BUTTON_LEFT", OF_MOUSE_BUTTON_LEFT)},
    {SWIG_LUA_CONSTTAB_INT("MOUSE_BUTTON_MIDDLE", OF_MOUSE_BUTTON_MIDDLE)},
    {SWIG_LUA_CONSTTAB_INT("MOUSE_BUTTON_RIGHT", OF_MOUSE_BUTTON_RIGHT)},
    {SWIG_LUA_CONSTTAB_INT("TouchEventArgs_down", ofTouchEventArgs::down)},
    {SWIG_LUA_CONSTTAB_INT("TouchEventArgs_up", ofTouchEventArgs::up)},
    {SWIG_LUA_CONSTTAB_INT("TouchEventArgs_move", ofTouchEventArgs::move)},
    {SWIG_LUA_CONSTTAB_INT("TouchEventArgs_doubleTap", ofTouchEventArgs::doubleTap)},
    {SWIG_LUA_CONSTTAB_INT("TouchEventArgs_cancel", ofTouchEventArgs::cancel)},
    {SWIG_LUA_CONSTTAB_INT("TEXTURE_LUMINANCE", 6409)},
    {SWIG_LUA_CONSTTAB_INT("TEXTURE_RGB", 6407)},
    {SWIG_LUA_CONSTTAB_INT("TEXTURE_RGBA", 6408)},
    {SWIG_LUA_CONSTTAB_INT("NEAREST", 9728)},
    {SWIG_LUA_CONSTTAB_INT("LINEAR", 9729)},
    {SWIG_LUA_CONSTTAB_INT("FRAGMENT_SHADER", 35632)},
    {SWIG_LUA_CONSTTAB_INT("VERTEX_SHADER", 35633)},
    {SWIG_LUA_CONSTTAB_INT("CLAMP_TO_EDGE", 33071)},
    {SWIG_LUA_CONSTTAB_INT("CLAMP_TO_BORDER", 33069)},
    {SWIG_LUA_CONSTTAB_INT("REPEAT", 10497)},
    {SWIG_LUA_CONSTTAB_INT("MIRRORED_REPEAT", 33648)},
    {SWIG_LUA_CONSTTAB_INT("LIGHT_POINT", OF_LIGHT_POINT)},
    {SWIG_LUA_CONSTTAB_INT("LIGHT_DIRECTIONAL", OF_LIGHT_DIRECTIONAL)},
    {SWIG_LUA_CONSTTAB_INT("LIGHT_SPOT", OF_LIGHT_SPOT)},
    {SWIG_LUA_CONSTTAB_INT("LIGHT_AREA", OF_LIGHT_AREA)},
    {SWIG_LUA_CONSTTAB_INT("MESH_POINTS", OF_MESH_POINTS)},
    {SWIG_LUA_CONSTTAB_INT("MESH_WIREFRAME", OF_MESH_WIREFRAME)},
    {SWIG_LUA_CONSTTAB_INT("MESH_FILL", OF_MESH_FILL)},
    {SWIG_LUA_CONSTTAB_INT("PRIMITIVE_TRIANGLES", OF_PRIMITIVE_TRIANGLES)},
    {SWIG_LUA_CONSTTAB_INT("PRIMITIVE_TRIANGLE_STRIP", OF_PRIMITIVE_TRIANGLE_STRIP)},
    {SWIG_LUA_CONSTTAB_INT("PRIMITIVE_TRIANGLE_FAN", OF_PRIMITIVE_TRIANGLE_FAN)},
    {SWIG_LUA_CONSTTAB_INT("PRIMITIVE_LINES", OF_PRIMITIVE_LINES)},
    {SWIG_LUA_CONSTTAB_INT("PRIMITIVE_LINE_STRIP", OF_PRIMITIVE_LINE_STRIP)},
    {SWIG_LUA_CONSTTAB_INT("PRIMITIVE_LINE_LOOP", OF_PRIMITIVE_LINE_LOOP)},
    {SWIG_LUA_CONSTTAB_INT("PRIMITIVE_POINTS", OF_PRIMITIVE_POINTS)},
    {SWIG_LUA_CONSTTAB_INT("PRIMITIVE_LINES_ADJACENCY", OF_PRIMITIVE_LINES_ADJACENCY)},
    {SWIG_LUA_CONSTTAB_INT("PRIMITIVE_LINE_STRIP_ADJACENCY", OF_PRIMITIVE_LINE_STRIP_ADJACENCY)},
    {SWIG_LUA_CONSTTAB_INT("PRIMITIVE_TRIANGLES_ADJACENCY", OF_PRIMITIVE_TRIANGLES_ADJACENCY)},
    {SWIG_LUA_CONSTTAB_INT("PRIMITIVE_TRIANGLE_STRIP_ADJACENCY", OF_PRIMITIVE_TRIANGLE_STRIP_ADJACENCY)},
    {SWIG_LUA_CONSTTAB_INT("PRIMITIVE_PATCHES", OF_PRIMITIVE_PATCHES)},
    {SWIG_LUA_CONSTTAB_INT("OUTLINE", OF_OUTLINE)},
    {SWIG_LUA_CONSTTAB_INT("FILLED", OF_FILLED)},
    {SWIG_LUA_CONSTTAB_INT("MAX_STYLE_HISTORY", 32)},
    {SWIG_LUA_CONSTTAB_INT("MAX_VIEWPORT_HISTORY", 32)},
    {SWIG_LUA_CONSTTAB_INT("MAX_CIRCLE_PTS", 1024)},
    {SWIG_LUA_CONSTTAB_INT("BLENDMODE_DISABLED", OF_BLENDMODE_DISABLED)},
    {SWIG_LUA_CONSTTAB_INT("BLENDMODE_ALPHA", OF_BLENDMODE_ALPHA)},
    {SWIG_LUA_CONSTTAB_INT("BLENDMODE_ADD", OF_BLENDMODE_ADD)},
    {SWIG_LUA_CONSTTAB_INT("BLENDMODE_SUBTRACT", OF_BLENDMODE_SUBTRACT)},
    {SWIG_LUA_CONSTTAB_INT("BLENDMODE_MULTIPLY", OF_BLENDMODE_MULTIPLY)},
    {SWIG_LUA_CONSTTAB_INT("BLENDMODE_SCREEN", OF_BLENDMODE_SCREEN)},
    {SWIG_LUA_CONSTTAB_INT("GRADIENT_LINEAR", OF_GRADIENT_LINEAR)},
    {SWIG_LUA_CONSTTAB_INT("GRADIENT_CIRCULAR", OF_GRADIENT_CIRCULAR)},
    {SWIG_LUA_CONSTTAB_INT("GRADIENT_BAR", OF_GRADIENT_BAR)},
    {SWIG_LUA_CONSTTAB_INT("POLY_WINDING_ODD", OF_POLY_WINDING_ODD)},
    {SWIG_LUA_CONSTTAB_INT("POLY_WINDING_NONZERO", OF_POLY_WINDING_NONZERO)},
    {SWIG_LUA_CONSTTAB_INT("POLY_WINDING_POSITIVE", OF_POLY_WINDING_POSITIVE)},
    {SWIG_LUA_CONSTTAB_INT("POLY_WINDING_NEGATIVE", OF_POLY_WINDING_NEGATIVE)},
    {SWIG_LUA_CONSTTAB_INT("POLY_WINDING_ABS_GEQ_TWO", OF_POLY_WINDING_ABS_GEQ_TWO)},
    {SWIG_LUA_CONSTTAB_INT("LEFT_HANDED", OF_LEFT_HANDED)},
    {SWIG_LUA_CONSTTAB_INT("RIGHT_HANDED", OF_RIGHT_HANDED)},
    {SWIG_LUA_CONSTTAB_INT("MATRIX_MODELVIEW", OF_MATRIX_MODELVIEW)},
    {SWIG_LUA_CONSTTAB_INT("MATRIX_PROJECTION", OF_MATRIX_PROJECTION)},
    {SWIG_LUA_CONSTTAB_INT("MATRIX_TEXTURE", OF_MATRIX_TEXTURE)},
    {SWIG_LUA_CONSTTAB_INT("BITMAPMODE_SIMPLE", OF_BITMAPMODE_SIMPLE)},
    {SWIG_LUA_CONSTTAB_INT("BITMAPMODE_SCREEN", OF_BITMAPMODE_SCREEN)},
    {SWIG_LUA_CONSTTAB_INT("BITMAPMODE_VIEWPORT", OF_BITMAPMODE_VIEWPORT)},
    {SWIG_LUA_CONSTTAB_INT("BITMAPMODE_MODEL", OF_BITMAPMODE_MODEL)},
    {SWIG_LUA_CONSTTAB_INT("BITMAPMODE_MODEL_BILLBOARD", OF_BITMAPMODE_MODEL_BILLBOARD)},
    {SWIG_LUA_CONSTTAB_INT("RECTMODE_CORNER", OF_RECTMODE_CORNER)},
    {SWIG_LUA_CONSTTAB_INT("RECTMODE_CENTER", OF_RECTMODE_CENTER)},
    {SWIG_LUA_CONSTTAB_INT("IMAGE_GRAYSCALE", OF_IMAGE_GRAYSCALE)},
    {SWIG_LUA_CONSTTAB_INT("IMAGE_COLOR", OF_IMAGE_COLOR)},
    {SWIG_LUA_CONSTTAB_INT("IMAGE_COLOR_ALPHA", OF_IMAGE_COLOR_ALPHA)},
    {SWIG_LUA_CONSTTAB_INT("IMAGE_UNDEFINED", OF_IMAGE_UNDEFINED)},
    {SWIG_LUA_CONSTTAB_INT("INTERPOLATE_NEAREST_NEIGHBOR", OF_INTERPOLATE_NEAREST_NEIGHBOR)},
    {SWIG_LUA_CONSTTAB_INT("INTERPOLATE_BILINEAR", OF_INTERPOLATE_BILINEAR)},
    {SWIG_LUA_CONSTTAB_INT("INTERPOLATE_BICUBIC", OF_INTERPOLATE_BICUBIC)},
    {SWIG_LUA_CONSTTAB_INT("PIXELS_GRAY", OF_PIXELS_GRAY)},
    {SWIG_LUA_CONSTTAB_INT("PIXELS_GRAY_ALPHA", OF_PIXELS_GRAY_ALPHA)},
    {SWIG_LUA_CONSTTAB_INT("PIXELS_RGB", OF_PIXELS_RGB)},
    {SWIG_LUA_CONSTTAB_INT("PIXELS_BGR", OF_PIXELS_BGR)},
    {SWIG_LUA_CONSTTAB_INT("PIXELS_RGBA", OF_PIXELS_RGBA)},
    {SWIG_LUA_CONSTTAB_INT("PIXELS_BGRA", OF_PIXELS_BGRA)},
    {SWIG_LUA_CONSTTAB_INT("PIXELS_RGB565", OF_PIXELS_RGB565)},
    {SWIG_LUA_CONSTTAB_INT("PIXELS_NV12", OF_PIXELS_NV12)},
    {SWIG_LUA_CONSTTAB_INT("PIXELS_NV21", OF_PIXELS_NV21)},
    {SWIG_LUA_CONSTTAB_INT("PIXELS_YV12", OF_PIXELS_YV12)},
    {SWIG_LUA_CONSTTAB_INT("PIXELS_I420", OF_PIXELS_I420)},
    {SWIG_LUA_CONSTTAB_INT("PIXELS_YUY2", OF_PIXELS_YUY2)},
    {SWIG_LUA_CONSTTAB_INT("PIXELS_UYVY", OF_PIXELS_UYVY)},
    {SWIG_LUA_CONSTTAB_INT("PIXELS_Y", OF_PIXELS_Y)},
    {SWIG_LUA_CONSTTAB_INT("PIXELS_U", OF_PIXELS_U)},
    {SWIG_LUA_CONSTTAB_INT("PIXELS_V", OF_PIXELS_V)},
    {SWIG_LUA_CONSTTAB_INT("PIXELS_UV", OF_PIXELS_UV)},
    {SWIG_LUA_CONSTTAB_INT("PIXELS_VU", OF_PIXELS_VU)},
    {SWIG_LUA_CONSTTAB_INT("PIXELS_NUM_FORMATS", OF_PIXELS_NUM_FORMATS)},
    {SWIG_LUA_CONSTTAB_INT("PIXELS_UNKNOWN", OF_PIXELS_UNKNOWN)},
    {SWIG_LUA_CONSTTAB_INT("PIXELS_NATIVE", OF_PIXELS_NATIVE)},
    {SWIG_LUA_CONSTTAB_INT("CIRC_RESOLUTION", 22)},
    {SWIG_LUA_CONSTTAB_INT("OPEN", OF_OPEN)},
    {SWIG_LUA_CONSTTAB_INT("CLOSE", OF_CLOSE)},
    {SWIG_LUA_CONSTTAB_INT("TTF_LEFT_TO_RIGHT", OF_TTF_LEFT_TO_RIGHT)},
    {SWIG_LUA_CONSTTAB_INT("TTF_RIGHT_TO_LEFT", OF_TTF_RIGHT_TO_LEFT)},
    {SWIG_LUA_CONSTTAB_INT("ASPECT_RATIO_IGNORE", OF_ASPECT_RATIO_IGNORE)},
    {SWIG_LUA_CONSTTAB_INT("ASPECT_RATIO_KEEP", OF_ASPECT_RATIO_KEEP)},
    {SWIG_LUA_CONSTTAB_INT("ASPECT_RATIO_KEEP_BY_EXPANDING", OF_ASPECT_RATIO_KEEP_BY_EXPANDING)},
    {SWIG_LUA_CONSTTAB_INT("ALIGN_VERT_IGNORE", OF_ALIGN_VERT_IGNORE)},
    {SWIG_LUA_CONSTTAB_INT("ALIGN_VERT_TOP", OF_ALIGN_VERT_TOP)},
    {SWIG_LUA_CONSTTAB_INT("ALIGN_VERT_BOTTOM", OF_ALIGN_VERT_BOTTOM)},
    {SWIG_LUA_CONSTTAB_INT("ALIGN_VERT_CENTER", OF_ALIGN_VERT_CENTER)},
    {SWIG_LUA_CONSTTAB_INT("ALIGN_HORZ_IGNORE", OF_ALIGN_HORZ_IGNORE)},
    {SWIG_LUA_CONSTTAB_INT("ALIGN_HORZ_LEFT", OF_ALIGN_HORZ_LEFT)},
    {SWIG_LUA_CONSTTAB_INT("ALIGN_HORZ_RIGHT", OF_ALIGN_HORZ_RIGHT)},
    {SWIG_LUA_CONSTTAB_INT("ALIGN_HORZ_CENTER", OF_ALIGN_HORZ_CENTER)},
    {SWIG_LUA_CONSTTAB_INT("SCALEMODE_FIT", OF_SCALEMODE_FIT)},
    {SWIG_LUA_CONSTTAB_INT("SCALEMODE_FILL", OF_SCALEMODE_FILL)},
    {SWIG_LUA_CONSTTAB_INT("SCALEMODE_CENTER", OF_SCALEMODE_CENTER)},
    {SWIG_LUA_CONSTTAB_INT("SCALEMODE_STRETCH_TO_FILL", OF_SCALEMODE_STRETCH_TO_FILL)},
    {SWIG_LUA_CONSTTAB_INT("File_Reference", ofFile::Reference)},
    {SWIG_LUA_CONSTTAB_INT("File_ReadOnly", ofFile::ReadOnly)},
    {SWIG_LUA_CONSTTAB_INT("File_WriteOnly", ofFile::WriteOnly)},
    {SWIG_LUA_CONSTTAB_INT("File_ReadWrite", ofFile::ReadWrite)},
    {SWIG_LUA_CONSTTAB_INT("File_Append", ofFile::Append)},
    {SWIG_LUA_CONSTTAB_INT("LOG_VERBOSE", OF_LOG_VERBOSE)},
    {SWIG_LUA_CONSTTAB_INT("LOG_NOTICE", OF_LOG_NOTICE)},
    {SWIG_LUA_CONSTTAB_INT("LOG_WARNING", OF_LOG_WARNING)},
    {SWIG_LUA_CONSTTAB_INT("LOG_ERROR", OF_LOG_ERROR)},
    {SWIG_LUA_CONSTTAB_INT("LOG_FATAL_ERROR", OF_LOG_FATAL_ERROR)},
    {SWIG_LUA_CONSTTAB_INT("LOG_SILENT", OF_LOG_SILENT)},
    {SWIG_LUA_CONSTTAB_INT("CONSOLE_COLOR_RESTORE", (0))},
    {SWIG_LUA_CONSTTAB_INT("CONSOLE_COLOR_BLACK", (30))},
    {SWIG_LUA_CONSTTAB_INT("CONSOLE_COLOR_RED", (31))},
    {SWIG_LUA_CONSTTAB_INT("CONSOLE_COLOR_GREEN", (32))},
    {SWIG_LUA_CONSTTAB_INT("CONSOLE_COLOR_YELLOW", (33))},
    {SWIG_LUA_CONSTTAB_INT("CONSOLE_COLOR_BLUE", (34))},
    {SWIG_LUA_CONSTTAB_INT("CONSOLE_COLOR_PURPLE", (35))},
    {SWIG_LUA_CONSTTAB_INT("CONSOLE_COLOR_CYAN", (36))},
    {SWIG_LUA_CONSTTAB_INT("CONSOLE_COLOR_WHITE", (37))},
    {SWIG_LUA_CONSTTAB_INT("HttpRequest_GET", ofHttpRequest::GET)},
    {SWIG_LUA_CONSTTAB_INT("HttpRequest_POST", ofHttpRequest::POST)},
    {0,0,0,0,0,0}
};
static swig_lua_method swig_SwigModule_methods[]= {
    { "resetElapsedTimeCounter", _wrap_resetElapsedTimeCounter},
    { "getElapsedTimef", _wrap_getElapsedTimef},
    { "getElapsedTimeMillis", _wrap_getElapsedTimeMillis},
    { "getElapsedTimeMicros", _wrap_getElapsedTimeMicros},
    { "getFrameNum", _wrap_getFrameNum},
    { "getSeconds", _wrap_getSeconds},
    { "getMinutes", _wrap_getMinutes},
    { "getHours", _wrap_getHours},
    { "getUnixTime", _wrap_getUnixTime},
    { "getSystemTimeMillis", _wrap_getSystemTimeMillis},
    { "getSystemTimeMicros", _wrap_getSystemTimeMicros},
    { "getCurrentTime", _wrap_getCurrentTime},
    { "sleepMillis", _wrap_sleepMillis},
    { "getTimestampString", _wrap_getTimestampString},
    { "getYear", _wrap_getYear},
    { "getMonth", _wrap_getMonth},
    { "getDay", _wrap_getDay},
    { "getWeekday", _wrap_getWeekday},
    { "enableDataPath", _wrap_enableDataPath},
    { "disableDataPath", _wrap_disableDataPath},
    { "toDataPath", _wrap_toDataPath},
    { "restoreWorkingDirectoryToDefault", _wrap_restoreWorkingDirectoryToDefault},
    { "setDataPathRoot", _wrap_setDataPathRoot},
    { "splitString", _wrap_splitString},
    { "joinString", _wrap_joinString},
    { "stringReplace", _wrap_stringReplace},
    { "isStringInString", _wrap_isStringInString},
    { "stringTimesInString", _wrap_stringTimesInString},
    { "toLower", _wrap_toLower},
    { "toUpper", _wrap_toUpper},
    { "trimFront", _wrap_trimFront},
    { "trimBack", _wrap_trimBack},
    { "trim", _wrap_trim},
    { "UTF8Append", _wrap_UTF8Append},
    { "UTF8Insert", _wrap_UTF8Insert},
    { "UTF8Erase", _wrap_UTF8Erase},
    { "UTF8Substring", _wrap_UTF8Substring},
    { "UTF8ToString", _wrap_UTF8ToString},
    { "UTF8Length", _wrap_UTF8Length},
    { "toInt", _wrap_toInt},
    { "toInt64", _wrap_toInt64},
    { "toFloat", _wrap_toFloat},
    { "toDouble", _wrap_toDouble},
    { "toBool", _wrap_toBool},
    { "toHex", _wrap_toHex},
    { "hexToInt", _wrap_hexToInt},
    { "hexToChar", _wrap_hexToChar},
    { "hexToFloat", _wrap_hexToFloat},
    { "hexToString", _wrap_hexToString},
    { "toChar", _wrap_toChar},
    { "toBinary", _wrap_toBinary},
    { "binaryToInt", _wrap_binaryToInt},
    { "binaryToChar", _wrap_binaryToChar},
    { "binaryToFloat", _wrap_binaryToFloat},
    { "binaryToString", _wrap_binaryToString},
    { "getVersionInfo", _wrap_getVersionInfo},
    { "getVersionMajor", _wrap_getVersionMajor},
    { "getVersionMinor", _wrap_getVersionMinor},
    { "getVersionPatch", _wrap_getVersionPatch},
    { "getVersionPreRelease", _wrap_getVersionPreRelease},
    { "saveScreen", _wrap_saveScreen},
    { "saveFrame", _wrap_saveFrame},
    { "saveViewport", _wrap_saveViewport},
    { "launchBrowser", _wrap_launchBrowser},
    { "system", _wrap_system},
    { "getTargetPlatform", _wrap_getTargetPlatform},
    { "getEnv", _wrap_getEnv},
    { "FboModeOr", _wrap_FboModeOr},
    { "FboModeAnd", _wrap_FboModeAnd},
    { "Fbo_checkGLSupport", _wrap_Fbo_checkGLSupport},
    { "Fbo_maxColorAttachments", _wrap_Fbo_maxColorAttachments},
    { "Fbo_maxDrawBuffers", _wrap_Fbo_maxDrawBuffers},
    { "Fbo_maxSamples", _wrap_Fbo_maxSamples},
    { "getUsingArbTex", _wrap_getUsingArbTex},
    { "enableArbTex", _wrap_enableArbTex},
    { "disableArbTex", _wrap_disableArbTex},
    { "getUsingNormalizedTexCoords", _wrap_getUsingNormalizedTexCoords},
    { "enableNormalizedTexCoords", _wrap_enableNormalizedTexCoords},
    { "disableNormalizedTexCoords", _wrap_disableNormalizedTexCoords},
    { "enableTextureEdgeHack", _wrap_enableTextureEdgeHack},
    { "disableTextureEdgeHack", _wrap_disableTextureEdgeHack},
    { "isTextureEdgeHackEnabled", _wrap_isTextureEdgeHackEnabled},
    { "imageFormatExtension", _wrap_imageFormatExtension},
    { "toString", _wrap_toString},
    { "drawAxis", _wrap_drawAxis},
    { "drawGrid", _wrap_drawGrid},
    { "drawGridPlane", _wrap_drawGridPlane},
    { "drawArrow", _wrap_drawArrow},
    { "drawRotationAxes", _wrap_drawRotationAxes},
    { "Mesh_plane", _wrap_Mesh_plane},
    { "Mesh_sphere", _wrap_Mesh_sphere},
    { "Mesh_icosahedron", _wrap_Mesh_icosahedron},
    { "Mesh_icosphere", _wrap_Mesh_icosphere},
    { "Mesh_cylinder", _wrap_Mesh_cylinder},
    { "Mesh_cone", _wrap_Mesh_cone},
    { "Mesh_box", _wrap_Mesh_box},
    { "Mesh_axis", _wrap_Mesh_axis},
    { "exit", _wrap_exit},
    { "getFrameRate", _wrap_getFrameRate},
    { "getTargetFrameRate", _wrap_getTargetFrameRate},
    { "setFrameRate", _wrap_setFrameRate},
    { "getLastFrameTime", _wrap_getLastFrameTime},
    { "setTimeModeSystem", _wrap_setTimeModeSystem},
    { "getFixedStepForFps", _wrap_getFixedStepForFps},
    { "setTimeModeFixedRate", _wrap_setTimeModeFixedRate},
    { "setTimeModeFiltered", _wrap_setTimeModeFiltered},
    { "setOrientation", _wrap_setOrientation},
    { "getOrientation", _wrap_getOrientation},
    { "hideCursor", _wrap_hideCursor},
    { "showCursor", _wrap_showCursor},
    { "getWindowPositionX", _wrap_getWindowPositionX},
    { "getWindowPositionY", _wrap_getWindowPositionY},
    { "getScreenWidth", _wrap_getScreenWidth},
    { "getScreenHeight", _wrap_getScreenHeight},
    { "getWindowMode", _wrap_getWindowMode},
    { "getWidth", _wrap_getWidth},
    { "getHeight", _wrap_getHeight},
    { "getWindowWidth", _wrap_getWindowWidth},
    { "getWindowHeight", _wrap_getWindowHeight},
    { "getClipboardString", _wrap_getClipboardString},
    { "setClipboardString", _wrap_setClipboardString},
    { "randomWidth", _wrap_randomWidth},
    { "randomHeight", _wrap_randomHeight},
    { "doesHWOrientation", _wrap_doesHWOrientation},
    { "getWindowSize", _wrap_getWindowSize},
    { "getWindowRect", _wrap_getWindowRect},
    { "setWindowPosition", _wrap_setWindowPosition},
    { "setWindowShape", _wrap_setWindowShape},
    { "setWindowTitle", _wrap_setWindowTitle},
    { "enableSetupScreen", _wrap_enableSetupScreen},
    { "disableSetupScreen", _wrap_disableSetupScreen},
    { "setFullscreen", _wrap_setFullscreen},
    { "toggleFullscreen", _wrap_toggleFullscreen},
    { "setVerticalSync", _wrap_setVerticalSync},
    { "events", _wrap_events},
    { "setEscapeQuitsApp", _wrap_setEscapeQuitsApp},
    { "random", _wrap_random},
    { "randomf", _wrap_randomf},
    { "randomuf", _wrap_randomuf},
    { "seedRandom", _wrap_seedRandom},
    { "normalize", _wrap_normalize},
    { "map", _wrap_map},
    { "clamp", _wrap_clamp},
    { "inRange", _wrap_inRange},
    { "lerp", _wrap_lerp},
    { "dist", _wrap_dist},
    { "distSquared", _wrap_distSquared},
    { "radToDeg", _wrap_radToDeg},
    { "degToRad", _wrap_degToRad},
    { "lerpDegrees", _wrap_lerpDegrees},
    { "lerpRadians", _wrap_lerpRadians},
    { "angleDifferenceDegrees", _wrap_angleDifferenceDegrees},
    { "angleDifferenceRadians", _wrap_angleDifferenceRadians},
    { "wrap", _wrap_wrap},
    { "wrapRadians", _wrap_wrapRadians},
    { "wrapDegrees", _wrap_wrapDegrees},
    { "noise", _wrap_noise},
    { "signedNoise", _wrap_signedNoise},
    { "nextPow2", _wrap_nextPow2},
    { "sign", _wrap_sign},
    { "Matrix4x4_newIdentityMatrix", _wrap_Matrix4x4_newIdentityMatrix},
    { "Matrix4x4_newScaleMatrix", _wrap_Matrix4x4_newScaleMatrix},
    { "Matrix4x4_newTranslationMatrix", _wrap_Matrix4x4_newTranslationMatrix},
    { "Matrix4x4_newRotationMatrix", _wrap_Matrix4x4_newRotationMatrix},
    { "Matrix4x4_newOrthoMatrix", _wrap_Matrix4x4_newOrthoMatrix},
    { "Matrix4x4_newOrtho2DMatrix", _wrap_Matrix4x4_newOrtho2DMatrix},
    { "Matrix4x4_newFrustumMatrix", _wrap_Matrix4x4_newFrustumMatrix},
    { "Matrix4x4_newPerspectiveMatrix", _wrap_Matrix4x4_newPerspectiveMatrix},
    { "Matrix4x4_newLookAtMatrix", _wrap_Matrix4x4_newLookAtMatrix},
    { "Matrix4x4_getInverseOf", _wrap_Matrix4x4_getInverseOf},
    { "Matrix4x4_getTransposedOf", _wrap_Matrix4x4_getTransposedOf},
    { "Matrix4x4_getOrthoNormalOf", _wrap_Matrix4x4_getOrthoNormalOf},
    { "Matrix4x4_transform3x3", _wrap_Matrix4x4_transform3x3},
    { "Vec2f_zero", _wrap_Vec2f_zero},
    { "Vec2f_one", _wrap_Vec2f_one},
    { "Vec3f_zero", _wrap_Vec3f_zero},
    { "Vec3f_one", _wrap_Vec3f_one},
    { "Vec4f_zero", _wrap_Vec4f_zero},
    { "Vec4f_one", _wrap_Vec4f_one},
    { "getMousePressed", _wrap_getMousePressed},
    { "getKeyPressed", _wrap_getKeyPressed},
    { "getMouseX", _wrap_getMouseX},
    { "getMouseY", _wrap_getMouseY},
    { "getPreviousMouseX", _wrap_getPreviousMouseX},
    { "getPreviousMouseY", _wrap_getPreviousMouseY},
    { "sendMessage", _wrap_sendMessage},
    { "getGLInternalFormat", _wrap_getGLInternalFormat},
    { "getGLInternalFormatName", _wrap_getGLInternalFormatName},
    { "getGLFormatFromInternal", _wrap_getGLFormatFromInternal},
    { "getGLTypeFromInternal", _wrap_getGLTypeFromInternal},
    { "getGLType", _wrap_getGLType},
    { "getImageTypeFromGLType", _wrap_getImageTypeFromGLType},
    { "getGLPolyMode", _wrap_getGLPolyMode},
    { "getOFPolyMode", _wrap_getOFPolyMode},
    { "getGLPrimitiveMode", _wrap_getGLPrimitiveMode},
    { "getOFPrimitiveMode", _wrap_getOFPrimitiveMode},
    { "getGLInternalFormatFromPixelFormat", _wrap_getGLInternalFormatFromPixelFormat},
    { "getGLFormatFromPixelFormat", _wrap_getGLFormatFromPixelFormat},
    { "getBytesPerChannelFromGLType", _wrap_getBytesPerChannelFromGLType},
    { "getNumChannelsFromGLFormat", _wrap_getNumChannelsFromGLFormat},
    { "setPixelStoreiAlignment", _wrap_setPixelStoreiAlignment},
    { "GLSupportedExtensions", _wrap_GLSupportedExtensions},
    { "GLCheckExtension", _wrap_GLCheckExtension},
    { "GLSupportsNPOTTextures", _wrap_GLSupportsNPOTTextures},
    { "isGLProgrammableRenderer", _wrap_isGLProgrammableRenderer},
    { "GLSLVersionFromGL", _wrap_GLSLVersionFromGL},
    { "enableGLDebugLog", _wrap_enableGLDebugLog},
    { "disableGLDebugLog", _wrap_disableGLDebugLog},
    { "enableLighting", _wrap_enableLighting},
    { "disableLighting", _wrap_disableLighting},
    { "enableSeparateSpecularLight", _wrap_enableSeparateSpecularLight},
    { "disableSeparateSpecularLight", _wrap_disableSeparateSpecularLight},
    { "getLightingEnabled", _wrap_getLightingEnabled},
    { "setSmoothLighting", _wrap_setSmoothLighting},
    { "setGlobalAmbientColor", _wrap_setGlobalAmbientColor},
    { "getGlobalAmbientColor", _wrap_getGlobalAmbientColor},
    { "drawBitmapString", _wrap_drawBitmapString},
    { "setColor", _wrap_setColor},
    { "setHexColor", _wrap_setHexColor},
    { "noFill", _wrap_noFill},
    { "fill", _wrap_fill},
    { "getFill", _wrap_getFill},
    { "getBackgroundColor", _wrap_getBackgroundColor},
    { "background", _wrap_background},
    { "backgroundHex", _wrap_backgroundHex},
    { "backgroundGradient", _wrap_backgroundGradient},
    { "setBackgroundColor", _wrap_setBackgroundColor},
    { "setBackgroundColorHex", _wrap_setBackgroundColorHex},
    { "setBackgroundAuto", _wrap_setBackgroundAuto},
    { "getBackgroundAuto", _wrap_getBackgroundAuto},
    { "clear", _wrap_clear},
    { "clearAlpha", _wrap_clearAlpha},
    { "drawTriangle", _wrap_drawTriangle},
    { "drawCircle", _wrap_drawCircle},
    { "drawEllipse", _wrap_drawEllipse},
    { "drawLine", _wrap_drawLine},
    { "drawRectangle", _wrap_drawRectangle},
    { "drawRectRounded", _wrap_drawRectRounded},
    { "drawCurve", _wrap_drawCurve},
    { "drawBezier", _wrap_drawBezier},
    { "beginShape", _wrap_beginShape},
    { "vertex", _wrap_vertex},
    { "vertices", _wrap_vertices},
    { "curveVertex", _wrap_curveVertex},
    { "curveVertices", _wrap_curveVertices},
    { "bezierVertex", _wrap_bezierVertex},
    { "endShape", _wrap_endShape},
    { "nextContour", _wrap_nextContour},
    { "setDrawBitmapMode", _wrap_setDrawBitmapMode},
    { "drawBitmapStringHighlight", _wrap_drawBitmapStringHighlight},
    { "setupGraphicDefaults", _wrap_setupGraphicDefaults},
    { "setupScreen", _wrap_setupScreen},
    { "getRectMode", _wrap_getRectMode},
    { "setCircleResolution", _wrap_setCircleResolution},
    { "setCurveResolution", _wrap_setCurveResolution},
    { "setLineWidth", _wrap_setLineWidth},
    { "setDepthTest", _wrap_setDepthTest},
    { "enableDepthTest", _wrap_enableDepthTest},
    { "disableDepthTest", _wrap_disableDepthTest},
    { "enableBlendMode", _wrap_enableBlendMode},
    { "disableBlendMode", _wrap_disableBlendMode},
    { "enablePointSprites", _wrap_enablePointSprites},
    { "disablePointSprites", _wrap_disablePointSprites},
    { "enableAlphaBlending", _wrap_enableAlphaBlending},
    { "disableAlphaBlending", _wrap_disableAlphaBlending},
    { "enableSmoothing", _wrap_enableSmoothing},
    { "disableSmoothing", _wrap_disableSmoothing},
    { "enableAntiAliasing", _wrap_enableAntiAliasing},
    { "disableAntiAliasing", _wrap_disableAntiAliasing},
    { "getStyle", _wrap_getStyle},
    { "setStyle", _wrap_setStyle},
    { "pushStyle", _wrap_pushStyle},
    { "popStyle", _wrap_popStyle},
    { "setPolyMode", _wrap_setPolyMode},
    { "setRectMode", _wrap_setRectMode},
    { "pushMatrix", _wrap_pushMatrix},
    { "popMatrix", _wrap_popMatrix},
    { "getCurrentMatrix", _wrap_getCurrentMatrix},
    { "getCurrentOrientationMatrix", _wrap_getCurrentOrientationMatrix},
    { "getCurrentNormalMatrix", _wrap_getCurrentNormalMatrix},
    { "translate", _wrap_translate},
    { "scale", _wrap_scale},
    { "rotateDeg", _wrap_rotateDeg},
    { "rotateXDeg", _wrap_rotateXDeg},
    { "rotateYDeg", _wrap_rotateYDeg},
    { "rotateZDeg", _wrap_rotateZDeg},
    { "rotateRad", _wrap_rotateRad},
    { "rotateXRad", _wrap_rotateXRad},
    { "rotateYRad", _wrap_rotateYRad},
    { "rotateZRad", _wrap_rotateZRad},
    { "loadIdentityMatrix", _wrap_loadIdentityMatrix},
    { "loadMatrix", _wrap_loadMatrix},
    { "multMatrix", _wrap_multMatrix},
    { "setMatrixMode", _wrap_setMatrixMode},
    { "loadViewMatrix", _wrap_loadViewMatrix},
    { "multViewMatrix", _wrap_multViewMatrix},
    { "getCurrentViewMatrix", _wrap_getCurrentViewMatrix},
    { "pushView", _wrap_pushView},
    { "popView", _wrap_popView},
    { "isVFlipped", _wrap_isVFlipped},
    { "viewport", _wrap_viewport},
    { "getCurrentViewport", _wrap_getCurrentViewport},
    { "getNativeViewport", _wrap_getNativeViewport},
    { "getViewportWidth", _wrap_getViewportWidth},
    { "getViewportHeight", _wrap_getViewportHeight},
    { "setupScreenPerspective", _wrap_setupScreenPerspective},
    { "setupScreenOrtho", _wrap_setupScreenOrtho},
    { "orientationToDegrees", _wrap_orientationToDegrees},
    { "setCoordHandedness", _wrap_setCoordHandedness},
    { "getCoordHandedness", _wrap_getCoordHandedness},
    { "beginSaveScreenAsPDF", _wrap_beginSaveScreenAsPDF},
    { "endSaveScreenAsPDF", _wrap_endSaveScreenAsPDF},
    { "beginSaveScreenAsSVG", _wrap_beginSaveScreenAsSVG},
    { "endSaveScreenAsSVG", _wrap_endSaveScreenAsSVG},
    { "setPlaneResolution", _wrap_setPlaneResolution},
    { "getPlaneResolution", _wrap_getPlaneResolution},
    { "drawPlane", _wrap_drawPlane},
    { "setSphereResolution", _wrap_setSphereResolution},
    { "getSphereResolution", _wrap_getSphereResolution},
    { "drawSphere", _wrap_drawSphere},
    { "setIcoSphereResolution", _wrap_setIcoSphereResolution},
    { "getIcoSphereResolution", _wrap_getIcoSphereResolution},
    { "drawIcoSphere", _wrap_drawIcoSphere},
    { "setCylinderResolution", _wrap_setCylinderResolution},
    { "getCylinderResolution", _wrap_getCylinderResolution},
    { "drawCylinder", _wrap_drawCylinder},
    { "setConeResolution", _wrap_setConeResolution},
    { "getConeResolution", _wrap_getConeResolution},
    { "drawCone", _wrap_drawCone},
    { "setBoxResolution", _wrap_setBoxResolution},
    { "getBoxResolution", _wrap_getBoxResolution},
    { "drawBox", _wrap_drawBox},
    { "TrueTypeFont_setGlobalDpi", _wrap_TrueTypeFont_setGlobalDpi},
    { "soundStreamSetup", _wrap_soundStreamSetup},
    { "soundStreamStop", _wrap_soundStreamStop},
    { "soundStreamStart", _wrap_soundStreamStart},
    { "soundStreamClose", _wrap_soundStreamClose},
    { "soundStreamListDevices", _wrap_soundStreamListDevices},
    { "Color_fromHsb", _wrap_Color_fromHsb},
    { "Color_fromHex", _wrap_Color_fromHex},
    { "Color_limit", _wrap_Color_limit},
    { "FloatColor_fromHsb", _wrap_FloatColor_fromHsb},
    { "FloatColor_fromHex", _wrap_FloatColor_fromHex},
    { "FloatColor_limit", _wrap_FloatColor_limit},
    { "ShortColor_fromHsb", _wrap_ShortColor_fromHsb},
    { "ShortColor_fromHex", _wrap_ShortColor_fromHex},
    { "ShortColor_limit", _wrap_ShortColor_limit},
    { "serialize", _wrap_serialize},
    { "deserialize", _wrap_deserialize},
    { "bufferFromFile", _wrap_bufferFromFile},
    { "bufferToFile", _wrap_bufferToFile},
    { "FilePath_getFileExt", _wrap_FilePath_getFileExt},
    { "FilePath_removeExt", _wrap_FilePath_removeExt},
    { "FilePath_addLeadingSlash", _wrap_FilePath_addLeadingSlash},
    { "FilePath_addTrailingSlash", _wrap_FilePath_addTrailingSlash},
    { "FilePath_removeTrailingSlash", _wrap_FilePath_removeTrailingSlash},
    { "FilePath_getPathForDirectory", _wrap_FilePath_getPathForDirectory},
    { "FilePath_getAbsolutePath", _wrap_FilePath_getAbsolutePath},
    { "FilePath_isAbsolute", _wrap_FilePath_isAbsolute},
    { "FilePath_getFileName", _wrap_FilePath_getFileName},
    { "FilePath_getBaseName", _wrap_FilePath_getBaseName},
    { "FilePath_getEnclosingDirectory", _wrap_FilePath_getEnclosingDirectory},
    { "FilePath_createEnclosingDirectory", _wrap_FilePath_createEnclosingDirectory},
    { "FilePath_getCurrentWorkingDirectory", _wrap_FilePath_getCurrentWorkingDirectory},
    { "FilePath_join", _wrap_FilePath_join},
    { "FilePath_getCurrentExePath", _wrap_FilePath_getCurrentExePath},
    { "FilePath_getCurrentExeDir", _wrap_FilePath_getCurrentExeDir},
    { "FilePath_getUserHomeDir", _wrap_FilePath_getUserHomeDir},
    { "FilePath_makeRelative", _wrap_FilePath_makeRelative},
    { "File_copyFromTo", _wrap_File_copyFromTo},
    { "File_moveFromTo", _wrap_File_moveFromTo},
    { "File_doesFileExist", _wrap_File_doesFileExist},
    { "File_removeFile", _wrap_File_removeFile},
    { "Directory_createDirectory", _wrap_Directory_createDirectory},
    { "Directory_isDirectoryEmpty", _wrap_Directory_isDirectoryEmpty},
    { "Directory_doesDirectoryExist", _wrap_Directory_doesDirectoryExist},
    { "Directory_removeDirectory", _wrap_Directory_removeDirectory},
    { "log", _wrap_log},
    { "setLogLevel", _wrap_setLogLevel},
    { "getLogLevel", _wrap_getLogLevel},
    { "getLogLevelName", _wrap_getLogLevelName},
    { "logToFile", _wrap_logToFile},
    { "logToConsole", _wrap_logToConsole},
    { "getLoggerChannel", _wrap_getLoggerChannel},
    { "systemAlertDialog", _wrap_systemAlertDialog},
    { "systemLoadDialog", _wrap_systemLoadDialog},
    { "systemSaveDialog", _wrap_systemSaveDialog},
    { "systemTextBoxDialog", _wrap_systemTextBoxDialog},
    { "loadURL", _wrap_loadURL},
    { "loadURLAsync", _wrap_loadURLAsync},
    { "saveURLTo", _wrap_saveURLTo},
    { "saveURLAsync", _wrap_saveURLAsync},
    { "removeURLRequest", _wrap_removeURLRequest},
    { "removeAllURLRequests", _wrap_removeAllURLRequests},
    { "stopURLLoader", _wrap_stopURLLoader},
    {0,0}
};
static swig_lua_class* swig_SwigModule_classes[]= {
&_wrap_class_string,
&_wrap_class_path,
&_wrap_class_IntVector,
&_wrap_class_FloatVector,
&_wrap_class_StringVector,
&_wrap_class_UCharVector,
&_wrap_class_VideoDeviceVector,
&_wrap_class_TextureVector,
&_wrap_class_Fbo,
&_wrap_class_TextureData,
&_wrap_class_Texture,
&_wrap_class_ImageLoadSettings,
&_wrap_class_Image,
&_wrap_class_FloatImage,
&_wrap_class_ShortImage,
&_wrap_class_Style,
&_wrap_class_SoundDevice,
&_wrap_class_SoundStreamSettings,
&_wrap_class_BaseSoundStream,
&_wrap_class_BaseSoundPlayer,
&_wrap_class_VideoFormat,
&_wrap_class_VideoDevice,
&_wrap_class_Node,
&_wrap_class_Camera,
&_wrap_class_EasyCam,
&_wrap_class_Mesh,
&_wrap_class_3dPrimitive,
&_wrap_class_PlanePrimitive,
&_wrap_class_SpherePrimitive,
&_wrap_class_IcoSpherePrimitive,
&_wrap_class_CylinderPrimitive,
&_wrap_class_ConePrimitive,
&_wrap_class_BoxPrimitive,
&_wrap_class_supportedPinTypes,
&_wrap_class_Firmata_I2C_Data,
&_wrap_class_Firmata_Encoder_Data,
&_wrap_class_Firmata_Stepper_Data,
&_wrap_class_Firmata_Serial_Data,
&_wrap_class_Arduino,
&_wrap_class_SerialDeviceInfo,
&_wrap_class_Serial,
&_wrap_class_Matrix3x3,
&_wrap_class_Matrix4x4,
&_wrap_class_Quaternion,
&_wrap_class_Vec2f,
&_wrap_class_Vec3f,
&_wrap_class_Vec4f,
&_wrap_class_vec2,
&_wrap_class_DragInfo,
&_wrap_class_TouchEventArgs,
&_wrap_class_BufferObject,
&_wrap_class_Light,
&_wrap_class_Material,
&_wrap_class_Shader,
&_wrap_class_Vbo,
&_wrap_class_VboMesh,
&_wrap_class_Pixels,
&_wrap_class_FloatPixels,
&_wrap_class_ShortPixels,
&_wrap_class_PolylineVector,
&_wrap_class_TrueTypeFont,
&_wrap_class_SoundStream,
&_wrap_class_SoundPlayer,
&_wrap_class_Color,
&_wrap_class_FloatColor,
&_wrap_class_ShortColor,
&_wrap_class_Rectangle,
&_wrap_class_FpsCounter,
&_wrap_class_Xml,
&_wrap_class_MatrixStack,
&_wrap_class_Buffer,
&_wrap_class_FilePath,
&_wrap_class_File,
&_wrap_class_Directory,
&_wrap_class_FileDialogResult,
&_wrap_class_HttpRequest,
&_wrap_class_HttpResponse,
&_wrap_class_URLFileLoader,
&_wrap_class_VideoGrabber,
&_wrap_class_VideoPlayer,
    0
};
static swig_lua_namespace* swig_SwigModule_namespaces[] = {
    0
};

static swig_lua_namespace swig_SwigModule = {
    "of",
    swig_SwigModule_methods,
    swig_SwigModule_attributes,
    swig_SwigModule_constants,
    swig_SwigModule_classes,
    swig_SwigModule_namespaces
};
#ifdef __cplusplus
}
#endif

/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */

static void *_p_ofImage_T_unsigned_char_tTo_p_ofBaseImage_T_unsigned_char_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ofBaseImage_< unsigned char > *)  ((ofImage_< unsigned char > *) x));
}
static void *_p_ofImage_T_float_tTo_p_ofBaseImage_T_float_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ofBaseImage_< float > *)  ((ofImage_< float > *) x));
}
static void *_p_ofMaterialTo_p_ofBaseMaterial(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ofBaseMaterial *)  ((ofMaterial *) x));
}
static void *_p_ofSoundPlayerTo_p_ofBaseSoundPlayer(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ofBaseSoundPlayer *)  ((ofSoundPlayer *) x));
}
static void *_p_ofEasyCamTo_p_ofCamera(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ofCamera *)  ((ofEasyCam *) x));
}
static void *_p_ofPlanePrimitiveTo_p_of3dPrimitive(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((of3dPrimitive *)  ((ofPlanePrimitive *) x));
}
static void *_p_ofSpherePrimitiveTo_p_of3dPrimitive(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((of3dPrimitive *)  ((ofSpherePrimitive *) x));
}
static void *_p_ofIcoSpherePrimitiveTo_p_of3dPrimitive(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((of3dPrimitive *)  ((ofIcoSpherePrimitive *) x));
}
static void *_p_ofCylinderPrimitiveTo_p_of3dPrimitive(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((of3dPrimitive *)  ((ofCylinderPrimitive *) x));
}
static void *_p_ofConePrimitiveTo_p_of3dPrimitive(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((of3dPrimitive *)  ((ofConePrimitive *) x));
}
static void *_p_ofBoxPrimitiveTo_p_of3dPrimitive(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((of3dPrimitive *)  ((ofBoxPrimitive *) x));
}
static void *_p_ofVideoPlayerTo_p_ofBaseVideoPlayer(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ofBaseVideoPlayer *)  ((ofVideoPlayer *) x));
}
static void *_p_of3dPrimitiveTo_p_ofNode(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ofNode *)  ((of3dPrimitive *) x));
}
static void *_p_ofPlanePrimitiveTo_p_ofNode(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ofNode *) (of3dPrimitive *) ((ofPlanePrimitive *) x));
}
static void *_p_ofSpherePrimitiveTo_p_ofNode(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ofNode *) (of3dPrimitive *) ((ofSpherePrimitive *) x));
}
static void *_p_ofIcoSpherePrimitiveTo_p_ofNode(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ofNode *) (of3dPrimitive *) ((ofIcoSpherePrimitive *) x));
}
static void *_p_ofCylinderPrimitiveTo_p_ofNode(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ofNode *) (of3dPrimitive *) ((ofCylinderPrimitive *) x));
}
static void *_p_ofConePrimitiveTo_p_ofNode(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ofNode *) (of3dPrimitive *) ((ofConePrimitive *) x));
}
static void *_p_ofBoxPrimitiveTo_p_ofNode(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ofNode *) (of3dPrimitive *) ((ofBoxPrimitive *) x));
}
static void *_p_ofEasyCamTo_p_ofNode(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ofNode *) (ofCamera *) ((ofEasyCam *) x));
}
static void *_p_ofLightTo_p_ofNode(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ofNode *)  ((ofLight *) x));
}
static void *_p_ofCameraTo_p_ofNode(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ofNode *)  ((ofCamera *) x));
}
static void *_p_ofConsoleLoggerChannelTo_p_ofBaseLoggerChannel(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ofBaseLoggerChannel *)  ((ofConsoleLoggerChannel *) x));
}
static void *_p_ofFileLoggerChannelTo_p_ofBaseLoggerChannel(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ofBaseLoggerChannel *)  ((ofFileLoggerChannel *) x));
}
static void *_p_ofBaseVideoDrawsTo_p_ofBaseVideo(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ofBaseVideo *)  ((ofBaseVideoDraws *) x));
}
static void *_p_ofBaseVideoGrabberTo_p_ofBaseVideo(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ofBaseVideo *)  ((ofBaseVideoGrabber *) x));
}
static void *_p_ofVideoGrabberTo_p_ofBaseVideo(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ofBaseVideo *) (ofBaseVideoGrabber *) ((ofVideoGrabber *) x));
}
static void *_p_ofBaseVideoPlayerTo_p_ofBaseVideo(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ofBaseVideo *)  ((ofBaseVideoPlayer *) x));
}
static void *_p_ofVideoPlayerTo_p_ofBaseVideo(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ofBaseVideo *) (ofBaseVideoPlayer *) ((ofVideoPlayer *) x));
}
static void *_p_ofMouseEventArgsTo_p_glm__vec2(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((glm::vec2 *)  ((ofMouseEventArgs *) x));
}
static void *_p_ofTouchEventArgsTo_p_glm__vec2(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((glm::vec2 *)  ((ofTouchEventArgs *) x));
}
static void *_p_ofWindowPosEventArgsTo_p_glm__vec2(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((glm::vec2 *)  ((ofWindowPosEventArgs *) x));
}
static void *_p_ofFileTo_p_std__fstream(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::fstream *)  ((ofFile *) x));
}
static void *_p_ofFboTo_p_ofBaseHasTexture(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ofBaseHasTexture *)  ((ofFbo *) x));
}
static void *_p_ofKeyEventArgsTo_p_ofEventArgs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ofEventArgs *)  ((ofKeyEventArgs *) x));
}
static void *_p_ofMouseEventArgsTo_p_ofEventArgs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ofEventArgs *)  ((ofMouseEventArgs *) x));
}
static void *_p_ofTouchEventArgsTo_p_ofEventArgs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ofEventArgs *)  ((ofTouchEventArgs *) x));
}
static void *_p_ofResizeEventArgsTo_p_ofEventArgs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ofEventArgs *)  ((ofResizeEventArgs *) x));
}
static void *_p_ofWindowPosEventArgsTo_p_ofEventArgs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ofEventArgs *)  ((ofWindowPosEventArgs *) x));
}
static void *_p_ofMessageTo_p_ofEventArgs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ofEventArgs *)  ((ofMessage *) x));
}
static void *_p_ofBaseVideoDrawsTo_p_ofBaseDraws(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ofBaseDraws *)  ((ofBaseVideoDraws *) x));
}
static void *_p_ofVideoGrabberTo_p_ofBaseDraws(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ofBaseDraws *) (ofBaseVideoDraws *) ((ofVideoGrabber *) x));
}
static void *_p_ofTextureTo_p_ofBaseDraws(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ofBaseDraws *)  ((ofTexture *) x));
}
static void *_p_ofFboTo_p_ofBaseDraws(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ofBaseDraws *)  ((ofFbo *) x));
}
static void *_p_ofVideoPlayerTo_p_ofBaseDraws(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ofBaseDraws *) (ofBaseVideoDraws *) ((ofVideoPlayer *) x));
}
static void *_p_ofVboMeshTo_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *)  ((ofVboMesh *) x));
}
static void *_p_ofVideoGrabberTo_p_ofBaseVideoGrabber(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ofBaseVideoGrabber *)  ((ofVideoGrabber *) x));
}
static void *_p_ofVideoGrabberTo_p_ofBaseVideoDraws(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ofBaseVideoDraws *)  ((ofVideoGrabber *) x));
}
static void *_p_ofVideoPlayerTo_p_ofBaseVideoDraws(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ofBaseVideoDraws *)  ((ofVideoPlayer *) x));
}
static void *_p_ofLogErrorTo_p_ofLog(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ofLog *)  ((ofLogError *) x));
}
static void *_p_ofLogNoticeTo_p_ofLog(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ofLog *)  ((ofLogNotice *) x));
}
static void *_p_ofLogFatalErrorTo_p_ofLog(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ofLog *)  ((ofLogFatalError *) x));
}
static void *_p_ofLogVerboseTo_p_ofLog(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ofLog *)  ((ofLogVerbose *) x));
}
static void *_p_ofLogWarningTo_p_ofLog(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ofLog *)  ((ofLogWarning *) x));
}
static void *_p_ofBaseVideoDrawsTo_p_ofBaseHasPixels(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ofBaseHasPixels *) (ofBaseVideo *) ((ofBaseVideoDraws *) x));
}
static void *_p_ofBaseVideoGrabberTo_p_ofBaseHasPixels(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ofBaseHasPixels *) (ofBaseVideo *) ((ofBaseVideoGrabber *) x));
}
static void *_p_ofVideoGrabberTo_p_ofBaseHasPixels(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ofBaseHasPixels *) (ofBaseVideo *)(ofBaseVideoGrabber *) ((ofVideoGrabber *) x));
}
static void *_p_ofBaseVideoTo_p_ofBaseHasPixels(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ofBaseHasPixels *)  ((ofBaseVideo *) x));
}
static void *_p_ofBaseVideoPlayerTo_p_ofBaseHasPixels(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ofBaseHasPixels *) (ofBaseVideo *) ((ofBaseVideoPlayer *) x));
}
static void *_p_ofVideoPlayerTo_p_ofBaseHasPixels(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ofBaseHasPixels *) (ofBaseVideo *)(ofBaseVideoPlayer *) ((ofVideoPlayer *) x));
}
static void *_p_ofImage_T_unsigned_short_tTo_p_ofBaseImage_T_unsigned_short_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ofBaseImage_< unsigned short > *)  ((ofImage_< unsigned short > *) x));
}
static void *_p_ofBaseVideoDrawsTo_p_ofBaseUpdates(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ofBaseUpdates *) (ofBaseVideo *) ((ofBaseVideoDraws *) x));
}
static void *_p_ofBaseVideoGrabberTo_p_ofBaseUpdates(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ofBaseUpdates *) (ofBaseVideo *) ((ofBaseVideoGrabber *) x));
}
static void *_p_ofVideoGrabberTo_p_ofBaseUpdates(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ofBaseUpdates *) (ofBaseVideo *)(ofBaseVideoGrabber *) ((ofVideoGrabber *) x));
}
static void *_p_ofBaseVideoTo_p_ofBaseUpdates(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ofBaseUpdates *)  ((ofBaseVideo *) x));
}
static void *_p_ofBaseVideoPlayerTo_p_ofBaseUpdates(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ofBaseUpdates *) (ofBaseVideo *) ((ofBaseVideoPlayer *) x));
}
static void *_p_ofVideoPlayerTo_p_ofBaseUpdates(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ofBaseUpdates *) (ofBaseVideo *)(ofBaseVideoPlayer *) ((ofVideoPlayer *) x));
}
static swig_type_info _swigt__p_Firmata_Encoder_Data = {"_p_Firmata_Encoder_Data", "Firmata_Encoder_Data *", 0, 0, (void*)&_wrap_class_Firmata_Encoder_Data, 0};
static swig_type_info _swigt__p_Firmata_I2C_Data = {"_p_Firmata_I2C_Data", "Firmata_I2C_Data *", 0, 0, (void*)&_wrap_class_Firmata_I2C_Data, 0};
static swig_type_info _swigt__p_Firmata_Serial_Data = {"_p_Firmata_Serial_Data", "Firmata_Serial_Data *", 0, 0, (void*)&_wrap_class_Firmata_Serial_Data, 0};
static swig_type_info _swigt__p_Firmata_Stepper_Data = {"_p_Firmata_Stepper_Data", "Firmata_Stepper_Data *", 0, 0, (void*)&_wrap_class_Firmata_Stepper_Data, 0};
static swig_type_info _swigt__p_GLintptr = {"_p_GLintptr", "GLintptr *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_GLsizei = {"_p_GLsizei", "GLsizei *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_GLsizeiptr = {"_p_GLsizeiptr", "GLsizeiptr *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_TESSindex = {"_p_TESSindex", "ofIndexType *|TESSindex *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p__XDisplay = {"_p__XDisplay", "_XDisplay *|Display *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_boost__filesystem__path = {"_p_boost__filesystem__path", "boost::filesystem::path *|std::filesystem::path *", 0, 0, (void*)&_wrap_class_path, 0};
static swig_type_info _swigt__p_double = {"_p_double", "double *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_float = {"_p_float", "float *|GLfloat *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_glm__mat3 = {"_p_glm__mat3", "glm::mat3 *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_glm__mat4 = {"_p_glm__mat4", "glm::mat4 *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_glm__quat = {"_p_glm__quat", "glm::quat *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_glm__tvec2T_int_glm__precision__defaultp_t = {"_p_glm__tvec2T_int_glm__precision__defaultp_t", "glm::tvec2< int,glm::precision::defaultp > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_glm__tvec3T_int_glm__precision__defaultp_t = {"_p_glm__tvec3T_int_glm__precision__defaultp_t", "glm::tvec3< int,glm::precision::defaultp > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_glm__tvec4T_int_glm__precision__defaultp_t = {"_p_glm__tvec4T_int_glm__precision__defaultp_t", "glm::tvec4< int,glm::precision::defaultp > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_glm__vec2 = {"_p_glm__vec2", "ofDefaultTexCoordType *|ofDefaultVec2 *|glm::vec2 *", 0, 0, (void*)&_wrap_class_vec2, 0};
static swig_type_info _swigt__p_ofMouseEventArgs = {"_p_ofMouseEventArgs", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_ofWindowPosEventArgs = {"_p_ofWindowPosEventArgs", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_glm__vec3 = {"_p_glm__vec3", "ofDefaultNormalType *|ofDefaultVertexType *|ofDefaultVec3 *|glm::vec3 *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_glm__vec4 = {"_p_glm__vec4", "ofDefaultVec4 *|glm::vec4 *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_int = {"_p_int", "int *|GLint *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_int16_t = {"_p_int16_t", "int16_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_int32_t = {"_p_int32_t", "int32_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_int8_t = {"_p_int8_t", "int8_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_long_long = {"_p_long_long", "int64_t *|long long *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_of3dPrimitive = {"_p_of3dPrimitive", "of3dPrimitive *", 0, 0, (void*)&_wrap_class_3dPrimitive, 0};
static swig_type_info _swigt__p_ofAbstractParameter = {"_p_ofAbstractParameter", "ofAbstractParameter *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ofAppBaseWindow = {"_p_ofAppBaseWindow", "ofAppBaseWindow *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ofArduino = {"_p_ofArduino", "ofArduino *|ofStandardFirmata *", 0, 0, (void*)&_wrap_class_Arduino, 0};
static swig_type_info _swigt__p_ofBaseDraws = {"_p_ofBaseDraws", "ofBaseDraws *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ofBaseHasPixels = {"_p_ofBaseHasPixels", "ofBaseHasPixels *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ofBaseHasTexture = {"_p_ofBaseHasTexture", "ofBaseHasTexture *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ofBaseImage_T_float_t = {"_p_ofBaseImage_T_float_t", "ofBaseImage_< float > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ofBaseImage_T_unsigned_char_t = {"_p_ofBaseImage_T_unsigned_char_t", "ofBaseImage_< unsigned char > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ofBaseImage_T_unsigned_short_t = {"_p_ofBaseImage_T_unsigned_short_t", "ofBaseImage_< unsigned short > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ofBaseLoggerChannel = {"_p_ofBaseLoggerChannel", "ofBaseLoggerChannel *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ofConsoleLoggerChannel = {"_p_ofConsoleLoggerChannel", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_ofFileLoggerChannel = {"_p_ofFileLoggerChannel", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_ofBaseMaterial = {"_p_ofBaseMaterial", "ofBaseMaterial *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ofBaseRenderer = {"_p_ofBaseRenderer", "ofBaseRenderer *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ofBaseSoundInput = {"_p_ofBaseSoundInput", "ofBaseSoundInput *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ofBaseSoundOutput = {"_p_ofBaseSoundOutput", "ofBaseSoundOutput *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ofBaseSoundPlayer = {"_p_ofBaseSoundPlayer", "ofBaseSoundPlayer *", 0, 0, (void*)&_wrap_class_BaseSoundPlayer, 0};
static swig_type_info _swigt__p_ofBaseSoundStream = {"_p_ofBaseSoundStream", "ofBaseSoundStream *", 0, 0, (void*)&_wrap_class_BaseSoundStream, 0};
static swig_type_info _swigt__p_ofBaseUpdates = {"_p_ofBaseUpdates", "ofBaseUpdates *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ofBaseVideo = {"_p_ofBaseVideo", "ofBaseVideo *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ofBaseVideoDraws = {"_p_ofBaseVideoDraws", "ofBaseVideoDraws *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ofBaseVideoGrabber = {"_p_ofBaseVideoGrabber", "ofBaseVideoGrabber *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ofBaseVideoPlayer = {"_p_ofBaseVideoPlayer", "ofBaseVideoPlayer *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ofBoxPrimitive = {"_p_ofBoxPrimitive", "ofBoxPrimitive *", 0, 0, (void*)&_wrap_class_BoxPrimitive, 0};
static swig_type_info _swigt__p_ofBuffer = {"_p_ofBuffer", "ofBuffer *", 0, 0, (void*)&_wrap_class_Buffer, 0};
static swig_type_info _swigt__p_ofBufferObject = {"_p_ofBufferObject", "ofBufferObject *", 0, 0, (void*)&_wrap_class_BufferObject, 0};
static swig_type_info _swigt__p_ofCamera = {"_p_ofCamera", "ofCamera *", 0, 0, (void*)&_wrap_class_Camera, 0};
static swig_type_info _swigt__p_ofColor_T_float_t = {"_p_ofColor_T_float_t", "ofDefaultColorType *|ofColor_< float > *|ofFloatColor *", 0, 0, (void*)&_wrap_class_FloatColor, 0};
static swig_type_info _swigt__p_ofColor_T_unsigned_char_t = {"_p_ofColor_T_unsigned_char_t", "ofColor_< unsigned char > *|ofColor *", 0, 0, (void*)&_wrap_class_Color, 0};
static swig_type_info _swigt__p_ofColor_T_unsigned_short_t = {"_p_ofColor_T_unsigned_short_t", "ofColor_< unsigned short > *|ofShortColor *", 0, 0, (void*)&_wrap_class_ShortColor, 0};
static swig_type_info _swigt__p_ofConePrimitive = {"_p_ofConePrimitive", "ofConePrimitive *", 0, 0, (void*)&_wrap_class_ConePrimitive, 0};
static swig_type_info _swigt__p_ofCoreEvents = {"_p_ofCoreEvents", "ofCoreEvents *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ofCylinderPrimitive = {"_p_ofCylinderPrimitive", "ofCylinderPrimitive *", 0, 0, (void*)&_wrap_class_CylinderPrimitive, 0};
static swig_type_info _swigt__p_ofDirectory = {"_p_ofDirectory", "ofDirectory *", 0, 0, (void*)&_wrap_class_Directory, 0};
static swig_type_info _swigt__p_ofDragInfo = {"_p_ofDragInfo", "ofDragInfo *", 0, 0, (void*)&_wrap_class_DragInfo, 0};
static swig_type_info _swigt__p_ofEasyCam = {"_p_ofEasyCam", "ofEasyCam *", 0, 0, (void*)&_wrap_class_EasyCam, 0};
static swig_type_info _swigt__p_ofEventArgs = {"_p_ofEventArgs", "ofEventArgs *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ofKeyEventArgs = {"_p_ofKeyEventArgs", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_ofResizeEventArgs = {"_p_ofResizeEventArgs", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_ofMessage = {"_p_ofMessage", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_ofEventT_Firmata_I2C_Data_const_t = {"_p_ofEventT_Firmata_I2C_Data_const_t", "ofEvent< Firmata_I2C_Data const > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ofEventT_Firmata_Serial_Data_const_t = {"_p_ofEventT_Firmata_Serial_Data_const_t", "ofEvent< Firmata_Serial_Data const > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ofEventT_Firmata_Stepper_Data_const_t = {"_p_ofEventT_Firmata_Stepper_Data_const_t", "ofEvent< Firmata_Stepper_Data const > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ofEventT_int_const_t = {"_p_ofEventT_int_const_t", "ofEvent< int const > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ofEventT_std__pairT_int_Firmata_Pin_Modes_t_const_t = {"_p_ofEventT_std__pairT_int_Firmata_Pin_Modes_t_const_t", "ofEvent< std::pair< int,enum Firmata_Pin_Modes > const > *|ofEvent< std::pair< int,Firmata_Pin_Modes > const > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ofEventT_std__string_const_t = {"_p_ofEventT_std__string_const_t", "ofEvent< std::string const > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ofEventT_std__vectorT_Firmata_Encoder_Data_t_const_t = {"_p_ofEventT_std__vectorT_Firmata_Encoder_Data_t_const_t", "ofEvent< std::vector< Firmata_Encoder_Data > const > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ofEventT_std__vectorT_unsigned_char_t_const_t = {"_p_ofEventT_std__vectorT_unsigned_char_t_const_t", "ofEvent< std::vector< unsigned char > const > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ofFbo = {"_p_ofFbo", "ofFbo *", 0, 0, (void*)&_wrap_class_Fbo, 0};
static swig_type_info _swigt__p_ofFile = {"_p_ofFile", "ofFile *", 0, 0, (void*)&_wrap_class_File, 0};
static swig_type_info _swigt__p_ofFileDialogResult = {"_p_ofFileDialogResult", "ofFileDialogResult *", 0, 0, (void*)&_wrap_class_FileDialogResult, 0};
static swig_type_info _swigt__p_ofFilePath = {"_p_ofFilePath", "ofFilePath *", 0, 0, (void*)&_wrap_class_FilePath, 0};
static swig_type_info _swigt__p_ofFpsCounter = {"_p_ofFpsCounter", "ofFpsCounter *", 0, 0, (void*)&_wrap_class_FpsCounter, 0};
static swig_type_info _swigt__p_ofHttpRequest = {"_p_ofHttpRequest", "ofHttpRequest *", 0, 0, (void*)&_wrap_class_HttpRequest, 0};
static swig_type_info _swigt__p_ofHttpResponse = {"_p_ofHttpResponse", "ofHttpResponse *", 0, 0, (void*)&_wrap_class_HttpResponse, 0};
static swig_type_info _swigt__p_ofIcoSpherePrimitive = {"_p_ofIcoSpherePrimitive", "ofIcoSpherePrimitive *", 0, 0, (void*)&_wrap_class_IcoSpherePrimitive, 0};
static swig_type_info _swigt__p_ofImageLoadSettings = {"_p_ofImageLoadSettings", "ofImageLoadSettings *", 0, 0, (void*)&_wrap_class_ImageLoadSettings, 0};
static swig_type_info _swigt__p_ofImage_T_float_t = {"_p_ofImage_T_float_t", "ofFloatImage *|ofImage_< float > *", 0, 0, (void*)&_wrap_class_FloatImage, 0};
static swig_type_info _swigt__p_ofImage_T_unsigned_char_t = {"_p_ofImage_T_unsigned_char_t", "ofImage *|ofImage_< unsigned char > *", 0, 0, (void*)&_wrap_class_Image, 0};
static swig_type_info _swigt__p_ofImage_T_unsigned_short_t = {"_p_ofImage_T_unsigned_short_t", "ofImage_< unsigned short > *|ofShortImage *", 0, 0, (void*)&_wrap_class_ShortImage, 0};
static swig_type_info _swigt__p_ofLight = {"_p_ofLight", "ofLight *", 0, 0, (void*)&_wrap_class_Light, 0};
static swig_type_info _swigt__p_ofLog = {"_p_ofLog", "ofLog *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ofLogError = {"_p_ofLogError", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_ofLogNotice = {"_p_ofLogNotice", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_ofLogFatalError = {"_p_ofLogFatalError", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_ofLogVerbose = {"_p_ofLogVerbose", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_ofLogWarning = {"_p_ofLogWarning", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_ofMaterial = {"_p_ofMaterial", "ofMaterial *", 0, 0, (void*)&_wrap_class_Material, 0};
static swig_type_info _swigt__p_ofMaterialSettings = {"_p_ofMaterialSettings", "ofMaterialSettings *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ofMatrix3x3 = {"_p_ofMatrix3x3", "ofMatrix3x3 *", 0, 0, (void*)&_wrap_class_Matrix3x3, 0};
static swig_type_info _swigt__p_ofMatrix4x4 = {"_p_ofMatrix4x4", "ofMatrix4x4 *", 0, 0, (void*)&_wrap_class_Matrix4x4, 0};
static swig_type_info _swigt__p_ofMatrixStack = {"_p_ofMatrixStack", "ofMatrixStack *", 0, 0, (void*)&_wrap_class_MatrixStack, 0};
static swig_type_info _swigt__p_ofMeshFace_T_glm__vec3_glm__vec3_ofColor_T_float_t_glm__vec2_t = {"_p_ofMeshFace_T_glm__vec3_glm__vec3_ofColor_T_float_t_glm__vec2_t", "ofMeshFace_< glm::vec3,glm::vec3,ofColor_< float >,glm::vec2 > *|ofMeshFace *|ofMeshFace_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t = {"_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t", "ofMesh_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > *|ofMesh *", 0, 0, (void*)&_wrap_class_Mesh, 0};
static swig_type_info _swigt__p_ofNode = {"_p_ofNode", "ofNode *", 0, 0, (void*)&_wrap_class_Node, 0};
static swig_type_info _swigt__p_ofParameterGroup = {"_p_ofParameterGroup", "ofParameterGroup *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ofPath = {"_p_ofPath", "ofPath *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ofPixels_T_float_t = {"_p_ofPixels_T_float_t", "ofPixels_< float > *|ofFloatPixels *", 0, 0, (void*)&_wrap_class_FloatPixels, 0};
static swig_type_info _swigt__p_ofPixels_T_unsigned_char_t = {"_p_ofPixels_T_unsigned_char_t", "ofPixels_< unsigned char > *|ofPixels *", 0, 0, (void*)&_wrap_class_Pixels, 0};
static swig_type_info _swigt__p_ofPixels_T_unsigned_short_t = {"_p_ofPixels_T_unsigned_short_t", "ofPixels_< unsigned short > *|ofShortPixels *", 0, 0, (void*)&_wrap_class_ShortPixels, 0};
static swig_type_info _swigt__p_ofPlanePrimitive = {"_p_ofPlanePrimitive", "ofPlanePrimitive *", 0, 0, (void*)&_wrap_class_PlanePrimitive, 0};
static swig_type_info _swigt__p_ofPolyline_T_glm__vec3_t = {"_p_ofPolyline_T_glm__vec3_t", "ofPolyline *|ofPolyline_< glm::vec3 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ofQuaternion = {"_p_ofQuaternion", "ofQuaternion *", 0, 0, (void*)&_wrap_class_Quaternion, 0};
static swig_type_info _swigt__p_ofRectangle = {"_p_ofRectangle", "ofRectangle *", 0, 0, (void*)&_wrap_class_Rectangle, 0};
static swig_type_info _swigt__p_ofSerial = {"_p_ofSerial", "ofSerial *", 0, 0, (void*)&_wrap_class_Serial, 0};
static swig_type_info _swigt__p_ofSerialDeviceInfo = {"_p_ofSerialDeviceInfo", "ofSerialDeviceInfo *", 0, 0, (void*)&_wrap_class_SerialDeviceInfo, 0};
static swig_type_info _swigt__p_ofShader = {"_p_ofShader", "ofShader *", 0, 0, (void*)&_wrap_class_Shader, 0};
static swig_type_info _swigt__p_ofShaderSettings = {"_p_ofShaderSettings", "ofShaderSettings *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ofShader__TransformFeedbackSettings = {"_p_ofShader__TransformFeedbackSettings", "ofShader::TransformFeedbackSettings *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ofSoundDevice = {"_p_ofSoundDevice", "ofSoundDevice *", 0, 0, (void*)&_wrap_class_SoundDevice, 0};
static swig_type_info _swigt__p_ofSoundPlayer = {"_p_ofSoundPlayer", "ofSoundPlayer *", 0, 0, (void*)&_wrap_class_SoundPlayer, 0};
static swig_type_info _swigt__p_ofSoundStream = {"_p_ofSoundStream", "ofSoundStream *", 0, 0, (void*)&_wrap_class_SoundStream, 0};
static swig_type_info _swigt__p_ofSoundStreamSettings = {"_p_ofSoundStreamSettings", "ofSoundStreamSettings *", 0, 0, (void*)&_wrap_class_SoundStreamSettings, 0};
static swig_type_info _swigt__p_ofSpherePrimitive = {"_p_ofSpherePrimitive", "ofSpherePrimitive *", 0, 0, (void*)&_wrap_class_SpherePrimitive, 0};
static swig_type_info _swigt__p_ofStyle = {"_p_ofStyle", "ofStyle *", 0, 0, (void*)&_wrap_class_Style, 0};
static swig_type_info _swigt__p_ofTexture = {"_p_ofTexture", "ofTexture *", 0, 0, (void*)&_wrap_class_Texture, 0};
static swig_type_info _swigt__p_ofTextureData = {"_p_ofTextureData", "ofTextureData *", 0, 0, (void*)&_wrap_class_TextureData, 0};
static swig_type_info _swigt__p_ofTime = {"_p_ofTime", "ofTime *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ofTouchEventArgs = {"_p_ofTouchEventArgs", "ofTouchEventArgs *", 0, 0, (void*)&_wrap_class_TouchEventArgs, 0};
static swig_type_info _swigt__p_ofTrueTypeFont = {"_p_ofTrueTypeFont", "ofTrueTypeFont *", 0, 0, (void*)&_wrap_class_TrueTypeFont, 0};
static swig_type_info _swigt__p_ofURLFileLoader = {"_p_ofURLFileLoader", "ofURLFileLoader *", 0, 0, (void*)&_wrap_class_URLFileLoader, 0};
static swig_type_info _swigt__p_ofVbo = {"_p_ofVbo", "ofVbo *", 0, 0, (void*)&_wrap_class_Vbo, 0};
static swig_type_info _swigt__p_ofVboMesh = {"_p_ofVboMesh", "ofVboMesh *", 0, 0, (void*)&_wrap_class_VboMesh, 0};
static swig_type_info _swigt__p_ofVec2f = {"_p_ofVec2f", "ofVec2f *", 0, 0, (void*)&_wrap_class_Vec2f, 0};
static swig_type_info _swigt__p_ofVec3f = {"_p_ofVec3f", "ofPoint *|ofVec3f *", 0, 0, (void*)&_wrap_class_Vec3f, 0};
static swig_type_info _swigt__p_ofVec4f = {"_p_ofVec4f", "ofVec4f *", 0, 0, (void*)&_wrap_class_Vec4f, 0};
static swig_type_info _swigt__p_ofVideoDevice = {"_p_ofVideoDevice", "ofVideoDevice *", 0, 0, (void*)&_wrap_class_VideoDevice, 0};
static swig_type_info _swigt__p_ofVideoFormat = {"_p_ofVideoFormat", "ofVideoFormat *", 0, 0, (void*)&_wrap_class_VideoFormat, 0};
static swig_type_info _swigt__p_ofVideoGrabber = {"_p_ofVideoGrabber", "ofVideoGrabber *", 0, 0, (void*)&_wrap_class_VideoGrabber, 0};
static swig_type_info _swigt__p_ofVideoPlayer = {"_p_ofVideoPlayer", "ofVideoPlayer *", 0, 0, (void*)&_wrap_class_VideoPlayer, 0};
static swig_type_info _swigt__p_ofXml = {"_p_ofXml", "ofXml *", 0, 0, (void*)&_wrap_class_Xml, 0};
static swig_type_info _swigt__p_ofXml__Attribute = {"_p_ofXml__Attribute", "ofXml::Attribute *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ofXml__RangeT_ofXmlIteratorT_pugi__xml_attribute_iterator_t_t = {"_p_ofXml__RangeT_ofXmlIteratorT_pugi__xml_attribute_iterator_t_t", "ofXml::Range< ofXmlIterator< pugi::xml_attribute_iterator > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ofXml__RangeT_ofXmlIteratorT_pugi__xml_named_node_iterator_t_t = {"_p_ofXml__RangeT_ofXmlIteratorT_pugi__xml_named_node_iterator_t_t", "ofXml::Range< ofXmlIterator< pugi::xml_named_node_iterator > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ofXml__RangeT_ofXmlIteratorT_pugi__xml_node_iterator_t_t = {"_p_ofXml__RangeT_ofXmlIteratorT_pugi__xml_node_iterator_t_t", "ofXml::Range< ofXmlIterator< pugi::xml_node_iterator > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__fstream = {"_p_std__fstream", "std::fstream *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__functionT_void_fofHttpResponse_const_RF_t = {"_p_std__functionT_void_fofHttpResponse_const_RF_t", "std::function< void (ofHttpResponse const &) > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__functionT_void_fofSoundBuffer_RF_t = {"_p_std__functionT_void_fofSoundBuffer_RF_t", "std::function< void (ofSoundBuffer &) > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__istream = {"_p_std__istream", "std::istream *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__mapT_int_supportedPinTypes_t = {"_p_std__mapT_int_supportedPinTypes_t", "std::map< int,supportedPinTypes > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__mapT_std__string_std__string_t = {"_p_std__mapT_std__string_std__string_t", "std::map< std::string,std::string > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__shared_ptrT_ofBaseLoggerChannel_t = {"_p_std__shared_ptrT_ofBaseLoggerChannel_t", "std::shared_ptr< ofBaseLoggerChannel > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__shared_ptrT_ofBaseRenderer_t = {"_p_std__shared_ptrT_ofBaseRenderer_t", "std::shared_ptr< ofBaseRenderer > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__shared_ptrT_ofBaseSoundPlayer_t = {"_p_std__shared_ptrT_ofBaseSoundPlayer_t", "std::shared_ptr< ofBaseSoundPlayer > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__shared_ptrT_ofBaseSoundStream_t = {"_p_std__shared_ptrT_ofBaseSoundStream_t", "std::shared_ptr< ofBaseSoundStream > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__shared_ptrT_ofBaseVideoGrabber_t = {"_p_std__shared_ptrT_ofBaseVideoGrabber_t", "std::shared_ptr< ofBaseVideoGrabber > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__shared_ptrT_ofBaseVideoPlayer_t = {"_p_std__shared_ptrT_ofBaseVideoPlayer_t", "std::shared_ptr< ofBaseVideoPlayer > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__string = {"_p_std__string", "std::string *", 0, 0, (void*)&_wrap_class_string, 0};
static swig_type_info _swigt__p_std__vectorT_TESSindex_t = {"_p_std__vectorT_TESSindex_t", "std::vector< TESSindex > *|std::vector< ofIndexType > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_float_t = {"_p_std__vectorT_float_t", "std::vector< float > *", 0, 0, (void*)&_wrap_class_FloatVector, 0};
static swig_type_info _swigt__p_std__vectorT_glm__vec2_t = {"_p_std__vectorT_glm__vec2_t", "std::vector< glm::vec2 > *|std::vector< ofDefaultTexCoordType > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_glm__vec3_t = {"_p_std__vectorT_glm__vec3_t", "std::vector< glm::vec3 > *|std::vector< ofDefaultVertexType > *|std::vector< ofDefaultNormalType > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_int_t = {"_p_std__vectorT_int_t", "std::vector< int > *", 0, 0, (void*)&_wrap_class_IntVector, 0};
static swig_type_info _swigt__p_std__vectorT_ofColor_T_float_t_t = {"_p_std__vectorT_ofColor_T_float_t_t", "std::vector< ofColor_< float > > *|std::vector< ofDefaultColorType > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_ofFile_t = {"_p_std__vectorT_ofFile_t", "std::vector< ofFile > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_ofMeshFace_T_glm__vec3_glm__vec3_ofColor_T_float_t_glm__vec2_t_t = {"_p_std__vectorT_ofMeshFace_T_glm__vec3_glm__vec3_ofColor_T_float_t_glm__vec2_t_t", "std::vector< ofMeshFace_< ofDefaultVertexType,ofDefaultNormalType,ofDefaultColorType,ofDefaultTexCoordType > > *|std::vector< ofMeshFace_< glm::vec3,glm::vec3,ofColor_< float >,glm::vec2 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_ofPath_t = {"_p_std__vectorT_ofPath_t", "std::vector< ofPath > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_ofPolyline_T_ofDefaultVertexType_t_t = {"_p_std__vectorT_ofPolyline_T_ofDefaultVertexType_t_t", "std::vector< ofPolyline_< glm::vec3 > > *|std::vector< ofPolyline > *|std::vector< ofPolyline_< ofDefaultVertexType > > *", 0, 0, (void*)&_wrap_class_PolylineVector, 0};
static swig_type_info _swigt__p_std__vectorT_ofSerialDeviceInfo_t = {"_p_std__vectorT_ofSerialDeviceInfo_t", "std::vector< ofSerialDeviceInfo > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_ofSoundDevice_t = {"_p_std__vectorT_ofSoundDevice_t", "std::vector< ofSoundDevice > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_ofTexture_t = {"_p_std__vectorT_ofTexture_t", "std::vector< ofTexture > *", 0, 0, (void*)&_wrap_class_TextureVector, 0};
static swig_type_info _swigt__p_std__vectorT_ofVec2f_t = {"_p_std__vectorT_ofVec2f_t", "std::vector< ofVec2f > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_ofVec3f_t = {"_p_std__vectorT_ofVec3f_t", "std::vector< ofVec3f > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_ofVideoDevice_t = {"_p_std__vectorT_ofVideoDevice_t", "std::vector< ofVideoDevice > *", 0, 0, (void*)&_wrap_class_VideoDeviceVector, 0};
static swig_type_info _swigt__p_std__vectorT_ofVideoFormat_t = {"_p_std__vectorT_ofVideoFormat_t", "std::vector< ofVideoFormat > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_std__string_t = {"_p_std__vectorT_std__string_t", "std::vector< std::string > *", 0, 0, (void*)&_wrap_class_StringVector, 0};
static swig_type_info _swigt__p_std__vectorT_unsigned_char_t = {"_p_std__vectorT_unsigned_char_t", "std::vector< unsigned char > *", 0, 0, (void*)&_wrap_class_UCharVector, 0};
static swig_type_info _swigt__p_std__vectorT_unsigned_int_t = {"_p_std__vectorT_unsigned_int_t", "std::vector< unsigned int > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_supportedPinTypes = {"_p_supportedPinTypes", "supportedPinTypes *", 0, 0, (void*)&_wrap_class_supportedPinTypes, 0};
static swig_type_info _swigt__p_uint16_t = {"_p_uint16_t", "uint16_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_uint32_t = {"_p_uint32_t", "uint32_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_uint8_t = {"_p_uint8_t", "uint8_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_unsigned_char = {"_p_unsigned_char", "unsigned char *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_unsigned_int = {"_p_unsigned_int", "size_t *|unsigned int *|GLuint *|GLenum *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_unsigned_long = {"_p_unsigned_long", "Window *|unsigned long *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_unsigned_long_long = {"_p_unsigned_long_long", "uint64_t *|unsigned long long *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_unsigned_short = {"_p_unsigned_short", "unsigned short *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_void = {"_p_void", "void *", 0, 0, (void*)0, 0};

static swig_type_info *swig_type_initial[] = {
  &_swigt__p_Firmata_Encoder_Data,
  &_swigt__p_Firmata_I2C_Data,
  &_swigt__p_Firmata_Serial_Data,
  &_swigt__p_Firmata_Stepper_Data,
  &_swigt__p_GLintptr,
  &_swigt__p_GLsizei,
  &_swigt__p_GLsizeiptr,
  &_swigt__p_TESSindex,
  &_swigt__p__XDisplay,
  &_swigt__p_boost__filesystem__path,
  &_swigt__p_double,
  &_swigt__p_float,
  &_swigt__p_glm__mat3,
  &_swigt__p_glm__mat4,
  &_swigt__p_glm__quat,
  &_swigt__p_glm__tvec2T_int_glm__precision__defaultp_t,
  &_swigt__p_glm__tvec3T_int_glm__precision__defaultp_t,
  &_swigt__p_glm__tvec4T_int_glm__precision__defaultp_t,
  &_swigt__p_glm__vec2,
  &_swigt__p_glm__vec3,
  &_swigt__p_glm__vec4,
  &_swigt__p_int,
  &_swigt__p_int16_t,
  &_swigt__p_int32_t,
  &_swigt__p_int8_t,
  &_swigt__p_long_long,
  &_swigt__p_of3dPrimitive,
  &_swigt__p_ofAbstractParameter,
  &_swigt__p_ofAppBaseWindow,
  &_swigt__p_ofArduino,
  &_swigt__p_ofBaseDraws,
  &_swigt__p_ofBaseHasPixels,
  &_swigt__p_ofBaseHasTexture,
  &_swigt__p_ofBaseImage_T_float_t,
  &_swigt__p_ofBaseImage_T_unsigned_char_t,
  &_swigt__p_ofBaseImage_T_unsigned_short_t,
  &_swigt__p_ofBaseLoggerChannel,
  &_swigt__p_ofBaseMaterial,
  &_swigt__p_ofBaseRenderer,
  &_swigt__p_ofBaseSoundInput,
  &_swigt__p_ofBaseSoundOutput,
  &_swigt__p_ofBaseSoundPlayer,
  &_swigt__p_ofBaseSoundStream,
  &_swigt__p_ofBaseUpdates,
  &_swigt__p_ofBaseVideo,
  &_swigt__p_ofBaseVideoDraws,
  &_swigt__p_ofBaseVideoGrabber,
  &_swigt__p_ofBaseVideoPlayer,
  &_swigt__p_ofBoxPrimitive,
  &_swigt__p_ofBuffer,
  &_swigt__p_ofBufferObject,
  &_swigt__p_ofCamera,
  &_swigt__p_ofColor_T_float_t,
  &_swigt__p_ofColor_T_unsigned_char_t,
  &_swigt__p_ofColor_T_unsigned_short_t,
  &_swigt__p_ofConePrimitive,
  &_swigt__p_ofConsoleLoggerChannel,
  &_swigt__p_ofCoreEvents,
  &_swigt__p_ofCylinderPrimitive,
  &_swigt__p_ofDirectory,
  &_swigt__p_ofDragInfo,
  &_swigt__p_ofEasyCam,
  &_swigt__p_ofEventArgs,
  &_swigt__p_ofEventT_Firmata_I2C_Data_const_t,
  &_swigt__p_ofEventT_Firmata_Serial_Data_const_t,
  &_swigt__p_ofEventT_Firmata_Stepper_Data_const_t,
  &_swigt__p_ofEventT_int_const_t,
  &_swigt__p_ofEventT_std__pairT_int_Firmata_Pin_Modes_t_const_t,
  &_swigt__p_ofEventT_std__string_const_t,
  &_swigt__p_ofEventT_std__vectorT_Firmata_Encoder_Data_t_const_t,
  &_swigt__p_ofEventT_std__vectorT_unsigned_char_t_const_t,
  &_swigt__p_ofFbo,
  &_swigt__p_ofFile,
  &_swigt__p_ofFileDialogResult,
  &_swigt__p_ofFileLoggerChannel,
  &_swigt__p_ofFilePath,
  &_swigt__p_ofFpsCounter,
  &_swigt__p_ofHttpRequest,
  &_swigt__p_ofHttpResponse,
  &_swigt__p_ofIcoSpherePrimitive,
  &_swigt__p_ofImageLoadSettings,
  &_swigt__p_ofImage_T_float_t,
  &_swigt__p_ofImage_T_unsigned_char_t,
  &_swigt__p_ofImage_T_unsigned_short_t,
  &_swigt__p_ofKeyEventArgs,
  &_swigt__p_ofLight,
  &_swigt__p_ofLog,
  &_swigt__p_ofLogError,
  &_swigt__p_ofLogFatalError,
  &_swigt__p_ofLogNotice,
  &_swigt__p_ofLogVerbose,
  &_swigt__p_ofLogWarning,
  &_swigt__p_ofMaterial,
  &_swigt__p_ofMaterialSettings,
  &_swigt__p_ofMatrix3x3,
  &_swigt__p_ofMatrix4x4,
  &_swigt__p_ofMatrixStack,
  &_swigt__p_ofMeshFace_T_glm__vec3_glm__vec3_ofColor_T_float_t_glm__vec2_t,
  &_swigt__p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,
  &_swigt__p_ofMessage,
  &_swigt__p_ofMouseEventArgs,
  &_swigt__p_ofNode,
  &_swigt__p_ofParameterGroup,
  &_swigt__p_ofPath,
  &_swigt__p_ofPixels_T_float_t,
  &_swigt__p_ofPixels_T_unsigned_char_t,
  &_swigt__p_ofPixels_T_unsigned_short_t,
  &_swigt__p_ofPlanePrimitive,
  &_swigt__p_ofPolyline_T_glm__vec3_t,
  &_swigt__p_ofQuaternion,
  &_swigt__p_ofRectangle,
  &_swigt__p_ofResizeEventArgs,
  &_swigt__p_ofSerial,
  &_swigt__p_ofSerialDeviceInfo,
  &_swigt__p_ofShader,
  &_swigt__p_ofShaderSettings,
  &_swigt__p_ofShader__TransformFeedbackSettings,
  &_swigt__p_ofSoundDevice,
  &_swigt__p_ofSoundPlayer,
  &_swigt__p_ofSoundStream,
  &_swigt__p_ofSoundStreamSettings,
  &_swigt__p_ofSpherePrimitive,
  &_swigt__p_ofStyle,
  &_swigt__p_ofTexture,
  &_swigt__p_ofTextureData,
  &_swigt__p_ofTime,
  &_swigt__p_ofTouchEventArgs,
  &_swigt__p_ofTrueTypeFont,
  &_swigt__p_ofURLFileLoader,
  &_swigt__p_ofVbo,
  &_swigt__p_ofVboMesh,
  &_swigt__p_ofVec2f,
  &_swigt__p_ofVec3f,
  &_swigt__p_ofVec4f,
  &_swigt__p_ofVideoDevice,
  &_swigt__p_ofVideoFormat,
  &_swigt__p_ofVideoGrabber,
  &_swigt__p_ofVideoPlayer,
  &_swigt__p_ofWindowPosEventArgs,
  &_swigt__p_ofXml,
  &_swigt__p_ofXml__Attribute,
  &_swigt__p_ofXml__RangeT_ofXmlIteratorT_pugi__xml_attribute_iterator_t_t,
  &_swigt__p_ofXml__RangeT_ofXmlIteratorT_pugi__xml_named_node_iterator_t_t,
  &_swigt__p_ofXml__RangeT_ofXmlIteratorT_pugi__xml_node_iterator_t_t,
  &_swigt__p_std__fstream,
  &_swigt__p_std__functionT_void_fofHttpResponse_const_RF_t,
  &_swigt__p_std__functionT_void_fofSoundBuffer_RF_t,
  &_swigt__p_std__istream,
  &_swigt__p_std__mapT_int_supportedPinTypes_t,
  &_swigt__p_std__mapT_std__string_std__string_t,
  &_swigt__p_std__shared_ptrT_ofBaseLoggerChannel_t,
  &_swigt__p_std__shared_ptrT_ofBaseRenderer_t,
  &_swigt__p_std__shared_ptrT_ofBaseSoundPlayer_t,
  &_swigt__p_std__shared_ptrT_ofBaseSoundStream_t,
  &_swigt__p_std__shared_ptrT_ofBaseVideoGrabber_t,
  &_swigt__p_std__shared_ptrT_ofBaseVideoPlayer_t,
  &_swigt__p_std__string,
  &_swigt__p_std__vectorT_TESSindex_t,
  &_swigt__p_std__vectorT_float_t,
  &_swigt__p_std__vectorT_glm__vec2_t,
  &_swigt__p_std__vectorT_glm__vec3_t,
  &_swigt__p_std__vectorT_int_t,
  &_swigt__p_std__vectorT_ofColor_T_float_t_t,
  &_swigt__p_std__vectorT_ofFile_t,
  &_swigt__p_std__vectorT_ofMeshFace_T_glm__vec3_glm__vec3_ofColor_T_float_t_glm__vec2_t_t,
  &_swigt__p_std__vectorT_ofPath_t,
  &_swigt__p_std__vectorT_ofPolyline_T_ofDefaultVertexType_t_t,
  &_swigt__p_std__vectorT_ofSerialDeviceInfo_t,
  &_swigt__p_std__vectorT_ofSoundDevice_t,
  &_swigt__p_std__vectorT_ofTexture_t,
  &_swigt__p_std__vectorT_ofVec2f_t,
  &_swigt__p_std__vectorT_ofVec3f_t,
  &_swigt__p_std__vectorT_ofVideoDevice_t,
  &_swigt__p_std__vectorT_ofVideoFormat_t,
  &_swigt__p_std__vectorT_std__string_t,
  &_swigt__p_std__vectorT_unsigned_char_t,
  &_swigt__p_std__vectorT_unsigned_int_t,
  &_swigt__p_supportedPinTypes,
  &_swigt__p_uint16_t,
  &_swigt__p_uint32_t,
  &_swigt__p_uint8_t,
  &_swigt__p_unsigned_char,
  &_swigt__p_unsigned_int,
  &_swigt__p_unsigned_long,
  &_swigt__p_unsigned_long_long,
  &_swigt__p_unsigned_short,
  &_swigt__p_void,
};

static swig_cast_info _swigc__p_Firmata_Encoder_Data[] = {  {&_swigt__p_Firmata_Encoder_Data, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Firmata_I2C_Data[] = {  {&_swigt__p_Firmata_I2C_Data, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Firmata_Serial_Data[] = {  {&_swigt__p_Firmata_Serial_Data, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Firmata_Stepper_Data[] = {  {&_swigt__p_Firmata_Stepper_Data, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_GLintptr[] = {  {&_swigt__p_GLintptr, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_GLsizei[] = {  {&_swigt__p_GLsizei, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_GLsizeiptr[] = {  {&_swigt__p_GLsizeiptr, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_TESSindex[] = {  {&_swigt__p_TESSindex, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p__XDisplay[] = {  {&_swigt__p__XDisplay, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_boost__filesystem__path[] = {  {&_swigt__p_boost__filesystem__path, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_double[] = {  {&_swigt__p_double, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_float[] = {  {&_swigt__p_float, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_glm__mat3[] = {  {&_swigt__p_glm__mat3, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_glm__mat4[] = {  {&_swigt__p_glm__mat4, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_glm__quat[] = {  {&_swigt__p_glm__quat, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_glm__tvec2T_int_glm__precision__defaultp_t[] = {  {&_swigt__p_glm__tvec2T_int_glm__precision__defaultp_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_glm__tvec3T_int_glm__precision__defaultp_t[] = {  {&_swigt__p_glm__tvec3T_int_glm__precision__defaultp_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_glm__tvec4T_int_glm__precision__defaultp_t[] = {  {&_swigt__p_glm__tvec4T_int_glm__precision__defaultp_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofMouseEventArgs[] = {{&_swigt__p_ofMouseEventArgs, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofWindowPosEventArgs[] = {{&_swigt__p_ofWindowPosEventArgs, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_glm__vec2[] = {  {&_swigt__p_glm__vec2, 0, 0, 0},  {&_swigt__p_ofMouseEventArgs, _p_ofMouseEventArgsTo_p_glm__vec2, 0, 0},  {&_swigt__p_ofTouchEventArgs, _p_ofTouchEventArgsTo_p_glm__vec2, 0, 0},  {&_swigt__p_ofWindowPosEventArgs, _p_ofWindowPosEventArgsTo_p_glm__vec2, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_glm__vec3[] = {  {&_swigt__p_glm__vec3, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_glm__vec4[] = {  {&_swigt__p_glm__vec4, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_int[] = {  {&_swigt__p_int, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_int16_t[] = {  {&_swigt__p_int16_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_int32_t[] = {  {&_swigt__p_int32_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_int8_t[] = {  {&_swigt__p_int8_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_long_long[] = {  {&_swigt__p_long_long, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_of3dPrimitive[] = {  {&_swigt__p_of3dPrimitive, 0, 0, 0},  {&_swigt__p_ofPlanePrimitive, _p_ofPlanePrimitiveTo_p_of3dPrimitive, 0, 0},  {&_swigt__p_ofSpherePrimitive, _p_ofSpherePrimitiveTo_p_of3dPrimitive, 0, 0},  {&_swigt__p_ofIcoSpherePrimitive, _p_ofIcoSpherePrimitiveTo_p_of3dPrimitive, 0, 0},  {&_swigt__p_ofCylinderPrimitive, _p_ofCylinderPrimitiveTo_p_of3dPrimitive, 0, 0},  {&_swigt__p_ofConePrimitive, _p_ofConePrimitiveTo_p_of3dPrimitive, 0, 0},  {&_swigt__p_ofBoxPrimitive, _p_ofBoxPrimitiveTo_p_of3dPrimitive, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofAbstractParameter[] = {  {&_swigt__p_ofAbstractParameter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofAppBaseWindow[] = {  {&_swigt__p_ofAppBaseWindow, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofArduino[] = {  {&_swigt__p_ofArduino, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofBaseDraws[] = {  {&_swigt__p_ofBaseVideoDraws, _p_ofBaseVideoDrawsTo_p_ofBaseDraws, 0, 0},  {&_swigt__p_ofVideoGrabber, _p_ofVideoGrabberTo_p_ofBaseDraws, 0, 0},  {&_swigt__p_ofBaseDraws, 0, 0, 0},  {&_swigt__p_ofTexture, _p_ofTextureTo_p_ofBaseDraws, 0, 0},  {&_swigt__p_ofFbo, _p_ofFboTo_p_ofBaseDraws, 0, 0},  {&_swigt__p_ofVideoPlayer, _p_ofVideoPlayerTo_p_ofBaseDraws, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofBaseHasPixels[] = {  {&_swigt__p_ofBaseVideoDraws, _p_ofBaseVideoDrawsTo_p_ofBaseHasPixels, 0, 0},  {&_swigt__p_ofVideoGrabber, _p_ofVideoGrabberTo_p_ofBaseHasPixels, 0, 0},  {&_swigt__p_ofBaseVideoGrabber, _p_ofBaseVideoGrabberTo_p_ofBaseHasPixels, 0, 0},  {&_swigt__p_ofBaseVideo, _p_ofBaseVideoTo_p_ofBaseHasPixels, 0, 0},  {&_swigt__p_ofBaseHasPixels, 0, 0, 0},  {&_swigt__p_ofVideoPlayer, _p_ofVideoPlayerTo_p_ofBaseHasPixels, 0, 0},  {&_swigt__p_ofBaseVideoPlayer, _p_ofBaseVideoPlayerTo_p_ofBaseHasPixels, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofBaseHasTexture[] = {  {&_swigt__p_ofBaseHasTexture, 0, 0, 0},  {&_swigt__p_ofFbo, _p_ofFboTo_p_ofBaseHasTexture, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofBaseImage_T_float_t[] = {  {&_swigt__p_ofBaseImage_T_float_t, 0, 0, 0},  {&_swigt__p_ofImage_T_float_t, _p_ofImage_T_float_tTo_p_ofBaseImage_T_float_t, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofBaseImage_T_unsigned_char_t[] = {  {&_swigt__p_ofBaseImage_T_unsigned_char_t, 0, 0, 0},  {&_swigt__p_ofImage_T_unsigned_char_t, _p_ofImage_T_unsigned_char_tTo_p_ofBaseImage_T_unsigned_char_t, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofBaseImage_T_unsigned_short_t[] = {  {&_swigt__p_ofBaseImage_T_unsigned_short_t, 0, 0, 0},  {&_swigt__p_ofImage_T_unsigned_short_t, _p_ofImage_T_unsigned_short_tTo_p_ofBaseImage_T_unsigned_short_t, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofConsoleLoggerChannel[] = {{&_swigt__p_ofConsoleLoggerChannel, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofFileLoggerChannel[] = {{&_swigt__p_ofFileLoggerChannel, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofBaseLoggerChannel[] = {  {&_swigt__p_ofBaseLoggerChannel, 0, 0, 0},  {&_swigt__p_ofConsoleLoggerChannel, _p_ofConsoleLoggerChannelTo_p_ofBaseLoggerChannel, 0, 0},  {&_swigt__p_ofFileLoggerChannel, _p_ofFileLoggerChannelTo_p_ofBaseLoggerChannel, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofBaseMaterial[] = {  {&_swigt__p_ofBaseMaterial, 0, 0, 0},  {&_swigt__p_ofMaterial, _p_ofMaterialTo_p_ofBaseMaterial, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofBaseRenderer[] = {  {&_swigt__p_ofBaseRenderer, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofBaseSoundInput[] = {  {&_swigt__p_ofBaseSoundInput, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofBaseSoundOutput[] = {  {&_swigt__p_ofBaseSoundOutput, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofBaseSoundPlayer[] = {  {&_swigt__p_ofBaseSoundPlayer, 0, 0, 0},  {&_swigt__p_ofSoundPlayer, _p_ofSoundPlayerTo_p_ofBaseSoundPlayer, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofBaseSoundStream[] = {  {&_swigt__p_ofBaseSoundStream, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofBaseUpdates[] = {  {&_swigt__p_ofBaseVideoDraws, _p_ofBaseVideoDrawsTo_p_ofBaseUpdates, 0, 0},  {&_swigt__p_ofVideoGrabber, _p_ofVideoGrabberTo_p_ofBaseUpdates, 0, 0},  {&_swigt__p_ofBaseVideoGrabber, _p_ofBaseVideoGrabberTo_p_ofBaseUpdates, 0, 0},  {&_swigt__p_ofBaseVideo, _p_ofBaseVideoTo_p_ofBaseUpdates, 0, 0},  {&_swigt__p_ofBaseUpdates, 0, 0, 0},  {&_swigt__p_ofVideoPlayer, _p_ofVideoPlayerTo_p_ofBaseUpdates, 0, 0},  {&_swigt__p_ofBaseVideoPlayer, _p_ofBaseVideoPlayerTo_p_ofBaseUpdates, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofBaseVideo[] = {  {&_swigt__p_ofBaseVideoDraws, _p_ofBaseVideoDrawsTo_p_ofBaseVideo, 0, 0},  {&_swigt__p_ofVideoGrabber, _p_ofVideoGrabberTo_p_ofBaseVideo, 0, 0},  {&_swigt__p_ofBaseVideoGrabber, _p_ofBaseVideoGrabberTo_p_ofBaseVideo, 0, 0},  {&_swigt__p_ofBaseVideo, 0, 0, 0},  {&_swigt__p_ofVideoPlayer, _p_ofVideoPlayerTo_p_ofBaseVideo, 0, 0},  {&_swigt__p_ofBaseVideoPlayer, _p_ofBaseVideoPlayerTo_p_ofBaseVideo, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofBaseVideoDraws[] = {  {&_swigt__p_ofBaseVideoDraws, 0, 0, 0},  {&_swigt__p_ofVideoGrabber, _p_ofVideoGrabberTo_p_ofBaseVideoDraws, 0, 0},  {&_swigt__p_ofVideoPlayer, _p_ofVideoPlayerTo_p_ofBaseVideoDraws, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofBaseVideoGrabber[] = {  {&_swigt__p_ofBaseVideoGrabber, 0, 0, 0},  {&_swigt__p_ofVideoGrabber, _p_ofVideoGrabberTo_p_ofBaseVideoGrabber, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofBaseVideoPlayer[] = {  {&_swigt__p_ofBaseVideoPlayer, 0, 0, 0},  {&_swigt__p_ofVideoPlayer, _p_ofVideoPlayerTo_p_ofBaseVideoPlayer, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofBoxPrimitive[] = {  {&_swigt__p_ofBoxPrimitive, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofBuffer[] = {  {&_swigt__p_ofBuffer, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofBufferObject[] = {  {&_swigt__p_ofBufferObject, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofCamera[] = {  {&_swigt__p_ofEasyCam, _p_ofEasyCamTo_p_ofCamera, 0, 0},  {&_swigt__p_ofCamera, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofColor_T_float_t[] = {  {&_swigt__p_ofColor_T_float_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofColor_T_unsigned_char_t[] = {  {&_swigt__p_ofColor_T_unsigned_char_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofColor_T_unsigned_short_t[] = {  {&_swigt__p_ofColor_T_unsigned_short_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofConePrimitive[] = {  {&_swigt__p_ofConePrimitive, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofCoreEvents[] = {  {&_swigt__p_ofCoreEvents, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofCylinderPrimitive[] = {  {&_swigt__p_ofCylinderPrimitive, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofDirectory[] = {  {&_swigt__p_ofDirectory, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofDragInfo[] = {  {&_swigt__p_ofDragInfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofEasyCam[] = {  {&_swigt__p_ofEasyCam, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofKeyEventArgs[] = {{&_swigt__p_ofKeyEventArgs, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofResizeEventArgs[] = {{&_swigt__p_ofResizeEventArgs, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofMessage[] = {{&_swigt__p_ofMessage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofEventArgs[] = {  {&_swigt__p_ofEventArgs, 0, 0, 0},  {&_swigt__p_ofKeyEventArgs, _p_ofKeyEventArgsTo_p_ofEventArgs, 0, 0},  {&_swigt__p_ofMouseEventArgs, _p_ofMouseEventArgsTo_p_ofEventArgs, 0, 0},  {&_swigt__p_ofTouchEventArgs, _p_ofTouchEventArgsTo_p_ofEventArgs, 0, 0},  {&_swigt__p_ofResizeEventArgs, _p_ofResizeEventArgsTo_p_ofEventArgs, 0, 0},  {&_swigt__p_ofWindowPosEventArgs, _p_ofWindowPosEventArgsTo_p_ofEventArgs, 0, 0},  {&_swigt__p_ofMessage, _p_ofMessageTo_p_ofEventArgs, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofEventT_Firmata_I2C_Data_const_t[] = {  {&_swigt__p_ofEventT_Firmata_I2C_Data_const_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofEventT_Firmata_Serial_Data_const_t[] = {  {&_swigt__p_ofEventT_Firmata_Serial_Data_const_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofEventT_Firmata_Stepper_Data_const_t[] = {  {&_swigt__p_ofEventT_Firmata_Stepper_Data_const_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofEventT_int_const_t[] = {  {&_swigt__p_ofEventT_int_const_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofEventT_std__pairT_int_Firmata_Pin_Modes_t_const_t[] = {  {&_swigt__p_ofEventT_std__pairT_int_Firmata_Pin_Modes_t_const_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofEventT_std__string_const_t[] = {  {&_swigt__p_ofEventT_std__string_const_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofEventT_std__vectorT_Firmata_Encoder_Data_t_const_t[] = {  {&_swigt__p_ofEventT_std__vectorT_Firmata_Encoder_Data_t_const_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofEventT_std__vectorT_unsigned_char_t_const_t[] = {  {&_swigt__p_ofEventT_std__vectorT_unsigned_char_t_const_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofFbo[] = {  {&_swigt__p_ofFbo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofFile[] = {  {&_swigt__p_ofFile, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofFileDialogResult[] = {  {&_swigt__p_ofFileDialogResult, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofFilePath[] = {  {&_swigt__p_ofFilePath, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofFpsCounter[] = {  {&_swigt__p_ofFpsCounter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofHttpRequest[] = {  {&_swigt__p_ofHttpRequest, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofHttpResponse[] = {  {&_swigt__p_ofHttpResponse, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofIcoSpherePrimitive[] = {  {&_swigt__p_ofIcoSpherePrimitive, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofImageLoadSettings[] = {  {&_swigt__p_ofImageLoadSettings, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofImage_T_float_t[] = {  {&_swigt__p_ofImage_T_float_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofImage_T_unsigned_char_t[] = {  {&_swigt__p_ofImage_T_unsigned_char_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofImage_T_unsigned_short_t[] = {  {&_swigt__p_ofImage_T_unsigned_short_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofLight[] = {  {&_swigt__p_ofLight, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofLogError[] = {{&_swigt__p_ofLogError, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofLogNotice[] = {{&_swigt__p_ofLogNotice, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofLogFatalError[] = {{&_swigt__p_ofLogFatalError, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofLogVerbose[] = {{&_swigt__p_ofLogVerbose, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofLogWarning[] = {{&_swigt__p_ofLogWarning, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofLog[] = {  {&_swigt__p_ofLogError, _p_ofLogErrorTo_p_ofLog, 0, 0},  {&_swigt__p_ofLogNotice, _p_ofLogNoticeTo_p_ofLog, 0, 0},  {&_swigt__p_ofLogFatalError, _p_ofLogFatalErrorTo_p_ofLog, 0, 0},  {&_swigt__p_ofLogVerbose, _p_ofLogVerboseTo_p_ofLog, 0, 0},  {&_swigt__p_ofLog, 0, 0, 0},  {&_swigt__p_ofLogWarning, _p_ofLogWarningTo_p_ofLog, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofMaterial[] = {  {&_swigt__p_ofMaterial, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofMaterialSettings[] = {  {&_swigt__p_ofMaterialSettings, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofMatrix3x3[] = {  {&_swigt__p_ofMatrix3x3, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofMatrix4x4[] = {  {&_swigt__p_ofMatrix4x4, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofMatrixStack[] = {  {&_swigt__p_ofMatrixStack, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofMeshFace_T_glm__vec3_glm__vec3_ofColor_T_float_t_glm__vec2_t[] = {  {&_swigt__p_ofMeshFace_T_glm__vec3_glm__vec3_ofColor_T_float_t_glm__vec2_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t[] = {  {&_swigt__p_ofVboMesh, _p_ofVboMeshTo_p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t, 0, 0},  {&_swigt__p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofNode[] = {  {&_swigt__p_ofNode, 0, 0, 0},  {&_swigt__p_of3dPrimitive, _p_of3dPrimitiveTo_p_ofNode, 0, 0},  {&_swigt__p_ofPlanePrimitive, _p_ofPlanePrimitiveTo_p_ofNode, 0, 0},  {&_swigt__p_ofSpherePrimitive, _p_ofSpherePrimitiveTo_p_ofNode, 0, 0},  {&_swigt__p_ofIcoSpherePrimitive, _p_ofIcoSpherePrimitiveTo_p_ofNode, 0, 0},  {&_swigt__p_ofCylinderPrimitive, _p_ofCylinderPrimitiveTo_p_ofNode, 0, 0},  {&_swigt__p_ofConePrimitive, _p_ofConePrimitiveTo_p_ofNode, 0, 0},  {&_swigt__p_ofBoxPrimitive, _p_ofBoxPrimitiveTo_p_ofNode, 0, 0},  {&_swigt__p_ofEasyCam, _p_ofEasyCamTo_p_ofNode, 0, 0},  {&_swigt__p_ofLight, _p_ofLightTo_p_ofNode, 0, 0},  {&_swigt__p_ofCamera, _p_ofCameraTo_p_ofNode, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofParameterGroup[] = {  {&_swigt__p_ofParameterGroup, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofPath[] = {  {&_swigt__p_ofPath, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofPixels_T_float_t[] = {  {&_swigt__p_ofPixels_T_float_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofPixels_T_unsigned_char_t[] = {  {&_swigt__p_ofPixels_T_unsigned_char_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofPixels_T_unsigned_short_t[] = {  {&_swigt__p_ofPixels_T_unsigned_short_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofPlanePrimitive[] = {  {&_swigt__p_ofPlanePrimitive, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofPolyline_T_glm__vec3_t[] = {  {&_swigt__p_ofPolyline_T_glm__vec3_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofQuaternion[] = {  {&_swigt__p_ofQuaternion, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofRectangle[] = {  {&_swigt__p_ofRectangle, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofSerial[] = {  {&_swigt__p_ofSerial, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofSerialDeviceInfo[] = {  {&_swigt__p_ofSerialDeviceInfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofShader[] = {  {&_swigt__p_ofShader, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofShaderSettings[] = {  {&_swigt__p_ofShaderSettings, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofShader__TransformFeedbackSettings[] = {  {&_swigt__p_ofShader__TransformFeedbackSettings, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofSoundDevice[] = {  {&_swigt__p_ofSoundDevice, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofSoundPlayer[] = {  {&_swigt__p_ofSoundPlayer, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofSoundStream[] = {  {&_swigt__p_ofSoundStream, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofSoundStreamSettings[] = {  {&_swigt__p_ofSoundStreamSettings, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofSpherePrimitive[] = {  {&_swigt__p_ofSpherePrimitive, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofStyle[] = {  {&_swigt__p_ofStyle, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofTexture[] = {  {&_swigt__p_ofTexture, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofTextureData[] = {  {&_swigt__p_ofTextureData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofTime[] = {  {&_swigt__p_ofTime, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofTouchEventArgs[] = {  {&_swigt__p_ofTouchEventArgs, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofTrueTypeFont[] = {  {&_swigt__p_ofTrueTypeFont, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofURLFileLoader[] = {  {&_swigt__p_ofURLFileLoader, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofVbo[] = {  {&_swigt__p_ofVbo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofVboMesh[] = {  {&_swigt__p_ofVboMesh, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofVec2f[] = {  {&_swigt__p_ofVec2f, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofVec3f[] = {  {&_swigt__p_ofVec3f, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofVec4f[] = {  {&_swigt__p_ofVec4f, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofVideoDevice[] = {  {&_swigt__p_ofVideoDevice, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofVideoFormat[] = {  {&_swigt__p_ofVideoFormat, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofVideoGrabber[] = {  {&_swigt__p_ofVideoGrabber, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofVideoPlayer[] = {  {&_swigt__p_ofVideoPlayer, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofXml[] = {  {&_swigt__p_ofXml, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofXml__Attribute[] = {  {&_swigt__p_ofXml__Attribute, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofXml__RangeT_ofXmlIteratorT_pugi__xml_attribute_iterator_t_t[] = {  {&_swigt__p_ofXml__RangeT_ofXmlIteratorT_pugi__xml_attribute_iterator_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofXml__RangeT_ofXmlIteratorT_pugi__xml_named_node_iterator_t_t[] = {  {&_swigt__p_ofXml__RangeT_ofXmlIteratorT_pugi__xml_named_node_iterator_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ofXml__RangeT_ofXmlIteratorT_pugi__xml_node_iterator_t_t[] = {  {&_swigt__p_ofXml__RangeT_ofXmlIteratorT_pugi__xml_node_iterator_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__fstream[] = {  {&_swigt__p_std__fstream, 0, 0, 0},  {&_swigt__p_ofFile, _p_ofFileTo_p_std__fstream, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__functionT_void_fofHttpResponse_const_RF_t[] = {  {&_swigt__p_std__functionT_void_fofHttpResponse_const_RF_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__functionT_void_fofSoundBuffer_RF_t[] = {  {&_swigt__p_std__functionT_void_fofSoundBuffer_RF_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__istream[] = {  {&_swigt__p_std__istream, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__mapT_int_supportedPinTypes_t[] = {  {&_swigt__p_std__mapT_int_supportedPinTypes_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__mapT_std__string_std__string_t[] = {  {&_swigt__p_std__mapT_std__string_std__string_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__shared_ptrT_ofBaseLoggerChannel_t[] = {  {&_swigt__p_std__shared_ptrT_ofBaseLoggerChannel_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__shared_ptrT_ofBaseRenderer_t[] = {  {&_swigt__p_std__shared_ptrT_ofBaseRenderer_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__shared_ptrT_ofBaseSoundPlayer_t[] = {  {&_swigt__p_std__shared_ptrT_ofBaseSoundPlayer_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__shared_ptrT_ofBaseSoundStream_t[] = {  {&_swigt__p_std__shared_ptrT_ofBaseSoundStream_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__shared_ptrT_ofBaseVideoGrabber_t[] = {  {&_swigt__p_std__shared_ptrT_ofBaseVideoGrabber_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__shared_ptrT_ofBaseVideoPlayer_t[] = {  {&_swigt__p_std__shared_ptrT_ofBaseVideoPlayer_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__string[] = {  {&_swigt__p_std__string, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_TESSindex_t[] = {  {&_swigt__p_std__vectorT_TESSindex_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_float_t[] = {  {&_swigt__p_std__vectorT_float_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_glm__vec2_t[] = {  {&_swigt__p_std__vectorT_glm__vec2_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_glm__vec3_t[] = {  {&_swigt__p_std__vectorT_glm__vec3_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_int_t[] = {  {&_swigt__p_std__vectorT_int_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_ofColor_T_float_t_t[] = {  {&_swigt__p_std__vectorT_ofColor_T_float_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_ofFile_t[] = {  {&_swigt__p_std__vectorT_ofFile_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_ofMeshFace_T_glm__vec3_glm__vec3_ofColor_T_float_t_glm__vec2_t_t[] = {  {&_swigt__p_std__vectorT_ofMeshFace_T_glm__vec3_glm__vec3_ofColor_T_float_t_glm__vec2_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_ofPath_t[] = {  {&_swigt__p_std__vectorT_ofPath_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_ofPolyline_T_ofDefaultVertexType_t_t[] = {  {&_swigt__p_std__vectorT_ofPolyline_T_ofDefaultVertexType_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_ofSerialDeviceInfo_t[] = {  {&_swigt__p_std__vectorT_ofSerialDeviceInfo_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_ofSoundDevice_t[] = {  {&_swigt__p_std__vectorT_ofSoundDevice_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_ofTexture_t[] = {  {&_swigt__p_std__vectorT_ofTexture_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_ofVec2f_t[] = {  {&_swigt__p_std__vectorT_ofVec2f_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_ofVec3f_t[] = {  {&_swigt__p_std__vectorT_ofVec3f_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_ofVideoDevice_t[] = {  {&_swigt__p_std__vectorT_ofVideoDevice_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_ofVideoFormat_t[] = {  {&_swigt__p_std__vectorT_ofVideoFormat_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_std__string_t[] = {  {&_swigt__p_std__vectorT_std__string_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_unsigned_char_t[] = {  {&_swigt__p_std__vectorT_unsigned_char_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_unsigned_int_t[] = {  {&_swigt__p_std__vectorT_unsigned_int_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_supportedPinTypes[] = {  {&_swigt__p_supportedPinTypes, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_uint16_t[] = {  {&_swigt__p_uint16_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_uint32_t[] = {  {&_swigt__p_uint32_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_uint8_t[] = {  {&_swigt__p_uint8_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_unsigned_char[] = {  {&_swigt__p_unsigned_char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_unsigned_int[] = {  {&_swigt__p_unsigned_int, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_unsigned_long[] = {  {&_swigt__p_unsigned_long, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_unsigned_long_long[] = {  {&_swigt__p_unsigned_long_long, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_unsigned_short[] = {  {&_swigt__p_unsigned_short, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_void[] = {  {&_swigt__p_void, 0, 0, 0},{0, 0, 0, 0}};

static swig_cast_info *swig_cast_initial[] = {
  _swigc__p_Firmata_Encoder_Data,
  _swigc__p_Firmata_I2C_Data,
  _swigc__p_Firmata_Serial_Data,
  _swigc__p_Firmata_Stepper_Data,
  _swigc__p_GLintptr,
  _swigc__p_GLsizei,
  _swigc__p_GLsizeiptr,
  _swigc__p_TESSindex,
  _swigc__p__XDisplay,
  _swigc__p_boost__filesystem__path,
  _swigc__p_double,
  _swigc__p_float,
  _swigc__p_glm__mat3,
  _swigc__p_glm__mat4,
  _swigc__p_glm__quat,
  _swigc__p_glm__tvec2T_int_glm__precision__defaultp_t,
  _swigc__p_glm__tvec3T_int_glm__precision__defaultp_t,
  _swigc__p_glm__tvec4T_int_glm__precision__defaultp_t,
  _swigc__p_glm__vec2,
  _swigc__p_glm__vec3,
  _swigc__p_glm__vec4,
  _swigc__p_int,
  _swigc__p_int16_t,
  _swigc__p_int32_t,
  _swigc__p_int8_t,
  _swigc__p_long_long,
  _swigc__p_of3dPrimitive,
  _swigc__p_ofAbstractParameter,
  _swigc__p_ofAppBaseWindow,
  _swigc__p_ofArduino,
  _swigc__p_ofBaseDraws,
  _swigc__p_ofBaseHasPixels,
  _swigc__p_ofBaseHasTexture,
  _swigc__p_ofBaseImage_T_float_t,
  _swigc__p_ofBaseImage_T_unsigned_char_t,
  _swigc__p_ofBaseImage_T_unsigned_short_t,
  _swigc__p_ofBaseLoggerChannel,
  _swigc__p_ofBaseMaterial,
  _swigc__p_ofBaseRenderer,
  _swigc__p_ofBaseSoundInput,
  _swigc__p_ofBaseSoundOutput,
  _swigc__p_ofBaseSoundPlayer,
  _swigc__p_ofBaseSoundStream,
  _swigc__p_ofBaseUpdates,
  _swigc__p_ofBaseVideo,
  _swigc__p_ofBaseVideoDraws,
  _swigc__p_ofBaseVideoGrabber,
  _swigc__p_ofBaseVideoPlayer,
  _swigc__p_ofBoxPrimitive,
  _swigc__p_ofBuffer,
  _swigc__p_ofBufferObject,
  _swigc__p_ofCamera,
  _swigc__p_ofColor_T_float_t,
  _swigc__p_ofColor_T_unsigned_char_t,
  _swigc__p_ofColor_T_unsigned_short_t,
  _swigc__p_ofConePrimitive,
  _swigc__p_ofConsoleLoggerChannel,
  _swigc__p_ofCoreEvents,
  _swigc__p_ofCylinderPrimitive,
  _swigc__p_ofDirectory,
  _swigc__p_ofDragInfo,
  _swigc__p_ofEasyCam,
  _swigc__p_ofEventArgs,
  _swigc__p_ofEventT_Firmata_I2C_Data_const_t,
  _swigc__p_ofEventT_Firmata_Serial_Data_const_t,
  _swigc__p_ofEventT_Firmata_Stepper_Data_const_t,
  _swigc__p_ofEventT_int_const_t,
  _swigc__p_ofEventT_std__pairT_int_Firmata_Pin_Modes_t_const_t,
  _swigc__p_ofEventT_std__string_const_t,
  _swigc__p_ofEventT_std__vectorT_Firmata_Encoder_Data_t_const_t,
  _swigc__p_ofEventT_std__vectorT_unsigned_char_t_const_t,
  _swigc__p_ofFbo,
  _swigc__p_ofFile,
  _swigc__p_ofFileDialogResult,
  _swigc__p_ofFileLoggerChannel,
  _swigc__p_ofFilePath,
  _swigc__p_ofFpsCounter,
  _swigc__p_ofHttpRequest,
  _swigc__p_ofHttpResponse,
  _swigc__p_ofIcoSpherePrimitive,
  _swigc__p_ofImageLoadSettings,
  _swigc__p_ofImage_T_float_t,
  _swigc__p_ofImage_T_unsigned_char_t,
  _swigc__p_ofImage_T_unsigned_short_t,
  _swigc__p_ofKeyEventArgs,
  _swigc__p_ofLight,
  _swigc__p_ofLog,
  _swigc__p_ofLogError,
  _swigc__p_ofLogFatalError,
  _swigc__p_ofLogNotice,
  _swigc__p_ofLogVerbose,
  _swigc__p_ofLogWarning,
  _swigc__p_ofMaterial,
  _swigc__p_ofMaterialSettings,
  _swigc__p_ofMatrix3x3,
  _swigc__p_ofMatrix4x4,
  _swigc__p_ofMatrixStack,
  _swigc__p_ofMeshFace_T_glm__vec3_glm__vec3_ofColor_T_float_t_glm__vec2_t,
  _swigc__p_ofMesh_T_ofDefaultVertexType_ofDefaultNormalType_ofDefaultColorType_ofDefaultTexCoordType_t,
  _swigc__p_ofMessage,
  _swigc__p_ofMouseEventArgs,
  _swigc__p_ofNode,
  _swigc__p_ofParameterGroup,
  _swigc__p_ofPath,
  _swigc__p_ofPixels_T_float_t,
  _swigc__p_ofPixels_T_unsigned_char_t,
  _swigc__p_ofPixels_T_unsigned_short_t,
  _swigc__p_ofPlanePrimitive,
  _swigc__p_ofPolyline_T_glm__vec3_t,
  _swigc__p_ofQuaternion,
  _swigc__p_ofRectangle,
  _swigc__p_ofResizeEventArgs,
  _swigc__p_ofSerial,
  _swigc__p_ofSerialDeviceInfo,
  _swigc__p_ofShader,
  _swigc__p_ofShaderSettings,
  _swigc__p_ofShader__TransformFeedbackSettings,
  _swigc__p_ofSoundDevice,
  _swigc__p_ofSoundPlayer,
  _swigc__p_ofSoundStream,
  _swigc__p_ofSoundStreamSettings,
  _swigc__p_ofSpherePrimitive,
  _swigc__p_ofStyle,
  _swigc__p_ofTexture,
  _swigc__p_ofTextureData,
  _swigc__p_ofTime,
  _swigc__p_ofTouchEventArgs,
  _swigc__p_ofTrueTypeFont,
  _swigc__p_ofURLFileLoader,
  _swigc__p_ofVbo,
  _swigc__p_ofVboMesh,
  _swigc__p_ofVec2f,
  _swigc__p_ofVec3f,
  _swigc__p_ofVec4f,
  _swigc__p_ofVideoDevice,
  _swigc__p_ofVideoFormat,
  _swigc__p_ofVideoGrabber,
  _swigc__p_ofVideoPlayer,
  _swigc__p_ofWindowPosEventArgs,
  _swigc__p_ofXml,
  _swigc__p_ofXml__Attribute,
  _swigc__p_ofXml__RangeT_ofXmlIteratorT_pugi__xml_attribute_iterator_t_t,
  _swigc__p_ofXml__RangeT_ofXmlIteratorT_pugi__xml_named_node_iterator_t_t,
  _swigc__p_ofXml__RangeT_ofXmlIteratorT_pugi__xml_node_iterator_t_t,
  _swigc__p_std__fstream,
  _swigc__p_std__functionT_void_fofHttpResponse_const_RF_t,
  _swigc__p_std__functionT_void_fofSoundBuffer_RF_t,
  _swigc__p_std__istream,
  _swigc__p_std__mapT_int_supportedPinTypes_t,
  _swigc__p_std__mapT_std__string_std__string_t,
  _swigc__p_std__shared_ptrT_ofBaseLoggerChannel_t,
  _swigc__p_std__shared_ptrT_ofBaseRenderer_t,
  _swigc__p_std__shared_ptrT_ofBaseSoundPlayer_t,
  _swigc__p_std__shared_ptrT_ofBaseSoundStream_t,
  _swigc__p_std__shared_ptrT_ofBaseVideoGrabber_t,
  _swigc__p_std__shared_ptrT_ofBaseVideoPlayer_t,
  _swigc__p_std__string,
  _swigc__p_std__vectorT_TESSindex_t,
  _swigc__p_std__vectorT_float_t,
  _swigc__p_std__vectorT_glm__vec2_t,
  _swigc__p_std__vectorT_glm__vec3_t,
  _swigc__p_std__vectorT_int_t,
  _swigc__p_std__vectorT_ofColor_T_float_t_t,
  _swigc__p_std__vectorT_ofFile_t,
  _swigc__p_std__vectorT_ofMeshFace_T_glm__vec3_glm__vec3_ofColor_T_float_t_glm__vec2_t_t,
  _swigc__p_std__vectorT_ofPath_t,
  _swigc__p_std__vectorT_ofPolyline_T_ofDefaultVertexType_t_t,
  _swigc__p_std__vectorT_ofSerialDeviceInfo_t,
  _swigc__p_std__vectorT_ofSoundDevice_t,
  _swigc__p_std__vectorT_ofTexture_t,
  _swigc__p_std__vectorT_ofVec2f_t,
  _swigc__p_std__vectorT_ofVec3f_t,
  _swigc__p_std__vectorT_ofVideoDevice_t,
  _swigc__p_std__vectorT_ofVideoFormat_t,
  _swigc__p_std__vectorT_std__string_t,
  _swigc__p_std__vectorT_unsigned_char_t,
  _swigc__p_std__vectorT_unsigned_int_t,
  _swigc__p_supportedPinTypes,
  _swigc__p_uint16_t,
  _swigc__p_uint32_t,
  _swigc__p_uint8_t,
  _swigc__p_unsigned_char,
  _swigc__p_unsigned_int,
  _swigc__p_unsigned_long,
  _swigc__p_unsigned_long_long,
  _swigc__p_unsigned_short,
  _swigc__p_void,
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */

/* -----------------------------------------------------------------------------
 * Type initialization:
 * This problem is tough by the requirement that no dynamic
 * memory is used. Also, since swig_type_info structures store pointers to
 * swig_cast_info structures and swig_cast_info structures store pointers back
 * to swig_type_info structures, we need some lookup code at initialization.
 * The idea is that swig generates all the structures that are needed.
 * The runtime then collects these partially filled structures.
 * The SWIG_InitializeModule function takes these initial arrays out of
 * swig_module, and does all the lookup, filling in the swig_module.types
 * array with the correct data and linking the correct swig_cast_info
 * structures together.
 *
 * The generated swig_type_info structures are assigned statically to an initial
 * array. We just loop through that array, and handle each type individually.
 * First we lookup if this type has been already loaded, and if so, use the
 * loaded structure instead of the generated one. Then we have to fill in the
 * cast linked list. The cast data is initially stored in something like a
 * two-dimensional array. Each row corresponds to a type (there are the same
 * number of rows as there are in the swig_type_initial array). Each entry in
 * a column is one of the swig_cast_info structures for that type.
 * The cast_initial array is actually an array of arrays, because each row has
 * a variable number of columns. So to actually build the cast linked list,
 * we find the array of casts associated with the type, and loop through it
 * adding the casts to the list. The one last trick we need to do is making
 * sure the type pointer in the swig_cast_info struct is correct.
 *
 * First off, we lookup the cast->type name to see if it is already loaded.
 * There are three cases to handle:
 *  1) If the cast->type has already been loaded AND the type we are adding
 *     casting info to has not been loaded (it is in this module), THEN we
 *     replace the cast->type pointer with the type pointer that has already
 *     been loaded.
 *  2) If BOTH types (the one we are adding casting info to, and the
 *     cast->type) are loaded, THEN the cast info has already been loaded by
 *     the previous module so we just ignore it.
 *  3) Finally, if cast->type has not already been loaded, then we add that
 *     swig_cast_info to the linked list (because the cast->type) pointer will
 *     be correct.
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#if 0
} /* c-mode */
#endif
#endif

#if 0
#define SWIGRUNTIME_DEBUG
#endif


SWIGRUNTIME void
SWIG_InitializeModule(void *clientdata) {
  size_t i;
  swig_module_info *module_head, *iter;
  int init;

  /* check to see if the circular list has been setup, if not, set it up */
  if (swig_module.next==0) {
    /* Initialize the swig_module */
    swig_module.type_initial = swig_type_initial;
    swig_module.cast_initial = swig_cast_initial;
    swig_module.next = &swig_module;
    init = 1;
  } else {
    init = 0;
  }

  /* Try and load any already created modules */
  module_head = SWIG_GetModule(clientdata);
  if (!module_head) {
    /* This is the first module loaded for this interpreter */
    /* so set the swig module into the interpreter */
    SWIG_SetModule(clientdata, &swig_module);
  } else {
    /* the interpreter has loaded a SWIG module, but has it loaded this one? */
    iter=module_head;
    do {
      if (iter==&swig_module) {
        /* Our module is already in the list, so there's nothing more to do. */
        return;
      }
      iter=iter->next;
    } while (iter!= module_head);

    /* otherwise we must add our module into the list */
    swig_module.next = module_head->next;
    module_head->next = &swig_module;
  }

  /* When multiple interpreters are used, a module could have already been initialized in
     a different interpreter, but not yet have a pointer in this interpreter.
     In this case, we do not want to continue adding types... everything should be
     set up already */
  if (init == 0) return;

  /* Now work on filling in swig_module.types */
#ifdef SWIGRUNTIME_DEBUG
  printf("SWIG_InitializeModule: size %d\n", swig_module.size);
#endif
  for (i = 0; i < swig_module.size; ++i) {
    swig_type_info *type = 0;
    swig_type_info *ret;
    swig_cast_info *cast;

#ifdef SWIGRUNTIME_DEBUG
    printf("SWIG_InitializeModule: type %d %s\n", i, swig_module.type_initial[i]->name);
#endif

    /* if there is another module already loaded */
    if (swig_module.next != &swig_module) {
      type = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, swig_module.type_initial[i]->name);
    }
    if (type) {
      /* Overwrite clientdata field */
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: found type %s\n", type->name);
#endif
      if (swig_module.type_initial[i]->clientdata) {
	type->clientdata = swig_module.type_initial[i]->clientdata;
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: found and overwrite type %s \n", type->name);
#endif
      }
    } else {
      type = swig_module.type_initial[i];
    }

    /* Insert casting types */
    cast = swig_module.cast_initial[i];
    while (cast->type) {

      /* Don't need to add information already in the list */
      ret = 0;
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: look cast %s\n", cast->type->name);
#endif
      if (swig_module.next != &swig_module) {
        ret = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, cast->type->name);
#ifdef SWIGRUNTIME_DEBUG
	if (ret) printf("SWIG_InitializeModule: found cast %s\n", ret->name);
#endif
      }
      if (ret) {
	if (type == swig_module.type_initial[i]) {
#ifdef SWIGRUNTIME_DEBUG
	  printf("SWIG_InitializeModule: skip old type %s\n", ret->name);
#endif
	  cast->type = ret;
	  ret = 0;
	} else {
	  /* Check for casting already in the list */
	  swig_cast_info *ocast = SWIG_TypeCheck(ret->name, type);
#ifdef SWIGRUNTIME_DEBUG
	  if (ocast) printf("SWIG_InitializeModule: skip old cast %s\n", ret->name);
#endif
	  if (!ocast) ret = 0;
	}
      }

      if (!ret) {
#ifdef SWIGRUNTIME_DEBUG
	printf("SWIG_InitializeModule: adding cast %s\n", cast->type->name);
#endif
        if (type->cast) {
          type->cast->prev = cast;
          cast->next = type->cast;
        }
        type->cast = cast;
      }
      cast++;
    }
    /* Set entry in modules->types array equal to the type */
    swig_module.types[i] = type;
  }
  swig_module.types[i] = 0;

#ifdef SWIGRUNTIME_DEBUG
  printf("**** SWIG_InitializeModule: Cast List ******\n");
  for (i = 0; i < swig_module.size; ++i) {
    int j = 0;
    swig_cast_info *cast = swig_module.cast_initial[i];
    printf("SWIG_InitializeModule: type %d %s\n", i, swig_module.type_initial[i]->name);
    while (cast->type) {
      printf("SWIG_InitializeModule: cast type %s\n", cast->type->name);
      cast++;
      ++j;
    }
  printf("---- Total casts: %d\n",j);
  }
  printf("**** SWIG_InitializeModule: Cast List ******\n");
#endif
}

/* This function will propagate the clientdata field of type to
* any new swig_type_info structures that have been added into the list
* of equivalent types.  It is like calling
* SWIG_TypeClientData(type, clientdata) a second time.
*/
SWIGRUNTIME void
SWIG_PropagateClientData(void) {
  size_t i;
  swig_cast_info *equiv;
  static int init_run = 0;

  if (init_run) return;
  init_run = 1;

  for (i = 0; i < swig_module.size; i++) {
    if (swig_module.types[i]->clientdata) {
      equiv = swig_module.types[i]->cast;
      while (equiv) {
        if (!equiv->converter) {
          if (equiv->type && !equiv->type->clientdata)
            SWIG_TypeClientData(equiv->type, swig_module.types[i]->clientdata);
        }
        equiv = equiv->next;
      }
    }
  }
}

#ifdef __cplusplus
#if 0
{ /* c-mode */
#endif
}
#endif



/* Forward declaration of where the user's %init{} gets inserted */
void SWIG_init_user(lua_State* L );
    
#ifdef __cplusplus
extern "C" {
#endif
/* this is the initialization function
  added at the very end of the code
  the function is always called SWIG_init, but an earlier #define will rename it
*/
#if ((SWIG_LUA_TARGET == SWIG_LUA_FLAVOR_ELUA) || (SWIG_LUA_TARGET == SWIG_LUA_FLAVOR_ELUAC))
LUALIB_API int SWIG_init(lua_State* L)
#else
SWIGEXPORT int SWIG_init(lua_State* L) /* default Lua action */
#endif
{
#if (SWIG_LUA_TARGET != SWIG_LUA_FLAVOR_ELUAC) /* valid for both Lua and eLua */
  int i;
  int globalRegister = 0;
  /* start with global table */
  lua_pushglobaltable (L);
  /* SWIG's internal initialisation */
  SWIG_InitializeModule((void*)L);
  SWIG_PropagateClientData();
#endif

#if ((SWIG_LUA_TARGET != SWIG_LUA_FLAVOR_ELUA) && (SWIG_LUA_TARGET != SWIG_LUA_FLAVOR_ELUAC)) || defined(SWIG_LUA_ELUA_EMULATE)
  /* add a global fn */
  SWIG_Lua_add_function(L,"swig_type",SWIG_Lua_type);
  SWIG_Lua_add_function(L,"swig_equals",SWIG_Lua_class_equal);
#endif

#if (SWIG_LUA_TARGET != SWIG_LUA_FLAVOR_ELUAC)
  /* set up base class pointers (the hierarchy) */
  for (i = 0; swig_types[i]; i++){
    if (swig_types[i]->clientdata){
      SWIG_Lua_init_base_class(L,(swig_lua_class*)(swig_types[i]->clientdata));
    }
  }
#ifdef SWIG_LUA_MODULE_GLOBAL
  globalRegister = 1;
#endif


#if (SWIG_LUA_TARGET == SWIG_LUA_FLAVOR_LUA)
  SWIG_Lua_namespace_register(L,&swig_SwigModule, globalRegister);
#endif

#if (SWIG_LUA_TARGET == SWIG_LUA_FLAVOR_ELUA) || (SWIG_LUA_TARGET == SWIG_LUA_FLAVOR_ELUAC)
  for (i = 0; swig_types[i]; i++){
    if (swig_types[i]->clientdata){
      SWIG_Lua_elua_class_register_instance(L,(swig_lua_class*)(swig_types[i]->clientdata));
    }
  }
#endif

#if defined(SWIG_LUA_ELUA_EMULATE)
  lua_newtable(L);
  SWIG_Lua_elua_emulate_register(L,swig_SwigModule.ns_methods);
  SWIG_Lua_elua_emulate_register_clear(L);
  if(globalRegister) {
    lua_pushstring(L,swig_SwigModule.name);
    lua_pushvalue(L,-2);
    lua_rawset(L,-4);
  }
#endif

#endif

#if (SWIG_LUA_TARGET != SWIG_LUA_FLAVOR_ELUAC)
  /* invoke user-specific initialization */
  SWIG_init_user(L);
  /* end module */
  /* Note: We do not clean up the stack here (Lua will do this for us). At this
     point, we have the globals table and out module table on the stack. Returning
     one value makes the module table the result of the require command. */
  return 1;
#else
  return 0;
#endif
}

#ifdef __cplusplus
}
#endif


const char* SWIG_LUACODE=
  "\n"
  "\n"
  "-- this isn't wrapped correctly, so set it here\n"
  "of.CLOSE = true\n"
  "\n"
  "-- handle typedefs which swig doesn't wrap\n"
  "of.Point = of.Vec3f\n"
  "\n"
  "-- class.lua\n"
  "-- Compatible with Lua 5.1 (not 5.0).\n"
  "function class(base, __init)\n"
  "   local c = {}    -- a new class instance\n"
  "   if not __init and type(base) == 'function' then\n"
  "	  __init = base\n"
  "	  base = nil\n"
  "   elseif type(base) == 'table' then\n"
  "	-- our new class is a shallow copy of the base class!\n"
  "	  for i,v in pairs(base) do\n"
  "		 c[i] = v\n"
  "	  end\n"
  "	  c._base = base\n"
  "   end\n"
  "   -- the class will be the metatable for all its objects,\n"
  "   -- and they will look up their methods in it.\n"
  "   c.__index = c\n"
  "\n"
  "   -- expose a constructor which can be called by <classname>(<args>)\n"
  "   local mt = {}\n"
  "   mt.__call = function(class_tbl, ...)\n"
  "   local obj = {}\n"
  "   setmetatable(obj,c)\n"
  "   if class_tbl.__init then\n"
  "	  class_tbl.__init(obj,...)\n"
  "   else\n"
  "	  -- make sure that any stuff from the base class is initialized!\n"
  "	  if base and base.__init then\n"
  "	  base.__init(obj, ...)\n"
  "	  end\n"
  "   end\n"
  "   return obj\n"
  "   end\n"
  "   c.__init = __init\n"
  "   c.is_a = function(self, klass)\n"
  "	  local m = getmetatable(self)\n"
  "	  while m do\n"
  "		 if m == klass then return true end\n"
  "		 m = m._base\n"
  "	  end\n"
  "	  return false\n"
  "   end\n"
  "   setmetatable(c, mt)\n"
  "   return c\n"
  "end";

void SWIG_init_user(lua_State* L)
{
  /* exec Lua code if applicable */
  SWIG_Lua_dostring(L,SWIG_LUACODE);
}

